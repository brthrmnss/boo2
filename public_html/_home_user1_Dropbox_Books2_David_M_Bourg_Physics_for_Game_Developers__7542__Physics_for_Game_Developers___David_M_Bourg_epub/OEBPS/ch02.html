<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 2. Kinematics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch01.html" title="Chapter 1. Basic Concepts"/><link rel="next" href="ch03.html" title="Chapter 3. Force"/></head><body><section class="chapter" title="Chapter 2. Kinematics" epub:type="chapter" id="kinematics"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Kinematics</h2></div></div></div><p>In this chapter we’ll explain the <a id="I_indexterm2_id296124" class="indexterm"/>fundamental aspects of the subject of kinematics.
  Specifically, we’ll explain the concepts of linear and angular displacement,
  velocity, and acceleration. We’ve prepared an example program for this
  chapter that shows you how to implement the kinematic equations for particle
  motion. After discussing particle motion, we go on to explain the specific
  aspects of rigid-body motion. This chapter, along with the next chapter on
  force, is prerequisite to understanding the subject of kinetics, which
  you’ll study in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>.</p><p>In the preface, we told you that kinematics is the study of the motion
  of bodies without regard to the forces acting on the body. Therefore, in
  kinematics, attention is focused on position, velocity, and acceleration of
  a body, how these properties are related, and how they change over
  time.</p><p>Here you’ll look at two types of bodies, particles and rigid bodies. A
  <a id="I_indexterm2_id296154" class="indexterm"/>rigid body is a system of particles that remain at fixed
  distances from one another with no relative translation or rotation among
  them. In other words, a rigid body does not change its shape as it moves—or
  any changes in its shape are so small or unimportant that they can safely be
  neglected. When you are considering a rigid body, its dimensions and
  <a id="I_indexterm2_id296169" class="indexterm"/>orientation are important, and you must account for both the
  body’s linear motion and its angular motion.</p><p>A particle, on <a id="I_indexterm2_id296184" class="indexterm"/>the other hand, is a body that has mass but whose dimensions
  are negligible or unimportant in the problem being investigated. For
  example, when considering the path of a projectile or a rocket over a great
  distance, you can safely ignore the body’s dimensions when analyzing its
  trajectory. When you are considering a particle, its linear motion is
  important, but the angular motion of the particle itself is not. Think of it
  this way: when looking at a particle, you are zooming way out to view the
  big picture, so to speak, as opposed to zooming in as you do when looking at
  the rotation of rigid bodies.</p><p>Whether you are looking at problems involving particles or rigid
  bodies, there are some important kinematic properties common to both. These
  are, of course, the object’s position, velocity, and acceleration. The next
  section discusses these properties in detail.</p><div class="sect1" title="Velocity and Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="velocity_and_acceleration">Velocity and Acceleration</h2></div></div></div><p>In general,<a id="ki2.1" class="indexterm"/><a id="ve2.1" class="indexterm"/><a id="vea2.1" class="indexterm"/><a id="ac2.1" class="indexterm"/><a id="I_indexterm2_id296283" class="indexterm"/> velocity is a vector quantity that has magnitude and
    direction. The magnitude of <a id="I_indexterm2_id296294" class="indexterm"/><a id="I_indexterm2_id296304" class="indexterm"/><a id="I_indexterm2_id296314" class="indexterm"/>velocity is speed. Speed is a familiar term—it’s how fast
    your speedometer says you’re going when driving your car down the highway.
    Formally, <a id="I_indexterm2_id296329" class="indexterm"/>speed is the rate of travel, or the ratio of <a id="I_indexterm2_id296340" class="indexterm"/><a id="I_indexterm2_id296350" class="indexterm"/>distance traveled to the time it took to travel that
    distance. In math terms, you can write:</p><table style="border: 0; " class="simplelist"><tr><td>v = Δs/Δt</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is speed, the magnitude of velocity
    <span class="strong"><strong>v</strong></span>, and Δ<span class="emphasis"><em>s</em></span> is
    distance traveled over the time interval Δ<span class="emphasis"><em>t</em></span>. Note
    that this relation reveals that the units for speed are composed of the
    basic dimension’s length divided by time, <span class="emphasis"><em>L/T</em></span>. Some
    common <a id="I_indexterm2_id296398" class="indexterm"/>units for speed are meters per second,
    <span class="emphasis"><em>m/s</em></span>; feet per second, <span class="emphasis"><em>ft/sec</em></span>;
    and miles per hour, <span class="emphasis"><em>mi/hr</em></span>.</p><p>Here’s a simple example (illustrated in <a class="xref" href="ch02.html#example_car_speed" title="Figure 2-1. Example car speed">Figure 2-1</a>): a car is driving down a straight road and
    passes marker one at time <span class="emphasis"><em>t</em></span><sub>1</sub>
    and marker two at time <span class="emphasis"><em>t</em></span><sub>2</sub>,
    where <span class="emphasis"><em>t</em></span><sub>1</sub> equals 0 seconds and
    <span class="emphasis"><em>t</em></span><sub>2</sub> equals 1.136 seconds. The
    distance between these two markers, <span class="emphasis"><em>s</em></span>, is 30 m.
    Calculate the <a id="I_indexterm2_id296458" class="indexterm"/>speed of the car.</p><div class="figure"><a id="example_car_speed"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id296480"/><img src="httpatomoreillycomsourceoreillyimages1598883.png" alt="Example car speed"/></div></div><div class="figure-title">Figure 2-1. Example car speed</div></div><p>You are given that <span class="emphasis"><em>s</em></span> equals 30 m; therefore,
    Δ<span class="emphasis"><em>s</em></span> equals 30 m and Δ<sub>t</sub> equals
    <span class="emphasis"><em>t</em></span><sub>2</sub> <span class="emphasis"><em>−
    t</em></span><sub>1</sub> or 1.136 seconds. The speed of the
    car over this distance is:</p><table style="border: 0; " class="simplelist"><tr><td>v = Δs/Δt = 30 m/1.136 sec = 26.4 m/sec</td></tr></table><p>which is approximately 60 mi/hr. This is a simple one-dimensional
    example, but it brings up an important point, which is that the speed just
    calculated is the average speed of the car over that distance. You don’t
    know anything at this point about the car’s acceleration, or whether or
    not it is traveling at a constant 60 mi/hr. It could very well be that the
    car was accelerating (or decelerating) over that 30 m distance.</p><p>To more precisely analyze the motion of the car in this example, you
    need to understand the concept <a id="I_indexterm2_id296551" class="indexterm"/><a id="I_indexterm2_id296560" class="indexterm"/>of <span class="emphasis"><em>instantaneous</em></span> velocity.
    Instantaneous velocity is the specific velocity at a given instant in
    time, not over a large time interval as in the car example. This means
    that you need to look at very small Δ<span class="emphasis"><em>t</em></span>’s. In math
    terms, you must consider the limit as Δ<span class="emphasis"><em>t</em></span> approaches
    0—that is, as Δ<span class="emphasis"><em>t</em></span> gets infinitesimally small. This is
    written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v = lim<sub>Δt→0</sub> (Δs/Δt)</td></tr></table><p>In differential terms, velocity is the derivative of displacement
    (change in position) with respect to time:</p><table style="border: 0; " class="simplelist"><tr><td>v = ds/dt</td></tr></table><p>You can rearrange this relationship and integrate over the intervals
    from <span class="emphasis"><em>s</em></span><sub>1</sub> to
    <span class="emphasis"><em>s</em></span><sub>2</sub> and
    <span class="emphasis"><em>t</em></span><sub>1</sub> to
    t<sub>2</sub>, as shown here:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds</td></tr><tr><td>∫<sub>(s1 to s2)</sub> ds = ∫<sub>(t1 to
      t2)</sub> v dt</td></tr><tr><td>s2 – s1 = Δs = ∫<sub>(t1 to t2)</sub> v dt</td></tr></table><p>This relation shows that displacement is the integral of velocity
    over time. This gives you a way of working back and forth between
    displacement and velocity.</p><p>Kinematics makes an important distinction between <a id="I_indexterm2_id296680" class="indexterm"/><a id="I_indexterm2_id296690" class="indexterm"/>displacement and distance traveled. In one dimension,
    displacement is the same as distance traveled; however, with vectors in
    space, displacement <a id="I_indexterm2_id296702" class="indexterm"/>is actually the vector from the initial position to the
    final position without regard to the path traveled, while displacement is
    the difference between the starting position coordinates and the ending
    position coordinates. Thus, you need to be careful when calculating
    average velocity given displacement if the path from the starting position
    to the final position is not a straight line. When Δ<span class="emphasis"><em>t</em></span>
    is very small (as it approaches 0), displacement and distance traveled are
    the <a id="I_indexterm2_id296721" class="indexterm"/>same.</p><p>Another important kinematic property is <a id="I_indexterm2_id296736" class="indexterm"/>acceleration, which should also be familiar to you.
    Referring to your driving experience, you know that acceleration is the
    rate at which you can increase your <a id="I_indexterm2_id296748" class="indexterm"/>speed. Your friend who boasts that his brand new XYZ 20II
    can go from 0 to 60 in 4.2 seconds is referring to acceleration.
    Specifically, he is referring to average acceleration.</p><p>Formally, average acceleration<a id="I_indexterm2_id296764" class="indexterm"/><a id="I_indexterm2_id296770" class="indexterm"/> is the rate of change in velocity, or
    Δ<span class="emphasis"><em>v</em></span> over Δ<span class="emphasis"><em>t</em></span>:</p><table style="border: 0; " class="simplelist"><tr><td>a = Δv/Δt</td></tr></table><p>Taking the limit as Δ<span class="emphasis"><em>t</em></span> goes to 0 gives
    <a id="I_indexterm2_id296806" class="indexterm"/><a id="I_indexterm2_id296813" class="indexterm"/>the instantaneous acceleration:</p><table style="border: 0; " class="simplelist"><tr><td>a = lim<sub>Δt→0</sub> Δv/Δt</td></tr><tr><td>a = dv/dt</td></tr></table><p>Thus, acceleration is the time rate of change in velocity, or, the
    derivative of velocity with respect to time.</p><p>Multiplying both sides by <span class="emphasis"><em>dt</em></span> and integrating
    yields:</p><table style="border: 0; " class="simplelist"><tr><td>dv = a dt</td></tr><tr><td>∫<sub>(v1 to v2)</sub> dv = ∫<sub>(t1 to
      t2)</sub> a dt</td></tr><tr><td>v2 – v1 = Δv = ∫<sub>(t1 to t2)</sub> a dt</td></tr></table><p>This relationship provides a means to work back and forth between
    velocity and acceleration.</p><p>Thus, the relationships between displacement, velocity, and
    acceleration are:</p><table style="border: 0; " class="simplelist"><tr><td>a = dv/dt =
      d<sup>2</sup>s/dt<sup>2</sup></td></tr></table><p>and:</p><table style="border: 0; " class="simplelist"><tr><td>v dv = a ds</td></tr></table><p>This is the kinematic differential equation of motion (see the
    sidebar <a class="xref" href="ch02.html#second_derivatives" title="Second Derivatives">Second Derivatives</a> for some helpful
    background). In the next few sections you’ll see some examples of the
    application of these equations for some common classes of problems in
    <a id="I_indexterm2_id296928" class="indexterm"/><a id="I_indexterm2_id296937" class="indexterm"/><a id="I_indexterm2_id296947" class="indexterm"/>kinematics.</p><div class="sidebar"><a id="second_derivatives"/><div class="sidebar-title">Second Derivatives</div><p>In <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>, we <a id="I_indexterm2_id296979" class="indexterm"/><a id="I_indexterm2_id296990" class="indexterm"/>explained that you need not worry about the use of
      derivatives and integrals in this book if you’re unfamiliar with
      calculus since we’ll show you how to implement the code to take care of
      them computationally. That still applies, but here we’ve introduced new
      notation:</p><table style="border: 0; " class="simplelist"><tr><td>d<sup>2</sup>s/dt<sup>2</sup></td></tr></table><p>which is an equation representing <a id="I_indexterm2_id297020" class="indexterm"/>acceleration as the <span class="emphasis"><em>second derivative</em></span>
      of distance traveled with respect to time. You can think of second
      derivatives as just two successive derivatives in the manner we
      explained in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>. In the case of distance
      traveled, <a id="I_indexterm2_id297041" class="indexterm"/><a id="I_indexterm2_id297051" class="indexterm"/>velocity, and acceleration, the first derivative of
      distance traveled with respect to time is velocity and the second
      derivative of distance traveled with respect to time is acceleration,
      which is the same as the first derivative of velocity with respect to
      time.</p></div></div><div class="sect1" title="Constant Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="constant_acceleration">Constant Acceleration</h2></div></div></div><p>One of the <a id="ki2.2" class="indexterm"/><a id="ac2.2" class="indexterm"/><a id="co2.2" class="indexterm"/>simplest classes of problems in kinematics involves constant
    acceleration. A good example of this sort of problem involves the
    acceleration due to gravity, <span class="emphasis"><em>g</em></span>, on objects moving
    relatively near the earth’s surface, where the gravitational acceleration
    is a constant 9.81 m/s<sup>2</sup>. Having constant
    acceleration makes integration over time relatively easy since you can
    pull the acceleration constant out of the integrand, leaving just
    <span class="emphasis"><em>dt</em></span>.</p><p>Integrating the relationship between velocity and acceleration
    described earlier when acceleration is constant yields the following
    equation for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>∫<sub>(v1 to v2)</sub> dv = ∫<sub>(t1 to
      t2)</sub> a dt</td></tr><tr><td>∫<sub>(v1 to v2)</sub> dv = a ∫<sub>(t1 to
      t2)</sub> dt</td></tr><tr><td>v<sub>2</sub> – v<sub>1</sub> = a
      ∫<sub>(t1 to t2)</sub> dt</td></tr><tr><td>v<sub>2</sub> – v<sub>1</sub> = a
      (t<sub>2</sub> − t<sub>1</sub>)</td></tr><tr><td>v<sub>2</sub> = a t<sub>2</sub> − a
      t<sub>1</sub> + v<sub>1</sub></td></tr></table><p>When <span class="emphasis"><em>t</em></span><sub>1</sub> equals 0, you
    can rewrite this equation in the following form:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = a t<sub>2</sub> +
      v<sub>1</sub></td></tr><tr><td>v<sub>2</sub> = v<sub>1</sub> + a
      t<sub>2</sub></td></tr></table><p>This simple equation allows you to calculate the <a id="I_indexterm2_id297267" class="indexterm"/><a id="I_indexterm2_id297277" class="indexterm"/>instantaneous velocity at any given time by knowing the
    elapsed time, the initial velocity, and the constant acceleration.</p><p>You can also derive an equation for velocity as a function of
    displacement instead of time by considering the kinematic differential
    equation of motion:</p><table style="border: 0; " class="simplelist"><tr><td>v dv = a ds</td></tr></table><p>Integrating both sides of this equation yields the following
    alternative function for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>∫<sub>(v1 to v2)</sub> v dv = a ∫<sub>(s1 to
      s2)</sub> ds</td></tr><tr><td>(v<sub>2</sub><sup>2</sup> −
      v<sub>1</sub><sup>2</sup>) / 2 = a
      (s<sub>2</sub> − s<sub>1</sub>)</td></tr><tr><td>v<sub>2</sub><sup>2</sup> = 2a
      (s<sub>2</sub> − s<sub>1</sub>) +
      v<sub>1</sub><sup>2</sup></td></tr></table><p>You can derive a similar formula for <a id="I_indexterm2_id297376" class="indexterm"/>displacement as a function of velocity, acceleration, and
    time by integrating the differential equation:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds</td></tr></table><p>with the formula derived earlier for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = v<sub>1</sub> +
      at</td></tr></table><p>substituted for <span class="emphasis"><em>v</em></span>. Doing so yields the
    formula:</p><table style="border: 0; " class="simplelist"><tr><td>s<sub>2</sub> = s<sub>1</sub> +
      v<sub>1</sub> t + (a t<sup>2</sup>) /
      2</td></tr></table><p>In summary, the three preceding kinematic equations derived
    are:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = v<sub>1</sub> + a
      t<sub>2</sub></td></tr><tr><td>v<sub>2</sub><sup>2</sup> = 2a
      (s<sub>2</sub> − s<sub>1</sub>) +
      v<sub>1</sub><sup>2</sup></td></tr><tr><td>s<sub>2</sub> = s<sub>1</sub> +
      v<sub>1</sub> t + (a t<sup>2</sup>) /
      2</td></tr></table><p>Remember, these equations are valid only when acceleration is
    constant. Note that acceleration can be 0 or even negative in cases where
    the body is decelerating.</p><p>You can rearrange these equations by algebraically solving for
    different variables, and you can also derive other handy equations using
    the approach that we just demonstrated. For your convenience, we’ve
    provided some other useful kinematic equations for constant acceleration
    problems in <a class="xref" href="ch02.html#constant_acceleration_kinematic_formulas" title="Table 2-1. Constant acceleration kinematic formulas">Table 2-1</a>.</p><div class="table"><a id="constant_acceleration_kinematic_formulas"/><div class="table-title">Table 2-1. Constant acceleration kinematic formulas</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To find:</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Given
            these:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a =
            (v<sub>2</sub> – v<sub>1</sub>) /
            Δt</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a = (2 Δs – 2
            v<sub>1</sub> Δt) /
            (Δt)<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub>,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a =
            (v<sub>2</sub><sup>2</sup> –
            v<sub>1</sub><sup>2</sup>) / (2
            Δs)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δs</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δs =
            (v<sub>2</sub><sup>2</sup> –
            v<sub>1</sub><sup>2</sup>) /
            (2a)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δs</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δs = (Δt / 2)
            (v<sub>1</sub> +
            v<sub>2</sub>)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =
            (v<sub>2</sub> – v<sub>1</sub>) /
            a</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =</p>
              <span class="inlinemediaobject"><img src="inleq_0201.png" alt=""/></span>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub>,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =(2Δs) /
            (v<sub>1</sub> +
            v<sub>2</sub>)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt, a,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub> =
            v<sub>2</sub> – aΔt</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt, a, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub> =
            Δs/Δt – (aΔt)/2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>a,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; "><p>v<sub>1</sub> = </p>
              <span class="inlinemediaobject"><img src="inleq_0202.png" alt=""/></span>
            </td></tr></tbody></table></div></div><p>In cases where acceleration is not constant, but is some function of
    time, velocity, or position, you can substitute the function for
    acceleration into the differential equations shown earlier to derive new
    equations for instantaneous velocity and displacement. The next section
    considers <a id="I_indexterm2_id298124" class="indexterm"/><a id="I_indexterm2_id298133" class="indexterm"/><a id="I_indexterm2_id298143" class="indexterm"/>such a problem.</p></div><div class="sect1" title="Nonconstant Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="nonconstant_acceleration">Nonconstant Acceleration</h2></div></div></div><p>A common <a id="I_indexterm2_id298165" class="indexterm"/><a id="I_indexterm2_id298175" class="indexterm"/><a id="I_indexterm2_id298181" class="indexterm"/>situation that arises in real-world problems is when drag
    forces act on a body in motion. Typically, drag forces are proportional to
    velocity squared. Recalling the equation of Newton’s second law of motion,
    <span class="emphasis"><em>F</em></span> = <span class="emphasis"><em>ma</em></span>, you can deduce that the
    acceleration induced by these <a id="I_indexterm2_id298201" class="indexterm"/>drag forces is also proportional to velocity squared</p><p>Later we’ll show you some techniques to calculate this sort of drag
    force, but for now let the functional form of drag-induced acceleration
    be:</p><table style="border: 0; " class="simplelist"><tr><td>a = –kv<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>k</em></span> is a constant and the negative sign
    indicates that this acceleration acts in the direction opposing the body’s
    velocity. Now substituting this formula for acceleration into the previous
    equation and then rearranging yields:</p><table style="border: 0; " class="simplelist"><tr><td>a = dv/dt</td></tr><tr><td>–kv<sup>2</sup> = dv/dt</td></tr><tr><td>–k dt = dv/v<sup>2</sup></td></tr></table><p>If you integrate the right side of this equation from
    <span class="emphasis"><em>v</em></span><sub>1</sub> to
    <span class="emphasis"><em>v</em></span><sub>2</sub> and the left side from 0 to
    <span class="emphasis"><em>t</em></span>, and then solve for
    <span class="emphasis"><em>v</em></span><sub>2</sub>, you’ll get this formula
    for the instantaneous velocity as a function of the initial velocity and
    time:</p><table style="border: 0; " class="simplelist"><tr><td>–k ∫<sub>(0 to t)</sub> dt = ∫<sub>(v1 to
      v2)</sub> (1/v<sup>2</sup>) dv</td></tr><tr><td>–k t = 1/v<sub>1</sub> –
      1/v<sub>2</sub></td></tr><tr><td>v<sub>2</sub> = v<sub>1</sub> / (1 +
      v<sub>1</sub>k t)</td></tr></table><p>If you substitute this equation for <span class="emphasis"><em>v</em></span> in the
    relation <span class="emphasis"><em>v</em></span> = <span class="emphasis"><em>ds/dt</em></span> and integrate
    again, you’ll end up with a new equation for displacement as a function of
    initial velocity and time; see the following procedure:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds; <span class="emphasis"><em>where</em></span> v =
      v<sub>1</sub> / (1 + v<sub>1</sub>k t)</td></tr><tr><td>∫<sub>(0 to t)</sub> v dt = ∫<sub>(s1 to
      s2)</sub> ds</td></tr><tr><td>∫<sub>(0 to t)</sub> [v<sub>1</sub> / (1
      + v<sub>1</sub>k t)] dt = ∫<sub>(s1 to s2)</sub>
      ds</td></tr><tr><td>ln(1 + v<sub>1</sub> k t) / k =
      s<sub>2</sub> – s<sub>1</sub></td></tr></table><p>If s<sub>1</sub> equals 0, then:</p><table style="border: 0; " class="simplelist"><tr><td>s = ln(1 + v<sub>1</sub> k t) / k</td></tr></table><p>Note that in this equation, <span class="emphasis"><em>ln</em></span> is the natural
    logarithm operator.</p><p>This example demonstrates the relative complexity of nonconstant
    acceleration problems versus constant acceleration problems. It’s a fairly
    simple example where you are able to derive closed-form equations for
    velocity and displacement. In practice, however, there may be several
    different types of forces acting on a given body in motion, which could
    make the expression for induced acceleration quite complicated. This
    complexity would render a closed-form solution like the preceding one
    impossible to obtain unless you impose some simplifying restrictions on
    the problem, forcing you to rely on other solution techniques like
    numerical integration. We’ll talk about this sort of problem in greater
    depth in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p></div><div class="sect1" title="2D Particle Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="d_particle_kinematics">2D Particle Kinematics</h2></div></div></div><p>When we are <a id="ki2.4" class="indexterm"/><a id="pa2.4" class="indexterm"/><a id="tw2.4" class="indexterm"/>considering motion in one dimension—that is, when the motion
    is restricted to a straight line—it is easy enough to directly apply the
    formulas derived earlier to determine instantaneous velocity,
    acceleration, and displacement. However, in two dimensions, with motion
    possible in any direction on a given plane, you must consider the
    kinematic properties of velocity, acceleration, and displacement as
    vectors.</p><p>Using rectangular coordinates in the standard <a id="I_indexterm2_id298532" class="indexterm"/><a id="I_indexterm2_id298544" class="indexterm"/>Cartesian coordinate system, you must account for the
    <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> components of
    displacement, velocity, and acceleration. Essentially, you can treat the
    <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> components separately
    and then superimpose these components to define the corresponding vector
    quantities.</p><p>To help keep track of these <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>y</em></span> components, let <span class="strong"><strong>i</strong></span> and <span class="strong"><strong>j</strong></span> be
    unit vectors in the x- and y-directions, respectively. Now you can write
    the kinematic property vectors in terms of their components as
    follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = v<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + v<sub>y</sub>
      <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = a<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + a<sub>y</sub>
      <span class="strong"><strong>j</strong></span></td></tr></table><p>If <span class="emphasis"><em>x</em></span> is the displacement in the x-direction and
    <span class="emphasis"><em>y</em></span> is the displacement in the y-direction, then the
    displacement vector is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> = x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span></td></tr></table><p>It follows that:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = d<span class="strong"><strong>s</strong></span>/dt = dx/dt <span class="strong"><strong>i</strong></span> + dy/dt <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = d<span class="strong"><strong>v</strong></span>/dt = d<sup>2</sup><span class="strong"><strong>s</strong></span>/dt<sup>2</sup> =
      d<sup>2</sup>x/dt<sup>2</sup> <span class="strong"><strong>i</strong></span> +
      d<sup>2</sup>y/dt<sup>2</sup> <span class="strong"><strong>j</strong></span></td></tr></table><p>Consider a simple example where you’re writing a <a id="sh2.4" class="indexterm"/>shooting game and you need to figure out the vertical drop
    in a fired bullet from its aim point to the point at which it actually
    hits the target. In this example, assume that there is no wind and no drag
    on the bullet as it flies through the air (we’ll deal with wind and drag
    on projectiles in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>). These assumptions
    reduce the problem to one of constant acceleration, which in this case is
    that due to gravity. It is this gravitational acceleration that is
    responsible for the drop in the bullet as it travels from the rifle to the
    target. <a class="xref" href="ch02.html#a_2d_kinematics_example_problem" title="Figure 2-2. A 2D kinematics example problem">Figure 2-2</a> illustrates the
    problem.</p><div class="figure"><a id="a_2d_kinematics_example_problem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id298826"/><img src="httpatomoreillycomsourceoreillyimages1598884.png" alt="A 2D kinematics example problem"/></div></div><div class="figure-title">Figure 2-2. A 2D kinematics example problem</div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>While we’re talking about guns and shooting here, we should point
      out that these techniques can be applied just as easily to simulating
      the flight of angry birds in <span class="emphasis"><em>Angry Birds</em></span> being shot
      from oversized slingshots, as in the very popular iPhone app. Heck, you
      can use these techniques to simulate flying monkeys, ballistic shoes, or
      coconuts being hurled at Navy combatants! This particle kinematic stuff
      is perfect for diversionary smartphone apps.</p></div><p>Let the origin of the 2D coordinate system be at the end of the
    rifle with the x-axis pointing toward the target and the y-axis pointing
    up. Positive displacements along the x-axis are toward the target, and
    positive displacements along the y-axis are upward. This implies that the
    gravitational acceleration will act in the negative y-direction.</p><p>Treating the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>
    components separately allows you to break up the problem into small,
    easy-to-manage pieces. Looking at the <span class="emphasis"><em>x</em></span> component
    first, you know that the bullet will leave the rifle with an initial
    muzzle velocity <span class="emphasis"><em>v</em></span><sub>m</sub> in the
    x-direction, and since we are neglecting drag, this speed will be
    constant. Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>x</sub> = 0</td></tr><tr><td>v<sub>x</sub> = v<sub>m</sub></td></tr><tr><td>x = v<sub>x</sub> t = v<sub>m</sub>
      t</td></tr></table><p>Now looking at the <span class="emphasis"><em>y</em></span> component, you know that
    the initial speed in the y-direction, as the bullet leaves the rifle, is
    0, but the y-acceleration is <span class="emphasis"><em>–g</em></span> (due to gravity).
    Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>y</sub> = –g =
      dv<sub>y</sub>/dt</td></tr><tr><td>v<sub>y</sub> = a<sub>y</sub> t = –g
      t</td></tr><tr><td>y = (1/2) a<sub>y</sub>
      t<sup>2</sup> = –(1/2) g
      t<sup>2</sup></td></tr></table><p>The displacement, velocity, and acceleration vectors can now be
    written as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> =
      (v<sub>m</sub> t) <span class="strong"><strong>i</strong></span> –
      (1/2 g t<sup>2</sup>) <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> =
      (v<sub>m</sub>) <span class="strong"><strong>i</strong></span> – (g t)
      <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = – (g) <span class="strong"><strong>j</strong></span></td></tr></table><p>These equations give the instantaneous displacement, velocity, and
    acceleration for any given instant between the time the bullet leaves the
    rifle and the time it hits the target. The magnitudes of these vectors
    give the total displacement, velocity, and acceleration at a given time.
    For example:</p><div class="informalequation"><div class="mediaobject"><img src="eq_0203.png" alt="A 2D kinematics example problem"/></div></div><div class="informalequation"><div class="mediaobject"><img src="eq_0204.png" alt="A 2D kinematics example problem"/></div></div><div class="informalequation"><div class="mediaobject"><img src="eq_0205.png" alt="A 2D kinematics example problem"/></div></div><p>To calculate the bullet’s vertical drop at the instant the bullet
    hits the target, you must first calculate the time required to reach the
    target; then, you can use that time to calculate the
    <span class="emphasis"><em>y</em></span> component of displacement, which is the vertical
    drop. Here are the formulas to use:</p><table style="border: 0; " class="simplelist"><tr><td>t<sub>hit</sub> =
      x<sub>hit</sub>/v<sub>m</sub> =
      n/v<sub>m</sub></td></tr><tr><td>d = y<sub>hit</sub> = –(1/2) g
      (t<sub>hit</sub>)<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>n</em></span> is the distance from the rifle to the
    target and <span class="emphasis"><em>d</em></span> is the vertical drop of the bullet at
    the target.</p><p>If the distance to the target, <span class="emphasis"><em>n</em></span>, equals 500 m
    and the muzzle velocity, <span class="emphasis"><em>v</em></span><sub>m</sub>,
    equals 800 m/sec, then the equations for
    <span class="emphasis"><em>t</em></span><sub>hit</sub> and
    <span class="emphasis"><em>d</em></span> give:</p><table style="border: 0; " class="simplelist"><tr><td>t<sub>hit</sub> = 0.625 sec</td></tr><tr><td>d = 1.9 m</td></tr></table><p>These results tell you that in order to hit the intended target at
    that range, you’ll need to aim for a point about 2 m <a id="I_indexterm2_id299190" class="indexterm"/><a id="I_indexterm2_id299200" class="indexterm"/><a id="I_indexterm2_id299209" class="indexterm"/><a id="I_indexterm2_id299219" class="indexterm"/>above it.</p></div><div class="sect1" title="3D Particle Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="d_particle_kinematics-id1">3D Particle Kinematics</h2></div></div></div><p>Extending the <a id="ki2.5" class="indexterm"/><a id="I_indexterm2_id299257" class="indexterm"/><a id="pa2.5" class="indexterm"/>kinematic property vectors to three dimensions is not very
    difficult. It simply involves the addition of one more component to the
    vector representations shown in the previous section on 2D kinematics.
    Introducing <span class="strong"><strong>k</strong></span> as the unit vector in the
    z-direction, you can now write:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> = x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span> + z
      <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> = d<span class="strong"><strong>s</strong></span>/dt = dx/dt <span class="strong"><strong>i</strong></span> + dy/dt <span class="strong"><strong>j</strong></span>
      + dz/dt <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> =
      d<sup>2</sup><span class="strong"><strong>s</strong></span>/dt<sup>2</sup> =
      d<sup>2</sup>x/dt<sup>2</sup> <span class="strong"><strong>i</strong></span> +
      d<sup>2</sup>y/dt<sup>2</sup> <span class="strong"><strong>j</strong></span> +
      d<sup>2</sup>z/dt<sup>2</sup> <span class="strong"><strong>k</strong></span></td></tr></table><p>Instead of treating two components separately and then superimposing
    them, you now treat three components separately and superimpose these.
    This is best illustrated by an example.</p><p>Suppose that instead of a hunting game, you’re now <a id="th2.5" class="indexterm"/><a id="sh2.5" class="indexterm"/>writing a game that involves the firing of a cannon from,
    say, a battleship to a target some distance away—for example, another ship
    or an inland target like a building. To add complexity to this activity
    for your user, you’ll want to give her control of several factors that
    affect the shell’s trajectory—namely, the firing angle of the cannon, both
    horizontal and vertical angles, and the muzzle velocity of the shell,
    which is controlled by the amount of powder packed behind the shell when
    it’s loaded into the cannon. The situation is set up in <a class="xref" href="ch02.html#a_3d_kinematics_example_problem" title="Figure 2-3. A 3D kinematics example problem">Figure 2-3</a>.</p><div class="figure"><a id="a_3d_kinematics_example_problem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id299483"/><img src="httpatomoreillycomsourceoreillyimages1598885.png" alt="A 3D kinematics example problem"/></div></div><div class="figure-title">Figure 2-3. A 3D kinematics example problem</div></div><p>We’ll show you how to set up the kinematic equations for this
    problem by treating each vector component separately at first and then
    combining these components.</p><div class="sect2" title="X Components"><div class="titlepage"><div><div><h3 class="title" id="x_components">X Components</h3></div></div></div><p>The <span class="emphasis"><em>x</em></span> components <a id="th2.5.1" class="indexterm"/>here are similar to those in the previous section’s rifle
      example in that there is no drag force acting on the shell; thus, the
      <span class="emphasis"><em>x</em></span> component of acceleration is 0, which means that
      the <span class="emphasis"><em>x</em></span> component of velocity is constant and equal
      to the <span class="emphasis"><em>x</em></span> component of the muzzle velocity as the
      shell leaves the cannon. Note that since the cannon barrel may not be
      horizontal, you’ll have to compute the <span class="emphasis"><em>x</em></span> component
      of the muzzle velocity, which is a function of the <a id="di2.5.1" class="indexterm"/>direction in which the cannon is aimed.</p><p>The muzzle velocity vector is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>m</sub> =
        v<sub>mx</sub> <span class="strong"><strong>i</strong></span> +
        v<sub>my</sub> <span class="strong"><strong>j</strong></span> +
        v<sub>mz</sub> <span class="strong"><strong>k</strong></span></td></tr></table><p>and you are given only the direction of <span class="strong"><strong>v</strong></span><sub>m</sub> as determined by the
      direction in which the user points the cannon, and its magnitude as
      determined by the amount of powder the user packs into the cannon. To
      calculate the components of the muzzle velocity, you need to develop
      some equations for these components in terms of the direction angles of
      the cannon and the magnitude of the muzzle velocity.</p><p>You can use the direction cosines of a vector to determine the
      velocity components as follows:</p><table style="border: 0; " class="simplelist"><tr><td>cos θ<sub>x</sub> =
        v<sub>mx</sub>/v<sub>m</sub></td></tr><tr><td>cos θ<sub>y</sub> =
        v<sub>my</sub>/v<sub>m</sub></td></tr><tr><td>cox θ<sub>z</sub> =
        v<sub>mz</sub>/v<sub>m</sub></td></tr></table><p>Refer to <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a> for a description
      and <a id="I_indexterm2_id299703" class="indexterm"/><a id="I_indexterm2_id299709" class="indexterm"/>illustration of vector direction cosines.</p><p>Since the initial muzzle velocity vector direction is the same as
      the direction in which the cannon is aimed, you can treat the cannon as
      a vector with a magnitude of <span class="emphasis"><em>L</em></span>, its length, and
      pointing in a direction defined by the angles given in this problem.
      Using the cannon length, <span class="emphasis"><em>L</em></span>, and its components
      instead of muzzle velocity in the equations for direction cosines
      gives:</p><table style="border: 0; " class="simplelist"><tr><td>cos θ<sub>x</sub> =
        L<sub>x</sub>/L</td></tr><tr><td>cos θ<sub>y</sub> =
        L<sub>y</sub>/L</td></tr><tr><td>cos θ<sub>z</sub> =
        L<sub>z</sub>/L</td></tr></table><p>In this example, you are given the angles <span class="emphasis"><em>α</em></span>
      and <span class="emphasis"><em>γ</em></span> (see <a class="xref" href="ch02.html#cannon_orientation" title="Figure 2-4. Cannon orientation">Figure 2-4</a>)
      that define the <a id="I_indexterm2_id299787" class="indexterm"/>cannon orientation.</p><div class="figure"><a id="cannon_orientation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id299810"/><img src="httpatomoreillycomsourceoreillyimages1598886.png" alt="Cannon orientation"/></div></div><div class="figure-title">Figure 2-4. Cannon orientation</div></div><p>Using these angles, it follows that the projection,
      <span class="emphasis"><em>b</em></span>, of the cannon length, <span class="emphasis"><em>L</em></span>,
      onto the x-z plane is:</p><table style="border: 0; " class="simplelist"><tr><td>b = L cos(90° – α)</td></tr></table><p>and the components of the cannon length, <span class="emphasis"><em>L</em></span>,
      on each coordinate axis are:</p><table style="border: 0; " class="simplelist"><tr><td>Lx = b cos γ</td></tr><tr><td>Ly = L cos α</td></tr><tr><td>Lz = b sin γ</td></tr></table><p>Now that you have the information required to compute direction
      cosines, you can write equations for the initial muzzle velocity
      components as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>mx</sub> = v<sub>m</sub> cos
        θ<sub>x</sub></td></tr><tr><td>v<sub>my</sub> = v<sub>m</sub> cos
        θ<sub>y</sub></td></tr><tr><td>v<sub>mz</sub> = v<sub>m</sub> cos
        θ<sub>z</sub></td></tr></table><p>Finally, you can write the <span class="emphasis"><em>x</em></span> components of
      displacement, velocity, and acceleration as <a id="I_indexterm2_id299933" class="indexterm"/><a id="I_indexterm2_id299943" class="indexterm"/>follows:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>x</sub> = 0</td></tr><tr><td>v<sub>x</sub> = v<sub>mx</sub> =
        v<sub>m</sub> cos θ<sub>x</sub></td></tr><tr><td>x = v<sub>x</sub> t = (v<sub>m</sub>
        cos θ<sub>x</sub>) t</td></tr></table></div><div class="sect2" title="Y Components"><div class="titlepage"><div><div><h3 class="title" id="y_components">Y Components</h3></div></div></div><p>The <span class="emphasis"><em>y</em></span> components are <a id="I_indexterm2_id300012" class="indexterm"/>just like the previous rifle example, again with the
      exception here of the initial velocity in the y-direction:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>my</sub> = v<sub>m</sub> cos
        θ<sub>y</sub></td></tr></table><p>Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>y</sub> = –g</td></tr><tr><td>v<sub>y</sub> = v<sub>my</sub> + a t =
        (v<sub>m</sub> cos θ<sub>y</sub>) – g
        t</td></tr></table><p>Before writing the equation for the <span class="emphasis"><em>y</em></span>
      component of displacement, you need to consider the elevation of the
      base of the cannon, plus the height of the end of the cannon barrel, in
      order to calculate the initial <span class="emphasis"><em>y</em></span> component of
      displacement when the shell leaves the cannon. Let
      <span class="emphasis"><em>y</em></span><sub>b</sub> be the elevation of the
      base of the cannon, and let <span class="emphasis"><em>L</em></span> be the length of the
      cannon barrel; then the initial <span class="emphasis"><em>y</em></span> component of
      displacement, <span class="emphasis"><em>y</em></span><sub>o</sub>, is:</p><table style="border: 0; " class="simplelist"><tr><td>y<sub>o</sub> = y<sub>b</sub> + L cos
        α</td></tr></table><p>Now you can write the equation for <span class="emphasis"><em>y</em></span>
      as:</p><table style="border: 0; " class="simplelist"><tr><td>y = y<sub>o</sub> + v<sub>my</sub> t +
        (1/2) a t<sup>2</sup></td></tr><tr><td>y = (y<sub>b</sub> + L cos α) +
        (v<sub>m</sub> cos θ<sub>y</sub>) t – (1/2) g
        t<sup>2</sup></td></tr></table></div><div class="sect2" title="Z Components"><div class="titlepage"><div><div><h3 class="title" id="z_components">Z Components</h3></div></div></div><p>The <span class="emphasis"><em>z</em></span> components <a id="I_indexterm2_id300194" class="indexterm"/>are largely analogous to the <span class="emphasis"><em>x</em></span>
      components and can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>z</sub> = 0</td></tr><tr><td>v<sub>z</sub> = v<sub>mz</sub> =
        v<sub>m</sub> cos θ<sub>z</sub></td></tr><tr><td>z = v<sub>z</sub> t = (v<sub>m</sub>
        cos θ<sub>z</sub>) t</td></tr></table></div><div class="sect2" title="The Vectors"><div class="titlepage"><div><div><h3 class="title" id="the_vectors">The Vectors</h3></div></div></div><p>With the components <a id="I_indexterm2_id300271" class="indexterm"/><a id="I_indexterm2_id300284" class="indexterm"/>all worked out, you can now combine them to form the
      vector for each kinematic property. Doing so for this example gives the
      displacement, velocity, and acceleration vectors shown here:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> =
        [(v<sub>m</sub> cos θ<sub>x</sub>) t]
        <span class="strong"><strong>i</strong></span> + [(y<sub>b</sub> + L
        cos α) + (v<sub>m</sub> cos θ<sub>y</sub>) t –
        (1/2) g t<sup>2</sup>] <span class="strong"><strong>j</strong></span> + [(v<sub>m</sub> cos
        θ<sub>z</sub>) t ] <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> =
        [v<sub>m</sub> cos θ<sub>x</sub> ] <span class="strong"><strong>i</strong></span> + [(v<sub>m</sub> cos
        θ<sub>y</sub>) – g t ] <span class="strong"><strong>j</strong></span> + [v<sub>m</sub> cos
        θ<sub>z</sub> ] <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = –g <span class="strong"><strong>j</strong></span></td></tr></table><p>Observe here that the displacement vector essentially gives the
      position of the shell’s center of mass at any given instant in time;
      thus, you can use this vector to plot the shell’s trajectory from the
      cannon to the target.</p></div><div class="sect2" title="Hitting the Target"><div class="titlepage"><div><div><h3 class="title" id="hitting_the_target">Hitting the Target</h3></div></div></div><p>Now that you have the <a id="th2.5.5" class="indexterm"/><a id="tr2.5.5" class="indexterm"/><a id="si2.5.5" class="indexterm"/><a id="pr2.5.5" class="indexterm"/>equations fully describing the shell’s trajectory, you
      need to consider the location of the target in order to determine when a
      direct hit occurs. To show you how to do this, we’ve prepared a sample
      program that implements these kinematic equations along with a simple
      bounding box collision detection method for checking whether or not the
      shell has struck the target. Basically, at each time step where we
      calculate the position of the shell after it has left the cannon, we
      check to see if this position falls within the bounding dimensions of
      the target object represented by a cube.</p><p>The sample program is set up such that you can change all of the
      variables in the simulation and view the effects of your changes. <a class="xref" href="ch02.html#cannon_sample_program_main_window" title="Figure 2-5. Cannon sample program main window">Figure 2-5</a> shows the main screen for
      the cannon example program, with the governing variables shown on the
      left. The upper illustration is a bird’s-eye view looking down on the
      cannon and the target, while the lower illustration is a profile (side)
      view.</p><div class="figure"><a id="cannon_sample_program_main_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id300534"/><img src="httpatomoreillycomsourceoreillyimages1598887.png" alt="Cannon sample program main window"/></div></div><div class="figure-title">Figure 2-5. Cannon sample program main window</div></div><p>You can change any of the variables shown on the main window and
      press the Fire button to see the resulting flight path of the shell. A
      message box will appear when you hit the target or when the shell hits
      the ground. The program is set up so you can repeatedly change the
      variables and press Fire to see the result without erasing the previous
      trial. This allows you to gauge how much you need to adjust each
      variable in order to hit the target. Press the Refresh button to redraw
      the views when they get too cluttered.</p><p><a class="xref" href="ch02.html#trial_shots_open_parenthesis_profile_vie" title="Figure 2-6. Trial shots (profile view)">Figure 2-6</a> shows
      a few trial shots that we made before finally hitting the target.</p><div class="figure"><a id="trial_shots_open_parenthesis_profile_vie"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id300579"/><img src="httpatomoreillycomsourceoreillyimages1598888.png" alt="Trial shots (profile view)"/></div></div><div class="figure-title">Figure 2-6. Trial shots (profile view)</div></div><p>The code for this example is really quite simple. Aside from the
      overhead of the window, controls, and illustrations setup, all of the
      action takes place when the Fire button is pressed. In pseudocode, the
      Fire button’s pressed event handler looks something like this:</p><a id="I_programlisting2_id300602"/><pre class="programlisting">    FIRE BUTTON PRESSED EVENT:

        Fetch and store user input values for global variables,
        Vm, Alpha, Gamma, L, Yb, X, Y, Z, Length, Width, Height...

        Initialize the time and status variables...
        <span class="strong"><strong>status = 0;</strong></span>
        <span class="strong"><strong>time = 0;</strong></span>

        Start stepping through time for the simulation
        until the target is hit, the shell hits
        the ground, or the simulation times out...

        <span class="strong"><strong>while(status == 0)</strong></span>
        <span class="strong"><strong>{</strong></span>
            <span class="strong"><strong>// do the next time step</strong></span>
            <span class="strong"><strong>status = DoSimulation();</strong></span>

            <span class="strong"><strong>Update the display...</strong></span>

        <span class="strong"><strong>}</strong></span>

        // Report results
        if (status == 1)
            Display DIRECT HIT message to the user...

        if (status == 2)
            Display MISSED TARGET message to the user...

        if (status == 3)
            Display SIMULATION TIMED OUT message to the user...</pre><p>The first task is to simply get the new values for the variables
      shown on the main window. After that, the program enters a <code class="literal">while</code> loop, stepping through increments of
      time and recalculating the position of the shell projectile using the
      formula for the displacement vector, <span class="strong"><strong>s</strong></span>, shown earlier. The shell position at the
      current time is calculated in the function <code class="literal">DoSimulation</code>. Immediately after calling
      <code class="literal">DoSimulation</code>, the program updates the
      illustrations on the main window, showing the shell’s trajectory.
      <code class="literal">DoSimulation</code> returns <code class="literal">0</code>, keeping the <code class="literal">while</code> loop going, if there has not yet been a
      collision or if the time has not yet reached the preset time-out
      value.</p><p>Once the <code class="literal">while</code> loop terminates
      by <code class="literal">DoSimulation</code> returning nonzero,
      the program checks the return value from this function call to see if a
      hit has occurred between the shell and the ground or the shell and the
      target. Just so the program does not get stuck in this <code class="literal">while</code> loop, <code class="literal">DoSimulation</code> will return a value of <code class="literal">3</code>, indicating that it is taking too
      long.</p><p>Now let’s look at what’s happing in the function <code class="literal">DoSimulation</code> (we’ve also included here the
      global variables that are used in <code class="literal">DoSimulation</code>).</p><a id="I_programlisting2_id300764"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Define a custom type to represent
// the three components of a 3D vector, where
// i represents the x component, j represents
// the y component, and k represents the z
// component
//---------------------------------------------------------------------------//
typedef struct TVectorTag
{
     double i;
     double j;
     double k;
} TVector;

//---------------------------------------------------------------------------//
// Now define the variables required for this simulation
//---------------------------------------------------------------------------//
double          Vm;    // Magnitude of muzzle velocity, m/s
double          Alpha; // Angle from y-axis (upward) to the cannon.
                       // When this angle is 0, the cannon is pointing
                       // straight up, when it is 90 degrees, the cannon
                       // is horizontal
double          Gamma; // Angle from x-axis, in the x-z plane to the cannon.
                       // When this angle is 0, the cannon is pointing in
                       // the positive x-direction, positive values of this angle
                       // are toward the positive z-axis
double          L;     // This is the length of the cannon, m
double          Yb;    // This is the base elevation of the cannon, m

double          X;     // The x-position of the center of the target, m
double          Y;     // The y-position of the center of the target, m
double          Z;     // The z-position of the center of the target, m
double          Length; // The length of the target measured along the x-axis, m
double          Width;  // The width of the target measured along the z-axis, m
double          Height; // The height of the target measure along the y-axis, m

TVector          s;     // The shell position (displacement) vector

double          time;   // The time from the instant the shell leaves
                        // the cannon, seconds
double          tInc;   // The time increment to use when stepping through
                        // the simulation, seconds

double          g;      // acceleration due to gravity, m/s^2

//-----------------------------------------------------------------------------//
// This function steps the simulation ahead in time. This is where the kinematic
// properties are calculated. The function will return 1 when the target is hit,
// and 2 when the shell hits the ground (x-z plane) before hitting the target;
// otherwise, the function returns 0.
//-----------------------------------------------------------------------------//
int    DoSimulation(void)
//-----------------------------------------------------------------------------//
{
    double    cosX;
    double    cosY;
    double    cosZ;
    double    xe, ze;
    double    b, Lx, Ly, Lz;
    double    tx1, tx2, ty1, ty2, tz1, tz2;

    // step to the next time in the simulation
    time+=tInc;

    // First calculate the direction cosines for the cannon orientation.
    // In a real game, you would not want to put this calculation in this
    // function since it is a waste of CPU time to calculate these values
    // at each time step as they never change during the sim. We only put them
     // here in this case so you can see all the calculation steps in a single
    // function.
    b = L * cos((90-Alpha) *3.14/180);  // projection of barrel onto x-z plane
    Lx = b * cos(Gamma * 3.14/180);    // x-component of barrel length
    Ly = L * cos(Alpha * 3.14/180);    // y-component of barrel length
    Lz = b  * sin(Gamma * 3.14/180);    // z-component of barrel length

    cosX = Lx/L;
    cosY = Ly/L;
    cosZ = Lz/L;

    // These are the x and z coordinates of the very end of the cannon barrel
    // we'll use these as the initial x and z displacements
    xe = L * cos((90-Alpha) *3.14/180) * cos(Gamma * 3.14/180);
    ze = L * cos((90-Alpha) *3.14/180) * sin(Gamma * 3.14/180);

    // Now we can calculate the position vector at this time
    s.i =     Vm * cosX * time + xe;
    s.j =     (Yb + L * cos(Alpha*3.14/180)) + (Vm * cosY * time) −
        (0.5 * g * time * time);
    s.k =     Vm * cosZ * time + ze;

    // Check for collision with target
    // Get extents (bounding coordinates) of the target
    tx1 = X - Length/2;
    tx2 = X + Length/2;
    ty1 = Y - Height/2;
    ty2 = Y + Height/2;
    tz1 = Z - Width/2;
    tz2 = Z + Width/2;

    // Now check to see if the shell has passed through the target
    // We're using a rudimentary collision detection scheme here where
    // we simply check to see if the shell's coordinates are within the
    // bounding box of the target. This works for demo purposes, but
    // a practical problem is that you may miss a collision if for a given
    // time step the shell's change in position is large enough to allow
    // it to "skip" over the target.
    // A better approach is to look at the previous time step's position data
    // and to check the line from the previous position to the current position
    // to see if that line intersects the target bounding box.
    if( (s.i &gt;= tx1 &amp;&amp; s.i &lt;= tx2) &amp;&amp;
        (s.j &gt;= ty1 &amp;&amp; s.j &lt;= ty2) &amp;&amp;
        (s.k &gt;= tz1 &amp;&amp; s.k &lt;= tz2) )
        return 1;

    // Check for collision with ground (x-z plane)
    if(s.j &lt;= 0)
        return 2;

    // Cut off the simulation if it's taking too long
    // This is so the program does not get stuck in the while loop
    if(time&gt;3600)
        return 3;

    return 0;
}</pre><p>We’ve commented the code so that you can readily see what’s going
      on. This function essentially does four things: 1) increments the time
      variable by the specified time increment, 2) calculates the initial
      muzzle velocity components in the x-, y-, and z-directions, 3)
      calculates the shell’s new position, and 4) checks for a collision with
      the target using a bounding box scheme or the ground.</p><p>Here’s the code that computes the shell’s position:</p><a id="I_programlisting2_id300827"/><pre class="programlisting">    // Now we can calculate the position vector at this time
    s.i =     Vm * cosX * time + xe;
    s.j =     (Yb + L * cos(Alpha*3.14/180)) + (Vm * cosY * time) −
        (0.5 * g * time * time);
    s.k =     Vm * cosZ * time + ze;</pre><p>This code calculates the three components of the displacement
      vector, <span class="strong"><strong>s</strong></span>, using the formulas that we
      gave you earlier. If you wanted to compute the velocity and acceleration
      vectors as well, just to see their values, you should do so in this
      section of the program. You can set up a couple of new global variables
      to represent the velocity and acceleration vectors, just as we did with
      the displacement vector, and apply the velocity and acceleration
      formulas that we gave you.</p><p>That’s all there is to it. It’s obvious by playing with this
      sample program that the shell’s trajectory is parabolic in shape, which
      is typical <span class="emphasis"><em>projectile motion</em></span>. We’ll take a more
      detailed look at this sort of motion in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>.</p><p>Even though we put a comment in the source code, we must reiterate
      a warning here regarding the collision detection scheme that we used in
      this example. Because we’re checking only the current position
      coordinate to see if it falls within the bounding dimensions of the
      target cube, we run the risk of skipping over the target if the change
      in position is too large for a given time step. A better approach would
      be to keep track of the shell’s previous position and check to see if
      the line connecting the previous position to the new one intersects the
      target <a id="I_indexterm2_id300870" class="indexterm"/><a id="I_indexterm2_id300880" class="indexterm"/><a id="I_indexterm2_id300889" class="indexterm"/><a id="I_indexterm2_id300899" class="indexterm"/><a id="I_indexterm2_id300908" class="indexterm"/><a id="I_indexterm2_id300917" class="indexterm"/><a id="I_indexterm2_id300927" class="indexterm"/><a id="I_indexterm2_id300936" class="indexterm"/>cube.</p></div></div><div class="sect1" title="Kinematic Particle Explosion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="kinematic_particle_explosion">Kinematic Particle Explosion</h2></div></div></div><p>At this <a id="ki2.6" class="indexterm"/><a id="ex2.6" class="indexterm"/><a id="pae2.6" class="indexterm"/><a id="pa2.6" class="indexterm"/><a id="pr2.6" class="indexterm"/>point you might be wondering how particle kinematics can
    help you create realistic game content unless you’re writing a game that
    involves shooting a gun or a cannon. If so, let us offer you a few ideas
    and then show you an example. Say you’re writing a football simulation
    game. You can use particle kinematics to model the <a id="I_indexterm2_id301035" class="indexterm"/><a id="I_indexterm2_id301046" class="indexterm"/><a id="I_indexterm2_id301056" class="indexterm"/><a id="I_indexterm2_id301062" class="indexterm"/><a id="I_indexterm2_id301072" class="indexterm"/>trajectory of the football after it’s thrown or kicked. You
    can also treat the wide receivers as particles when calculating whether or
    not they’ll be able to catch the thrown ball. In this scenario you’ll have
    two particles—the receiver and the ball—traveling independently, and
    you’ll have to calculate when a collision occurs between these two
    particles, indicating a catch (unless, of course, your player is all
    thumbs and fumbles the ball after it hits his hands). You can find similar
    applications for other sports-based games as well.</p><p>What about a 3D “shoot ’em up” game? How <a id="I_indexterm2_id301091" class="indexterm"/>could you use particle kinematics in this genre aside from
    bullets, cannons, grenades, and the like? Well, you could use particle
    kinematics to model your player when she jumps into the air, either from a
    run or from a standing position. For example, your player reaches the
    middle of a catwalk only to find a section missing, so you immediately
    back up a few paces to get a running head start before leaping into the
    air, hoping to clear the gap. This long-jump scenario is perfect for using
    particle kinematics. All you really need to do is define your player’s
    initial velocity, both speed and take-off angle, and then apply the vector
    formula for displacement to calculate whether or not the player makes the
    jump. You can also use the displacement formula to calculate the player’s
    trajectory so that you can move the player’s viewpoint accordingly, giving
    the illusion of leaping into the air. You may in fact already be using
    these principles to model this action in your games, or at least you’ve
    seen it done if you play games of this genre. If your player happens to
    fall short on the jump, you can use the formulas for velocity to calculate
    the player’s impact velocity when she hits the ground below. Based on this
    impact velocity, you can determine an appropriate amount of damage to
    deduct from the player’s health score, or if the velocity is over a
    certain threshold, you can say goodbye to your would-be adventurer!</p><p>Another use for simple particle kinematics is for certain <a id="I_indexterm2_id301118" class="indexterm"/>special effects like particle explosions. This sort of
    effect is quite simple to implement and really adds a sense of realism to
    explosion effects. The particles don’t just fly off in random,
    straight-line trajectories. Instead, they rise and fall under the
    influence of their initial velocity, angle, and the acceleration due to
    gravity, which gives the impression that the particles have mass.</p><p>So, let’s explore an example of a kinematic particle explosion. The
    code for this example is taken from the cannon example discussed
    previously, so a lot of it should look familiar to you. <a class="xref" href="ch02.html#particle_explosion_example_program" title="Figure 2-7. Particle explosion example program">Figure 2-7</a> shows this example
    program’s main window.</p><div class="figure"><a id="particle_explosion_example_program"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id301156"/><img src="httpatomoreillycomsourceoreillyimages1598889.png.jpg" alt="Particle explosion example program"/></div></div><div class="figure-title">Figure 2-7. Particle explosion example program</div></div><p>The explosion effect takes place in the large rectangular area on
    the right. While the black dots representing exploding particles are
    certainly static in the figure, we assure you they move in the most
    spectacular way during the simulation.</p><p>In the edit controls on the left, you specify an x- and y-position
    for the effect, along with the initial velocity of the particles (which is
    a measure of the explosion’s strength), a duration in milliseconds, a
    gravity factor, and finally an angle. The angle parameter can be any
    number between 0 and 360 degrees or 999. When you specify an angle in the
    range of 0 to 360 degrees, all the particles in the explosion will be
    launched generally in that direction. If you specify a value of 999, then
    all the particles will shoot off in random directions. The duration
    parameter is essentially the life of the effect. The particles will fade
    out as they approach that life.</p><p>The first thing you need to do for this example is set up some
    structures and global variables to represent the particle effect and the
    individual particles making up the effect along with the initial
    parameters describing the behavior of the effect as discussed in the
    previous paragraph. Here’s the code:</p><a id="I_programlisting2_id301195"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Define a custom type to represent each particle in the effect.
//---------------------------------------------------------------------------//
typedef     struct _TParticle
{
     float          x;           // x coordinate of the particle
     float          y;           // y coordinate of the particle
     float          vi;          // initial velocity
     float          angle;       // initial trajectory (direction)
     int            life;        // duration in milliseconds
     int            r;           // red component of particle's color
     int            g;           // green component of particle's color
     int            b;           // blue component of particle's color
     int            time;        // keeps track of the effect's time
     float          gravity;     // gravity factor
     BOOL           Active;      // indicates whether this particle
                                 // is active or dead
} TParticle;

#define     _MAXPARTICLES 50

typedef struct _TParticleExplosion
{
     TParticle     p[_MAXPARTICLES];  // list of particles
                                      // making up this effect
     int           V0; // initial velocity, or strength, of the effect
     int           x;  // initial x location
     int           y;  // initial y location
     BOOL          Active;      // indicates whether this effect is
                                //active or dead
} TParticleExplosion;

//---------------------------------------------------------------------------//
// Now define the variables required for this simulation
//---------------------------------------------------------------------------//
TParticleExplosion     Explosion;

int                      xc;         // x coordinate of the effect
int                      yc;         // y coordinate of the effect
int                      V0;         // initial velocity
int                      Duration;   // life in milliseconds
float                    Gravity;    // gravity factor (acceleration)
float                    Angle;      // indicates particles' direction</pre><p>You can see from this code that the particle explosion effect is
    made up of a collection of particles. The behavior of each particle is
    determined by kinematics and the initial parameters set for each
    particle.</p><p>Whenever you press the Go button, the initial parameters that you
    specified are used to initialize the particle explosion (if you press the
    Random button, the program randomly selects these initial values for you).
    This takes place in the function called <code class="literal">CreateParticleExplosion</code>:</p><a id="I_programlisting2_id301235"/><pre class="programlisting">/////////////////////////////////////////////////////////////////////
/*     This function creates a new particle explosion effect.

     x,y:      starting point of the effect
     Vinit:    a measure of how fast the particles will be sent flying
               (it's actually the initial velocity of the particles)
     life:     life of the particles in milliseconds; particles will
               fade and die out as they approach
               their specified life
     gravity:  the acceleration due to gravity, which controls the
               rate at which particles will fall
               as they fly
     angle:    initial trajectory angle of the particles,
               specify 999 to create a particle explosion
               that emits particles in all directions; otherwise,
               0 right, 90 up, 180 left, etc...
*/
void CreateParticleExplosion(int x, int y, int Vinit, int life,
                             float gravity, float angle)
{
     int   i;
     int   m;
     float f;

     Explosion.Active = TRUE;
     Explosion.x = x;
     Explosion.y = y;
     Explosion.V0 = Vinit;

     for(i=0; i&lt;_MAXPARTICLES; i++)
     {
          Explosion.p[i].x = 0;
          Explosion.p[i].y = 0;
          Explosion.p[i].vi = tb_Rnd(Vinit/2, Vinit);

          if(angle &lt; 999)
          {
               if(tb_Rnd(0,1) == 0)
                    m = −1;
               else
                    m = 1;
               Explosion.p[i].angle = -angle + m * tb_Rnd(0,10);
          } else
               Explosion.p[i].angle = tb_Rnd(0,360);

          f = (float) tb_Rnd(80, 100) / 100.0f;
          Explosion.p[i].life = tb_Round(life * f);
          Explosion.p[i].r = 255;//tb_Rnd(225, 255);
          Explosion.p[i].g = 255;//tb_Rnd(85, 115);
          Explosion.p[i].b = 255;//tb_Rnd(15, 45);
          Explosion.p[i].time = 0;
          Explosion.p[i].Active = TRUE;
          Explosion.p[i].gravity = gravity;
     }

}</pre><p>Here you can see that all the particles are set to start off in the
    same position, as specified by the <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>y</em></span> coordinates that you provide; however, you’ll
    notice that the initial velocity of each particle is actually randomly
    selected from a range of <code class="literal">Vinit/2</code> to
    <code class="literal">Vinit</code>. We do this to give the particle
    behavior some variety. We do the same thing for the life parameter of each
    particle so they don’t all fade out and die at the exact same time.</p><p>After the particle explosion is created, the program enters a loop
    to propagate and draw the effect. The loop is a <code class="literal">while</code> loop, as shown here in pseudocode:</p><a id="I_programlisting2_id301295"/><pre class="programlisting">while(status)
{
    Clear the off screen buffer...

    <span class="strong"><strong>status = DrawParticleExplosion( );</strong></span>

    Copy the off screen buffer to the screen...
}</pre><p>The <code class="literal">while</code> loop continues as long
    as <code class="literal">status</code> remains <code class="literal">true</code>, which indicates that the particle effect
    is still alive. After all the particles in the effect reach their set
    life, then the effect is dead and <code class="literal">status</code> will be set to <code class="literal">false</code>. All the calculations for the particle
    behavior actually take place in the function called <code class="literal">DrawParticleExplosion</code>; the rest of the code in
    this <code class="literal">while</code> loop is for clearing the
    off-screen buffer and then copying it to the main window.</p><p><code class="literal">DrawParticleExplosion</code> updates the
    state of each particle in the effect by calling another function, <code class="literal">UpdateParticleState</code>, and then draws the effect
    to the off-screen buffer passed in as a parameter. Here’s what these two
    functions look like:</p><a id="I_programlisting2_id301372"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Draws the particle system and updates the state of each particle.
// Returns false when all of the particles have died out.
//---------------------------------------------------------------------------//

BOOL     DrawParticleExplosion(void)
{
     int      i;
     BOOL     finished = TRUE;
     float    r;

     if(Explosion.Active)
       for(i=0; i&lt;_MAXPARTICLES; i++)
       {
          if(Explosion.p[i].Active)
          {
               finished = FALSE;

               // Calculate a color scale factor to fade the particle's color
               // as its life expires
               r = ((float)(Explosion.p[i].life-
                     Explosion.p[i].time)/(float)(Explosion.p[i].life));

               ...
               Draw the particle as a small circle...
               ...

               Explosion.p[i].Active = UpdateParticleState(&amp;(Explosion.p[i]),
                                                           10);
          }
       }

     if(finished)
          Explosion.Active = FALSE;

     return !finished;
}

//---------------------------------------------------------------------------//
/*  This is generic function to update the state of a given particle.
     p:         pointer to a particle structure
     dtime:     time increment in milliseconds to
                advance the state of the particle

     If the total elapsed time for this particle has exceeded the particle's
     set life, then this function returns FALSE, indicating that the particle
     should expire.
*/
BOOL     UpdateParticleState(TParticle* p, int dtime)
{
     BOOL retval;
     float     t;

     p-&gt;time+=dtime;
     t = (float)p-&gt;time/1000.0f;
     p-&gt;x = p-&gt;vi * cos(p-&gt;angle*PI/180.0f) * t;
     p-&gt;y = p-&gt;vi * sin(p-&gt;angle*PI/180.0f) * t + (p-&gt;gravity*t*t)/2.0f;

     if (p-&gt;time &gt;= p-&gt;life)
          retval = FALSE;
     else
          retval = TRUE;

     return retval;
}</pre><p><code class="literal">UpdateParticleState</code> uses the
    kinematic formulas that we’ve already shown you to update the particle’s
    position as a function of its initial velocity, time, and the acceleration
    due to gravity. After <code class="literal">UpdateParticleState</code> is called, <code class="literal">DrawParticleExplosion</code> scales down each
    particle’s color, fading it to black, based on the life of each particle
    and elapsed time. The <a id="I_indexterm2_id301417" class="indexterm"/><a id="I_indexterm2_id301424" class="indexterm"/>fade effect is simply to show the particles dying slowly
    over time instead of disappearing from the screen. The effect resembles
    the behavior of <a id="I_indexterm2_id301437" class="indexterm"/>fireworks as they explode in the <a id="I_indexterm2_id301444" class="indexterm"/><a id="I_indexterm2_id301453" class="indexterm"/><a id="I_indexterm2_id301463" class="indexterm"/><a id="I_indexterm2_id301472" class="indexterm"/><a id="I_indexterm2_id301481" class="indexterm"/>night sky.</p></div><div class="sect1" title="Rigid-Body Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="rigid-body_kinematics">Rigid-Body Kinematics</h2></div></div></div><p>The formulas for <a id="I_indexterm2_id301500" class="indexterm"/><a id="I_indexterm2_id301511" class="indexterm"/>displacement, velocity, and acceleration discussed in the
    previous sections apply equally well for rigid bodies as they do for
    particles. The difference is that with rigid bodies, the point on the
    rigid body that you track, in terms of linear motion, is the body’s
    <a id="I_indexterm2_id301520" class="indexterm"/>center of mass (gravity).</p><p>When a rigid body translates with no rotation, all of the particles
    making up the rigid body move on parallel paths since the body does not
    change its shape. Further, when a rigid body does rotate, it generally
    rotates about axes that pass through its center of mass, unless the body
    is hinged at some other point about which it’s forced to rotate. These
    facts make the center of mass a convenient point to use to track its
    linear motion. This is good news for you since you can use all of the
    material you learned on particle kinematics here in your study of
    rigid-body kinematics.</p><p>The procedure for dealing with rigid bodies involves two distinct
    aspects: 1) tracking the translation of the body’s center of mass, and 2)
    tracking the body’s rotation. The first aspect is old hat by now—just
    treat the body as a particle. The second aspect, however, requires you to
    consider a few more concepts—namely, local coordinates, angular
    displacement, angular velocity, and angular acceleration.</p><p>For most of the remainder of this chapter, we’ll discuss
    <span class="emphasis"><em>plane</em></span> kinematics of rigid bodies. Plane motion
    <a id="I_indexterm2_id301556" class="indexterm"/><a id="I_indexterm2_id301562" class="indexterm"/>simply means that the body’s motion is restricted to a flat
    plane in space where the only axis of rotation about which the body can
    rotate is perpendicular to the plane. Plane motion is essentially
    two-dimensional. This allows us to focus on the new kinematic concepts of
    angular displacement, velocity, and acceleration without getting lost in
    the math required to describe arbitrary rotation in three
    dimensions.</p><p>You might be surprised by how many problems lend themselves to plane
    kinematic solutions. For example, in some popular 3D “shoot ’em up” games,
    your character is able to push objects, such as boxes and barrels, around
    on the floor. While the game world here is three dimensions, these
    particular objects may be restricted to sliding on the floor—a plane—and
    thus can be treated like a 2D problem. Even if the player pushes on these
    objects at some angle instead of straight on, you’ll be able to simulate
    the sliding and rotation of these objects using 2D kinematics (and
    kinetics) techniques.</p></div><div class="sect1" title="Local Coordinate Axes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="local_coordinate_axes">Local Coordinate Axes</h2></div></div></div><p>Earlier, we <a id="I_indexterm2_id301601" class="indexterm"/><a id="I_indexterm2_id301611" class="indexterm"/><a id="I_indexterm2_id301617" class="indexterm"/><a id="I_indexterm2_id301628" class="indexterm"/>defined the Cartesian coordinate system to use for your
    fixed global reference, or world coordinates. This world coordinate system
    is all that’s required when treating particles; however, for rigid bodies
    you’ll also use a set of local coordinates fixed to the body.
    Specifically, this local coordinate system will be fixed at the body’s
    center-of-mass location. You’ll use this coordinate system to track the
    <a id="I_indexterm2_id301642" class="indexterm"/>orientation of the body as it rotates.</p><p>For plane motion, we require only one scalar quantity to describe
    the body’s orientation. This is illustrated in <a class="xref" href="ch02.html#local_coordinate_axes-id1" title="Figure 2-8. Local coordinate axes">Figure 2-8</a>.</p><div class="figure"><a id="local_coordinate_axes-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id301675"/><img src="httpatomoreillycomsourceoreillyimages1598890.png" alt="Local coordinate axes"/></div></div><div class="figure-title">Figure 2-8. Local coordinate axes</div></div><p>Here the orientation, Ω, is defined as the angular difference
    between the two sets of coordinate axes: the fixed world axes and the
    local body axes. This is the so-called Euler angle. In general 3D motion
    there is a total of <a id="I_indexterm2_id301712" class="indexterm"/>three Euler angles, which are usually called
    <span class="emphasis"><em>yaw</em></span>, <span class="emphasis"><em>pitch</em></span>, and
    <span class="emphasis"><em>roll</em></span> in <a id="I_indexterm2_id301736" class="indexterm"/><a id="I_indexterm2_id301746" class="indexterm"/><a id="I_indexterm2_id301756" class="indexterm"/>aerodynamic and hydrodynamic jargon. While these angular
    representations are easy to visualize in terms of their physical meaning,
    they aren’t so nice from a numerical point of view, so you’ll have to look
    for alternative representations when writing your 3D real-time simulator.
    These issues are addressed in <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>.</p></div><div class="sect1" title="Angular Velocity and Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="angular_velocity_and_acceleration">Angular Velocity and Acceleration</h2></div></div></div><p>In two-dimensional <a id="ki2.9" class="indexterm"/><a id="av2.9" class="indexterm"/><a id="aa2.9" class="indexterm"/><a id="va2.9" class="indexterm"/><a id="aca2.9" class="indexterm"/>plane motion, as the body rotates, Ω will change, and the
    rate at which it changes is the angular velocity, ω. Likewise, the rate at
    which ω changes is the angular acceleration, α. These angular properties
    are analogous to the linear properties of displacement, <a id="I_indexterm2_id301873" class="indexterm"/><a id="I_indexterm2_id301883" class="indexterm"/>velocity, and acceleration. The units for angular
    displacement, velocity, and acceleration are radians (rad), radians per
    sec (rad/s), and radians per second-squared
    (rad/s<sup>2</sup>), respectively.</p><p>Mathematically, you can write these relations between angular
    displacement, angular velocity, and angular acceleration as:</p><table style="border: 0; " class="simplelist"><tr><td>ω = dΩ/dt</td></tr><tr><td>α = dω/dt =
      d<sup>2</sup>Ω/dt<sup>2</sup></td></tr><tr><td>ω = ∫ α dt</td></tr><tr><td>Ω = ∫ ω dt</td></tr><tr><td>ω dω = α dΩ</td></tr></table><p>In fact, you can substitute the angular properties Ω, ω, and α for
    the linear properties <span class="emphasis"><em>s</em></span>, <span class="emphasis"><em>v</em></span>, and
    <span class="emphasis"><em>a</em></span> in the equations derived earlier for particle
    kinematics to obtain similar kinematic equations for rotation. For
    constant angular acceleration, you’ll end up with the following
    equations:</p><table style="border: 0; " class="simplelist"><tr><td>ω<sub>2</sub> = ω<sub>1</sub> + α
      t</td></tr><tr><td>ω<sub>2</sub><sup>2</sup> =
      ω<sub>1</sub><sup>2</sup> + 2 α
      (Ω<sub>2</sub> − Ω<sub>1</sub>)</td></tr><tr><td>Ω<sub>2</sub> = Ω<sub>1</sub> +
      ω<sub>1</sub>t + (1/2) α
      t<sup>2</sup></td></tr></table><p>When a rigid body rotates about a given axis, every point on the
    rigid body sweeps out a circular path around the axis of rotation. You can
    think of the body’s rotation as causing additional linear motion of each
    particle making up the body—that is, this linear motion is in addition to
    the linear motion of the body’s center of mass. To get the total linear
    motion of any particle or point on the rigid body, you must be able to
    relate the angular motion of the body to the linear motion of the particle
    or point as it sweeps its circular path about the axis of rotation.</p><p>Before we show you how to do this, we’ll explain why you would even
    want to perform such a calculation. Basically, in dynamics, knowing that
    two objects have collided is not always enough, and you’ll often want to
    know how hard, so to speak, these two objects have collided. When you’re
    dealing with interacting rigid bodies that may at some point make contact
    with one another or with other fixed objects, you need to determine not
    only the location of the points of contact, but also the relative velocity
    or acceleration between the contact points. This information will allow
    you to calculate the interaction forces between the colliding
    bodies.</p><p>The arc length of the path swept by a particle on the rigid body is
    a function of the distance from the axis of rotation to the particle and
    the angular displacement, Ω. We’ll use <span class="emphasis"><em>c</em></span> to denote
    arc length and <span class="emphasis"><em>r</em></span> to denote the distance from the axis
    of rotation to the particle, as <a id="I_indexterm2_id302037" class="indexterm"/>shown in <a class="xref" href="ch02.html#circular_path_of_particles_making_up" title="Figure 2-9. Circular path of particles making up a rigid body">Figure 2-9</a>.</p><div class="figure"><a id="circular_path_of_particles_making_up"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302065"/><img src="httpatomoreillycomsourceoreillyimages1598891.png" alt="Circular path of particles making up a rigid body"/></div></div><div class="figure-title">Figure 2-9. Circular path of particles making up a rigid body</div></div><p>The formula relating arc length to <a id="I_indexterm2_id302085" class="indexterm"/><a id="I_indexterm2_id302095" class="indexterm"/>angular displacement is:</p><table style="border: 0; " class="simplelist"><tr><td>c = r Ω</td></tr></table><p>where Ω must be in radians, not degrees. If you differentiate this
    formula with respect to time:</p><table style="border: 0; " class="simplelist"><tr><td>dc/dt = r dΩ/dt</td></tr></table><p>you get an equation relating the <a id="I_indexterm2_id302131" class="indexterm"/><a id="I_indexterm2_id302140" class="indexterm"/>linear velocity of the particle as it moves along its
    circular path to the angular velocity of the rigid body. This equation is
    written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v = r ω</td></tr></table><p>This velocity as a vector is tangent to the circular path swept by
    the particle. Imagine this particle as a ball at the end of a rod where
    the other end of the rod is fixed to a rotating axis. If the ball is
    released from the end of the rod as it rotates, the ball will fly off in a
    direction tangent to the circular path it was taking when attached to the
    rod. This is in the same direction as the tangential linear velocity given
    by the preceding equation. <a class="xref" href="ch02.html#linear_velocity_due_to_angular_velocity" title="Figure 2-10. Linear velocity due to angular velocity">Figure 2-10</a> illustrates the
    <a id="I_indexterm2_id302176" class="indexterm"/><a id="I_indexterm2_id302182" class="indexterm"/>tangential velocity.</p><div class="figure"><a id="linear_velocity_due_to_angular_velocity"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302205"/><img src="httpatomoreillycomsourceoreillyimages1598892.png" alt="Linear velocity due to angular velocity"/></div></div><div class="figure-title">Figure 2-10. Linear velocity due to angular velocity</div></div><p>Differentiating the equation, <span class="emphasis"><em>v</em></span> =
    <span class="emphasis"><em>r</em></span> ω:</p><table style="border: 0; " class="simplelist"><tr><td>dv/dt = r dω/dt</td></tr></table><p>yields this formula for the tangential linear acceleration as a
    function of angular acceleration:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>t</sub> = r α</td></tr></table><p>Note that there is another component of acceleration for the
    particle that results from the rotation of the rigid body. This <a id="I_indexterm2_id302268" class="indexterm"/><a id="I_indexterm2_id302274" class="indexterm"/>component—the <span class="emphasis"><em>centripetal</em></span>
    acceleration—is normal, or perpendicular, to the circular path of the
    particle and is always directed toward the axis of rotation. Remember that
    velocity is a vector and since acceleration is the rate of change in the
    velocity vector, there are two ways that acceleration can be produced. One
    way is by a change in the magnitude of the velocity vector—that is, a
    change in speed—and the other way is a change in the direction of the
    velocity vector. The change in speed gives rise to the <a id="I_indexterm2_id302293" class="indexterm"/><a id="I_indexterm2_id302299" class="indexterm"/>tangential acceleration component, while the direction
    change gives rise to the centripetal acceleration component. The resultant
    acceleration vector is the vector sum of the tangential and centripetal
    accelerations (see <a class="xref" href="ch02.html#tangential_and_centripetal_acceleration" title="Figure 2-11. Tangential and centripetal acceleration">Figure 2-11</a>). Centripetal
    acceleration is what you feel when you take your car around a tight curve
    even though your speed is constant.</p><div class="figure"><a id="tangential_and_centripetal_acceleration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302328"/><img src="httpatomoreillycomsourceoreillyimages1598893.png" alt="Tangential and centripetal acceleration"/></div></div><div class="figure-title">Figure 2-11. Tangential and centripetal acceleration</div></div><p>The formula for the magnitude of centripetal acceleration,
    <span class="emphasis"><em>a</em></span><sub>n</sub>, is:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>n</sub> =
      v<sup>2</sup>/r</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is the tangential velocity.
    Substituting the equation for tangential velocity into this equation for
    centripetal acceleration gives the following alternative form:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>n</sub> = r
      ω<sup>2</sup></td></tr></table><p>In two dimensions you can easily get away with using these scalar
    equations; however, in three dimensions you’ll have to use the vector
    forms of these equations. Angular velocity as a vector is parallel with
    the axis of rotation. In <a class="xref" href="ch02.html#linear_velocity_due_to_angular_velocity" title="Figure 2-10. Linear velocity due to angular velocity">Figure 2-10</a> the angular velocity
    would be pointing out of the page directly at you. Its sense, or direction
    of <a id="I_indexterm2_id302409" class="indexterm"/>rotation, is determined by the <span class="emphasis"><em>right hand
    rule</em></span>. If you curl the fingers of your right hand in an arc
    around the axis of rotation with your fingers pointing toward the
    direction in which the body is rotating, then your thumb will stick up in
    the direction of the angular velocity vector.</p><p>If you take the vector cross product (refer to the sidebar <a class="xref" href="ch02.html#vector_cross_product" title="Vector Cross Product">Vector Cross Product</a> for background and to <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a> for a review of vector math) of the angular
    velocity vector and the vector from the axis of rotation to the particle
    under consideration, you’ll end up with the linear, tangential velocity
    vector. This is written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = <span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span></td></tr></table><p>Note that this gives both the magnitude and direction of the linear,
    tangential velocity. Also, be sure to preserve the order of the vectors
    when taking the cross product—that is, <span class="strong"><strong>ω</strong></span> cross <span class="strong"><strong>r</strong></span>, and
    not the other way around, which would give the wrong direction for
    <span class="strong"><strong>v</strong></span>.</p><div class="sidebar"><a id="vector_cross_product"/><div class="sidebar-title">Vector Cross Product</div><p>Given any two <a id="I_indexterm2_id302510" class="indexterm"/><a id="I_indexterm2_id302516" class="indexterm"/>vectors <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span>, the cross product <span class="strong"><strong>A</strong></span> × <span class="strong"><strong>B</strong></span> is
      defined by a third vector <span class="strong"><strong>C</strong></span> with a
      magnitude equal to AB sin θ, where θ is the angle between the two
      vectors <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span>, as illustrated in the following
      figure.</p><div class="informalfigure"><a id="image_no_caption"/><div class="mediaobject"><a id="I_mediaobject2_id302577"/><img src="httpatomoreillycomsourceoreillyimages1598894.png" alt="image with no caption"/></div></div><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>C</strong></span> = <span class="strong"><strong>A</strong></span> × <span class="strong"><strong>B</strong></span></td></tr><tr><td><span class="strong"><strong>C</strong></span> = <span class="strong"><strong>AB</strong></span> sin θ</td></tr></table><p>The direction of <span class="strong"><strong>C</strong></span> is
      determined by the right hand rule. As noted previously, the right hand
      rule is a simple trick to help you keep track of vector directions.
      Assume that <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span> lie in a plane and let an axis of rotation
      extend perpendicular to this plane through a point located at the tail
      of <span class="strong"><strong>A</strong></span>. Pretend to curl the fingers of
      your right hand around the axis of rotation from vector <span class="strong"><strong>A</strong></span> toward <span class="strong"><strong>B</strong></span>.
      Now extend your thumb (as though you are giving a thumbs up) while
      keeping your fingers curled around the axis. The direction that your
      thumb is pointing indicates the direction of vector <span class="strong"><strong>C</strong></span>.</p><p>In the preceding figure, a parallelogram is formed by A and B (the
      shaded region). The area of this parallelogram is the magnitude of C,
      which is AB sin θ.</p></div><p>There are two equations that you’ll need in order to determine the
    vectors for tangential and centripetal acceleration. They are:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>n</sub> =
      <span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr><tr><td><span class="strong"><strong>a</strong></span><sub>t</sub> =
      <span class="strong"><strong>α</strong></span> × <span class="strong"><strong>r</strong></span></td></tr></table><p>Another way to look at the quantities <span class="strong"><strong>v</strong></span>, <span class="strong"><strong>a</strong></span><sub>n</sub>, and <span class="strong"><strong>a</strong></span><sub>t</sub> is that they are the
    velocity and acceleration of the particle under consideration, on the
    rigid body, relative to the point about which the rigid body is
    rotating—for example, the body’s center-of-mass location. This is very
    convenient because, as we said earlier, you’ll want to track the motion of
    the rigid body as a particle when viewing the big picture without having
    to worry about what each particle making up the rigid body is doing all
    the time. Thus, you treat the rigid body’s linear motion and its angular
    motion separately. When you do need to take a close look at specific
    particles of—or points on—the rigid body, you can do so by taking the
    motion of the rigid body as a particle and then adding to it the relative
    motion of the point under consideration.</p><p><a class="xref" href="ch02.html#relative_velocity" title="Figure 2-12. Relative velocity">Figure 2-12</a> shows a rigid body that is
    traveling at a speed <span class="strong"><strong>v</strong></span><sub>cg</sub>, where <span class="strong"><strong>v</strong></span><sub>cg</sub> is the speed of the
    rigid body’s center of mass (or center of gravity). Remember, the center
    of mass is the point to track when treating a rigid body as a particle.
    This rigid body is also rotating with an angular velocity <span class="strong"><strong>ω</strong></span> about an axis that passes through the body’s
    center of <a id="I_indexterm2_id302818" class="indexterm"/><a id="I_indexterm2_id302829" class="indexterm"/>mass. The vector <span class="strong"><strong>r</strong></span> is the
    vector from the rigid body’s center of mass to the particular point of
    interest, <span class="emphasis"><em>P</em></span>, located on the rigid body.</p><div class="figure"><a id="relative_velocity"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302861"/><img src="httpatomoreillycomsourceoreillyimages1598895.png" alt="Relative velocity"/></div></div><div class="figure-title">Figure 2-12. Relative velocity</div></div><p>In this case, we can find the resultant velocity of the point,
    <span class="emphasis"><em>P</em></span>, by taking the vector sum of the velocity of the
    body’s center of mass and the tangential velocity of point
    <span class="emphasis"><em>P</em></span> due to the body’s angular velocity <span class="strong"><strong>ω</strong></span>. Here’s what the vector equation looks
    like:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>R</sub> =
      <span class="strong"><strong>v</strong></span><sub>cg</sub> +
      <span class="strong"><strong>v</strong></span><sub>t</sub></td></tr></table><p>or:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>R</sub> =
      <span class="strong"><strong>v</strong></span><sub>cg</sub> +
      (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr></table><p>You can do the same thing with acceleration to determine point
    <span class="emphasis"><em>P</em></span>’s resultant acceleration. Here you’ll take the
    vector sum of the acceleration of the rigid body’s center of mass, the
    tangential acceleration due to the body’s angular acceleration, and the
    centripetal acceleration due to the change in direction of the tangential
    velocity. In equation form, this <a id="I_indexterm2_id302993" class="indexterm"/><a id="I_indexterm2_id302999" class="indexterm"/>looks like:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>R</sub> =
      <span class="strong"><strong>a</strong></span><sub>cg</sub> +
      <span class="strong"><strong>a</strong></span><sub>n</sub> + <span class="strong"><strong>a</strong></span><sub>t</sub></td></tr></table><p><a class="xref" href="ch02.html#relative_acceleration" title="Figure 2-13. Relative acceleration">Figure 2-13</a> illustrates what’s
    happening here.</p><div class="figure"><a id="relative_acceleration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id303071"/><img src="httpatomoreillycomsourceoreillyimages1598896.png" alt="Relative acceleration"/></div></div><div class="figure-title">Figure 2-13. Relative acceleration</div></div><p>You can rewrite the equation for the resultant acceleration in the
    following form:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>R</sub> =
      <span class="strong"><strong>a</strong></span><sub>cg</sub> +
      (<span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)) +
      (<span class="strong"><strong>α</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr></table><p>As you can see, using these principles of relative velocity and
    acceleration allows you to calculate the resultant kinematic properties of
    any point on a rigid body at any given time by determining what the body’s
    center of mass is doing along with how the body is <a id="I_indexterm2_id303153" class="indexterm"/><a id="I_indexterm2_id303163" class="indexterm"/><a id="I_indexterm2_id303172" class="indexterm"/><a id="I_indexterm2_id303181" class="indexterm"/><a id="I_indexterm2_id303191" class="indexterm"/>rotating.</p></div></section></body></html>
