<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix A. Vector Operations</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="ch26.html" title="Chapter 26. Sound"/><link rel="next" href="apb.html" title="Appendix B. Matrix Operations"/></head><body><section class="appendix" title="Appendix A. Vector Operations" epub:type="appendix" id="vector_operations"><div class="titlepage"><div><div><h2 class="title">Appendix A. Vector Operations</h2></div></div></div><p>This appendix implements a class called <code class="literal">Vector</code> that encapsulates all of the vector
  operations that you need when writing 2D or 3D rigid-body simulations.
  Although <code class="literal">Vector</code> represents 3D vectors,
  you can easily reduce it to handle 2D vectors by eliminating all of the
  <span class="emphasis"><em>z</em></span> terms or simply constraining the
  <span class="emphasis"><em>z</em></span> terms to 0 where appropriate in your
  implementation.</p><div class="sect1" title="Vector Class"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="vector_class">Vector Class</h2></div></div></div><p>The <code class="literal">Vector</code> class is <a id="vea1" class="indexterm"/><a id="I_indexterm_id364866" class="indexterm"/>defined with three components—<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and
        <span class="emphasis"><em>z</em></span>—along with several methods and operators that implement basic vector
      operations. The class has two constructors, one of which initializes the vector components to
      0, and the other of which initializes the vector components to those passed to the
      constructor:</p><a id="I_programlisting_id364890"/><pre class="programlisting">//------------------------------------------------------------------------
// Vector Class and vector functions
//------------------------------------------------------------------------
class Vector {
public:
     float x;
     float y;
     float z;

     Vector(void);
     Vector(float xi, float yi, float zi);

     float Magnitude(void);
     void  Normalize(void);
     void  Reverse(void);

     Vector&amp; operator+=(Vector u);
     Vector&amp; operator-=(Vector u);
     Vector&amp; operator*=(float s);
     Vector&amp; operator/=(float s);

     Vector operator-(void);

};

// Constructor
inline Vector::Vector(void)
{
     x = 0;
     y = 0;
     z = 0;
}

// Constructor
inline Vector::Vector(float xi, float yi, float zi)
{
     x = xi;
     y = yi;
     z = zi;
}</pre><div class="sect2" title="Magnitude"><div class="titlepage"><div><div><h3 class="title" id="magnitude-id1">Magnitude</h3></div></div></div><p>The <code class="literal">Magnitude</code> method <a id="I_indexterm_id364922" class="indexterm"/><a id="I_indexterm_id364933" class="indexterm"/><a id="I_indexterm_id364945" class="indexterm"/>simply calculates the scalar magnitude of the vector
      according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>v</strong></span>| = 
        
          <span class="inlinemediaobject"><img src="inleq_aa01.png" alt=""/></span>   
          
        </td></tr></table><p>This is for a zero-based vector where the components are specified
      relative to the origin. The magnitude of a vector is equal to its
      length, as illustrated in <a class="xref" href="apa.html#vector_length_open_parenthesis_magnitude" title="Figure A-1. Vector length (magnitude)">Figure A-1</a>.</p><div class="figure"><a id="vector_length_open_parenthesis_magnitude"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365005"/><img style="width: 152.36220472441; " src="httpatomoreillycomsourceoreillyimages1599030.png" alt="Vector length (magnitude)"/></div></div><div class="figure-title">Figure A-1. Vector length (magnitude)</div></div><p>Here’s the code that calculates the vector magnitude for our
      <code class="literal">Vector</code> class:</p><a id="I_programlisting_id365035"/><pre class="programlisting">inline     float Vector::Magnitude(void)
{
     return (float) sqrt(x*x + y*y + z*z);
}</pre><p>Note, you can calculate the components of a vector if you know its
      length <a id="I_indexterm_id365044" class="indexterm"/>and <span class="emphasis"><em>direction angles</em></span>. Direction
      angles are the angles between each coordinate axis and the vector, as
      shown in <a class="xref" href="apa.html#direction_angles" title="Figure A-2. Direction angles">Figure A-2</a>.</p><div class="figure"><a id="direction_angles"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365073"/><img src="httpatomoreillycomsourceoreillyimages1599031.png" alt="Direction angles"/></div></div><div class="figure-title">Figure A-2. Direction angles</div></div><p>The components of the vector shown in this figure are:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>x</sub> = |<span class="strong"><strong>v</strong></span>| cos φ<sub>x</sub></td></tr><tr><td>v<sub>y</sub> = |<span class="strong"><strong>v</strong></span>| cos φ<sub>y</sub></td></tr><tr><td>v<sub>z</sub> = |<span class="strong"><strong>v</strong></span>| cos φ<sub>z</sub></td></tr></table><p>The cosines of the direction angles seen in these equations are
      known <a id="I_indexterm_id365151" class="indexterm"/><a id="I_indexterm_id365158" class="indexterm"/>as <span class="emphasis"><em>direction cosines</em></span>. The sum of the
      squares of the direction cosines is always equal to 1:</p><table style="border: 0; " class="simplelist"><tr><td>cos<sup>2</sup> φ<sub>x</sub> +
        cos<sup>2</sup> φ<sub>y</sub> +
        cos<sup>2</sup> φ<sub>z</sub> = 1</td></tr></table></div><div class="sect2" title="Normalize"><div class="titlepage"><div><div><h3 class="title" id="normalize">Normalize</h3></div></div></div><p>The <code class="literal">Normalize</code> method
      normalizes, <a id="I_indexterm_id365222" class="indexterm"/><a id="I_indexterm_id365232" class="indexterm"/>or converts, the vector to a unit vector satisfying the
      following equation:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>v</strong></span>| = 
        
          <span class="inlinemediaobject"><img src="inleq_aa02.png" alt=""/></span>   
        
        </td></tr></table><p>In other words, the length of the normalized vector is 1 unit. If
      <span class="strong"><strong>v</strong></span> is a non-unit vector with
      components <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and
      <span class="emphasis"><em>z</em></span>, then we can calculate the unit vector <span class="strong"><strong>u</strong></span> from <span class="strong"><strong>v</strong></span> as
      follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> = <span class="strong"><strong>v</strong></span> / |<span class="strong"><strong>v</strong></span>| =
        (x / |<span class="strong"><strong>v</strong></span>|) <span class="strong"><strong>I</strong></span> + (y / |<span class="strong"><strong>v</strong></span>|) <span class="strong"><strong>j</strong></span> + (z
        / |<span class="strong"><strong>v</strong></span>|) <span class="strong"><strong>k</strong></span></td></tr></table><p>Here |<span class="strong"><strong>v</strong></span>| is simply the
      magnitude, or length, of vector <span class="strong"><strong>v</strong></span> as
      described earlier.</p><p>Here’s the code that converts our <code class="literal">Vector</code> class vector to a unit vector:</p><a id="I_programlisting_id365388"/><pre class="programlisting">inline     void  Vector::Normalize(void)
{
     float m = (float) sqrt(x*x + y*y + z*z);
     if(m &lt;= tol) m = 1;
     x /= m;
     y /= m;
     z /= m;

     if (fabs(x) &lt; tol) x = 0.0f;
     if (fabs(y) &lt; tol) y = 0.0f;
     if (fabs(z) &lt; tol) z = 0.0f;
}</pre><p>In this function, <code class="literal">tol</code> is a
      float type tolerance; for example:</p><a id="I_programlisting_id365406"/><pre class="programlisting">float    const    tol = 0.0001f;</pre></div><div class="sect2" title="Reverse"><div class="titlepage"><div><div><h3 class="title" id="reverse">Reverse</h3></div></div></div><p>The <code class="literal">Reverse</code> method reverses the <a id="I_indexterm_id365428" class="indexterm"/><a id="I_indexterm_id365436" class="indexterm"/>direction of the vector, which is accomplished by simply taking the negative of
        each component. After calling <code class="literal">Reverse</code>, the vector will
        point in a direction opposite to the direction it was pointing before <code class="literal">Reverse</code> was called:</p><a id="I_programlisting_id365461"/><pre class="programlisting">inline     void  Vector::Reverse(void)
{
     x = -x;
     y = -y;
     z = -z;
}</pre><p>This operation is illustrated in <a class="xref" href="apa.html#vector_reversal" title="Figure A-3. Vector reversal">Figure A-3</a>.</p><div class="figure"><a id="vector_reversal"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365486"/><img src="httpatomoreillycomsourceoreillyimages1599032.png" alt="Vector reversal"/></div></div><div class="figure-title">Figure A-3. Vector reversal</div></div></div><div class="sect2" title="Vector Addition: The += Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_addition_colon_the_plus_equals_op">Vector Addition: The += Operator</h3></div></div></div><p>This summation operator is <a id="I_indexterm_id365518" class="indexterm"/><a id="I_indexterm_id365528" class="indexterm"/><a id="I_indexterm_id365538" class="indexterm"/><a id="I_indexterm_id365544" class="indexterm"/><a id="I_indexterm_id365554" class="indexterm"/>used for vector addition, whereby the passed vector is
      added to the current vector, component by component. Graphically,
      vectors are added in tip-to-tail fashion, as illustrated in <a class="xref" href="apa.html#vector_addition" title="Figure A-4. Vector addition">Figure A-4</a>.</p><div class="figure"><a id="vector_addition"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365583"/><img src="httpatomoreillycomsourceoreillyimages1599033.png" alt="Vector addition"/></div></div><div class="figure-title">Figure A-4. Vector addition</div></div><p>Here’s the code that adds the vector <span class="strong"><strong>u</strong></span> to our <code class="literal">Vector</code> class vector:</p><a id="I_programlisting_id365617"/><pre class="programlisting">inline Vector&amp; Vector::operator+=(Vector u)
{
     x += u.x;
     y += u.y;
     z += u.z;
     return *this;
}</pre></div><div class="sect2" title="Vector Subtraction: The −= Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_subtraction_colon_the_m_equals_op">Vector Subtraction: The −= Operator</h3></div></div></div><p>This subtraction operator is <a id="I_indexterm_id365637" class="indexterm"/><a id="I_indexterm_id365647" class="indexterm"/><a id="I_indexterm_id365657" class="indexterm"/><a id="I_indexterm_id365663" class="indexterm"/><a id="I_indexterm_id365673" class="indexterm"/>used to subtract the passed vector from the current one,
      which is performed on a component-by-component basis. Vector subtraction
      is very similar to vector addition except that you take the reverse of
      the second vector and add it to the first, as illustrated in <a class="xref" href="apa.html#vector_subtraction" title="Figure A-5. Vector subtraction">Figure A-5</a>.</p><div class="figure"><a id="vector_subtraction"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365703"/><img src="httpatomoreillycomsourceoreillyimages1599034.png" alt="Vector subtraction"/></div></div><div class="figure-title">Figure A-5. Vector subtraction</div></div><p>Here’s the code that subtracts vector <span class="strong"><strong>u</strong></span> from our <code class="literal">Vector</code> class vector:</p><a id="I_programlisting_id365736"/><pre class="programlisting">inline     Vector&amp; Vector::operator-=(Vector u)
{
     x -= u.x;
     y -= u.y;
     z -= u.z;
     return *this;
}</pre></div><div class="sect2" title="Scalar Multiplication: The *= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the">Scalar Multiplication: The *= Operator</h3></div></div></div><p>This is the scalar <a id="I_indexterm_id365756" class="indexterm"/><a id="I_indexterm_id365766" class="indexterm"/><a id="I_indexterm_id365776" class="indexterm"/><a id="I_indexterm_id365786" class="indexterm"/><a id="I_indexterm_id365796" class="indexterm"/>multiplication operator that’s used to multiply a vector
      by a scalar, effectively scaling the vector’s length. When you multiply
      a vector by a scalar, you simply multiply each vector component by the
      scalar quantity to obtain the new vector. The new vector points in the
      same direction as the unscaled one, but its length will be different
      (unless the scale factor is 1). This is illustrated in <a class="xref" href="apa.html#scalar_multiplication" title="Figure A-6. Scalar multiplication">Figure A-6</a>.</p><div class="figure"><a id="scalar_multiplication"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id365827"/><img src="httpatomoreillycomsourceoreillyimages1599035.png" alt="Scalar multiplication"/></div></div><div class="figure-title">Figure A-6. Scalar multiplication</div></div><p>Here’s the code that scales our <code class="literal">Vector</code> class vector:</p><a id="I_programlisting_id365855"/><pre class="programlisting">inline     Vector&amp; Vector::operator*=(float s)
{
     x *= s;
     y *= s;
     z *= s;
     return *this;
}</pre></div><div class="sect2" title="Scalar Division: The /= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_division_colon_the_solidus_equals">Scalar Division: The /= Operator</h3></div></div></div><p>This scalar <a id="I_indexterm_id365873" class="indexterm"/><a id="I_indexterm_id365884" class="indexterm"/><a id="I_indexterm_id365894" class="indexterm"/><a id="I_indexterm_id365904" class="indexterm"/><a id="I_indexterm_id365914" class="indexterm"/>division operator is similar to the scalar multiplication operator except each
        vector component is divided by the passed scalar quantity:</p><a id="I_programlisting_id365927"/><pre class="programlisting">inline     Vector&amp; Vector::operator/=(float s)
{
     x /= s;
     y /= s;
     z /= s;
     return *this;
}</pre></div><div class="sect2" title="Conjugate: The − Operator"><div class="titlepage"><div><div><h3 class="title" id="conjugate_colon_the_m_operator">Conjugate: The − Operator</h3></div></div></div><p>The conjugate <a id="I_indexterm_id365947" class="indexterm"/><a id="I_indexterm_id365957" class="indexterm"/><a id="I_indexterm_id365963" class="indexterm"/><a id="I_indexterm_id365972" class="indexterm"/>operator simply takes the negative of each vector component and can be used when
        you are subtracting one vector from another or for reversing the direction of the vector.
        Applying the conjugate operator is the same as reversing a vector, as <a id="I_indexterm_id365986" class="indexterm"/>discussed earlier:</p><a id="I_programlisting_id365998"/><pre class="programlisting">inline     Vector Vector::operator-(void)
{
     return Vector(-x, -y, -z);
}</pre></div></div><div class="sect1" title="Vector Functions and Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="vector_functions_and_operators">Vector Functions and Operators</h2></div></div></div><p>The following <a id="vea.2" class="indexterm"/>functions and overloaded operators are useful when you are
    performing operations with two vectors, or with a vector and a scalar,
    where the vector is based on the <code class="literal">Vector</code>
    class.</p><div class="sect2" title="Vector Addition: The + Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_addition_colon_the_plus_operator">Vector Addition: The + Operator</h3></div></div></div><p>This addition <a id="I_indexterm_id366053" class="indexterm"/><a id="I_indexterm_id366063" class="indexterm"/><a id="I_indexterm_id366073" class="indexterm"/><a id="I_indexterm_id366083" class="indexterm"/>operator adds vector <span class="strong"><strong>v</strong></span>
      to vector <span class="strong"><strong>u</strong></span> according to the
      formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> + <span class="strong"><strong>v</strong></span> = (u<sub>x</sub> +
        v<sub>x</sub>) <span class="strong"><strong>i</strong></span> +
        (u<sub>y</sub> + v<sub>y</sub>) <span class="strong"><strong>j</strong></span> + (u<sub>z</sub> +
        v<sub>z</sub>) <span class="strong"><strong>k</strong></span></td></tr></table><p>Here’s the code:</p><a id="I_programlisting_id366167"/><pre class="programlisting">inline     Vector operator+(Vector u, Vector v)
{
     return Vector(u.x + v.x, u.y + v.y, u.z + v.z);
}</pre></div><div class="sect2" title="Vector Subtraction: The − Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_subtraction_colon_the_m_operator">Vector Subtraction: The − Operator</h3></div></div></div><p>This subtraction<a id="I_indexterm_id366186" class="indexterm"/><a id="I_indexterm_id366197" class="indexterm"/><a id="I_indexterm_id366207" class="indexterm"/><a id="I_indexterm_id366217" class="indexterm"/> operator subtracts vector <span class="strong"><strong>v</strong></span> from vector <span class="strong"><strong>u</strong></span> according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> − <span class="strong"><strong>v</strong></span> = (u<sub>x</sub> −
        v<sub>x</sub>) <span class="strong"><strong>i</strong></span> +
        (u<sub>y</sub> − v<sub>y</sub>) <span class="strong"><strong>j</strong></span> + (u<sub>z</sub> −
        v<sub>z</sub>) <span class="strong"><strong>k</strong></span></td></tr></table><p>Here’s the code:</p><a id="I_programlisting_id366301"/><pre class="programlisting">inline     Vector operator-(Vector u, Vector v)
{
     return Vector(u.x - v.x, u.y - v.y, u.z - v.z);
}</pre></div><div class="sect2" title="Vector Cross Product: The ^ Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_cross_product_colon_the_carret_op">Vector Cross Product: The ^ Operator</h3></div></div></div><p>This cross-product operator <a id="I_indexterm_id366324" class="indexterm"/><a id="I_indexterm_id366330" class="indexterm"/><a id="I_indexterm_id366337" class="indexterm"/><a id="I_indexterm_id366346" class="indexterm"/>takes the vector cross product between vectors <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span>
      (<span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v</strong></span>) and returns a vector perpendicular to both
      <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span> according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v</strong></span> = (u<sub>y</sub> *
        v<sub>z</sub> − u<sub>z</sub> *
        v<sub>y</sub>) <span class="strong"><strong>i</strong></span> +
        (−u<sub>x</sub> * v<sub>z</sub> +
        u<sub>z</sub> * v<sub>x</sub>) <span class="strong"><strong>j</strong></span> + (u<sub>x</sub> *
        v<sub>y</sub> − u<sub>y</sub> *
        v<sub>x</sub>) <span class="strong"><strong>k</strong></span></td></tr></table><p>The resulting vector is perpendicular to the plane that contains
      vectors <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span>. The direction in which this resulting vector
      points can be determined by the <span class="emphasis"><em>right hand rule</em></span>. If
      you place the two vectors <span class="strong"><strong>u</strong></span> and
      <span class="strong"><strong>v</strong></span> tail to tail, as shown in <a class="xref" href="apa.html#vector_cross_product-id1" title="Figure A-7. Vector cross product">Figure A-7</a>, and curl your fingers (of your
      right hand) in the direction from <span class="strong"><strong>u</strong></span>
      to <span class="strong"><strong>v</strong></span>, then your thumb will point in
      the direction of the resulting vector.</p><div class="figure"><a id="vector_cross_product-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id366533"/><img src="httpatomoreillycomsourceoreillyimages1599036.png" alt="Vector cross product"/></div></div><div class="figure-title">Figure A-7. Vector cross product</div></div><p>In this case, the resulting vector points out of the page along
      the z-axis since the vectors <span class="strong"><strong>u</strong></span> and
      <span class="strong"><strong>v</strong></span> lie in the plane formed by the x-
      and y-axes.</p><p>If two vectors are parallel, then their cross product will be 0.
      This is useful when you need to determine whether or not two vectors are
      indeed parallel.</p><p>The cross-product operation is distributive; however, it is not
      commutative:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v ≠ v</strong></span> × <span class="strong"><strong>u</strong></span></td></tr><tr><td><span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v = −</strong></span>(<span class="strong"><strong>v</strong></span> ×
        <span class="strong"><strong>u</strong></span>)</td></tr><tr><td>s (<span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v</strong></span>) = (s)(<span class="strong"><strong>u</strong></span>) × <span class="strong"><strong>v</strong></span> =
        <span class="strong"><strong>u</strong></span> × (s)(<span class="strong"><strong>v</strong></span>)</td></tr><tr><td><span class="strong"><strong>u</strong></span> × ( <span class="strong"><strong>v + p</strong></span>) = (<span class="strong"><strong>u</strong></span> × <span class="strong"><strong>v</strong></span>) +
        (<span class="strong"><strong>u</strong></span> × <span class="strong"><strong>p</strong></span>)</td></tr></table><p>Here’s the code that takes the cross product of vectors <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span>:</p><a id="I_programlisting_id366724"/><pre class="programlisting">inline     Vector operator^(Vector u, Vector v)
{
     return Vector(     u.y*v.z - u.z*v.y,
                         -u.x*v.z + u.z*v.x,
                         u.x*v.y - u.y*v.x );
}</pre><p>Vector cross products are handy when you need to find normal
      (perpendicular) vectors. For example, when performing collision
      detection you often need to find the vector normal to the face of a
      polygon. You can construct two vectors in the plane of the polygon using
      the polygon’s vertices and then take the cross product of these two
      vectors to get normal vector.</p></div><div class="sect2" title="Vector Dot Product: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_dot_product_colon_the_asterisk_op">Vector Dot Product: The * Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id366754" class="indexterm"/><a id="I_indexterm_id366763" class="indexterm"/><a id="I_indexterm_id366773" class="indexterm"/><a id="I_indexterm_id366783" class="indexterm"/><a id="I_indexterm_id366789" class="indexterm"/>takes the vector dot product between the vectors <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span>,
      according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>u</strong></span> • <span class="strong"><strong>v</strong></span> = (u<sub>x</sub> *
        v<sub>x</sub>) + (u<sub>y</sub> *
        v<sub>y</sub>) + (u<sub>z</sub> *
        v<sub>z</sub>)</td></tr></table><p>The dot product represents the projection of the vector <span class="strong"><strong>u</strong></span> onto the vector <span class="strong"><strong>v</strong></span>, as illustrated in <a class="xref" href="apa.html#vector_dot_product" title="Figure A-8. Vector dot product">Figure A-8</a>.</p><div class="figure"><a id="vector_dot_product"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject_id366883"/><img src="httpatomoreillycomsourceoreillyimages1599037.png" alt="Vector dot product"/></div></div><div class="figure-title">Figure A-8. Vector dot product</div></div><p>In this figure, <span class="emphasis"><em>P</em></span> is the result of the dot
      product, and it is a scalar. You can also calculate the dot product if
      you the know the angle between the vectors:</p><table style="border: 0; " class="simplelist"><tr><td>P = <span class="strong"><strong>u</strong></span> • <span class="strong"><strong>v</strong></span> = |<span class="strong"><strong>u|</strong></span>
        |<span class="strong"><strong>v|</strong></span> cos θ</td></tr></table><p>Here’s the code that takes the dot product of <span class="strong"><strong>u</strong></span> and <span class="strong"><strong>v</strong></span>:</p><a id="I_programlisting_id366959"/><pre class="programlisting">// Vector dot product
inline     float operator*(Vector u, Vector v)
{
     return (u.x*v.x + u.y*v.y + u.z*v.z);
}</pre><p>Vector dot products are handy when you need to find the magnitude
      of a vector projected onto another one. Going back to collision
      detection as an example, you often have to determine the closest
      distance from a point, which may be a polygon vertex on one body (body
      1) to a polygon face on another body (body 2). If you construct a vector
      from the face under consideration on body 2, using any of its vertices,
      to the point under consideration from body 1, then you can find the
      closest distance of that point from the plane of body 2’s face by taking
      the dot product of that point with the normal vector to the plane. (If
      the normal vector is not of unit length, then you’ll have to divide the
      result by the magnitude of the normal vector.)</p></div><div class="sect2" title="Scalar Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the-id1">Scalar Multiplication: The * Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id366986" class="indexterm"/><a id="I_indexterm_id366996" class="indexterm"/><a id="I_indexterm_id367006" class="indexterm"/><a id="I_indexterm_id367016" class="indexterm"/>multiplies the vector <span class="strong"><strong>u</strong></span> by the scalar
          <span class="emphasis"><em>s</em></span> on a component-by-component basis. There are two versions of this
        overloaded operator depending on the order in which the vector and scalar are
        encountered:</p><a id="I_programlisting_id367039"/><pre class="programlisting">inline     Vector operator*(float s, Vector u)
{
     return Vector(u.x*s, u.y*s, u.z*s);
}


inline     Vector operator*(Vector u, float s)
{
     return Vector(u.x*s, u.y*s, u.z*s);
}</pre></div><div class="sect2" title="Scalar Division: The / Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_division_colon_the_solidus_operat">Scalar Division: The / Operator</h3></div></div></div><p>This operator divides the <a id="I_indexterm_id367060" class="indexterm"/><a id="I_indexterm_id367070" class="indexterm"/><a id="I_indexterm_id367080" class="indexterm"/><a id="I_indexterm_id367090" class="indexterm"/>vector <span class="strong"><strong>u</strong></span> by the scalar <span class="emphasis"><em>s</em></span>
        on a component-by-component basis:</p><a id="I_programlisting_id367112"/><pre class="programlisting">inline     Vector operator/(Vector u, float s)
{
     return Vector(u.x/s, u.y/s, u.z/s);
}</pre></div><div class="sect2" title="Triple Scalar Product"><div class="titlepage"><div><div><h3 class="title" id="triple_scalar_product">Triple Scalar Product</h3></div></div></div><p>This function <a id="I_indexterm_id367134" class="indexterm"/><a id="I_indexterm_id367140" class="indexterm"/><a id="I_indexterm_id367150" class="indexterm"/>takes the triple scalar product of the vectors <span class="strong"><strong>u</strong></span>, <span class="strong"><strong>v</strong></span>, and
      <span class="strong"><strong>w</strong></span> according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td>s = <span class="strong"><strong>u</strong></span> • (<span class="strong"><strong>v</strong></span> × <span class="strong"><strong>w</strong></span>)</td></tr></table><p>Here, the result, <span class="emphasis"><em>s</em></span>, is a scalar. The code is
      as <a id="I_indexterm_id367213" class="indexterm"/>follows:</p><a id="I_programlisting_id367225"/><pre class="programlisting">inline     float TripleScalarProduct(Vector u, Vector v, Vector w)
{
     return float(     (u.x * (v.y*w.z - v.z*w.y)) +
                         (u.y * (-v.x*w.z + v.z*w.x)) +
                         (u.z * (v.x*w.y - v.y*w.x)) );
}</pre></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix B. Matrix Operations</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="apa.html" title="Appendix A. Vector Operations"/><link rel="next" href="apc.html" title="Appendix C. Quaternion Operations"/></head><body><section class="appendix" title="Appendix B. Matrix Operations" epub:type="appendix" id="matrix_operations"><div class="titlepage"><div><div><h2 class="title">Appendix B. Matrix Operations</h2></div></div></div><p>This appendix implements a class called <code class="literal">Matrix3x3</code> that encapsulates all of the operations
  you need to handle 3×3 (nine-element) matrices when writing 3D rigid-body
  simulations.</p><div class="sect1" title="Matrix3×3 Class"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matrix3t3_class">Matrix3×3 Class</h2></div></div></div><p>The <code class="literal">Matrix3x3</code> class is <a id="I_indexterm_id367275" class="indexterm"/><a id="mab.1" class="indexterm"/>defined with nine elements, e<sub>ij</sub>,
    where <span class="emphasis"><em>i</em></span> represents the <span class="emphasis"><em>i</em></span>th row
    and <span class="emphasis"><em>j</em></span> the <span class="emphasis"><em>j</em></span>th column. For
    example, <span class="emphasis"><em>e</em></span><sub>21</sub> refers to the
    element on the second row in the first column. Here’s how all of the
    elements are arranged:</p><div class="informalfigure"><a id="appendixbmatrix1"/><div class="mediaobject"><a id="I_mediaobject_id367333"/><img src="httpatomoreillycomsourceoreillyimages1599038.png" alt="image with no caption"/></div></div><p>The class has two constructors, one of which initializes the matrix elements to zero, and
      the other of which initializes the elements to those passed to the constructor:</p><a id="I_programlisting_id367356"/><pre class="programlisting">class Matrix3x3 {
public:
     // elements eij: i -&gt; row, j -&gt; column
     float     e11, e12, e13, e21, e22, e23, e31, e32, e33;

     Matrix3x3(void);
     Matrix3x3(float r1c1, float r1c2, float r1c3,
               float r2c1, float r2c2, float r2c3,
               float r3c1, float r3c2, float r3c3 );

     float         det(void);
     Matrix3x3     Transpose(void);
     Matrix3x3     Inverse(void);

     Matrix3x3&amp; operator+=(Matrix3x3 m);
     Matrix3x3&amp; operator-=(Matrix3x3 m);
     Matrix3x3&amp; operator*=(float s);
     Matrix3x3&amp; operator/=(float s);
};

// Constructor
inline     Matrix3x3::Matrix3x3(void)
{
     e11 = 0;
     e12 = 0;
     e13 = 0;
     e21 = 0;
     e22 = 0;
     e23 = 0;
     e31 = 0;
     e32 = 0;
     e33 = 0;
}

// Constructor
inline     Matrix3x3::Matrix3x3(float r1c1, float r1c2, float r1c3,
                                float r2c1, float r2c2, float r2c3,
                                float r3c1, float r3c2, float r3c3 )
{
     e11 = r1c1;
     e12 = r1c2;
     e13 = r1c3;
     e21 = r2c1;
     e22 = r2c2;
     e23 = r2c3;
     e31 = r3c1;
     e32 = r3c2;
     e33 = r3c3;
}</pre><div class="sect2" title="Determinant"><div class="titlepage"><div><div><h3 class="title" id="determinant">Determinant</h3></div></div></div><p>The method, <code class="literal">det</code>, returns the
      <a id="I_indexterm_id367388" class="indexterm"/><a id="I_indexterm_id367396" class="indexterm"/>determinant of the matrix. The determinant of a 2×2
      matrix:</p><div class="informalfigure"><a id="appendixbmatrix2"/><div class="mediaobject"><a id="I_mediaobject_id367415"/><img src="httpatomoreillycomsourceoreillyimages1599039.png" alt="image with no caption"/></div></div><p>is as follows:</p><table style="border: 0; " class="simplelist"><tr><td>det [m] = e<sub>11</sub>
        e<sub>22</sub> − e<sub>21</sub>
        e<sub>12</sub></td></tr></table><p>We find the determinant of a 3×3 matrix by first expanding the
      matrix by minors, and then resolving the determinants of the 2×2 minors.
      Here’s how you expand a 3×3 matrix by minors:</p><div class="informalfigure"><a id="appendixbmatrix3"/><div class="mediaobject"><a id="I_mediaobject_id367472"/><img src="httpatomoreillycomsourceoreillyimages1599040.png" alt="image with no caption"/></div></div><p>Here’s how this all looks in code:</p><a id="I_programlisting_id367494"/><pre class="programlisting">inline     float     Matrix3x3::det(void)
{
     return    e11*e22*e33 -
               e11*e32*e23 +
               e21*e32*e13 -
               e21*e12*e33 +
               e31*e12*e23 -
               e31*e22*e13;
}</pre></div><div class="sect2" title="Transpose"><div class="titlepage"><div><div><h3 class="title" id="transpose">Transpose</h3></div></div></div><p>The method <code class="literal">Transpose</code> transposes
      <a id="I_indexterm_id367520" class="indexterm"/><a id="I_indexterm_id367526" class="indexterm"/>the matrix by swapping rows with columns—that is, the
      elements in the first row become the elements in the first column and so
      on for the second and third rows and columns. The following relations
      are true for transpose operations:</p><table style="border: 0; " class="simplelist"><tr><td>(<span class="strong"><strong>M</strong></span><sup>t</sup>)<sup>t</sup>
        = <span class="strong"><strong>M</strong></span></td></tr><tr><td>(s <span class="strong"><strong>M</strong></span>)<sup>t</sup> = s (<span class="strong"><strong>M</strong></span><sup>t</sup>)</td></tr><tr><td>(<span class="strong"><strong>M
        N</strong></span>)<sup>t</sup> = <span class="strong"><strong>N</strong></span><sup>t</sup> <span class="strong"><strong>M</strong></span><sup>t</sup></td></tr><tr><td>(<span class="strong"><strong>M</strong></span> + <span class="strong"><strong>N</strong></span>)<sup>t</sup> = <span class="strong"><strong>M</strong></span><sup>t</sup> + <span class="strong"><strong>N</strong></span><sup>t</sup></td></tr><tr><td>det[<span class="strong"><strong>M</strong></span><sup>t</sup>] =
        det[<span class="strong"><strong>M</strong></span>]</td></tr></table><p>Here <span class="strong"><strong>M</strong></span> and <span class="strong"><strong>N</strong></span> are matrices, <sup>t</sup> is
      the transpose operator, and <span class="emphasis"><em>s</em></span> is a scalar.</p><p>Here’s the <code class="literal">Transpose</code> method for
      our <code class="literal">Matrix3x3</code> class:</p><a id="I_programlisting_id367710"/><pre class="programlisting">inline     Matrix3x3     Matrix3x3::Transpose(void)
{
     return Matrix3x3(e11,e21,e31,e12,e22,e32,e13,e23,e33);
}</pre></div><div class="sect2" title="Inverse"><div class="titlepage"><div><div><h3 class="title" id="inverse">Inverse</h3></div></div></div><p>The method <code class="literal">Inverse</code> computes
      <a id="I_indexterm_id367737" class="indexterm"/><a id="I_indexterm_id367744" class="indexterm"/>the inverse matrix such that the following relation is
      satisfied:</p><p><span class="strong"><strong>M
      M</strong></span><sup>−1</sup> = <span class="strong"><strong>M</strong></span><sup>−1</sup> <span class="strong"><strong>M</strong></span> = <span class="strong"><strong>I</strong></span></p><p>Here <span class="strong"><strong>M</strong></span><sup>−1</sup> is the inverse
      of matrix <span class="strong"><strong>M</strong></span>, and <span class="strong"><strong>I</strong></span> is the identity matrix. For a 3×3 matrix, we
      find the inverse as follows:</p><div class="informalfigure"><a id="appendixbmatrix4"/><div class="mediaobject"><a id="I_mediaobject_id367817"/><img src="httpatomoreillycomsourceoreillyimages1599041.png" alt="image with no caption"/></div></div><p>Here <span class="emphasis"><em>E</em></span><sub>ij</sub> represents
      the cofactor of element <span class="emphasis"><em>e</em></span><sub>ij</sub>,
      which we can find by taking the determinant of the minor of each
      element. Only square matrices, those with the same number of rows as
      columns, can be inverted. Note, however, that not all square matrices
      can be inverted. A matrix can be inverted only if its determinant is
      nonzero.</p><p>The follow relation applies to matrix inversion:</p><table style="border: 0; " class="simplelist"><tr><td>(<span class="strong"><strong>M
        N</strong></span>)<sup>−1</sup> = <span class="strong"><strong>N</strong></span><sup>−1</sup> <span class="strong"><strong>M</strong></span><sup>−1</sup></td></tr></table><p>Here’s how matrix inversion looks in code for our <code class="literal">Matrix3x3</code> class:</p><a id="I_programlisting_id367903"/><pre class="programlisting">inline     Matrix3x3     Matrix3x3::Inverse(void)
{
     float     d = e11*e22*e33 -
                   e11*e32*e23 +
                   e21*e32*e13 -
                   e21*e12*e33 +
                   e31*e12*e23 -
                   e31*e22*e13;

     if (d == 0) d = 1;

     return     Matrix3x3(     (e22*e33-e23*e32)/d,
                              -(e12*e33-e13*e32)/d,
                              (e12*e23-e13*e22)/d,
                              -(e21*e33-e23*e31)/d,
                              (e11*e33-e13*e31)/d,
                              -(e11*e23-e13*e21)/d,
                              (e21*e32-e22*e31)/d,
                              -(e11*e32-e12*e31)/d,
                              (e11*e22-e12*e21)/d );
}</pre></div><div class="sect2" title="Matrix Addition: The += Operator"><div class="titlepage"><div><div><h3 class="title" id="matrix_addition_colon_the_plus_equals_op">Matrix Addition: The += Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id367927" class="indexterm"/><a id="I_indexterm_id367933" class="indexterm"/><a id="I_indexterm_id367943" class="indexterm"/><a id="I_indexterm_id367953" class="indexterm"/><a id="I_indexterm_id367963" class="indexterm"/>simply adds the passed matrix to the current one on an element-by-element basis.
        For two matrices to be added, they must be of the same <span class="emphasis"><em>order</em></span>—that is,
        they must have the same number of rows and columns:</p><a id="I_programlisting_id367979"/><pre class="programlisting">inline     Matrix3x3&amp; Matrix3x3::operator+=(Matrix3x3 m)
{
     e11 += m.e11;
     e12 += m.e12;
     e13 += m.e13;
     e21 += m.e21;
     e22 += m.e22;
     e23 += m.e23;
     e31 += m.e31;
     e32 += m.e32;
     e33 += m.e33;
     return *this;
}</pre><p>Matrix addition (and subtraction) is commutative, associative, and
      distributive; thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M</strong></span> + <span class="strong"><strong>N</strong></span> = <span class="strong"><strong>N</strong></span> +
        <span class="strong"><strong>M</strong></span></td></tr><tr><td><span class="strong"><strong>M</strong></span> + (<span class="strong"><strong>N</strong></span> + <span class="strong"><strong>P</strong></span>) =
        (<span class="strong"><strong>M</strong></span> + <span class="strong"><strong>N</strong></span>) + <span class="strong"><strong>P</strong></span></td></tr><tr><td><span class="strong"><strong>M</strong></span> (<span class="strong"><strong>N</strong></span> + <span class="strong"><strong>P</strong></span>) =
        <span class="strong"><strong>M N</strong></span> + <span class="strong"><strong>M
        P</strong></span></td></tr><tr><td>(<span class="strong"><strong>N</strong></span> + <span class="strong"><strong>P</strong></span>) <span class="strong"><strong>M</strong></span> =
        <span class="strong"><strong>N M</strong></span> + <span class="strong"><strong>P
        M</strong></span></td></tr></table></div><div class="sect2" title="Matrix Subtraction: The −= Operator"><div class="titlepage"><div><div><h3 class="title" id="matrix_subtraction_colon_the_m_equals_op">Matrix Subtraction: The −= Operator</h3></div></div></div><p>This operator simply subtracts the <a id="I_indexterm_id368136" class="indexterm"/><a id="I_indexterm_id368143" class="indexterm"/><a id="I_indexterm_id368152" class="indexterm"/><a id="I_indexterm_id368162" class="indexterm"/><a id="I_indexterm_id368172" class="indexterm"/>passed matrix from the current one on an element-by-element basis. For two
        matrices to be subtracted, they must be of the same <span class="emphasis"><em>order</em></span>—that is, they
        must have the same number of rows and columns:</p><a id="I_programlisting_id368189"/><pre class="programlisting">inline     Matrix3x3&amp; Matrix3x3::operator-=(Matrix3x3 m)
{
     e11 -= m.e11;
     e12 -= m.e12;
     e13 -= m.e13;
     e21 -= m.e21;
     e22 -= m.e22;
     e23 -= m.e23;
     e31 -= m.e31;
     e32 -= m.e32;
     e33 -= m.e33;
     return *this;
}</pre></div><div class="sect2" title="Scalar Multiplication: The *= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the-id2">Scalar Multiplication: The *= Operator</h3></div></div></div><p>This operator simply <a id="I_indexterm_id368212" class="indexterm"/><a id="I_indexterm_id368222" class="indexterm"/><a id="I_indexterm_id368232" class="indexterm"/><a id="I_indexterm_id368242" class="indexterm"/><a id="I_indexterm_id368252" class="indexterm"/>multiplies each element by the scalar <span class="emphasis"><em>s</em></span>:</p><a id="I_programlisting_id368268"/><pre class="programlisting">inline     Matrix3x3&amp; Matrix3x3::operator*=(float s)
{
     e11 *= s;
     e12 *= s;
     e13 *= s;
     e21 *= s;
     e22 *= s;
     e23 *= s;
     e31 *= s;
     e32 *= s;
     e33 *= s;
     return *this;
}</pre><p>The following relation applies for scalar multiplication (and
      division):</p><table style="border: 0; " class="simplelist"><tr><td>s(<span class="strong"><strong>M N</strong></span>) = (s<span class="strong"><strong>M</strong></span>) <span class="strong"><strong>N</strong></span> =
        <span class="strong"><strong>M</strong></span> (s <span class="strong"><strong>N</strong></span>)</td></tr></table></div><div class="sect2" title="Scalar Division: The /= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_division_colon_the_solidus_eq">Scalar Division: The /= Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id368332" class="indexterm"/><a id="I_indexterm_id368342" class="indexterm"/><a id="I_indexterm_id368352" class="indexterm"/><a id="I_indexterm_id368361" class="indexterm"/><a id="I_indexterm_id368371" class="indexterm"/>simply divides each element by the <a id="I_indexterm_id368383" class="indexterm"/>scalar <span class="emphasis"><em>s</em></span>:</p><a id="I_programlisting_id368397"/><pre class="programlisting">inline     Matrix3x3&amp; Matrix3x3::operator/=(float s)
{
     e11 /= s;
     e12 /= s;
     e13 /= s;
     e21 /= s;
     e22 /= s;
     e23 /= s;
     e31 /= s;
     e32 /= s;
     e33 /= s;
     return *this;
}</pre></div></div><div class="sect1" title="Matrix Functions and Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="matrix_functions_and_operators">Matrix Functions and Operators</h2></div></div></div><p>The functions and <a id="mab.2" class="indexterm"/>overloaded operators that follow are useful when you are
    performing operations with two matrices, or with a matrix and a scalar, or
    a matrix and a vector. Here, the matrices are assumed to be of the type
    <code class="literal">Matrix3x3</code>, and vectors of the type
    <code class="literal">Vector</code>, as discussed in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>.</p><div class="sect2" title="Matrix Addition: The + Operator"><div class="titlepage"><div><div><h3 class="title" id="matrix_addition_colon_the_plus_operator">Matrix Addition: The + Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id368463" class="indexterm"/><a id="I_indexterm_id368474" class="indexterm"/><a id="I_indexterm_id368484" class="indexterm"/><a id="I_indexterm_id368490" class="indexterm"/>adds the two matrices together on an element-by-element basis:</p><a id="I_programlisting_id368502"/><pre class="programlisting">inline     Matrix3x3 operator+(Matrix3x3 m1, Matrix3x3 m2)
{
     return     Matrix3x3(     m1.e11+m2.e11,
                              m1.e12+m2.e12,
                              m1.e13+m2.e13,
                              m1.e21+m2.e21,
                              m1.e22+m2.e22,
                              m1.e23+m2.e23,
                              m1.e31+m2.e31,
                              m1.e32+m2.e32,
                              m1.e33+m2.e33);
}</pre></div><div class="sect2" title="Matrix Subtraction: The − Operator"><div class="titlepage"><div><div><h3 class="title" id="matrix_subtraction_colon_the_m_operator">Matrix Subtraction: The − Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id368525" class="indexterm"/><a id="I_indexterm_id368535" class="indexterm"/><a id="I_indexterm_id368545" class="indexterm"/><a id="I_indexterm_id368552" class="indexterm"/>subtracts matrix <code class="literal">m2</code> from <code class="literal">m1</code> on an element-by-element basis:</p><a id="I_programlisting_id368576"/><pre class="programlisting">inline     Matrix3x3 operator-(Matrix3x3 m1, Matrix3x3 m2)
{
     return     Matrix3x3(     m1.e11-m2.e11,
                              m1.e12-m2.e12,
                              m1.e13-m2.e13,
                              m1.e21-m2.e21,
                              m1.e22-m2.e22,
                              m1.e23-m2.e23,
                              m1.e31-m2.e31,
                              m1.e32-m2.e32,
                              m1.e33-m2.e33);
}</pre></div><div class="sect2" title="Scalar Divide: The / Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_divide_colon_the_solidus_operator">Scalar Divide: The / Operator</h3></div></div></div><p>This operator divides <a id="I_indexterm_id368598" class="indexterm"/><a id="I_indexterm_id368608" class="indexterm"/><a id="I_indexterm_id368618" class="indexterm"/><a id="I_indexterm_id368628" class="indexterm"/>every element in the matrix <code class="literal">m</code> by the scalar
          <span class="emphasis"><em>s</em></span>:</p><a id="I_programlisting_id368650"/><pre class="programlisting">inline     Matrix3x3 operator/(Matrix3x3 m, float s)
{
     return     Matrix3x3(    m.e11/s,
                              m.e12/s,
                              m.e13/s,
                              m.e21/s,
                              m.e22/s,
                              m.e23/s,
                              m.e31/s,
                              m.e32/s,
                              m.e33/s);
}</pre></div><div class="sect2" title="Matrix Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="matrix_multiplication_colon_the_asterisk">Matrix Multiplication: The * Operator</h3></div></div></div><p>This operator, when applied <a id="I_indexterm_id368676" class="indexterm"/><a id="I_indexterm_id368686" class="indexterm"/><a id="I_indexterm_id368696" class="indexterm"/><a id="I_indexterm_id368702" class="indexterm"/>between two matrices, performs a matrix multiplication. In matrix
        multiplication, each element, <span class="emphasis"><em>e</em></span><sub>ij</sub>, is determined
        by the product of the <span class="emphasis"><em>i</em></span>th row in the first matrix and the
          <span class="emphasis"><em>j</em></span>th column of the second matrix:</p><a id="I_programlisting_id368728"/><pre class="programlisting">inline     Matrix3x3 operator*(Matrix3x3 m1, Matrix3x3 m2)
{
     return Matrix3x3(m1.e11*m2.e11 + m1.e12*m2.e21 + m1.e13*m2.e31,
                      m1.e11*m2.e12 + m1.e12*m2.e22 + m1.e13*m2.e32,
                      m1.e11*m2.e13 + m1.e12*m2.e23 + m1.e13*m2.e33,
                      m1.e21*m2.e11 + m1.e22*m2.e21 + m1.e23*m2.e31,
                      m1.e21*m2.e12 + m1.e22*m2.e22 + m1.e23*m2.e32,
                      m1.e21*m2.e13 + m1.e22*m2.e23 + m1.e23*m2.e33,
                      m1.e31*m2.e11 + m1.e32*m2.e21 + m1.e33*m2.e31,
                      m1.e31*m2.e12 + m1.e32*m2.e22 + m1.e33*m2.e32,
                      m1.e31*m2.e13 + m1.e32*m2.e23 + m1.e33*m2.e33 );
}</pre><p>Two matrices can be multiplied only if one has the same number of
      columns as the other has rows. Matrix multiplication is not commutative,
      but it is associative; thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M N</strong></span> ≠ <span class="strong"><strong>N M</strong></span></td></tr><tr><td><span class="strong"><strong>(M N) P = M (N P)</strong></span></td></tr></table></div><div class="sect2" title="Scalar Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the-id3">Scalar Multiplication: The * Operator</h3></div></div></div><p>This operator, when <a id="I_indexterm_id368781" class="indexterm"/><a id="I_indexterm_id368791" class="indexterm"/><a id="I_indexterm_id368801" class="indexterm"/><a id="I_indexterm_id368811" class="indexterm"/>applied between a matrix and a scalar, multiplies each element in the matrix
          <code class="literal">m</code> by the scalar <span class="emphasis"><em>s</em></span>. Two forms are
        given here, depending on the order in which the matrix and scalar are encountered:</p><a id="I_programlisting_id368834"/><pre class="programlisting">inline     Matrix3x3 operator*(Matrix3x3 m, float s)
{
     return     Matrix3x3(     m.e11*s,
                              m.e12*s,
                              m.e13*s,
                              m.e21*s,
                              m.e22*s,
                              m.e23*s,
                              m.e31*s,
                              m.e32*s,
                              m.e33*s);
}

inline     Matrix3x3 operator*(float s, Matrix3x3 m)
{
     return     Matrix3x3(     m.e11*s,
                              m.e12*s,
                              m.e13*s,
                              m.e21*s,
                              m.e22*s,
                              m.e23*s,
                              m.e31*s,
                              m.e32*s,
                              m.e33*s);
}</pre></div><div class="sect2" title="Vector Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_multiplication_colon_the_aste-id1">Vector Multiplication: The * Operator</h3></div></div></div><p>This operator, <a id="I_indexterm_id368862" class="indexterm"/><a id="I_indexterm_id368872" class="indexterm"/><a id="I_indexterm_id368881" class="indexterm"/><a id="I_indexterm_id368891" class="indexterm"/>when applied between a vector and a matrix, performs a vector multiplication
        where the <span class="emphasis"><em>i</em></span>th column in the matrix is multiplied by the
          <span class="emphasis"><em>i</em></span>th component in the vector. Two forms are given here, depending on
        the order in which the matrix and vector are <a id="I_indexterm_id368911" class="indexterm"/>encountered:</p><a id="I_programlisting_id368922"/><pre class="programlisting">inline     Vector operator*(Matrix3x3 m, Vector u)
{
     return Vector(     m.e11*u.x + m.e12*u.y + m.e13*u.z,
                         m.e21*u.x + m.e22*u.y + m.e23*u.z,
                         m.e31*u.x + m.e32*u.y + m.e33*u.z);
}

inline     Vector operator*(Vector u, Matrix3x3 m)
{
     return Vector(     u.x*m.e11 + u.y*m.e21 + u.z*m.e31,
                         u.x*m.e12 + u.y*m.e22 + u.z*m.e32,
                         u.x*m.e13 + u.y*m.e23 + u.z*m.e33);
}</pre></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix C. Quaternion Operations</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="apb.html" title="Appendix B. Matrix Operations"/><link rel="next" href="apd.html" title="Appendix D. Bibliography"/></head><body><section class="appendix" title="Appendix C. Quaternion Operations" epub:type="appendix" id="quaternion_operations-id1"><div class="titlepage"><div><div><h2 class="title">Appendix C. Quaternion Operations</h2></div></div></div><p>This appendix implements a class called <code class="literal">Quaternion</code> that encapsulates all of the operations
  you need to handle quaternions when writing 3D rigid-body
  simulations.</p><div class="sect1" title="Quaternion Class"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="quaternion_class">Quaternion Class</h2></div></div></div><p>The <code class="literal">Quaternion</code> class is defined <a id="quc.1" class="indexterm"/><a id="I_indexterm_id368990" class="indexterm"/>with a scalar component, <span class="emphasis"><em>n</em></span>, and vector component, <span class="strong"><strong>v</strong></span>, where <span class="strong"><strong>v</strong></span> is the vector, ×
        <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span> + z <span class="strong"><strong>k</strong></span>. The class has two constructors, one of which initializes the
      quaternion to 0, and the other of which initializes the elements to those passed to the
      constructor:</p><a id="I_programlisting_id369035"/><pre class="programlisting">class Quaternion {
public:
     float      n;     // number (scalar) part
     Vector     v;     // vector part: v.x, v.y, v.z

     Quaternion(void);
     Quaternion(float e0, float e1, float e2, float e3);

     float      Magnitude(void);
     Vector     GetVector(void);
     float      GetScalar(void);
     Quaternion operator+=(Quaternion q);
     Quaternion operator-=(Quaternion q);
     Quaternion operator*=(float s);
     Quaternion operator/=(float s);
     Quaternion operator~(void) const { return Quaternion( n,
                                                           -v.x,
                                                           -v.y,
                                                           -v.z);}
};

// Constructor
inline     Quaternion::Quaternion(void)
{
     n   = 0;
     v.x = 0;
     v.y = 0;
     v.z = 0;
}

// Constructor
inline     Quaternion::Quaternion(float e0, float e1, float e2, float e3)
{
     n   = e0;
     v.x = e1;
     v.y = e2;
     v.z = e3;
}</pre><div class="sect2" title="Magnitude"><div class="titlepage"><div><div><h3 class="title" id="magnitude-id2">Magnitude</h3></div></div></div><p>The method <code class="literal">Magnitude</code> returns
      the <a id="I_indexterm_id369068" class="indexterm"/><a id="I_indexterm_id369080" class="indexterm"/>magnitude of the quaternion according to the following
      formula:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>q</strong></span>| =
          <span class="inlinemediaobject"><img src="inleq_ac01.png" alt=""/></span>   
        </td></tr></table><p>This is similar to calculating the magnitude of a vector except
      that for quaternions you have to take the fourth term, the scalar
      <span class="emphasis"><em>n</em></span>, into account.</p><p>Here’s the code that calculates the magnitude for our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting_id369138"/><pre class="programlisting">inline     float     Quaternion::Magnitude(void)
{
     return (float) sqrt(n*n + v.x*v.x + v.y*v.y + v.z*v.z);
}</pre></div><div class="sect2" title="GetVector"><div class="titlepage"><div><div><h3 class="title" id="getvector">GetVector</h3></div></div></div><p>The method <code class="literal">GetVector</code> returns <a id="I_indexterm_id369162" class="indexterm"/>the vector part of the quaternion. This method uses the <code class="literal">Vector</code> class defined in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>:</p><a id="I_programlisting_id369186"/><pre class="programlisting">inline     Vector     Quaternion::GetVector(void)
{
     return Vector(v.x, v.y, v.z);
}</pre></div><div class="sect2" title="GetScalar"><div class="titlepage"><div><div><h3 class="title" id="getscalar">GetScalar</h3></div></div></div><p>The method <code class="literal">GetScalar</code> returns the <a id="I_indexterm_id369211" class="indexterm"/>scalar part of the quaternion:</p><a id="I_programlisting_id369223"/><pre class="programlisting">inline     float     Quaternion::GetScalar(void)
{
     return n;
}</pre></div><div class="sect2" title="Quaternion Addition: The += Operator"><div class="titlepage"><div><div><h3 class="title" id="quaternion_addition_colon_the_plus_equal">Quaternion Addition: The += Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id369244" class="indexterm"/><a id="I_indexterm_id369254" class="indexterm"/><a id="I_indexterm_id369264" class="indexterm"/><a id="I_indexterm_id369270" class="indexterm"/><a id="I_indexterm_id369280" class="indexterm"/>performs quaternion addition by simply adding the
      quaternion, <span class="strong"><strong>q</strong></span>, to the current
      quaternion on a component-by-component basis.</p><p>If <span class="strong"><strong>q</strong></span> and <span class="strong"><strong>p</strong></span> are two quaternions, then:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> + <span class="strong"><strong>p</strong></span> = [n<sub>q</sub> +
        n<sub>p</sub>, (x<sub>q</sub> +
        x<sub>p</sub>) <span class="strong"><strong>i</strong></span> +
        (y<sub>q</sub> + y<sub>p</sub>) <span class="strong"><strong>j</strong></span> + (z<sub>q</sub> +
        z<sub>p</sub>) <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Here, <span class="emphasis"><em>n</em></span><sub>q</sub> +
      <span class="emphasis"><em>n</em></span><sub>p</sub> is the scalar part of the
      resulting quaternion, while
      (<span class="emphasis"><em>x</em></span><sub>q</sub> +
      <span class="emphasis"><em>x</em></span><sub>p</sub>) <span class="strong"><strong>i</strong></span> +
      (<span class="emphasis"><em>y</em></span><sub>q</sub> +
      <span class="emphasis"><em>y</em></span><sub>p</sub>) <span class="strong"><strong>j</strong></span> +
      (<span class="emphasis"><em>z</em></span><sub>q</sub> +
      <span class="emphasis"><em>z</em></span><sub>p</sub>) <span class="strong"><strong>k</strong></span> is the vector part.</p><p>Quaternion addition is both associative and commutative;
      thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> + (<span class="strong"><strong>p</strong></span> + <span class="strong"><strong>h</strong></span>) =
        (<span class="strong"><strong>q</strong></span> + <span class="strong"><strong>p</strong></span>) + <span class="strong"><strong>h</strong></span></td></tr><tr><td><span class="strong"><strong>q</strong></span> + <span class="strong"><strong>p</strong></span> = <span class="strong"><strong>p</strong></span> +
        <span class="strong"><strong>q</strong></span></td></tr></table><p>Here’s the code that adds the quaternion <span class="strong"><strong>q</strong></span> to our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting_id369544"/><pre class="programlisting">inline     Quaternion     Quaternion::operator+=(Quaternion q)
{
     n += q.n;
     v.x += q.v.x;
     v.y += q.v.y;
     v.z += q.v.z;
     return *this;
}</pre></div><div class="sect2" title="Quaternion Subtraction: The −= Operator"><div class="titlepage"><div><div><h3 class="title" id="quaternion_subtraction_colon_the_m_equal">Quaternion Subtraction: The −= Operator</h3></div></div></div><p>This operator performs <a id="I_indexterm_id369565" class="indexterm"/><a id="I_indexterm_id369575" class="indexterm"/><a id="I_indexterm_id369584" class="indexterm"/><a id="I_indexterm_id369590" class="indexterm"/><a id="I_indexterm_id369599" class="indexterm"/>quaternion subtraction by simply subtracting the
      quaternion, <span class="strong"><strong>q</strong></span>, from the current
      quaternion on a component-by-component basis.</p><p>If <span class="strong"><strong>q</strong></span> and <span class="strong"><strong>p</strong></span> are two quaternions, then:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> − <span class="strong"><strong>p</strong></span> = <span class="strong"><strong>q</strong></span> +
        (−<span class="strong"><strong>p</strong></span>) = [n<sub>q</sub> −
        n<sub>p</sub>, (x<sub>q</sub> −
        x<sub>p</sub>) <span class="strong"><strong>i</strong></span> +
        (y<sub>q</sub> − y<sub>p</sub>) <span class="strong"><strong>j</strong></span> + (z<sub>q</sub> −
        z<sub>p</sub>) <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Here, <span class="emphasis"><em>n</em></span><sub>q</sub> −
      <span class="emphasis"><em>n</em></span><sub>p</sub> is the scalar part of the
      resulting quaternion, while
      (<span class="emphasis"><em>x</em></span><sub>q</sub> −
      <span class="emphasis"><em>x</em></span><sub>p</sub>) <span class="strong"><strong>i</strong></span> +
      (<span class="emphasis"><em>y</em></span><sub>q</sub> −
      <span class="emphasis"><em>y</em></span><sub>p</sub>) <span class="strong"><strong>j</strong></span> +
      (<span class="emphasis"><em>z</em></span><sub>q</sub> −
      <span class="emphasis"><em>z</em></span><sub>p</sub>) <span class="strong"><strong>k</strong></span> is the vector part.</p><p>Here’s the code that subtracts the quaternion <span class="strong"><strong>q</strong></span> from our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting_id369801"/><pre class="programlisting">inline     Quaternion     Quaternion::operator-=(Quaternion q)
{
     n -= q.n;
     v.x -= q.v.x;
     v.y -= q.v.y;
     v.z -= q.v.z;
     return *this;
}</pre></div><div class="sect2" title="Scalar Multiplication: The *= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the-id4">Scalar Multiplication: The *= Operator</h3></div></div></div><p>This operator simply multiplies <a id="I_indexterm_id369821" class="indexterm"/><a id="I_indexterm_id369831" class="indexterm"/><a id="I_indexterm_id369841" class="indexterm"/><a id="I_indexterm_id369851" class="indexterm"/><a id="I_indexterm_id369861" class="indexterm"/>each component in the quaternion by the scalar <span class="emphasis"><em>s</em></span>. This
        operation is similar to scaling a vector, as described in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>:</p><a id="I_programlisting_id369881"/><pre class="programlisting">inline     Quaternion Quaternion::operator*=(float s)
{
     n *= s;
     v.x *= s;
     v.y *= s;
     v.z *= s;
     return *this;
}</pre></div><div class="sect2" title="Scalar Division: The /= Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_division_colon_the_solidus">Scalar Division: The /= Operator</h3></div></div></div><p>This operator simply <a id="I_indexterm_id369900" class="indexterm"/><a id="I_indexterm_id369912" class="indexterm"/><a id="I_indexterm_id369922" class="indexterm"/><a id="I_indexterm_id369932" class="indexterm"/><a id="I_indexterm_id369941" class="indexterm"/>divides each component in the quaternion by the scalar
        <span class="emphasis"><em>s</em></span>:</p><a id="I_programlisting_id369958"/><pre class="programlisting">inline     Quaternion Quaternion::operator/=(float s)
{
     n /= s;
     v.x /= s;
     v.y /= s;
     v.z /= s;
     return *this;
}</pre></div><div class="sect2" title="Conjugate: The ~ Operator"><div class="titlepage"><div><div><h3 class="title" id="conjugate_colon_the_tilde_operato">Conjugate: The ~ Operator</h3></div></div></div><p>This operator takes the<a id="I_indexterm_id369979" class="indexterm"/><a id="I_indexterm_id369989" class="indexterm"/><a id="I_indexterm_id369998" class="indexterm"/><a id="I_indexterm_id370008" class="indexterm"/> conjugate of the quaternion, ~<span class="strong"><strong>q</strong></span>, which is simply the negative of the vector
      part. If <span class="strong"><strong>q</strong></span> = [<span class="emphasis"><em>n</em></span>,
      <span class="emphasis"><em>x</em></span> <span class="strong"><strong>i</strong></span> +
      <span class="emphasis"><em>y</em></span> <span class="strong"><strong>j</strong></span> +
      <span class="emphasis"><em>z</em></span> <span class="strong"><strong>k</strong></span>], then
      ~<span class="strong"><strong>q</strong></span> = [<span class="emphasis"><em>n</em></span>,
      (−<span class="emphasis"><em>x</em></span>) <span class="strong"><strong>i</strong></span> +
      (−<span class="emphasis"><em>y</em></span>) <span class="strong"><strong>j</strong></span> +
      (−<span class="emphasis"><em>z</em></span>) <span class="strong"><strong>k</strong></span>].</p><p>The conjugate of the product of quaternions is equal to the
      product of the quaternion conjugates, but in <a id="I_indexterm_id370106" class="indexterm"/>reverse order:</p><table style="border: 0; " class="simplelist"><tr><td>~(<span class="strong"><strong>qp</strong></span>) = (~<span class="strong"><strong>p</strong></span>)(~<span class="strong"><strong>q</strong></span>)</td></tr></table><p>Here’s the code that computes the conjugate for our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting_id370155"/><pre class="programlisting">     Quaternion operator~(void) const { return Quaternion( n,
                                                           -v.x,
                                                           -v.y,
                                                           -v.z);}</pre></div></div><div class="sect1" title="Quaternion Functions and Operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="quaternion_functions_and_operators">Quaternion Functions and Operators</h2></div></div></div><p>The functions and overloaded <a id="quc.2" class="indexterm"/>operators that follow are useful when you are performing
    operations with two quaternions, or with a quaternion and a scalar, or a
    quaternion and a vector. Here, the quaternions are assumed to be of the
    type <code class="literal">Quaternion</code>, and vectors of the
    type <code class="literal">Vector</code>, as discussed in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>.</p><div class="sect2" title="Quaternion Addition: The + Operator"><div class="titlepage"><div><div><h3 class="title" id="quaternion_addition_colon_the_plus_opera">Quaternion Addition: The + Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id370223" class="indexterm"/><a id="I_indexterm_id370233" class="indexterm"/><a id="I_indexterm_id370243" class="indexterm"/><a id="I_indexterm_id370249" class="indexterm"/>performs quaternion addition by simply adding the quaternion <code class="literal">q1</code> to quaternion <code class="literal">q2</code> on a
        component-by-component basis:</p><a id="I_programlisting_id370274"/><pre class="programlisting">inline     Quaternion operator+(Quaternion q1, Quaternion q2)
{
     return     Quaternion(     q1.n + q2.n,
                                   q1.v.x + q2.v.x,
                                   q1.v.y + q2.v.y,
                                   q1.v.z + q2.v.z);
}</pre></div><div class="sect2" title="Quaternion Subtraction: The − Operator"><div class="titlepage"><div><div><h3 class="title" id="quaternion_subtraction_colon_the_m_opera">Quaternion Subtraction: The − Operator</h3></div></div></div><p>This operator performs <a id="I_indexterm_id370295" class="indexterm"/><a id="I_indexterm_id370305" class="indexterm"/><a id="I_indexterm_id370315" class="indexterm"/><a id="I_indexterm_id370321" class="indexterm"/>quaternion subtraction by simply subtracting the quaternion <code class="literal">q2</code> from quaternion <code class="literal">q1</code> on a
        component-by-component basis:</p><a id="I_programlisting_id370346"/><pre class="programlisting">inline     Quaternion operator-(Quaternion q1, Quaternion q2)
{
     return     Quaternion(     q1.n - q2.n,
                                   q1.v.x - q2.v.x,
                                   q1.v.y - q2.v.y,
                                   q1.v.z - q2.v.z);
}</pre></div><div class="sect2" title="Quaternion Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="quaternion_multiplication_colon_the">Quaternion Multiplication: The * Operator</h3></div></div></div><p>This operator performs <a id="I_indexterm_id370369" class="indexterm"/><a id="I_indexterm_id370379" class="indexterm"/><a id="I_indexterm_id370389" class="indexterm"/><a id="I_indexterm_id370396" class="indexterm"/>quaternion multiplication according to the following
      formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q p</strong></span> =
        n<sub>q</sub> n<sub>p</sub> − <span class="strong"><strong>v</strong></span><sub>q</sub> • <span class="strong"><strong>v</strong></span><sub>p</sub> +
        n<sub>q</sub> <span class="strong"><strong>v</strong></span><sub>p</sub> +
        n<sub>p</sub> <span class="strong"><strong>v</strong></span><sub>q</sub> + (<span class="strong"><strong>v</strong></span><sub>q</sub> × <span class="strong"><strong>v</strong></span><sub>p</sub>)</td></tr></table><p>Here,
      <span class="emphasis"><em>n</em></span><sub>q</sub><span class="emphasis"><em>n</em></span><sub>p</sub>
      − <span class="strong"><strong>v</strong></span><sub>q</sub> •
      <span class="strong"><strong>v</strong></span><sub>p</sub> is the
      scalar part of the result, while
      <span class="emphasis"><em>n</em></span><sub>q</sub> <span class="strong"><strong>v</strong></span><sub>p</sub> +
      <span class="emphasis"><em>n</em></span><sub>p</sub> <span class="strong"><strong>v</strong></span><sub>q</sub> + (<span class="strong"><strong>v</strong></span><sub>q</sub> × <span class="strong"><strong>v</strong></span><sub>p</sub>) is the vector part.
      Also note that <span class="strong"><strong>v</strong></span><sub>q</sub> and <span class="strong"><strong>v</strong></span><sub>p</sub> are the vector parts
      of <span class="strong"><strong>q</strong></span> and <span class="strong"><strong>p</strong></span>, respectively, • is the vector dot-product
      operator, and × is the vector cross-product operator.</p><p>Quaternion multiplication is associative but not commutative;
      thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span>(<span class="strong"><strong>ph</strong></span>) = (<span class="strong"><strong>qp</strong></span>)<span class="strong"><strong>h</strong></span></td></tr><tr><td><span class="strong"><strong>qp</strong></span> ≠ <span class="strong"><strong>pq</strong></span></td></tr></table><p>Here’s the code that multiplies two <code class="literal">Quaternion</code>s, <code class="literal">q1</code> and <code class="literal">q2</code>:</p><a id="I_programlisting_id370665"/><pre class="programlisting">inline     Quaternion operator*(Quaternion q1, Quaternion q2)
{
     return     Quaternion(q1.n*q2.n - q1.v.x*q2.v.x
                               - q1.v.y*q2.v.y - q1.v.z*q2.v.z,
                           q1.n*q2.v.x + q1.v.x*q2.n
                               + q1.v.y*q2.v.z - q1.v.z*q2.v.y,
                           q1.n*q2.v.y + q1.v.y*q2.n
                               + q1.v.z*q2.v.x - q1.v.x*q2.v.z,
                           q1.n*q2.v.z + q1.v.z*q2.n
                               + q1.v.x*q2.v.y - q1.v.y*q2.v.x);
}</pre></div><div class="sect2" title="Scalar Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_multiplication_colon_the-id5">Scalar Multiplication: The * Operator</h3></div></div></div><p>This operator simply multiplies<a id="I_indexterm_id370687" class="indexterm"/><a id="I_indexterm_id370698" class="indexterm"/><a id="I_indexterm_id370708" class="indexterm"/><a id="I_indexterm_id370718" class="indexterm"/> each component in the quaternion by the scalar <span class="emphasis"><em>s</em></span>. There
        are two forms of this operator, depending on the order in which the quaternion and scalar
        are encountered:</p><a id="I_programlisting_id370735"/><pre class="programlisting">inline     Quaternion operator*(Quaternion q, float s)
{
     return     Quaternion(q.n*s, q.v.x*s, q.v.y*s, q.v.z*s);
}

inline     Quaternion operator*(float s, Quaternion q)
{
     return     Quaternion(q.n*s, q.v.x*s, q.v.y*s, q.v.z*s);
}</pre></div><div class="sect2" title="Vector Multiplication: The * Operator"><div class="titlepage"><div><div><h3 class="title" id="vector_multiplication_colon_the_aste-id2">Vector Multiplication: The * Operator</h3></div></div></div><p>This operator multiplies the <a id="I_indexterm_id370758" class="indexterm"/><a id="I_indexterm_id370768" class="indexterm"/><a id="I_indexterm_id370778" class="indexterm"/><a id="I_indexterm_id370788" class="indexterm"/>quaternion <code class="literal">q</code> by the vector <code class="literal">v</code> as though the vector <code class="literal">v</code> were
        a quaternion with its scalar component equal to 0. There are two forms of this operator,
        depending on the order in which the quaternion and vector are encountered. Since <code class="literal">v</code> is assumed to be a quaternion with its scalar part equal to 0,
        the rules of multiplication follow those outlined earlier for quaternion
        multiplication:</p><a id="I_programlisting_id370826"/><pre class="programlisting">inline     Quaternion operator*(Quaternion q, Vector v)
{
     return     Quaternion(     -(q.v.x*v.x + q.v.y*v.y + q.v.z*v.z),
                                   q.n*v.x + q.v.y*v.z - q.v.z*v.y,
                                   q.n*v.y + q.v.z*v.x - q.v.x*v.z,
                                   q.n*v.z + q.v.x*v.y - q.v.y*v.x);
}
inline     Quaternion operator*(Vector v, Quaternion q)
{
     return     Quaternion(     -(q.v.x*v.x + q.v.y*v.y + q.v.z*v.z),
                                   q.n*v.x + q.v.z*v.y - q.v.y*v.z,
                                   q.n*v.y + q.v.x*v.z - q.v.z*v.x,
                                   q.n*v.z + q.v.y*v.x - q.v.x*v.y);
}</pre></div><div class="sect2" title="Scalar Division: The / Operator"><div class="titlepage"><div><div><h3 class="title" id="scalar_division_colon_the_solidus_op">Scalar Division: The / Operator</h3></div></div></div><p>This operator <a id="I_indexterm_id370850" class="indexterm"/><a id="I_indexterm_id370860" class="indexterm"/><a id="I_indexterm_id370871" class="indexterm"/><a id="I_indexterm_id370881" class="indexterm"/>simply divides each component in the quaternion by the scalar
          <span class="emphasis"><em>s</em></span>:</p><a id="I_programlisting_id370896"/><pre class="programlisting">inline     Quaternion operator/(Quaternion q, float s)
{
     return     Quaternion(q.n/s, q.v.x/s, q.v.y/s, q.v.z/s);
}</pre></div><div class="sect2" title="QGetAngle"><div class="titlepage"><div><div><h3 class="title" id="qgetangle">QGetAngle</h3></div></div></div><p>This function<sup>[<a id="APP-C-FN-1" href="#ftn.APP-C-FN-1" epub:type="noteref" class="footnote">30</a>]</sup> extracts the <a id="I_indexterm_id370936" class="indexterm"/><a id="I_indexterm_id370946" class="indexterm"/>angle of rotation about the axis represented by the vector part of the
        quaternion:</p><a id="I_programlisting_id370955"/><pre class="programlisting">inline     float QGetAngle(Quaternion q)
{
     return     (float) (2*acos(q.n));
}</pre></div><div class="sect2" title="QGetAxis"><div class="titlepage"><div><div><h3 class="title" id="qgetaxis">QGetAxis</h3></div></div></div><p>This function <a id="I_indexterm_id370973" class="indexterm"/><a id="I_indexterm_id370984" class="indexterm"/>returns a unit vector along the axis of rotation represented by the vector part
        of the quaternion <code class="literal">q</code>:</p><a id="I_programlisting_id370999"/><pre class="programlisting">inline     Vector QGetAxis(Quaternion q)
{
     Vector v;
     float m;

     v = q.GetVector();
     m = v.Magnitude();

     if (m &lt;= tol)
          return Vector();
     else
          return v/m;
}</pre></div><div class="sect2" title="QRotate"><div class="titlepage"><div><div><h3 class="title" id="qrotate">QRotate</h3></div></div></div><p>This function <a id="I_indexterm_id371020" class="indexterm"/><a id="I_indexterm_id371030" class="indexterm"/>rotates the quaternion <span class="strong"><strong>p</strong></span> by <span class="strong"><strong>q</strong></span>
      according to the formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>p</strong></span>’ = (<span class="strong"><strong>q</strong></span>)(<span class="strong"><strong>p</strong></span>)(~<span class="strong"><strong>q</strong></span>)</td></tr></table><p>Here, ~<span class="strong"><strong>q</strong></span> is the conjugate of
      the unit quaternion <span class="strong"><strong>q</strong></span>. Here’s the
      code:</p><a id="I_programlisting_id371100"/><pre class="programlisting">inline     Quaternion QRotate(Quaternion q1, Quaternion q2)
{
     return     q1*q2*(~q1);
}</pre></div><div class="sect2" title="QVRotate"><div class="titlepage"><div><div><h3 class="title" id="qvrotate-id1">QVRotate</h3></div></div></div><p>This function <a id="I_indexterm_id371119" class="indexterm"/><a id="I_indexterm_id371129" class="indexterm"/>rotates the vector <span class="strong"><strong>v</strong></span> by
      the unit quaternion <span class="strong"><strong>q</strong></span> according to
      the formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>p</strong></span>’ = (<span class="strong"><strong>q</strong></span>)(<span class="strong"><strong>v</strong></span>)(~<span class="strong"><strong>q</strong></span>)</td></tr></table><p>Here, ~<span class="strong"><strong>q</strong></span> is the conjugate of
      the unit quaternion <span class="strong"><strong>q</strong></span>. Here’s the
      code:</p><a id="I_programlisting_id371198"/><pre class="programlisting">inline     Vector     QVRotate(Quaternion q, Vector v)
{
     Quaternion t;


     t = q*v*(~q);

     return     t.GetVector();
}</pre></div><div class="sect2" title="MakeQFromEulerAngles"><div class="titlepage"><div><div><h3 class="title" id="makeqfromeulerangles-id1">MakeQFromEulerAngles</h3></div></div></div><p>This function <a id="I_indexterm_id371219" class="indexterm"/><a id="I_indexterm_id371229" class="indexterm"/><a id="I_indexterm_id371236" class="indexterm"/>constructs a quaternion from a set of Euler angles.</p><p>For a given set of Euler angles, yaw (ψ), pitch (τ), and roll (φ),
      defining rotation about the z-axis, then the y-axis, and then the
      z-axis, you can construct the representative rotation quaternion. You do
      this by first constructing a quaternion for each Euler angle and then
      multiplying the three quaternions following the rules of quaternion
      multiplication. Here are the three quaternions representing each Euler
      rotation angle:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span><sub>roll</sub> = [cos(φ/2),
        (sin(φ/2)) <span class="strong"><strong>i</strong></span> + 0 <span class="strong"><strong>j</strong></span> + 0 <span class="strong"><strong>k</strong></span>]</td></tr><tr><td><span class="strong"><strong>q</strong></span><sub>pitch</sub> = [cos(τ /2), 0
        <span class="strong"><strong>i</strong></span> + (sin(τ /2)) <span class="strong"><strong>j</strong></span> + 0 <span class="strong"><strong>k</strong></span>]</td></tr><tr><td><span class="strong"><strong>q</strong></span><sub>yaw</sub>
        = [cos(ψ /2), 0 <span class="strong"><strong>i</strong></span> + 0 <span class="strong"><strong>j</strong></span> + (sin(ψ /2)) <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Each one of these quaternions is of unit length.<sup>[<a id="APP-C-FN-2" href="#ftn.APP-C-FN-2" epub:type="noteref" class="footnote">31</a>]</sup></p><p>Now you can multiply these quaternions to obtain a single one that
      represents the rotation, or orientation, defined by the three Euler
      angles:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = <span class="strong"><strong>q</strong></span><sub>yaw</sub> <span class="strong"><strong>q</strong></span><sub>pitch</sub> <span class="strong"><strong>q</strong></span><sub>roll</sub></td></tr></table><p>Performing this multiplication yields:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = [ {cos(φ/2) cos(τ /2)
        cos(ψ /2) + sin(φ/2) sin(τ /2) sin(ψ /2)},</td></tr><tr><td>{ sin(φ/2) cos(τ /2) cos(ψ /2) - cos(φ/2) sin(τ /2) sin(ψ /2)
        } <span class="strong"><strong>i</strong></span> +</td></tr><tr><td>{ cos(φ/2) sin(τ /2) cos(ψ /2) + sin(φ/2) cos(τ /2) sin(ψ /2)
        } <span class="strong"><strong>j</strong></span> +</td></tr><tr><td>{ cos(φ/2) cos(τ /2) sin(ψ /2) - sin(φ/2) sin(τ /2) cos(ψ /2)
        } <span class="strong"><strong>k</strong></span> ]</td></tr></table><p>Here’s the code that takes three Euler angles and returns a
      quaternion:</p><a id="I_programlisting_id371469"/><pre class="programlisting">inline     Quaternion     MakeQFromEulerAngles(float x, float y, float z)
{
     Quaternion     q;
     double     roll = DegreesToRadians(x);
     double     pitch = DegreesToRadians(y);
     double     yaw = DegreesToRadians(z);

     double     cyaw, cpitch, croll, syaw, spitch, sroll;
     double     cyawcpitch, syawspitch, cyawspitch, syawcpitch;

     cyaw = cos(0.5f * yaw);
     cpitch = cos(0.5f * pitch);
     croll = cos(0.5f * roll);
     syaw = sin(0.5f * yaw);
     spitch = sin(0.5f * pitch);
     sroll = sin(0.5f * roll);

     cyawcpitch = cyaw*cpitch;
     syawspitch = syaw*spitch;
     cyawspitch = cyaw*spitch;
     syawcpitch = syaw*cpitch;

     q.n = (float) (cyawcpitch * croll + syawspitch * sroll);
     q.v.x = (float) (cyawcpitch * sroll - syawspitch * croll);
     q.v.y = (float) (cyawspitch * croll + syawcpitch * sroll);
     q.v.z = (float) (syawcpitch * croll - cyawspitch * sroll);

     return q;
}</pre></div><div class="sect2" title="MakeEulerAnglesFromQ"><div class="titlepage"><div><div><h3 class="title" id="makeeuleranglesfromq-id1">MakeEulerAnglesFromQ</h3></div></div></div><p>This function <a id="I_indexterm_id371495" class="indexterm"/><a id="I_indexterm_id371506" class="indexterm"/><a id="I_indexterm_id371512" class="indexterm"/>extracts the three Euler angles from a given
      quaternion.</p><p>You can extract the three Euler angles from a quaternion by first
      converting the quaternion to a rotation matrix and then extracting the
      Euler angles from the rotation matrix. Let <span class="strong"><strong>R</strong></span> be a nine-element rotation matrix:</p><div class="informalfigure"><a id="appendixcmatrix1"/><div class="mediaobject"><a id="I_mediaobject_id371543"/><img src="httpatomoreillycomsourceoreillyimages1599042.png" alt="image with no caption"/></div></div><p>and let <span class="strong"><strong>q</strong></span> be a
      quaternion:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = [n, x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span> +
        z <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Then each element in <span class="strong"><strong>R</strong></span> is
      calculated from <span class="strong"><strong>q</strong></span> as follows:</p><table style="border: 0; " class="simplelist"><tr><td>r<sub>11</sub> = n<sup>2</sup> +
        x<sup>2</sup> − y<sup>2</sup> −
        z<sup>2</sup></td></tr><tr><td>r<sub>21</sub> = 2xy+2zn</td></tr><tr><td>r<sub>31</sub> = 2zx − 2yn</td></tr><tr><td>r<sub>12</sub> = 2xy − 2zn</td></tr><tr><td>r<sub>22</sub> = n<sup>2</sup> −
        x<sup>2</sup> + y<sup>2</sup> −
        z<sup>2</sup></td></tr><tr><td>r<sub>32</sub> = 2zy + 2xn</td></tr><tr><td>r<sub>13</sub> = 2xz + 2yn</td></tr><tr><td>r<sub>23</sub> = 2yz − 2xn</td></tr><tr><td>r<sub>33</sub> = n<sup>2</sup> −
        x<sup>2</sup> − y<sup>2</sup> +
        z<sup>2</sup></td></tr></table><p>To extract the Euler angles, yaw (ψ), pitch (τ), and roll (φ),
      from <span class="strong"><strong>R</strong></span>, you can use these
      relations:</p><table style="border: 0; " class="simplelist"><tr><td>sin τ = −r<sub>31</sub></td></tr><tr><td>tan φ = r<sub>32</sub> /
        r<sub>33</sub></td></tr><tr><td>tan ψ = r<sub>21</sub> /
        r<sub>11</sub></td></tr></table><p>Here’s the code that extracts the three Euler angles, returned in
      the form of a <code class="literal">Vector</code>, from a given
      quaternion:</p><a id="I_programlisting_id371786"/><pre class="programlisting">inline     Vector     MakeEulerAnglesFromQ(Quaternion q)
{
     double     r11, r21, r31, r32, r33, r12, r13;
     double     q00, q11, q22, q33;
     double     tmp;
     Vector     u;

     q00 = q.n * q.n;
     q11 = q.v.x * q.v.x;
     q22 = q.v.y * q.v.y;
     q33 = q.v.z * q.v.z;

     r11 = q00 + q11 - q22 - q33;
     r21 = 2 * (q.v.x*q.v.y + q.n*q.v.z);
     r31 = 2 * (q.v.x*q.v.z - q.n*q.v.y);
     r32 = 2 * (q.v.y*q.v.z + q.n*q.v.x);
     r33 = q00 - q11 - q22 + q33;

     tmp = fabs(r31);
     if(tmp &gt; 0.999999)
     {
          r12 = 2 * (q.v.x*q.v.y - q.n*q.v.z);
          r13 = 2 * (q.v.x*q.v.z + q.n*q.v.y);

          u.x = RadiansToDegrees(0.0f); //roll
          u.y = RadiansToDegrees((float) (-(pi/2) * r31/tmp));   // pitch
          u.z = RadiansToDegrees((float) atan2(-r12, -r31*r13)); // yaw
          return u;
     }

     u.x = RadiansToDegrees((float) atan2(r32, r33)); // roll
     u.y = RadiansToDegrees((float) asin(-r31));      // pitch
     u.z = RadiansToDegrees((float) atan2(r21, r11)); // yaw
     return u;


}</pre></div><div class="sect2" title="Conversion Functions"><div class="titlepage"><div><div><h3 class="title" id="conversion_functions">Conversion Functions</h3></div></div></div><p>These two functions <a id="I_indexterm_id371809" class="indexterm"/><a id="I_indexterm_id371822" class="indexterm"/><a id="I_indexterm_id371828" class="indexterm"/><a id="I_indexterm_id371838" class="indexterm"/><a id="I_indexterm_id371844" class="indexterm"/><a id="I_indexterm_id371854" class="indexterm"/>are used to convert angles from degrees to radians and radians to degrees. They
        are not specific to quaternions but are used in some of the code samples shown <a id="I_indexterm_id371863" class="indexterm"/>earlier:</p><a id="I_programlisting_id371875"/><pre class="programlisting">inline     float     DegreesToRadians(float deg)
{
     return deg * pi / 180.0f;
}

inline     float     RadiansToDegrees(float rad)
{
     return rad * 180.0f / pi;
}</pre></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.APP-C-FN-1"><p><sup>[<a href="#APP-C-FN-1" class="para">30</a>] </sup>For a description of how quaternions are used to represent rotation, refer to the
            section <a class="xref" href="ch11.html#quaternions" title="Quaternions">Quaternions</a> in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p></div><div class="footnote" epub:type="footnote" id="ftn.APP-C-FN-2"><p><sup>[<a href="#APP-C-FN-2" class="para">31</a>] </sup>You can verify this by recalling the trigonometric relation
          cos<sup>2</sup>θ + sin<sup>2</sup> θ
          = 1.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix D. Bibliography</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="apc.html" title="Appendix C. Quaternion Operations"/><link rel="next" href="ix01.html" title="Index"/></head><body><section class="appendix" title="Appendix D. Bibliography" epub:type="appendix" id="bibliography"><div class="titlepage"><div><div><h2 class="title">Appendix D. Bibliography</h2></div></div></div><p>A wise old professor once told us that it is not important to know the
  answers to everything as long as you know where to find the answers when you
  need them. In that spirit, we’ve compiled a list of references to books,
  articles, and Internet resources that you might find useful when looking for
  additional information on the various topics discussed throughout this book.
  We’ve tried to categorize them as best we could, however, keep in mind that
  several references cover more than just the subject matter referred to in
  the category headings we’ve assigned.</p><div class="sect1" title="General Physics and Dynamics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id371905">General Physics and Dynamics</h2></div></div></div><p class="bib">Anand, D. K., and, Cunniff, P. F., <span class="emphasis"><em>Engineering Mechanics -
        Dynamics</em></span>, Houghton Mifflin Company, Boston, 1973.</p><p class="bib">Beer, Ferdinand P., and, Johnston, E. Russell Jr., <span class="emphasis"><em>Vector Mechanics
        for Engineers</em></span>, McGraw-Hill Book Company, New York, 1988.</p><p class="bib">Dugas, Rene, <span class="emphasis"><em>A History of Mechanics</em></span>, Dover Publications,
      Inc., New York, 1988.</p><p class="bib">Ginsberg, Jerry H., <span class="emphasis"><em>Advanced Engineering Dynamics</em></span>,
      Cambridge University Press, New York, 1995.</p><p class="bib">Lindeburg, Michael R., <span class="emphasis"><em>Engineer-in-Training Reference
        Manual</em></span>, Professional Publications, Inc., Belmont, CA, 1990.</p><p class="bib">Meriam, J. L., and, Kraige, L. G., <span class="emphasis"><em>Engineering Mechanics, Volume 2,
        Dynamics</em></span>, John Wiley &amp; Sons, New York, 1987.</p><p class="bib">Rothbart, Harold A., Editor, <span class="emphasis"><em>Mechanical Design Handbook</em></span>,
      McGraw-Hill, New York, 1996.</p><p class="bib">Serway, Raymond A., <span class="emphasis"><em>Physics for Scientists &amp;
      Engineers</em></span>, Saunders College Publishing, New York, 1986.</p></div><div class="sect1" title="Mathematics and Numerical Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id371993">Mathematics and Numerical Methods</h2></div></div></div><p class="bib">Boyce, William E., and, DiPrima, Richard C., <span class="emphasis"><em>Elementary Differential
        Equations</em></span>, John Wiley &amp; Sons, New York, 1986.</p><p class="bib">Kreyszig, Erwin, <span class="emphasis"><em>Advanced Engineering Mathematics</em></span>, John
      Wiley &amp; Sons, New York, 1988.</p><p class="bib">Larson, Roland E., and, Hostetler, Robert P., <span class="emphasis"><em>Calculus with Analytic
        Geometry</em></span>, D. C. Heath and Company, Lexington, Massachusetts, 1986.</p><p class="bib">Press, Flannery, Teukolsky, and Vetterling, <span class="emphasis"><em>Numerical Recipes in
        Pascal</em></span>, Cambridge University Press, New York, 1989.</p></div><div class="sect1" title="Computational Geometry"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372041">Computational Geometry</h2></div></div></div><p class="bib">Arvo, James, Editor, <span class="emphasis"><em>Graphics Gems II</em></span>, Academic Press,
      1991.</p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000330/bobic_01.htm" target="_top">Bobic,
        Nick, “Advanced Collision Detection Techniques,” Gamasutra, March 2000.</a></p><p class="bib">DaLoura, Mark, Editor <span class="emphasis"><em>Game Programming Gems</em></span>, Chapter 4.5,
      Charles River Media, Inc., Massachusetts, 2000.</p><p class="bib">Foley, van Dam, Feiner, and Hughes, <span class="emphasis"><em>Computer Graphics: Principles and
        Practice</em></span>, Addison-Wesley Publishing Company, New York, 1996.</p><p class="bib">Glassner, Andrew, Editor, <span class="emphasis"><em>Graphics Gems</em></span>, Academic Press,
      1990.</p><p class="bib">Goodman, J. E., and, O’Rourke, J., Editors, <span class="italic">Handbook of
        Discrete and Computational Geometry</span>, CRC Press LLC, 1997.</p><p class="bib">Heckbert, Paul, Editor, <span class="italic">Graphics Gems IV</span>,
      Academic Press, 1994.</p><p class="bib">Kirk, David, Editor, <span class="italic">Graphics Gems III</span>,
      Academic Press, 1992.</p><p class="bib">Mirtich, Brian, “Fast and Accurate Computation of
    Polyhedral Mass Properties,” Volume 1, number 2, 1996.</p><p class="bib">Mirtich, Brian, “Rigid Body Contact: Collision Detection
    to Force Computation,” MERL Technical Report 98-01, Proc. of Workshop on
    Contact Analysis and Simulation, IEEE International Conference on Robotics
    and Automation, May 1998.</p><p class="bib">Mirtich, Brian, “Efficient Algorithms for Two-Phase
    Collision Detection,” MERL Technical Report 97-23, Practical Motion
    Planning in Robotics: Current Approaches and Future Directions, K. Gupta
    and A.P. del Pobil, editors, 1998.</p><p class="bib">Mirtich, Brian, “V-Clip: Fast and Robust Polyhedral
    Collision Detection,” MERL Technical Report 97-05, ACM Trans. on Graphics
    17 (3), July 1998.</p><p class="bib">O’Rourke, Joseph, “comp.graphics.algorithms Frequently
    Asked Questions,” Copyright 2000 by Joseph O’Rourke.</p><p class="bib">O’Rourke, Joseph, <span class="emphasis"><em>Computational Geometry in C</em></span>, Cambridge
      University Press, New York, 1998.</p><p class="bib">Paeth, Alan, Editor, <span class="emphasis"><em>Graphics Gems V</em></span>, Academic Press,
      1995.</p></div><div class="sect1" title="Projectiles"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372046">Projectiles</h2></div></div></div><p class="bib">Power, H. L. and, Iversen, J. D., “Magnus Effect on
    Spinning Bodies of Revolution,” AIAA Journal Vol. 11, No. 4, April
    1973.</p><p class="bib">McCoy RL. <span class="emphasis"><em>A Brief History of Exterior Ballistics. Modern Exterior
        Ballistics</em></span>. Pennsylvania, Schiffer Publishing Ltd; 1999.</p></div><div class="sect1" title="Sports Ball Physics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372218">Sports Ball Physics</h2></div></div></div><p class="bib">Adair, Robert K., <span class="emphasis"><em>The Physics of Baseball</em></span>, Harper
      Perennial, New York, 1994.</p><p class="bib">Davies, John M., “The Aerodynamics of Golf Balls,”
    Journal of Applied Physics, Volume 20, No. 9, September 1949.</p><p class="bib">Jorgensen, Theodore P., <span class="emphasis"><em>The Physics of Golf</em></span>, Springer, New
      York, 1999.</p><p class="bib">MacDonald, William M., “The Physics of the drive in
    golf,” Am. J. Phys. 59 (3), March 1991.</p><p class="bib">McPhee, John J., and, Andrews, Gordon C., “Effect of
    sidespin and wind on projectile trajectory, with particular application to
    golf,” Am. J. Phys. 56 (10), October 1988.</p><p class="bib">Mehta, Rabindra D., “Aerodynamics of Sports Balls,” Ann.
    Rev. Fluid Mech., 1985. 17: 151-89.</p><p class="bib">Shepard, Ron, “Amateur Physics for the Amateur Pool
    Player,” Ron Shepard, 1997.</p><p class="bib">Watts, Robert G., and, Baroni, Steven, “Baseball-bat
    collisions and the resulting trajectories of spinning balls,” Am. J. Phys.
    57 (1), January 1989.</p><p class="bib">Watts, Robert G., and, Sawyer, Eric, “Aerodynamics of a
    knuckleball,” Am. J. Phys. 43 (11), November 1975.</p></div><div class="sect1" title="Aerodynamics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372223">Aerodynamics</h2></div></div></div><p class="bib">Abbot, Ira H., and, Von Doenhoff, Albert E., <span class="emphasis"><em>Theory of Wing
        Sections</em></span>, Dover Publications, Inc., New York, 1959.</p><p class="bib">Hoerner, Sighard F. and, Borst, Henry V., <span class="emphasis"><em>Fluid Dynamic
        Lift</em></span>, Hoerner Fluid Dynamics, Bakersfield, CA, 1985.</p><p class="bib">Hoerner, Sighard F., <span class="emphasis"><em>Fluid Dynamic Drag</em></span>, Hoerner Fluid
      Dynamics, Bakersfield, CA, 1992.</p><p class="bib">Thwaites, Bryan, Editor, <span class="emphasis"><em>Incompressible Aerodynamics</em></span>,
      Dover Publications, Inc., New York, 1960.</p></div><div class="sect1" title="Hydrostatics and Hydrodynamics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372342">Hydrostatics and Hydrodynamics</h2></div></div></div><p class="bib">Clayton, B. R., and, Bishop, R. E. D., <span class="emphasis"><em>Mechanics of Marine
        Vehicles</em></span>, Gulf Publishing Company, Houston, TX, 1982.</p><p class="bib">Daugherty, Franzini, and, Finnemore, <span class="emphasis"><em>Fluid Mechanics with Engineering
        Applications</em></span>, McGraw-Hill Book Company, New York, 1985.</p><p class="bib">Gillmer, Thomas C., and, Johnson, Bruce, <span class="emphasis"><em>Introduction to Naval
        Architecture</em></span>, Naval Institute Press, Annapolis, Maryland, 1982.</p><p class="bib">Lewis, Edward V., Editor, <span class="emphasis"><em>Principles of Naval Architecture Second
        Revision, Volume II, Resistance, Propulsion and Vibration</em></span>, The Society of Naval
      Architects and Marine Engineers, Jersey City, New Jersey, 1988.</p><p class="bib">Lewis, Edward V., Editor, <span class="emphasis"><em>Principles of Naval Architecture Second
        Revision, Volume I, Stability and Strength</em></span>, The Society of Naval Architects and
      Marine Engineers, Jersey City, New Jersey, 1988.</p><p class="bib">Newman, <span class="emphasis"><em>Marine Hydrodynamics</em></span>, The MIT Press, Cambridge,
      Massachusetts, 1989.</p><p class="bib">Zubaly, Robert B., <span class="emphasis"><em>Applied Naval Architecture</em></span>, The Society
      of Naval Architects and Marine Engineers, Jersey City, New Jersey, 1996.</p></div><div class="sect1" title="Automobile Physics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372424">Automobile Physics</h2></div></div></div><p class="bib"><a class="ulink" href="http://www.autopedia.com/stuttgart-west/StuttPhysics.html" target="_top">Beckman,
        Brian, “Physics of Racing Series,” Copyright 1991 by Brian Beckman, Stuttgart-West,
        1998.</a></p><p class="bib">Gillespie, Thomas, <span class="emphasis"><em>Fundamentals of Vehicle Dynamics</em></span>.
      Society of Automotive Engineers Inc, 1992.</p></div><div class="sect1" title="Real-time Physics Simulations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372453">Real-time Physics Simulations</h2></div></div></div><p class="bib">DaLoura, Mark, Editor <span class="emphasis"><em>Game Programming Gems</em></span>, Section 2,
      Charles River Media, Inc., Massachusetts, 2000.</p><p class="bib">Hecker, Chris, “Physics, The Next Frontier,” Game
    Developer, October/November 1996.</p><p class="bib">Hecker, Chris, “Physics, Part 2: Angular Effects,” Game
    Developer, December 1996/January 1997.</p><p class="bib">Hecker, Chris, “Physics, Part 3: Collision Response,”
    Game Developer, March 1997.</p><p class="bib">Hecker, Chris, “Physics, Part 4: The Third Dimension,”
    Game Developer, June 1997.</p><p class="bib">Katz, Amnon, <span class="emphasis"><em>Computational Rigid Vehicle Dynamics</em></span>, Krieger
      Publishing Company, Malabar, Florida, 1997.</p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000208/lander_01.htm" target="_top">Lander,
        Jeff, “Collision Response: Bouncy, Trouncy, Fun,” Gamasutra, February 08,
      2000.</a></p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000210/lander_01.htm" target="_top">Lander,
        Jeff, “Crashing into the New Year,” Gamasutra, February 10, 2000. </a></p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000214/lander_01.htm" target="_top">Lander,
        Jeff, “Lone Game Developer Battles Physics Simulator,” Gamasutra, February 15,
      2000.</a></p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000510/lander_01.htm" target="_top">Lander,
        Jeff, “Trials and Tribulations of Tribology,” Gamasutra, May 10, 2000.</a></p><p class="bib"><a class="ulink" href="http://www.gamasutra.com/features/20000516/lander_01.htm" target="_top">Lander,
        Jeff, “Physics on the Back of a Cocktail Napkin,” Gamasutra, May 16, 2000.</a></p><p class="bib">Mirtich, Brian, “Impulse-based Dynamic Simulation of
    Rigid Body Systems,” Ph.D. thesis, University of California, Berkeley,
    December 1996.</p><p class="bib">Mirtich, Brian, and Canny, John, “Impulse-based
    Simulation of Rigid Bodies,” Proc. of 1995 Symposium on Interactive 3D
    Graphics, April 1995.</p><p class="bib">Mirtich, Brian, and Canny, John, “Impulse-based Dynamic
    Simulation,” Proc. of Workshop on Algorithmic Foundations of Robotics,
    February 1994.</p><p class="bib"><a class="ulink" href="http://www.cs.cmu.edu/afs/cs/user/baraff/www/pbm/pbm.html" target="_top">Witkin,
        Andrew, and, Baraff, David, “An Introduction to Physically Based Modeling,” 1997.</a>
      (see also SIGGRAPH ’95 course entitled “An Introduction to Physically Based Modeling”)</p></div><div class="sect1" title="Digital Physics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id372458">Digital Physics</h2></div></div></div><p class="bib">Parkinson, Bradford. <span class="emphasis"><em>Global Positioning System: Theory &amp;
        Applications</em></span>. American Institute of Aeronautics and Astronautics, 1996.</p><p class="bib">Bradski, Gary, and, Kaehler, Adrian. <span class="emphasis"><em>Learning OpenCV</em></span>.
      O’Reilly Media, 2008.</p><p class="bib">Chipley, Michael, et al. <span class="emphasis"><em>FEMA 426 Reference Manual to Mitigate
        Potential Terrorist Attacks Against Buildings</em></span>. Federal Emergency Management
      Agency, 2003.</p><p class="bib"><a class="ulink" href="http://www.cs.cmu.edu/afs/cs/user/baraff/www/pbm/pbm.html" target="_top">Witkin,
        Andrew, and, Baraff, David, “An Introduction to Physically Based Modeling,” 1997.</a>
      (see also SIGGRAPH ’95 course entitled “An Introduction to Physically Based Modeling”)</p><p class="bib">Allan, Alasdair. <span class="emphasis"><em>Basic Sensors in IOS</em></span>. Sebastopol, CA:
      O’Reilly, 2011. Print.</p></div></section></body></html>
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>About the Authors</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="ix01.html" title="Index"/><link rel="next" href="co02.html" title="Colophon"/></head><body><div class="colophon" title="About the Authors" epub:type="colophon" id="id792811"><h2 class="title">About the Authors</h2><div><p>David Bourg is a Naval Architect involved in various military and commercial proposal, design, and construction efforts.  Since 1998, David has served as an independent consultant working for various regional clients engaged in both commercial and military shipbuilding where he provides design and analysis services including but not limited to concept design, proposal writing, detailed design and analysis, visualization, and software development among other services. He coordinated and led the winning design and proposal effort for the US Coast Guard Point Class (patrol boat) Replacement Program. In 2006, David joined fellow Naval Architect Kenneth Humphreys to form MiNO Marine, LLC, a naval architecture and marine professional services firm.</p><p>In addition to <i>Physics for Game Developers</i>, David has published two other books. He earned a PhD in Engineering and Applied Science in 2008 from the University of New Orleans. He has served as an Adjunct Professor at the University of New Orleans School of Naval Architecture and Marine Engineering, where he has taught various courses since 1993.</p></div><p>Ever since his father read A Brief History of Time to him in middle school, Bryan Bywalec wanted to be an astrophysicist. While he will always have a passion for pure physics, he became more and more obsessed in high school with the application of those physical principles he was learning. Having been around sailboats his entire life, his decision to seek a degree in Naval Architecture at the University of New Orleans surprised few.<br/><br/>While working on his degree, Mr. Bywalec was employed as a network administrator for the College of Engineering. Having an office in an electronics lab, he explored the world of enterprise computing and became very interested in high performance clusters, remote administration of desktops, and robotics.<br/><br/>Upon graduating in 2007, he began his career at MiNO Marine, LLC and, under the guidance of David Bourg and Kenneth Humphreys, now focuses on finite element analysis of complex welded steel structures. His structural analysis work depends largely on the accurate approximations of non-linear physical systems. Bryan has completed several computational fluid dynamics simulations of exhaust gases from ship stacks and current flow around offshore structures.<br/><br/>In addition to his work as a naval architect, Bryan strives to create innovative ways to connect everyday objects to various control networks. From unlocking door locks via text message to developing a real time street car tracking program, he constantly searches for opportunities to integrate technology into his life.</p></div></body></html><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Physics for Game Developers</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><meta name="description" content="&lt;p&gt;If you want to enrich your game&amp;#8217;s experience with physics-based realism, the expanded edition of this classic book details physics principles applicable to game development. You&amp;#8217;ll learn about collisions, explosions, sound, projectiles, and other effects used in games on Wii, PlayStation, Xbox, smartphones, and tablets. You&amp;#8217;ll also get a handle on how to take advantage of various sensors such as accelerometers and optical tracking devices.&lt;/p&gt;"/></head><body><h1>Physics for Game Developers</h1><div class="toc"><div class="toc-title">Table of Contents</div><nav epub:type="toc"><ol><li><a href="upgrade_offer_front.html">Special Upgrade Offer</a></li><li><a href="pr02.html">Preface</a><ol><li><a href="pr02.html#I_sect1_id286310">Who Is This Book For?</a></li><li><a href="pr02.html#I_sect1_id286370">What We Assume You Know</a></li><li><a href="pr02.html#I_sect1_id286399">Mechanics</a></li><li><a href="pr02.html#I_sect1_id286570">Digital Physics</a></li><li><a href="pr02.html#I_sect1_id286592">Arrangement of This Book</a></li><li><a href="pr02.html#I_sect1_id286597">Conventions Used in This Book</a></li><li><a href="pr02.html#I_sect1_id287764">Using Code Examples</a></li><li><a href="pr02.html#I_sect1_id287799">Safari® Books Online</a></li><li><a href="pr02.html#I_sect1_id287901">How to Contact Us</a></li><li><a href="pr02.html#I_sect1_id287997">Acknowledgments</a></li></ol></li><li><a href="pt01.html">I. Fundamentals</a><ol><li><a href="ch01.html">1. Basic Concepts</a><ol><li><a href="ch01.html#newtonas_laws_of_motion">Newton’s Laws of Motion</a></li><li><a href="ch01.html#units_and_measures">Units and Measures</a></li><li><a href="ch01.html#coordinate_system">Coordinate System</a></li><li><a href="ch01.html#vectors">Vectors</a></li><li><a href="ch01.html#derivatives_and_integrals">Derivatives and Integrals</a></li><li><a href="ch01.html#mass_comma_center_of_mass_comma_and_mome">Mass, Center of Mass, and Moment of Inertia</a></li><li><a href="ch01.html#newtonas_second_law_of_motion">Newton’s Second Law of Motion</a></li><li><a href="ch01.html#inertia_tensor">Inertia Tensor</a></li><li><a href="ch01.html#relativistic_time">Relativistic Time</a></li></ol></li><li><a href="ch02.html">2. Kinematics</a><ol><li><a href="ch02.html#velocity_and_acceleration">Velocity and Acceleration</a></li><li><a href="ch02.html#constant_acceleration">Constant Acceleration</a></li><li><a href="ch02.html#nonconstant_acceleration">Nonconstant Acceleration</a></li><li><a href="ch02.html#d_particle_kinematics">2D Particle Kinematics</a></li><li><a href="ch02.html#d_particle_kinematics-id1">3D Particle Kinematics</a><ol><li><a href="ch02.html#x_components">X Components</a></li><li><a href="ch02.html#y_components">Y Components</a></li><li><a href="ch02.html#z_components">Z Components</a></li><li><a href="ch02.html#the_vectors">The Vectors</a></li><li><a href="ch02.html#hitting_the_target">Hitting the Target</a></li></ol></li><li><a href="ch02.html#kinematic_particle_explosion">Kinematic Particle Explosion</a></li><li><a href="ch02.html#rigid-body_kinematics">Rigid-Body Kinematics</a></li><li><a href="ch02.html#local_coordinate_axes">Local Coordinate Axes</a></li><li><a href="ch02.html#angular_velocity_and_acceleration">Angular Velocity and Acceleration</a></li></ol></li><li><a href="ch03.html">3. Force</a><ol><li><a href="ch03.html#forces">Forces</a></li><li><a href="ch03.html#force_fields">Force Fields</a></li><li><a href="ch03.html#friction">Friction</a></li><li><a href="ch03.html#fluid_dynamic_drag">Fluid Dynamic Drag</a></li><li><a href="ch03.html#pressure">Pressure</a></li><li><a href="ch03.html#buoyancy">Buoyancy</a></li><li><a href="ch03.html#springs_and_dampers">Springs and Dampers</a></li><li><a href="ch03.html#force_and_torque">Force and Torque</a></li><li><a href="ch03.html#summary">Summary</a></li></ol></li><li><a href="ch04.html">4. Kinetics</a><ol><li><a href="ch04.html#particle_kinetics_in_2d">Particle Kinetics in 2D</a></li><li><a href="ch04.html#particle_kinetics_in_3d">Particle Kinetics in 3D</a><ol><li><a href="ch04.html#x_components-id1">X Components</a></li><li><a href="ch04.html#y_components-id1">Y Components</a></li><li><a href="ch04.html#z_components-id1">Z Components</a></li><li><a href="ch04.html#cannon_revised">Cannon Revised</a></li></ol></li><li><a href="ch04.html#rigid-body_kinetics">Rigid-Body Kinetics</a></li></ol></li><li><a href="ch05.html">5. Collisions</a><ol><li><a href="ch05.html#impulse-momentum_principle">Impulse-Momentum Principle</a></li><li><a href="ch05.html#impact">Impact</a></li><li><a href="ch05.html#linear_and_angular_impulse">Linear and Angular Impulse</a></li><li><a href="ch05.html#friction-id1">Friction</a></li></ol></li><li><a href="ch06.html">6. Projectiles</a><ol><li><a href="ch06.html#simple_trajectories">Simple Trajectories</a></li><li><a href="ch06.html#drag">Drag</a></li><li><a href="ch06.html#magnus_effect">Magnus Effect</a></li><li><a href="ch06.html#variable_mass">Variable Mass</a></li></ol></li></ol></li><li><a href="pt02.html">II. Rigid-Body Dynamics</a><ol><li><a href="ch07.html">7. Real-Time Simulations</a><ol><li><a href="ch07.html#integrating_the_equations_of_motion">Integrating the Equations of Motion</a></li><li><a href="ch07.html#euleras_method">Euler’s Method</a></li><li><a href="ch07.html#better_methods">Better Methods</a></li><li><a href="ch07.html#summary-id1">Summary</a></li></ol></li><li><a href="ch08.html">8. Particles</a><ol><li><a href="ch08.html#simple_particle_model">Simple Particle Model</a><ol><li><a href="ch08.html#integrator">Integrator</a></li><li><a href="ch08.html#rendering">Rendering</a></li></ol></li><li><a href="ch08.html#the_basic_simulator">The Basic Simulator</a></li><li><a href="ch08.html#implementing_external_forces">Implementing External Forces</a></li><li><a href="ch08.html#implementing_collisions">Implementing Collisions</a><ol><li><a href="ch08.html#particle-to-ground_collisions">Particle-to-Ground Collisions</a></li><li><a href="ch08.html#particle-to-obstacle_collisions">Particle-to-Obstacle Collisions</a></li></ol></li><li><a href="ch08.html#tuning">Tuning</a></li></ol></li><li><a href="ch09.html">9. 2D Rigid-Body Simulator</a><ol><li><a href="ch09.html#model">Model</a><ol><li><a href="ch09.html#transforming_coordinates">Transforming Coordinates</a></li><li><a href="ch09.html#integrator-id1">Integrator</a></li><li><a href="ch09.html#rendering-id1">Rendering</a></li></ol></li><li><a href="ch09.html#the_basic_simulator-id1">The Basic Simulator</a></li><li><a href="ch09.html#tuning-id1">Tuning</a></li></ol></li><li><a href="ch10.html">10. Implementing Collision Response</a><ol><li><a href="ch10.html#linear_collision_response">Linear Collision Response</a></li><li><a href="ch10.html#angular_effects">Angular Effects</a></li></ol></li><li><a href="ch11.html">11. Rotation in 3D Rigid-Body Simulators</a><ol><li><a href="ch11.html#rotation_matrices">Rotation Matrices</a></li><li><a href="ch11.html#quaternions">Quaternions</a><ol><li><a href="ch11.html#quaternion_operations">Quaternion Operations</a><ol><li><a href="ch11.html#magnitude">Magnitude</a></li><li><a href="ch11.html#conjugate_colon_the_tilde_operator">Conjugate: The ~ operator</a></li><li><a href="ch11.html#qvrotate">QVRotate</a></li><li><a href="ch11.html#quaternion_multiplication_colon_the_aste">Quaternion multiplication: The * operator</a></li><li><a href="ch11.html#vector_multiplication_colon_the_aste">Vector multiplication: The * operator</a></li><li><a href="ch11.html#makeqfromeulerangles">MakeQFromEulerAngles</a></li><li><a href="ch11.html#makeeuleranglesfromq">MakeEulerAnglesFromQ</a></li></ol></li></ol></li><li><a href="ch11.html#quaternions_in_3d_simulators">Quaternions in 3D Simulators</a></li></ol></li><li><a href="ch12.html">12. 3D Rigid-Body Simulator</a><ol><li><a href="ch12.html#model-id1">Model</a></li><li><a href="ch12.html#integration">Integration</a></li><li><a href="ch12.html#flight_controls">Flight Controls</a></li></ol></li><li><a href="ch13.html">13. Connecting Objects</a><ol><li><a href="ch13.html#springs_and_dampers-id1">Springs and Dampers</a></li><li><a href="ch13.html#connecting_particles">Connecting Particles</a><ol><li><a href="ch13.html#rope">Rope</a><ol><li><a href="ch13.html#spring_structure_and_variables">Spring structure and variables</a></li><li><a href="ch13.html#initialize_the_particles_and_springs">Initialize the particles and springs</a></li><li><a href="ch13.html#update_the_simulation">Update the simulation</a></li></ol></li></ol></li><li><a href="ch13.html#connecting_rigid_bodies">Connecting Rigid Bodies</a><ol><li><a href="ch13.html#links">Links</a><ol><li><a href="ch13.html#basic_structures_and_variables">Basic structures and variables</a></li><li><a href="ch13.html#initialize">Initialize</a></li><li><a href="ch13.html#update">Update</a></li></ol></li><li><a href="ch13.html#rotational_restraint">Rotational Restraint</a></li></ol></li></ol></li><li><a href="ch14.html">14. Physics Engines</a><ol><li><a href="ch14.html#building_your_own_physics_engine">Building Your Own Physics Engine</a><ol><li><a href="ch14.html#physics_models">Physics Models</a></li><li><a href="ch14.html#simulated_objects_manager">Simulated Objects Manager</a></li><li><a href="ch14.html#collision_detection">Collision Detection</a></li><li><a href="ch14.html#collision_response">Collision Response</a></li><li><a href="ch14.html#force_effectors">Force Effectors</a></li><li><a href="ch14.html#numerical_integrator">Numerical Integrator</a></li></ol></li></ol></li></ol></li><li><a href="pt03.html">III. Physical Modeling</a><ol><li><a href="ch15.html">15. Aircraft</a><ol><li><a href="ch15.html#geometry">Geometry</a></li><li><a href="ch15.html#lift_and_drag">Lift and Drag</a></li><li><a href="ch15.html#other_forces">Other Forces</a></li><li><a href="ch15.html#control">Control</a></li><li><a href="ch15.html#modeling">Modeling</a></li></ol></li><li><a href="ch16.html">16. Ships and Boats</a><ol><li><a href="ch16.html#stability_and_sinking">Stability and Sinking</a><ol><li><a href="ch16.html#stability">Stability</a></li><li><a href="ch16.html#sinking">Sinking</a></li></ol></li><li><a href="ch16.html#ship_motions">Ship Motions</a><ol><li><a href="ch16.html#heave">Heave</a></li><li><a href="ch16.html#roll">Roll</a></li><li><a href="ch16.html#pitch">Pitch</a></li><li><a href="ch16.html#coupled_motions">Coupled Motions</a></li></ol></li><li><a href="ch16.html#resistance_and_propulsion">Resistance and Propulsion</a><ol><li><a href="ch16.html#general_resistance">General Resistance</a><ol><li><a href="ch16.html#planing_craft">Planing craft</a></li><li><a href="ch16.html#virtual_mass">Virtual mass</a></li><li><a href="ch16.html#guidance_speeds">Guidance speeds</a></li></ol></li><li><a href="ch16.html#propulsion">Propulsion</a></li></ol></li><li><a href="ch16.html#maneuverability">Maneuverability</a><ol><li><a href="ch16.html#rudders_and_thrust_vectoring">Rudders and Thrust Vectoring</a><ol><li><a href="ch16.html#propeller_walk">Propeller walk</a></li></ol></li></ol></li></ol></li><li><a href="ch17.html">17. Cars and Hovercraft</a><ol><li><a href="ch17.html#cars">Cars</a><ol><li><a href="ch17.html#resistance">Resistance</a></li><li><a href="ch17.html#power">Power</a></li><li><a href="ch17.html#stopping_distance">Stopping Distance</a></li><li><a href="ch17.html#steering">Steering</a></li></ol></li><li><a href="ch17.html#hovercraft">Hovercraft</a><ol><li><a href="ch17.html#how_hovercraft_work">How Hovercraft Work</a></li><li><a href="ch17.html#resistance-id1">Resistance</a></li><li><a href="ch17.html#steering-id1">Steering</a></li></ol></li></ol></li><li><a href="ch18.html">18. Guns and Explosions</a><ol><li><a href="ch18.html#projectile_motion">Projectile Motion</a></li><li><a href="ch18.html#taking_aim">Taking Aim</a><ol><li><a href="ch18.html#zeroing_the_sights">Zeroing the Sights</a><ol><li><a href="ch18.html#bullet_drop_colon_gravity_and_air_resist">Bullet drop: Gravity and air resistance</a></li><li><a href="ch18.html#wind">Wind</a></li></ol></li><li><a href="ch18.html#breathing_and_body_position">Breathing and Body Position</a></li></ol></li><li><a href="ch18.html#recoil_and_impact">Recoil and Impact</a></li><li><a href="ch18.html#explosions">Explosions</a><ol><li><a href="ch18.html#particle_explosions">Particle Explosions</a></li><li><a href="ch18.html#polygon_explosions">Polygon Explosions</a></li></ol></li></ol></li><li><a href="ch19.html">19. Sports</a><ol><li><a href="ch19.html#modeling_a_golf_swing">Modeling a Golf Swing</a><ol><li><a href="ch19.html#solving_the_golf_swing_equations">Solving the Golf Swing Equations</a></li></ol></li><li><a href="ch19.html#billiards">Billiards</a><ol><li><a href="ch19.html#implementation">Implementation</a></li><li><a href="ch19.html#initialization">Initialization</a></li><li><a href="ch19.html#stepping_the_simulation">Stepping the Simulation</a></li><li><a href="ch19.html#calculating_forces">Calculating Forces</a></li><li><a href="ch19.html#handling_collisions">Handling Collisions</a></li></ol></li></ol></li></ol></li><li><a href="pt04.html">IV. Digital Physics</a><ol><li><a href="ch20.html">20. Touch Screens</a><ol><li><a href="ch20.html#types_of_touch_screens">Types of Touch Screens</a><ol><li><a href="ch20.html#resistive">Resistive</a></li><li><a href="ch20.html#capacitive">Capacitive</a></li><li><a href="ch20.html#infrared_and_optical_imaging">Infrared and Optical Imaging</a></li><li><a href="ch20.html#exotic_colon_dispersive_signal_and_surfa">Exotic: Dispersive Signal and Surface Acoustic Wave</a></li></ol></li><li><a href="ch20.html#step-by-step_physics">Step-by-Step Physics</a><ol><li><a href="ch20.html#resistive_touch_screens">Resistive Touch Screens</a><ol><li><a href="ch20.html#one-dimensional_resistive_touch_sensor">One-dimensional resistive touch sensor</a></li><li><a href="ch20.html#four-wire_resistive_touch_screen">Four-wire resistive touch screen</a></li></ol></li><li><a href="ch20.html#capacitive_touch_screens">Capacitive Touch Screens</a><ol><li><a href="ch20.html#self-capacitance">Self-capacitance</a></li><li><a href="ch20.html#mutual_capacitance">Mutual capacitance</a></li></ol></li></ol></li><li><a href="ch20.html#example_program">Example Program</a><ol><li><a href="ch20.html#multitouch">Multitouch</a></li></ol></li><li><a href="ch20.html#other_considerations">Other Considerations</a><ol><li><a href="ch20.html#haptic_feedback">Haptic Feedback</a></li><li><a href="ch20.html#modeling_touch_screens_in_games">Modeling Touch Screens in Games</a></li><li><a href="ch20.html#difference_from_mouse-based_input">Difference from Mouse-Based Input</a></li><li><a href="ch20.html#custom_gestures">Custom Gestures</a></li></ol></li></ol></li><li><a href="ch21.html">21. Accelerometers</a><ol><li><a href="ch21.html#accelerometer_theory">Accelerometer Theory</a><ol><li><a href="ch21.html#mems_accelerometers">MEMS Accelerometers</a></li><li><a href="ch21.html#common_accelerometer_specifications">Common Accelerometer Specifications</a></li><li><a href="ch21.html#data_clipping">Data Clipping</a></li></ol></li><li><a href="ch21.html#sensing_orientation">Sensing Orientation</a></li><li><a href="ch21.html#sensing_tilt">Sensing Tilt</a><ol><li><a href="ch21.html#using_tilt_to_control_a_sprite">Using Tilt to Control a Sprite</a></li><li><a href="ch21.html#two_degrees_of_freedom">Two Degrees of Freedom</a></li></ol></li></ol></li><li><a href="ch22.html">22. Gaming from One Place to Another</a><ol><li><a href="ch22.html#location-based_gaming">Location-Based Gaming</a><ol><li><a href="ch22.html#geocaching_and_reverse_geocaching">Geocaching and Reverse Geocaching</a></li><li><a href="ch22.html#mixed_reality">Mixed Reality</a></li><li><a href="ch22.html#street_games">Street Games</a></li></ol></li><li><a href="ch22.html#what_time_is_it_question">What Time Is It?</a><ol><li><a href="ch22.html#two-dimensional_mathematical_treatment">Two-Dimensional Mathematical Treatment</a></li></ol></li><li><a href="ch22.html#location_comma_location_comma_location">Location, Location, Location</a><ol><li><a href="ch22.html#distance">Distance</a></li><li><a href="ch22.html#great-circle_heading">Great-Circle Heading</a></li><li><a href="ch22.html#rhumb_line">Rhumb Line</a></li></ol></li></ol></li><li><a href="ch23.html">23. Pressure Sensors and Load Cells</a><ol><li><a href="ch23.html#under_pressure">Under Pressure</a><ol><li><a href="ch23.html#example_effects_of_high_pressure">Example Effects of High Pressure</a></li></ol></li><li><a href="ch23.html#button_mashing">Button Mashing</a><ol><li><a href="ch23.html#load_cells">Load Cells</a><ol><li><a href="ch23.html#tiny_scales">Tiny scales</a></li><li><a href="ch23.html#center_of_gravity">Center of gravity</a></li></ol></li></ol></li><li><a href="ch23.html#barometers">Barometers</a></li></ol></li><li><a href="ch24.html">24. 3D Display</a><ol><li><a href="ch24.html#binocular_vision">Binocular Vision</a></li><li><a href="ch24.html#stereoscopic_basics">Stereoscopic Basics</a><ol><li><a href="ch24.html#the_left_and_right_frustum">The Left and Right Frustums</a></li></ol></li><li><a href="ch24.html#types_of_display">Types of Display</a><ol><li><a href="ch24.html#complementary-color_anaglyphs">Complementary-Color Anaglyphs</a></li><li><a href="ch24.html#linear_and_circular_polarization">Linear and Circular Polarization</a></li><li><a href="ch24.html#liquid-crystal_plasma">Liquid-Crystal Plasma</a></li><li><a href="ch24.html#autostereoscopy">Autostereoscopy</a></li><li><a href="ch24.html#advanced_technologies">Advanced Technologies</a></li></ol></li><li><a href="ch24.html#programming_considerations">Programming Considerations</a><ol><li><a href="ch24.html#active_stereoization">Active Stereoization</a></li><li><a href="ch24.html#passive_stereoization">Passive Stereoization</a></li></ol></li></ol></li><li><a href="ch25.html">25. Optical Tracking</a><ol><li><a href="ch25.html#sensors_and_sdks">Sensors and SDKs</a><ol><li><a href="ch25.html#kinect">Kinect</a></li><li><a href="ch25.html#opencv">OpenCV</a></li></ol></li><li><a href="ch25.html#numerical_differentiation">Numerical Differentiation</a></li></ol></li><li><a href="ch26.html">26. Sound</a><ol><li><a href="ch26.html#what_is_sound_question">What Is Sound?</a></li><li><a href="ch26.html#characteristics_of_and_behavior_of_sound">Characteristics of and Behavior of Sound Waves</a><ol><li><a href="ch26.html#harmonic_wave">Harmonic Wave</a></li><li><a href="ch26.html#superposition">Superposition</a></li><li><a href="ch26.html#speed_of_sound">Speed of Sound</a></li><li><a href="ch26.html#attenuation">Attenuation</a></li><li><a href="ch26.html#reflection">Reflection</a></li><li><a href="ch26.html#doppler_effect">Doppler Effect</a></li></ol></li><li><a href="ch26.html#d_sound">3D Sound</a><ol><li><a href="ch26.html#how_we_hear_in_3d">How We Hear in 3D</a></li><li><a href="ch26.html#a_simple_example">A Simple Example</a></li></ol></li></ol></li></ol></li><li><a href="apa.html">A. Vector Operations</a><ol><li><a href="apa.html#vector_class">Vector Class</a><ol><li><a href="apa.html#magnitude-id1">Magnitude</a></li><li><a href="apa.html#normalize">Normalize</a></li><li><a href="apa.html#reverse">Reverse</a></li><li><a href="apa.html#vector_addition_colon_the_plus_equals_op">Vector Addition: The += Operator</a></li><li><a href="apa.html#vector_subtraction_colon_the_m_equals_op">Vector Subtraction: The −= Operator</a></li><li><a href="apa.html#scalar_multiplication_colon_the">Scalar Multiplication: The *= Operator</a></li><li><a href="apa.html#scalar_division_colon_the_solidus_equals">Scalar Division: The /= Operator</a></li><li><a href="apa.html#conjugate_colon_the_m_operator">Conjugate: The − Operator</a></li></ol></li><li><a href="apa.html#vector_functions_and_operators">Vector Functions and Operators</a><ol><li><a href="apa.html#vector_addition_colon_the_plus_operator">Vector Addition: The + Operator</a></li><li><a href="apa.html#vector_subtraction_colon_the_m_operator">Vector Subtraction: The − Operator</a></li><li><a href="apa.html#vector_cross_product_colon_the_carret_op">Vector Cross Product: The ^ Operator</a></li><li><a href="apa.html#vector_dot_product_colon_the_asterisk_op">Vector Dot Product: The * Operator</a></li><li><a href="apa.html#scalar_multiplication_colon_the-id1">Scalar Multiplication: The * Operator</a></li><li><a href="apa.html#scalar_division_colon_the_solidus_operat">Scalar Division: The / Operator</a></li><li><a href="apa.html#triple_scalar_product">Triple Scalar Product</a></li></ol></li></ol></li><li><a href="apb.html">B. Matrix Operations</a><ol><li><a href="apb.html#matrix3t3_class">Matrix3×3 Class</a><ol><li><a href="apb.html#determinant">Determinant</a></li><li><a href="apb.html#transpose">Transpose</a></li><li><a href="apb.html#inverse">Inverse</a></li><li><a href="apb.html#matrix_addition_colon_the_plus_equals_op">Matrix Addition: The += Operator</a></li><li><a href="apb.html#matrix_subtraction_colon_the_m_equals_op">Matrix Subtraction: The −= Operator</a></li><li><a href="apb.html#scalar_multiplication_colon_the-id2">Scalar Multiplication: The *= Operator</a></li><li><a href="apb.html#scalar_division_colon_the_solidus_eq">Scalar Division: The /= Operator</a></li></ol></li><li><a href="apb.html#matrix_functions_and_operators">Matrix Functions and Operators</a><ol><li><a href="apb.html#matrix_addition_colon_the_plus_operator">Matrix Addition: The + Operator</a></li><li><a href="apb.html#matrix_subtraction_colon_the_m_operator">Matrix Subtraction: The − Operator</a></li><li><a href="apb.html#scalar_divide_colon_the_solidus_operator">Scalar Divide: The / Operator</a></li><li><a href="apb.html#matrix_multiplication_colon_the_asterisk">Matrix Multiplication: The * Operator</a></li><li><a href="apb.html#scalar_multiplication_colon_the-id3">Scalar Multiplication: The * Operator</a></li><li><a href="apb.html#vector_multiplication_colon_the_aste-id1">Vector Multiplication: The * Operator</a></li></ol></li></ol></li><li><a href="apc.html">C. Quaternion Operations</a><ol><li><a href="apc.html#quaternion_class">Quaternion Class</a><ol><li><a href="apc.html#magnitude-id2">Magnitude</a></li><li><a href="apc.html#getvector">GetVector</a></li><li><a href="apc.html#getscalar">GetScalar</a></li><li><a href="apc.html#quaternion_addition_colon_the_plus_equal">Quaternion Addition: The += Operator</a></li><li><a href="apc.html#quaternion_subtraction_colon_the_m_equal">Quaternion Subtraction: The −= Operator</a></li><li><a href="apc.html#scalar_multiplication_colon_the-id4">Scalar Multiplication: The *= Operator</a></li><li><a href="apc.html#scalar_division_colon_the_solidus">Scalar Division: The /= Operator</a></li><li><a href="apc.html#conjugate_colon_the_tilde_operato">Conjugate: The ~ Operator</a></li></ol></li><li><a href="apc.html#quaternion_functions_and_operators">Quaternion Functions and Operators</a><ol><li><a href="apc.html#quaternion_addition_colon_the_plus_opera">Quaternion Addition: The + Operator</a></li><li><a href="apc.html#quaternion_subtraction_colon_the_m_opera">Quaternion Subtraction: The − Operator</a></li><li><a href="apc.html#quaternion_multiplication_colon_the">Quaternion Multiplication: The * Operator</a></li><li><a href="apc.html#scalar_multiplication_colon_the-id5">Scalar Multiplication: The * Operator</a></li><li><a href="apc.html#vector_multiplication_colon_the_aste-id2">Vector Multiplication: The * Operator</a></li><li><a href="apc.html#scalar_division_colon_the_solidus_op">Scalar Division: The / Operator</a></li><li><a href="apc.html#qgetangle">QGetAngle</a></li><li><a href="apc.html#qgetaxis">QGetAxis</a></li><li><a href="apc.html#qrotate">QRotate</a></li><li><a href="apc.html#qvrotate-id1">QVRotate</a></li><li><a href="apc.html#makeqfromeulerangles-id1">MakeQFromEulerAngles</a></li><li><a href="apc.html#makeeuleranglesfromq-id1">MakeEulerAnglesFromQ</a></li><li><a href="apc.html#conversion_functions">Conversion Functions</a></li></ol></li></ol></li><li><a href="apd.html">D. Bibliography</a><ol><li><a href="apd.html#I_sect1_id371905">General Physics and Dynamics</a></li><li><a href="apd.html#I_sect1_id371993">Mathematics and Numerical Methods</a></li><li><a href="apd.html#I_sect1_id372041">Computational Geometry</a></li><li><a href="apd.html#I_sect1_id372046">Projectiles</a></li><li><a href="apd.html#I_sect1_id372218">Sports Ball Physics</a></li><li><a href="apd.html#I_sect1_id372223">Aerodynamics</a></li><li><a href="apd.html#I_sect1_id372342">Hydrostatics and Hydrodynamics</a></li><li><a href="apd.html#I_sect1_id372424">Automobile Physics</a></li><li><a href="apd.html#I_sect1_id372453">Real-time Physics Simulations</a></li><li><a href="apd.html#I_sect1_id372458">Digital Physics</a></li></ol></li><li><a href="ix01.html">Index</a></li><li><a href="author_bios.html">About the Authors</a></li><li><a href="co02.html">Colophon</a></li><li><a href="upgrade_offer_back.html">Special Upgrade Offer</a></li><li><a href="copyright.html">Copyright</a></li></ol></nav></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 1. Basic Concepts</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="pt01.html" title="Part I. Fundamentals"/><link rel="next" href="ch02.html" title="Chapter 2. Kinematics"/></head><body><section class="chapter" title="Chapter 1. Basic Concepts" epub:type="chapter" id="basic_concepts"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Basic Concepts</h2></div></div></div><p>As a warm-up, this chapter will cover the most basic of the principles that will be used and
    referenced throughout the remainder of this book. First, we’ll introduce Newton’s laws of
    motion, which are very important in the study of mechanics. Then we’ll discuss units and
    measures, where we’ll explain the importance of keeping track of units in your calculations.
    You’ll also have a look at the units associated with various physical quantities that you’ll be
    studying. After discussing units, we’ll define our general coordinate system, which will serve
    as our standard frame of reference. Then we’ll explain the concepts of mass, center of mass, and
    moment of inertia, and show you how to calculate these quantities for a collection, or
    combination, of masses. Finally, we’ll discuss Newton’s second law of motion in greater detail,
    take a quick look at vectors, and briefly discuss relativistic time.</p><div class="sect1" title="Newton’s Laws of Motion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="newtonas_laws_of_motion">Newton’s Laws of Motion</h2></div></div></div><p>In the late 1600s (around 1687), Sir <a id="I_indexterm1_id288108" class="indexterm"/><a id="I_indexterm1_id288114" class="indexterm"/>Isaac Newton put forth his philosophies on mechanics in his <span class="emphasis"><em>Philosophiae
        Naturalis Principia Mathematica</em></span>. In this work Newton stated the now-famous laws
      of motion, which are summarized here:</p><div class="variablelist"><dl><dt><span class="term">Law I</span></dt><dd><p>A body tends to remain at rest or continue to move in a
          straight line at constant velocity unless acted upon by an external
          force. This is the so-called concept of inertia.</p></dd><dt><span class="term">Law II</span></dt><dd><p>The acceleration of a body is proportional to the resultant
          force acting on the body, and this acceleration is in the same
          direction as the resultant force.</p></dd><dt><span class="term">Law III</span></dt><dd><p>For every force acting on a body (action) there is an equal
          and opposite reacting force (reaction), where the reaction is
          collinear to the acting force.</p></dd></dl></div><p>These laws form the basis for much of the analysis in the field of
    mechanics. Of particular interest to us in the study of dynamics is the
    second law, which is written:</p><table style="border: 0; " class="simplelist"><tr><td>F = ma</td></tr></table><p>where <span class="emphasis"><em>F</em></span> is the resultant <a id="I_indexterm1_id288207" class="indexterm"/>force acting on the body, <span class="emphasis"><em>m</em></span> is the
    <a id="I_indexterm1_id288222" class="indexterm"/>mass of the body, and <span class="emphasis"><em>a</em></span> is the
    <a id="I_indexterm1_id288236" class="indexterm"/><a id="I_indexterm1_id288247" class="indexterm"/>linear acceleration of the body’s center of gravity. We’ll
    discuss this second law in greater detail later in this chapter, but
    before that there are some more fundamental issues that we must
    address.</p></div><div class="sect1" title="Units and Measures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="units_and_measures">Units and Measures</h2></div></div></div><p>Over years of <a id="I_indexterm1_id288276" class="indexterm"/><a id="I_indexterm1_id288286" class="indexterm"/>teaching various engineering courses, we’ve observed that
    one of the most common mistakes students make when performing calculations
    is using the wrong units for a quantity, thus failing to maintain
    consistent units and producing some pretty wacky answers. For example, in
    the field of ship performance, the most commonly misused unit is that for
    speed: people forget to convert speed in knots to speed in meters per
    second (m/s) or feet per second (ft/s). One knot is equal to 0.514 m/s,
    and considering that many quantities of interest in this field are
    proportional to speed squared, this mistake could result in answers that
    are as much as 185% off target! So, if some of your results look
    suspicious later on, the first thing you need to do is go back to your
    formulas and check their dimensional consistency.</p><p>To check dimensional consistency, <a id="un1.2" class="indexterm"/>you must take a closer look at your units of measure and
    consider their component dimensions. We are not talking about 2D or 3D
    type dimensions here, but rather the basic measurable dimensions that will
    make up various <span class="emphasis"><em>derived</em></span> units for the physical
    quantities that we will be using. These <a id="I_indexterm1_id288330" class="indexterm"/><a id="I_indexterm1_id288341" class="indexterm"/><a id="I_indexterm1_id288351" class="indexterm"/>basic dimensions are <span class="emphasis"><em>mass</em></span>,
    <span class="emphasis"><em>length</em></span>, and <span class="emphasis"><em>time</em></span>.</p><p>It is important for you to be aware of these dimensions, as well as
    the combinations of these dimensions that make up the other derived units,
    so that you can ensure dimensional consistency in your calculations. For
    example, you know that the <a id="I_indexterm1_id288377" class="indexterm"/><a id="I_indexterm1_id288387" class="indexterm"/>weight of an object is measured in units of force, which can
    be broken down into component dimensions like so:</p><table style="border: 0; " class="simplelist"><tr><td>F = (M) (L/T<sup>2</sup>)</td></tr></table><p>where <span class="emphasis"><em>M</em></span> is <a id="I_indexterm1_id288423" class="indexterm"/>mass, <span class="emphasis"><em>L</em></span> is length, and
    <span class="emphasis"><em>T</em></span> is time. <a id="I_indexterm1_id288442" class="indexterm"/>Does this look familiar? Well, if you consider that the
    component <a id="I_indexterm1_id288453" class="indexterm"/><a id="I_indexterm1_id288464" class="indexterm"/>units for acceleration are
    (<span class="emphasis"><em>L/T</em></span><sup>2</sup>) and let
    <span class="emphasis"><em>a</em></span> be the symbol for acceleration and
    <span class="emphasis"><em>m</em></span> be the symbol for the mass of an object, you
    get:</p><table style="border: 0; " class="simplelist"><tr><td>F = ma</td></tr></table><p>which is the famous expression of <a id="I_indexterm1_id288499" class="indexterm"/>Newton’s second law of motion. We will take a closer look at
    this equation later.</p><p>By no means did we just derive this famous formula. What we did was
    check its dimensional consistency (albeit in reverse), and all that means
    is that any formulas you develop to represent a force acting on a body had
    better come out to a consistent set of units in the form
    (<span class="emphasis"><em>M</em></span>)
    (<span class="emphasis"><em>L/T</em></span><sup>2</sup>). This may seem
    trivial at the moment; however, when you start looking at more complicated
    formulas for the forces acting on a body, you’ll want to be able to break
    down these formulas into their component dimensions so you can check their
    dimensional consistency. Later we will use actual units, from the SI
    (<span class="emphasis"><em>le Système international d’unités</em></span>, or International
    System of Units)<a id="I_indexterm1_id288535" class="indexterm"/><a id="I_indexterm1_id288541" class="indexterm"/> for our physical quantities. Of course, there are other
    unit systems, but unless you want to show these values to your gamers, it
    really does not matter which system you use in your games. Again, what is
    important is consistency.</p><p>To help clarify this point, consider the formula for the <a id="I_indexterm1_id288552" class="indexterm"/>friction drag on a body moving through a fluid, such as
    water:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>f</sub> = 1/2 ρ V<sup>2</sup>
      S C<sub>f</sub></td></tr></table><p>In this formula, <span class="emphasis"><em>R</em></span><sub>f</sub>
    represents resistance (a force) due to friction, ρ is the density of
    water, <span class="emphasis"><em>V</em></span> is the speed of the moving body,
    <span class="emphasis"><em>S</em></span> is the submerged surface area of the body, and
    <span class="emphasis"><em>C</em></span><sub>f</sub> is an empirical
    (experimentally determined) drag coefficient for the body. Now rewriting
    this formula in terms of basic dimensions instead of variables will show
    that the dimensions on the left side of the formula match exactly the
    dimensions on the right side. Since
    <span class="emphasis"><em>R</em></span><sub>f</sub> is a force, its basic
    dimensions are of the form:</p><table style="border: 0; " class="simplelist"><tr><td>(M) (L/T<sup>2</sup>)</td></tr></table><p>as discussed earlier, which implies that the dimensions of all the
    terms on the right side of the equation, when combined, must yield an
    equivalent form. Considering the basic <a id="I_indexterm1_id288641" class="indexterm"/><a id="I_indexterm1_id288651" class="indexterm"/><a id="I_indexterm1_id288661" class="indexterm"/>units for density, speed, and surface area:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Density: (M)/(L<sup>3</sup>)</p></li><li class="listitem"><p>Speed: (L)/(T)</p></li><li class="listitem"><p>Area: (L<sup>2</sup>)</p></li></ul></div><p>and combining these dimensions for the terms, ρ
    <span class="emphasis"><em>V</em></span><sup>2</sup> <span class="emphasis"><em>S</em></span>,
    as follows:</p><table style="border: 0; " class="simplelist"><tr><td>[(M)/(L<sup>3</sup>)]
      [(L)/(T)]<sup>2</sup>
      [L<sup>2</sup>]</td></tr></table><p>and collecting the dimensions in the numerator and denominator
    yields the following form:</p><table style="border: 0; " class="simplelist"><tr><td>(M L<sup>2</sup> L<sup>2</sup>)
      / (L<sup>3</sup> T<sup>2</sup>)</td></tr></table><p>Canceling dimensions that appear in both the numerator and
    denominator yields:</p><table style="border: 0; " class="simplelist"><tr><td>M (L/T<sup>2</sup>)</td></tr></table><p>which is consistent with the form shown earlier for resistance,
    <span class="emphasis"><em>R</em></span><sub>f</sub>. This exercise also reveals
    that the empirical term, <span class="emphasis"><em>C</em></span><sub>f</sub>,
    for the coefficient of friction must be nondimensional—that is, it is a
    constant number with no units.</p><p>With that, let’s take a look at some more common physical quantities
    that you will be using along with their corresponding symbols, component
    dimensions, and units in both the SI and English systems. This information
    is summarized in <a class="xref" href="ch01.html#common_physical_quantities_and_units" title="Table 1-1. Common physical quantities and units">Table 1-1</a>.</p><div class="table"><a id="common_physical_quantities_and_units"/><div class="table-title">Table 1-1. Common physical quantities and units</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/><col class="col5"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Quantity</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Symbol</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Dimensions</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Units, SI</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Units,
            English</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Acceleration,
            linear</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L/<a id="I_indexterm1_id288957" class="indexterm"/><a id="I_indexterm1_id288967" class="indexterm"/>T<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>m/s<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>ft/s<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Acceleration,
            angular</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>α</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ra<a id="I_indexterm1_id289036" class="indexterm"/><a id="I_indexterm1_id289046" class="indexterm"/>dian/T<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>radian/s<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>radian/s<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Density</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ρ</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M/<a id="I_indexterm1_id289115" class="indexterm"/>L<sup>3</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>kg/m<sup>3</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>slug/ft<sup>3</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Force</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>F</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M <a id="I_indexterm1_id289185" class="indexterm"/>(L/T<sup>2</sup>)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>newton, N</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>pound, lbs</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Kinematic
            viscosity</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ν</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L<sup>2</sup>/<a id="I_indexterm1_id289254" class="indexterm"/><a id="I_indexterm1_id289261" class="indexterm"/>T</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>m<sup>2</sup>/s</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>ft<sup>2</sup>/s</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L (or x, y, <a id="I_indexterm1_id289321" class="indexterm"/>z)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>meters, m</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>feet, ft</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mass</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>m</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>kilogram, <a id="I_indexterm1_id289402" class="indexterm"/>kg</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>slug</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moment
            (torque)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M<sup>[<a id="CHP-1-TFN-1" href="#ftn.CHP-1-TFN-1" class="footnote">a</a>]</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M<a id="I_indexterm1_id289479" class="indexterm"/><a id="I_indexterm1_id289489" class="indexterm"/>
            (L<sup>2</sup>/T<sup>2</sup>)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N-m</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>ft-lbs</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Mass Moment of
            Inertia</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>I</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M <a id="I_indexterm1_id289558" class="indexterm"/>L<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>kg-m<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>lbs-ft-s<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pressure</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>P</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M/<a id="I_indexterm1_id289628" class="indexterm"/>(L T<sup>2</sup>)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N/m<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>lbs/ft<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>seconds, <a id="I_indexterm1_id289708" class="indexterm"/>s</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>seconds, s</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Velocity,
            linear</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>V</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>L/T</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>m/<a id="I_indexterm1_id289768" class="indexterm"/><a id="I_indexterm1_id289777" class="indexterm"/>s</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>ft/s</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Velocity,
            angular</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ω</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>rad<a id="I_indexterm1_id289830" class="indexterm"/><a id="I_indexterm1_id289840" class="indexterm"/>ian/T</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>radian/s</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>radian/s</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Viscosity</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>µ</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>M<a id="I_indexterm1_id289902" class="indexterm"/>/(L T)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>N s/<a id="I_indexterm1_id289922" class="indexterm"/>m<sup>2</sup></p></td><td style="text-align: left; vertical-align: top; "><p>lbs •
            s/ft<sup>2</sup></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="5"><div class="footnote" id="ftn.CHP-1-TFN-1"><p><sup>[<a href="#CHP-1-TFN-1" class="para">a</a>] </sup>In general, we will use a capital <span class="emphasis"><em>M</em></span>
                to represent a moment (torque) acting on a body and a
                lowercase <span class="emphasis"><em>m</em></span> to represent the mass of a
                body. If we’re referring to the basic dimension of mass in a
                general sense—that is, referring to the dimensional components
                of derived units of measure—we’ll use a capital
                <span class="emphasis"><em>M</em></span>. Usually, the meanings of these symbols
                will be obvious based on the context in which they are used;
                however, we will specify their meanings in cases where
                ambiguity may exist.</p></div></td></tr></tbody></table></div></div></div><div class="sect1" title="Coordinate System"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="coordinate_system">Coordinate System</h2></div></div></div><p>Throughout this book <a id="I_indexterm1_id289956" class="indexterm"/><a id="I_indexterm1_id289966" class="indexterm"/>we will refer to a standard, <span class="emphasis"><em>right-handed</em></span> Cartesian
      coordinate system when specifying positions in 2D or 3D space. In two dimensions we will use
      the coordinate system shown in <a class="xref" href="ch01.html#right-handed_coordinate_system" title="Figure 1-1. Right-handed coordinate system">Figure 1-1</a>(a), where
      rotations are measured positive counterclockwise.</p><div class="figure"><a id="right-handed_coordinate_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id289998"/><img src="httpatomoreillycomsourceoreillyimages1598870.png" alt="Right-handed coordinate system"/></div></div><div class="figure-title">Figure 1-1. Right-handed coordinate system</div></div><p>In three dimensions we will use the coordinate system shown in <a class="xref" href="ch01.html#right-handed_coordinate_system" title="Figure 1-1. Right-handed coordinate system">Figure 1-1</a>(b), where rotations about the
    <a id="I_indexterm1_id290028" class="indexterm"/>x-axis are positive from <a id="I_indexterm1_id290035" class="indexterm"/><a id="I_indexterm1_id290041" class="indexterm"/>positive <span class="emphasis"><em>y</em></span> to positive
    <span class="emphasis"><em>z</em></span>, rotations about the y-axis are positive from
    positive <span class="emphasis"><em>z</em></span> to positive <span class="emphasis"><em>x</em></span>, and
    rotations about the z-axis are positive from positive
    <span class="emphasis"><em>x</em></span> to positive <span class="emphasis"><em>y</em></span>.</p></div><div class="sect1" title="Vectors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="vectors">Vectors</h2></div></div></div><p>Let us take <a id="I_indexterm1_id290086" class="indexterm"/>you back for a moment to your high school math class and
    review the concept of <span class="emphasis"><em>vectors</em></span>. Essentially, a vector
    is a quantity that has both <a id="I_indexterm1_id290101" class="indexterm"/><a id="I_indexterm1_id290114" class="indexterm"/><a id="I_indexterm1_id290123" class="indexterm"/><a id="I_indexterm1_id290133" class="indexterm"/>magnitude as well as direction. Recall that a
    <span class="emphasis"><em>scalar</em></span>, unlike a vector, <a id="I_indexterm1_id290148" class="indexterm"/><a id="I_indexterm1_id290158" class="indexterm"/><a id="I_indexterm1_id290168" class="indexterm"/>has only magnitude and no direction. In mechanics,
    quantities such as force, velocity, acceleration, and momentum are
    <a id="I_indexterm1_id290180" class="indexterm"/>vectors, and you must consider both their magnitude and
    direction. Quantities such as <a id="I_indexterm1_id290192" class="indexterm"/>distance, density, viscosity, and the like are
    scalars.</p><p>With regard to notation, we’ll use boldface type to indicate a
    vector quantity, such as force, <span class="strong"><strong>F</strong></span>. When
    referring to the magnitude only of a vector quantity, we’ll use standard
    type. For example, the magnitude of the vector force, <span class="strong"><strong>F</strong></span>, is F with components along the coordinate
    axes, F<sub>x</sub>, F<sub>y</sub>, and
    F<sub>z</sub>. In the code samples throughout the book, we’ll
    use the <code class="literal">*</code> (asterisk) to indicate vector
    dot product, or scalar product, operations depending on the context, and
    we’ll use the <code class="literal">^</code> (caret) to indicate
    vector cross product.</p><p>Because we will be using vectors throughout this book, it is important that you refresh
      your memory on the basic vector operations, such as vector addition, dot product, and cross
      product, among others. For your convenience (so you don’t have to drag out that old math
      book), we’ve included a summary of the basic vector operations in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>. This appendix provides code for a <code class="literal">Vector</code> class that contains all the important vector math functionality. Further,
      we explain how to use specific vector operations—such as the dot-product and cross-product
      operations—to perform some common and useful, calculations. For example, in dynamics you’ll
      often have to find a vector perpendicular, or <span class="emphasis"><em>normal</em></span>, to a plane or
      contacting surface; you use the <a id="I_indexterm1_id290276" class="indexterm"/><a id="I_indexterm1_id290283" class="indexterm"/><a id="I_indexterm1_id290289" class="indexterm"/><a id="I_indexterm1_id290298" class="indexterm"/>cross-product operation for this task. Another common calculation involves finding
      the shortest distance from a point to a plane in space; you use the <a id="I_indexterm1_id290308" class="indexterm"/><a id="I_indexterm1_id290313" class="indexterm"/><a id="I_indexterm1_id290319" class="indexterm"/>dot-product operation here. Both of these tasks are described in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>, which we encourage you to review before delving too deeply
      into the example code presented throughout the remainder of this book.</p></div><div class="sect1" title="Derivatives and Integrals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="derivatives_and_integrals">Derivatives and Integrals</h2></div></div></div><p>If you’re not familiar with calculus, or The Calculus, don’t let the
    use of derivatives and integrals in this text worry you. While we’ll write
    equations using derivatives and integrals, we’ll show you explicitly how
    to deal with them computationally throughout this book. Without going into
    a dissertation on all the properties and applications of derivatives and
    integrals, let’s touch on their physical significance as they relate to
    the material we’ll cover.</p><p>You can think of a <a id="I_indexterm1_id290356" class="indexterm"/>derivative as the rate of change in one variable with
    respect to another variable, or in other words, derivatives tells you how
    fast one variable changes as some other variable changes. Take speed, for
    example. A car travels at a certain speed covering some distance in a
    certain period of time. Its speed, on average, is the distance traveled
    over a specific time interval. If it travels a distance of 60 kilometers
    in one hour, then its average speed is 60 kilometers an hour. When we’re
    doing simulations, the ones you’ll see later in this book, we’re
    interested in what the car is doing over very short time intervals. As the
    time interval gets really small and we consider the distance traveled over
    that very short period of time, we’re looking at
    <span class="emphasis"><em>instantaneous</em></span> speed. We usually write such relations
    using symbols like the following:</p><table style="border: 0; " class="simplelist"><tr><td>|v| = ds/dt</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is the speed, <span class="emphasis"><em>ds</em></span>
    is a small distance (a <span class="emphasis"><em>differential</em></span> distance), and
    <span class="emphasis"><em>dt</em></span> is a small, differential, period of time. In
    reality, for our simulations, we’ll never deal with infinitely small
    numbers; we’ll use small numbers, such as time intervals of 1 millisecond,
    but not infinitely small numbers.</p><p>For our purposes, you can think of <a id="I_indexterm1_id290412" class="indexterm"/>integrals as the reverse, or the inverse, of derivatives; integration is the
      inverse of differentiation. The symbol ∫ represents integration. You can think of integration
      as a process of adding up a bunch of infinitely small chunks of some variable. Here again, we
      are not going to deal with infinitely small pieces of anything, but instead will consider
      small, discrete parcels of some variable—for example, a small, discrete amount of time, area,
      or mass. In these cases, we’ll use the ∑ symbol instead of the integration symbol. Consider a
      loaf of bread that’s sliced into uniformly thick slices along its whole length. If you wanted
      to compute the volume of that loaf of bread, you can approximate it by starting at one end and
      computing the volume of the first slice, approximating its volume as though it were a very
      short, square cylinder; then moving on to the second slice, estimating its volume and adding
      that to the volume of the first slice; and then moving on to the third, and fourth, and so on,
      aggregating the volume of the loaf as you move toward the other end. Integration applies this
      technique to infinitely thin slices of volume to compute the volume of any arbitrary shape.
      The same techniques apply to other computations—for example, computing areas,
        <span class="emphasis"><em>inertias</em></span>, masses, and so on, and even aggregating distance traveled
      over successive small slices of time, as you’ll see later. In fact, this latter application is
      the inverse of the derivative of distance with respect to time, which gives speed. Using
      integration and differentiation in this way allows you to work back and forth when computing
      speed, acceleration, and distance traveled, as you’ll see shortly. In fact, we’ll use these
      concepts heavily throughout the rest of this book.</p></div><div class="sect1" title="Mass, Center of Mass, and Moment of Inertia"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="mass_comma_center_of_mass_comma_and_mome">Mass, Center of Mass, and Moment of Inertia</h2></div></div></div><p>The properties of a <a id="I_indexterm1_id290465" class="indexterm"/>body—<span class="emphasis"><em>mass</em></span>, <span class="emphasis"><em>center of
    mass</em></span>, and <span class="emphasis"><em>moment of inertia</em></span>, collectively
    called <span class="emphasis"><em>mass properties—</em></span>are absolutely crucial to the
    study of mechanics, as the <a id="I_indexterm1_id290491" class="indexterm"/><a id="I_indexterm1_id290498" class="indexterm"/><a id="I_indexterm1_id290508" class="indexterm"/><a id="I_indexterm1_id290518" class="indexterm"/>linear and angular<sup>[<a id="CHP-1-FN-1" href="#ftn.CHP-1-FN-1" epub:type="noteref" class="footnote">5</a>]</sup> motion of a body and a body’s response to a given force are
    functions of these mass properties. Thus, in order to accurately model a
    body in motion, you need to know or be capable of calculating these mass
    properties. Let’s look at a few definitions first.</p><p>In general, people think of mass <a id="I_indexterm1_id290551" class="indexterm"/><a id="I_indexterm1_id290560" class="indexterm"/>as a measure of the amount of matter in a body. For our
    purposes in the study of mechanics, we can also think of mass as a measure
    of a body’s resistance to motion or a change in its motion. Thus, the
    greater a body’s mass, the harder it will be to set it in motion or change
    its motion.</p><p>In laymen’s terms, the <a id="I_indexterm1_id290578" class="indexterm"/><a id="I_indexterm1_id290587" class="indexterm"/><a id="I_indexterm1_id290597" class="indexterm"/>center of mass (also known as <span class="emphasis"><em>center of
    gravity</em></span>) is the point in a body around which the mass of the
    body is evenly distributed. In mechanics, the center of mass is the point
    through which any force can act on the body without resulting in a
    rotation of the body.</p><p>Although most people are familiar with the terms
    <span class="emphasis"><em>mass</em></span> and <span class="emphasis"><em>center of gravity</em></span>, the
    term<a id="I_indexterm1_id290627" class="indexterm"/> <span class="emphasis"><em>moment of inertia</em></span> is not so familiar;
    however, in mechanics it is equally important. The <a id="I_indexterm1_id290642" class="indexterm"/><a id="I_indexterm1_id290652" class="indexterm"/>mass moment of inertia of a body is a quantitative measure
    of the radial distribution of the mass of a body about a given axis of
    rotation. Analogous to mass being a measure of a body’s resistance to
    linear motion, mass moment of inertia (also known <a id="I_indexterm1_id290665" class="indexterm"/>as <span class="emphasis"><em>rotational inertia</em></span>) is a measure of
    a body’s resistance to rotational motion.</p><p>Now that you know what these properties mean, let’s look at how to
    calculate each.</p><p>For a given body <a id="I_indexterm1_id290687" class="indexterm"/><a id="I_indexterm1_id290698" class="indexterm"/>made up of a number of particles, the total mass of the body
    is simply the sum of the masses of all elemental particles making up the
    body, where the mass of each elemental particle is its mass density times
    its volume. Assuming that the body is of uniform density, then the total
    mass of the body is simply the density of the body times the total volume
    of the body. This is expressed in the following equation:</p><table style="border: 0; " class="simplelist"><tr><td>m = ∫ ρ dV = ρ ∫ dV</td></tr></table><p>In practice, you rarely need to take the volume integral to find the
    mass of a body, especially considering that many of the bodies we will
    consider—for example, cars and planes—are not of uniform density. Thus,
    you will simplify these complicated bodies by breaking them down into an
    ensemble of component bodies of known or easily calculable mass and simply
    sum the masses of all components to arrive at the total mass.</p><p>The calculation of the<a id="ce1.6" class="indexterm"/><a id="mc1.6" class="indexterm"/> center of gravity of a body is a little more involved.
    First, divide the body into a finite number of elemental masses with the
    center of each mass specified relative to the reference coordinate system
    axes. We’ll refer to these elemental masses as
    <span class="emphasis"><em>m</em></span><sub>i</sub>. Next, take the
    <span class="emphasis"><em>first moment</em></span> of each mass about the reference axes
    and then add up all of these moments. The first moment is the product of
    the mass times the distance along a given coordinate axis from the origin
    to the center of mass. Finally, divide this sum of moments by the total
    mass of the body, yielding the coordinates to the center of mass of the
    body relative to the reference axes. You must perform this calculation
    once for each dimension—that is, twice when working in 2D and three times
    when working in 3D. Here are the equations for the 3D coordinates of the
    center of mass of a body:</p><table style="border: 0; " class="simplelist"><tr><td>x<sub>c</sub> = {∫ x<sub>o</sub> dm} /
      m</td></tr><tr><td>y<sub>c</sub> = {∫ y<sub>o</sub> dm} /
      m</td></tr><tr><td>z<sub>c</sub> = {∫ z<sub>o</sub> dm} /
      m</td></tr></table><p>where (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>,
    <span class="emphasis"><em>z</em></span>)<sub>c</sub> are the coordinates of the
    center of mass for the body and (<span class="emphasis"><em>x</em></span>,
    <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>z</em></span>)<sub>o</sub>
    are the coordinates of the center of mass of each elemental mass. The
    quantities <span class="emphasis"><em>x</em></span><sub>o</sub>
    <span class="emphasis"><em>dm</em></span>, <span class="emphasis"><em>y</em></span><sub>o</sub>
    <span class="emphasis"><em>dm</em></span>, and
    <span class="emphasis"><em>z</em></span><sub>o</sub> <span class="emphasis"><em>dm</em></span>
    represent the first moments of the elemental mass,
    <span class="emphasis"><em>dm</em></span>, about each of the coordinate axes.</p><p>Here again, don’t worry too much about the integrals in these
    equations. In practice, you will be summing finite numbers of masses and
    the formulas will take on the friendlier forms shown here:</p><table style="border: 0; " class="simplelist"><tr><td>x<sub>c</sub> = {Σ
      x<sub>o</sub>m<sub>i</sub>} / {Σ
      m<sub>i</sub>}</td></tr><tr><td>y<sub>c</sub> = {Σ
      y<sub>o</sub>m<sub>i</sub>} / {Σ
      m<sub>i</sub>}</td></tr><tr><td>z<sub>c</sub> = {Σ
      z<sub>o</sub>m<sub>i</sub>} / {Σ
      m<sub>i</sub>}</td></tr></table><p>Note that you can easily substitute weights for masses in these
    formulas since the constant acceleration due to gravity,
    <span class="emphasis"><em>g</em></span>, would appear in both the numerators and
    denominators, thus dropping out of the equations. Recall that the weight
    of an object is its mass times the acceleration due to gravity,
    <span class="emphasis"><em>g</em></span>, which is 9.8 m/s<sup>2</sup> at
    sea level.</p><p>The formulas for calculating the total mass and center of gravity
    for a system of discrete point masses can conveniently be written in
    vector notation as follows:</p><table style="border: 0; " class="simplelist"><tr><td>m<sub>t</sub> = Σ m<sub>i</sub></td></tr><tr><td><span class="strong"><strong>CG</strong></span> =[Σ (<span class="strong"><strong>cg</strong></span><sub>i</sub>)
      (m<sub>i</sub>)] / m<sub>t</sub></td></tr></table><p>where <span class="emphasis"><em>m</em></span><sub>t</sub> is the total
    mass, <span class="emphasis"><em>m</em></span><sub>i</sub> is the mass of each
    point mass in the system, <span class="strong"><strong>CG</strong></span> is the
    combined center of gravity, and <span class="strong"><strong>cg</strong></span><sub>i</sub> is the location of the
    center of gravity of each point mass in design, or reference, coordinates.
    Notice that <span class="strong"><strong>CG</strong></span> and <span class="strong"><strong>cg</strong></span><sub>i</sub> are shown as vectors
    since they denote position in Cartesian coordinates. This is a matter of
    convenience since it allows you to take care of the
    <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>
    components (or just <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> in
    two dimensions) in one shot.</p><p>In the code samples that follow, let’s assume that the point masses
    making up the body are represented by an array of structures where each
    structure contains the point mass’s design coordinates and mass. The
    structure will also contain an element to hold the coordinates of the
    point mass relative to the combined center of gravity of the rigid body,
    which will be calculated later.</p><a id="I_programlisting1_id291091"/><pre class="programlisting">typedef struct _PointMass
{
   float mass;
   Vector designPosition;
   Vector correctedPosition;
} PointMass;

// Assume that _NUMELEMENTS has been defined
PointMassElements[_NUMELEMENTS];</pre><p>Here’s some code that illustrates how to calculate the total mass
    and combined center of gravity of the elements:</p><a id="I_programlisting1_id291103"/><pre class="programlisting">int  i;
float TotalMass;
Vector CombinedCG;
Vector FirstMoment;

TotalMass = 0;
for(i=0; i&lt;_NUMELEMENTS; i++)
   TotalMass FAC+= Elements[i].mass;

FirstMoment = Vector(0, 0, 0);
for(i=0; i&lt;_NUMELEMENTS; i++)
{
   FirstMoment += Element[i].mass * Element[i].designPosition;
}
CombinedCG = FirstMoment / TotalMass;</pre><p>Now that the combined center of gravity location has been found, you
    can calculate the relative position of each point mass as <a id="I_indexterm1_id291115" class="indexterm"/><a id="I_indexterm1_id291125" class="indexterm"/>follows:</p><a id="I_programlisting1_id291136"/><pre class="programlisting">for(i=0; i&lt;_NUMELEMENTS; i++)
{
   Element[i].correctedPosition = Element[i].designPosition -
                  CombinedCG;
}</pre><p>To calculate <a id="ma1.6" class="indexterm"/><a id="mm1.6" class="indexterm"/><a id="mo1.6" class="indexterm"/>mass moment of inertia, you need to take the second moment
    of each elemental mass making up the body about each coordinate axis. The
    second moment is then the product of the mass times distance squared. That
    distance is not the distance to the elemental mass centroid along the
    coordinate axis as in the calculation for center of mass, but rather the
    perpendicular distance from the coordinate axis, about which we want to
    calculate the moment of inertia, to the elemental mass centroid.</p><p>Referring to <a class="xref" href="ch01.html#arbitrary_body_in_3d" title="Figure 1-2. Arbitrary body in 3D">Figure 1-2</a> for an
    arbitrary body in three dimensions, when calculating moment of inertia
    about the x-axis, <span class="emphasis"><em>I</em></span><sub>xx</sub>, this
    distance, <span class="emphasis"><em>r</em></span>, will be in the yz-plane such that
    <span class="emphasis"><em>r</em></span><sub>x</sub><sup>2</sup>
    = <span class="emphasis"><em>y</em></span><sup>2</sup> +
    <span class="emphasis"><em>z</em></span><sup>2</sup>. Similarly, for the
    moment of inertia about the y-axis,
    <span class="emphasis"><em>I</em></span><sub>yy</sub>,
    <span class="emphasis"><em>r</em></span><sub>y</sub><sup>2</sup>
    = <span class="emphasis"><em>z</em></span><sup>2</sup> +
    <span class="emphasis"><em>x</em></span><sup>2</sup>, and for the moment of
    inertia about the z-axis, <span class="emphasis"><em>I</em></span><sub>zz</sub>,
    <span class="emphasis"><em>r</em></span><sub>z</sub><sup>2</sup>
    = <span class="emphasis"><em>x</em></span><sup>2</sup> +
    <span class="emphasis"><em>y</em></span><sup>2</sup>.</p><div class="figure"><a id="arbitrary_body_in_3d"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291301"/><img src="httpatomoreillycomsourceoreillyimages1598871.png" alt="Arbitrary body in 3D"/></div></div><div class="figure-title">Figure 1-2. Arbitrary body in 3D</div></div><p>The equations for mass moment of inertia about the coordinate axes
    in 3D are:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>xx</sub> = ∫
      r<sub>x</sub><sup>2</sup> dm = ∫
      (y<sup>2</sup> + z<sup>2</sup>)
      dm</td></tr><tr><td>I<sub>yy</sub> = ∫
      r<sub>y</sub><sup>2</sup> dm = ∫
      (z<sup>2</sup> + x<sup>2</sup>)
      dm</td></tr><tr><td>I<sub>zz</sub> = ∫
      r<sub>z</sub><sup>2</sup> dm = ∫
      (x<sup>2</sup> + y<sup>2</sup>)
      dm</td></tr></table><p>Let’s look for a moment at a common situation that arises in
    practice. Say you are given the moment of inertia,
    <span class="emphasis"><em>I</em></span><sub>o</sub>, of a body about an axis,
    called the <span class="emphasis"><em>neutral axis</em></span>, <a id="I_indexterm1_id291412" class="indexterm"/>passing through the center of mass of the body, but you want
    to know the moment of inertia, <span class="emphasis"><em>I</em></span>, about an axis some
    distance from but parallel to this neutral axis. In this case, you can use
    the transfer of axes, or <span class="emphasis"><em>parallel axis theorem</em></span>, to
    <a id="I_indexterm1_id291428" class="indexterm"/>determine the moment of inertia about this new axis. The
    formula to use is:</p><table style="border: 0; " class="simplelist"><tr><td>I = I<sub>o</sub> +
      md<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>m</em></span> is the mass of the body and
    <span class="emphasis"><em>d</em></span> is the perpendicular distance between the parallel
    axes.</p><p>There is an important practical observation to make here: the new
    moment of inertia is a function of the distance separating the axes
    squared. This means that in cases where
    <span class="emphasis"><em>I</em></span><sub>o</sub> is known to be relatively
    small and <span class="emphasis"><em>d</em></span> relatively large, you can safely ignore
    <span class="emphasis"><em>I</em></span><sub>o</sub>, since the
    <span class="emphasis"><em>md</em></span><sup>2</sup> term will dominate.
    You must use your best judgment here, of course. This formula for transfer
    of axes also indicates that the moment of inertia of a body will be at its
    minimum when calculated about an axis passing through the body’s center of
    gravity. The body’s moment of inertia about any parallel axis will always
    increase by an amount,
    <span class="emphasis"><em>md</em></span><sup>2</sup>, when calculated about
    an axis not passing through the body’s center of mass.</p><p>In practice, calculating mass moment of inertia for all but the
    simplest shapes of uniform density is a complicated endeavor, so we will
    often approximate the moment of inertia of a body about axes passing
    through its center of mass by using simple formulas for basic shapes that
    approximate the object. Further, we will break down complicated bodies
    into smaller components and take advantage of the fact that
    <span class="emphasis"><em>I</em></span><sub>o</sub> may be negligible for
    certain components considering its
    <span class="emphasis"><em>md</em></span><sup>2</sup> contribution to the
    total body’s moment of inertia.</p><p><a class="xref" href="ch01.html#circular_cylinder_colon_ixx_equals_iyy" title="Figure 1-3. Circular cylinder: Ixx = Iyy = (1/4) mr2 + (1/12) ml2; Izz = (1/2) mr2">Figure 1-3</a> through <a class="xref" href="ch01.html#spherical_shell_colon_ixx_equals_iyy_equ" title="Figure 1-7. Spherical shell: Ixx = Iyy = Izz = (2/3) mr2">Figure 1-7</a> show some simple solid geometries for
      which you can easily calculate mass moments of inertia. The mass moment of inertia formulas
      for each of these simple geometries of homogenous density about the three coordinate axes are
      shown in the figure captions. You can readily find similar formulas for other basic geometries
      in college-level dynamics texts (see the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a> at
      the end of this book for a <a id="I_indexterm1_id291542" class="indexterm"/><a id="I_indexterm1_id291548" class="indexterm"/><a id="I_indexterm1_id291554" class="indexterm"/>few sources).</p><div class="figure"><a id="circular_cylinder_colon_ixx_equals_iyy"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291596"/><img src="httpatomoreillycomsourceoreillyimages1598872.png" alt="Circular cylinder: Ixx = Iyy = (1/4) mr2 + (1/12) ml2; Izz = (1/2) mr2"/></div></div><div class="figure-title">Figure 1-3. Circular cylinder: I<sub>xx</sub> =
      I<sub>yy</sub> = (1/4) mr<sup>2</sup> +
      (1/12) ml<sup>2</sup>; I<sub>zz</sub> =
      (1/2) mr<sup>2</sup></div></div><div class="figure"><a id="circular_cylindrical_shell_colon_ixx_equ"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291647"/><img src="httpatomoreillycomsourceoreillyimages1598873.png.jpg" alt="Circular cylindrical shell: Ixx = Iyy = (1/2) mr2 + (1/12) ml2; Izz = mr2"/></div></div><div class="figure-title">Figure 1-4. Circular cylindrical shell: I<sub>xx</sub> =
      I<sub>yy</sub> = (1/2) mr<sup>2</sup> +
      (1/12) ml<sup>2</sup>; I<sub>zz</sub> =
      mr<sup>2</sup></div></div><div class="figure"><a id="rectangular_cylinder_colon_ixx_equals"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291710"/><img src="httpatomoreillycomsourceoreillyimages1598874.png" alt="Rectangular cylinder: Ixx = (1/12) m(a2 + l2); Iyy = (1/12) m(b2 + l2); Izz = (1/12) m(a2 + b2)"/></div></div><div class="figure-title">Figure 1-5. Rectangular cylinder: I<sub>xx</sub> = (1/12)
      m(a<sup>2</sup> + l<sup>2</sup>);
      I<sub>yy</sub> = (1/12) m(b<sup>2</sup> +
      l<sup>2</sup>); I<sub>zz</sub> = (1/12)
      m(a<sup>2</sup> + b<sup>2</sup>)</div></div><div class="figure"><a id="sphere_colon_ixx_equals_iyy_equals_izz"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291752"/><img src="httpatomoreillycomsourceoreillyimages1598875.png.jpg" alt="Sphere: Ixx = Iyy = Izz = (2/5) mr2"/></div></div><div class="figure-title">Figure 1-6. Sphere: I<sub>xx</sub> = I<sub>yy</sub> =
      I<sub>zz</sub> = (2/5)
      mr<sup>2</sup></div></div><div class="figure"><a id="spherical_shell_colon_ixx_equals_iyy_equ"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291794"/><img src="httpatomoreillycomsourceoreillyimages1598876.png.jpg" alt="Spherical shell: Ixx = Iyy = Izz = (2/3) mr2"/></div></div><div class="figure-title">Figure 1-7. Spherical shell: I<sub>xx</sub> =
      I<sub>yy</sub> = I<sub>zz</sub> = (2/3)
      mr<sup>2</sup></div></div><p>As you can see,<a id="I_indexterm1_id291815" class="indexterm"/><a id="I_indexterm1_id291825" class="indexterm"/> these formulas are relatively simple to implement. The
    trick here is to break up a complex body into a number of smaller, simpler
    representative geometries whose combination will approximate the complex
    body’s inertia properties. This exercise is largely a matter of judgment
    considering the desired level of <a id="I_indexterm1_id291835" class="indexterm"/><a id="I_indexterm1_id291844" class="indexterm"/><a id="I_indexterm1_id291853" class="indexterm"/>accuracy.</p><p>Let’s look at a simple 2D example <a id="mp1.6" class="indexterm"/>demonstrating how to apply the formulas discussed in this
    section. Suppose you’re working on a top-down-view auto racing game where
    you want to simulate the automobile sprite based on 2D rigid-body
    dynamics. At the start of the game, the player’s car is at the starting
    line, full of fuel and ready to go. Before starting the simulation, you
    need to calculate the mass properties of the car, driver, and fuel load at
    this initial state. In this case, the <span class="emphasis"><em>body</em></span> is made up
    of three components: the car, driver, and full load of fuel. Later during
    the game, however, the mass of this body will change as fuel burns off and
    the driver gets thrown after a crash! For now, let’s focus on the initial
    condition, as illustrated in <a class="xref" href="ch01.html#example_body_consisting_of_car_comma_dri" title="Figure 1-8. Example body consisting of car, driver, and fuel">Figure 1-8</a>.</p><div class="figure"><a id="example_body_consisting_of_car_comma_dri"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id291912"/><img src="httpatomoreillycomsourceoreillyimages1598877.png" alt="Example body consisting of car, driver, and fuel"/></div></div><div class="figure-title">Figure 1-8. Example body consisting of car, driver, and fuel</div></div><p>The properties of each component in this example are given in <a class="xref" href="ch01.html#example_properties" title="Table 1-2. Example properties">Table 1-2</a>. Note that length is measured along the
    x-axis, width along the y-axis, and height would be coming out of the
    screen. Also note that the coordinates—in the form
    (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>)—to the centroid of each
    component are referenced to the global origin.</p><div class="table"><a id="example_properties"/><div class="table-title">Table 1-2. Example properties</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Car</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Driver
            (seated)</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Fuel</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length = 4.70
            m</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length = 0.90
            m</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Length = 0.50
            m</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Width = 1.80
            m</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Width = 0.50
            m</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Width = 0.90
            m</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Height = 1.25
            m</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Height = 1.10
            m</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Height = 0.30
            m</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Weight = 17,500
            N</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Weight = 850
            N</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Density of fuel = 750
            kg/m<sup>3</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Centroid = (30.5, 30.5)
            m</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Centroid = (31.50, 31.00)
            m</p></td><td style="text-align: left; vertical-align: top; "><p>Centroid = (28.00, 30.50)
            m</p></td></tr></tbody></table></div></div><p>The first mass property we want to <a id="I_indexterm1_id292196" class="indexterm"/>calculate is the mass of the body. This is a simple
    calculation since we are already given the weight of the car and the
    driver. The only other component of weight we need is that of the fuel.
    Since we are given the mass density of the fuel and the geometry of the
    tank, we can calculate the volume of the tank and multiply by the density
    and the acceleration due to gravity to get the weight of the fuel in the
    tank. This yields 920.6 N of fuel, as shown here:</p><table style="border: 0; " class="simplelist"><tr><td>W<sub>fuel</sub> = ρvg = (750
      kg/m<sup>3</sup>) (0.50 m) (0.90 m) (0.30 m) (9.81
      m/s<sup>2</sup>) = 993 N</td></tr></table><div class="note" title="Note"><h3 class="title">Note</h3><p>Acceleration due to gravity is the acceleration of a falling
      object as it falls toward the earth. The weight of an object is equal to
      its mass times the acceleration due to gravity. The symbol
      <span class="emphasis"><em>g</em></span> is used to represent the acceleration due to
      gravity, and on Earth the value of <span class="emphasis"><em>g</em></span> is
      approximately 9.8 m/s<sup>2</sup> at sea level. Units
      for weight in the metric system are Newtons,
      <span class="emphasis"><em>N</em></span>.</p></div><p>Now, the total weight of the body is:</p><table style="border: 0; " class="simplelist"><tr><td>W<sub>total</sub> = W<sub>car</sub> +
      W<sub>driver</sub> + W<sub>fuel</sub></td></tr><tr><td>W<sub>total</sub> = 17,500 N + 850 N + 993 N =
      19,343 N</td></tr></table><p>To get the mass of the body, you simply divide the weight by the
    acceleration due to gravity.</p><table style="border: 0; " class="simplelist"><tr><td>M<sub>total</sub> = W<sub>total/</sub>g
      = 19,343 N /(9.81 m/s<sup>2</sup>) = 1972 kg</td></tr></table><p>The next mass property we want is the location of the <a id="I_indexterm1_id292322" class="indexterm"/>center of gravity of the body. In this example we will calculate the centroid
      relative to the global origin. We will also apply the first moment formula twice, once for the
        <span class="emphasis"><em>x</em></span> coordinate and again for the <span class="emphasis"><em>y</em></span>
      coordinate:</p><table style="border: 0; " class="simplelist"><tr><td>X<sub>cg</sub> <sub>body</sub> =
      {(x<sub>cg car</sub>)(W<sub>car</sub>) +
      (x<sub>cg driver</sub>)(W<sub>driver</sub>) +
      (x<sub>cg fuel</sub>)(W<sub>fuel</sub>)} /
      W<sub>total</sub></td></tr><tr><td>X<sub>cg body</sub> = {(30.50 m)(17,500 N) + (31.50
      m)(850 N) + (28.00 m)(993 N)} / 19,343 N</td></tr><tr><td>X<sub>cg</sub> <sub>body</sub> = 30.42
      m</td></tr><tr><td>Y<sub>cg</sub> <sub>body</sub> =
      {(y<sub>cg car</sub>)(W<sub>car</sub>) +
      (y<sub>cg driver</sub>)(W<sub>driver</sub>) +
      (y<sub>cg fuel</sub>)(W<sub>fuel</sub>)} /
      W<sub>total</sub></td></tr><tr><td>Y<sub>cg body</sub> = {(30.50 m)(17,500 N) + (31.00
      m)(850 N) + (30.50 m)(993 N)} / 19,343 N</td></tr><tr><td>Y<sub>cg</sub> <sub>body</sub> = 30.52
      m</td></tr></table><p>Notice that we used weight in these equations instead of mass.
    Remember we can do this because the acceleration due to gravity built into
    the weight value is constant and appears in both the numerator and
    denominator, thus canceling out.</p><p>Now it’s time to calculate the <a id="mmi1.6" class="indexterm"/><a id="mi1.6" class="indexterm"/>mass moment of inertia of the body. This is easy enough in
    this 2D example since we have only one rotational axis, coming out of the
    paper, and thus need only perform the calculation once. The first step is
    to calculate the local moment of inertia of each component about its own
    neutral axis. Given the limited information we have on the geometry and
    mass distribution of each component, we will make a simplifying
    approximation by assuming that each component can be represented by a
    rectangular cylinder, and will thus use the corresponding formula for
    moment of inertia from <a class="xref" href="ch01.html#rectangular_cylinder_colon_ixx_equals" title="Figure 1-5. Rectangular cylinder: Ixx = (1/12) m(a2 + l2); Iyy = (1/12) m(b2 + l2); Izz = (1/12) m(a2 + b2)">Figure 1-5</a>. In the equations to
    follow, we’ll use a lowercase <span class="emphasis"><em>w</em></span> to represent width so
    as to not confuse it with weight, where we’ve been using a capital
    <span class="emphasis"><em>W</em></span>.</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>o car</sub> = (m/12)
      (w<sup>2</sup> + L<sup>2</sup>)</td></tr><tr><td>I<sub>o car</sub> = ((17,500 N / 9.81
      m/s<sup>2</sup>) / 12 ) ((1.80
      m)<sup>2</sup> + (4.70 m)<sup>2</sup>) =
      3765.5 N − s<sup>2</sup> − m</td></tr><tr><td>I<sub>o driver</sub> = (m/12)
      (w<sup>2</sup> + L<sup>2</sup>)</td></tr><tr><td>I<sub>o driver</sub> = ((850 N / 9.81
      m/s<sup>2</sup>) / 12) ((0.50
      m)<sup>2</sup> + (0.90 m)<sup>2</sup>) =
      7.7 N − s<sup>2</sup> − m</td></tr><tr><td>I<sub>o fuel</sub> = (m/12)
      (w<sup>2</sup> + L<sup>2</sup>)</td></tr><tr><td>I<sub>o fuel</sub> = ((993 N / 9.81
      m/s<sup>2</sup>) / 12) ((0.90
      m)<sup>2</sup> + (0.50 m)<sup>2</sup>) =
      8.9 N − s<sup>2</sup> − m</td></tr></table><p>Since these are the moments of inertia of each component about its
    own neutral axis, we now need to use the <a id="I_indexterm1_id292648" class="indexterm"/>parallel axis theorem to transfer these moments to the
    neutral axis of the body, which is located at the body center of gravity
    that we recently calculated. To do this, we must find the distance from
    the body center of gravity to each component’s center of gravity. The
    distances squared from each component to the body center of gravity
    are:</p><table style="border: 0; " class="simplelist"><tr><td>d<sup>2</sup><sub>car</sub> =
      (x<sub>cg car</sub> −
      X<sub>cg</sub>)<sup>2</sup> +
      (y<sub>cg car</sub> −
      Y<sub>cg</sub>)<sup>2</sup></td></tr><tr><td>d<sup>2</sup><sub>car</sub> = (30.50
      m − 30.42 m)<sup>2</sup> + (30.50 m − 30.53
      m)<sup>2</sup> = 0.01
      m<sup>2</sup></td></tr><tr><td>d<sup>2</sup><sub>driver</sub> =
      (x<sub>cg driver</sub> −
      X<sub>cg</sub>)<sup>2</sup> +
      (y<sub>cg driver</sub> −
      Y<sub>cg</sub>)<sup>2</sup></td></tr><tr><td>d<sup>2</sup><sub>driver</sub> =
      (31.50 m − 30.42 m)<sup>2</sup> + (31.25 m − 30.53
      m)<sup>2</sup> = 1.68
      m<sup>2</sup></td></tr><tr><td>d<sup>2</sup><sub>fuel</sub> =
      (x<sub>cg fuel</sub> −
      X<sub>cg</sub>)<sup>2</sup> +
      (y<sub>cg fuel</sub> −
      Y<sub>cg</sub>)<sup>2</sup></td></tr><tr><td>d<sup>2</sup><sub>fuel</sub> =
      (28.00 m − 30.42 m)<sup>2</sup> + (30.50 m − 30.53
      m)<sup>2</sup> = 5.86
      m<sup>2</sup></td></tr></table><p>Now we can apply the parallel axis theorem as follows:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>cg car</sub> = I<sub>o</sub> +
      md<sup>2</sup></td></tr><tr><td>I<sub>cg car</sub> = 3765.5 N −
      s<sup>2</sup> − m + (17,500 N / 9.81
      m/s<sup>2</sup>) (0.01 m<sup>2</sup>) =
      3783.34 N − s<sup>2</sup> − m</td></tr><tr><td>I<sub>cg driver</sub> = I<sub>o</sub> +
      md<sup>2</sup></td></tr><tr><td>I<sub>cg driver</sub> = 7.7 N −
      s<sup>2</sup> − m + (850 N / 9.81
      m/s<sup>2</sup>) (1.68 m<sup>2</sup>) =
      153.27 N − s<sup>2</sup> − m</td></tr><tr><td>I<sub>cg fuel</sub> = I<sub>o</sub> +
      md<sup>2</sup></td></tr><tr><td>I<sub>cg fuel</sub> = 8.9 N −
      s<sup>2</sup> − m + (993 N / 9.81
      m/s<sup>2</sup>) (5.86 m<sup>2</sup>) =
      602.07 N − s<sup>2</sup> − m</td></tr></table><p>Notice how the calculations for the
    <span class="emphasis"><em>I</em></span><sub>cg</sub> of the driver and the fuel
    are dominated by their <span class="emphasis"><em>md</em></span><sup>2</sup>
    terms. In this example, the local inertia of the driver and fuel is only
    2.7% and 2.1%, respectively, of their corresponding
    <span class="emphasis"><em>md</em></span><sup>2</sup> terms.</p><p>Finally, we can obtain the total moment of inertia of the body about
    its own neutral axis by summing the
    <span class="emphasis"><em>I</em></span><sub>cg</sub> contributions of each
    component as follows:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>cg total</sub> = I<sub>cg
      car</sub> + I<sub>cg driver</sub> + I<sub>cg
      fuel</sub></td></tr><tr><td>I<sub>cg total</sub> = 3783.34 N −
      s<sup>2</sup> − m + 153.27 N −
      s<sup>2</sup> − m + 602.07 N −
      s<sup>2</sup> − m = 4538.68 N −
      s<sup>2</sup> − m</td></tr></table><p>The mass properties of the body—that is, the combination of the car,
    driver, and full tank of fuel—are shown in <a class="xref" href="ch01.html#example_summary_of_mass_properties" title="Table 1-3. Example summary of mass properties">Table 1-3</a>.</p><div class="table"><a id="example_summary_of_mass_properties"/><div class="table-title">Table 1-3. Example summary of mass properties</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Property</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Computed
            value</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Total mass
            (weight)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1972 kg (19,343
            N)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Combined center of mass
            location</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>)
            = (30.42 m, 30.53 m)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Mass moment of
            inertia</p></td><td style="text-align: left; vertical-align: top; "><p>4538.68 N –
            s<sup>2</sup> – m</p></td></tr></tbody></table></div></div><p>It is important that you understand the concepts illustrated in this example well because
      as we move on to more complicated systems and especially to general motion in 3D, these
      calculations are only going to get more complicated. Moreover, the motion of the bodies to be
      simulated are functions of these mass properties, where mass will determine how these bodies
      are affected by forces, center of mass will be used to track position, and mass moment of
      inertia will determine how these bodies rotate under the action of noncentroidal
      forces.</p><p>So far, we have looked at moments of inertia about the three coordinate axes in 3D space.
      However, in general 3D rigid-body dynamics, the body may rotate about any axis—not necessarily
      one of the coordinate axes, even if the local coordinate axes pass through the body center of
      mass. This complication implies that we must add a few more terms to our set of
        <span class="emphasis"><em>I</em></span>’s for a body to handle this generalized rotation. We will address
      this topic further later in this chapter, but before we do that we need to go over Newton’s
      second law of motion in <a id="I_indexterm1_id293188" class="indexterm"/><a id="I_indexterm1_id293197" class="indexterm"/><a id="I_indexterm1_id293207" class="indexterm"/>detail.</p></div><div class="sect1" title="Newton’s Second Law of Motion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="newtonas_second_law_of_motion">Newton’s Second Law of Motion</h2></div></div></div><p>As we stated in the first <a id="ne1.7" class="indexterm"/>section of this chapter, Newton’s second law of motion is of particular interest
      in the study of mechanics. Recall that the equation form of Newton’s second law is:</p><table style="border: 0; " class="simplelist"><tr><td>F = ma</td></tr></table><p>where <span class="emphasis"><em>F</em></span> is the resultant <a id="I_indexterm1_id293266" class="indexterm"/>force acting on the body, <span class="emphasis"><em>m</em></span> is the
    <a id="I_indexterm1_id293281" class="indexterm"/>mass of the body, and <span class="emphasis"><em>a</em></span> is the
    <a id="I_indexterm1_id293296" class="indexterm"/><a id="I_indexterm1_id293306" class="indexterm"/>linear acceleration of the body center of gravity.</p><p>If you rearrange this equation as follows:</p><table style="border: 0; " class="simplelist"><tr><td>F/m = a</td></tr></table><p>you can see how the mass of a body acts as a measure of resistance
    to motion. Observe here that as mass increases in the denominator for a
    constant applied force, then the resulting acceleration of the body will
    decrease. You could say that the body of greater mass offers greater
    resistance to motion. Similarly, as the mass decreases for a constant
    applied force, then the resulting acceleration of the body will increase,
    and you could say that the body of smaller mass offers lower resistance to
    motion.</p><p>Newton’s second law also states that the resulting acceleration is
    in the same <a id="I_indexterm1_id293342" class="indexterm"/>direction as the resultant force on the body; thus, force
    and acceleration must be treated as vector quantities. In general, there
    may be more than one force acting on the body at a given time, which means
    that the resultant force is the vector sum of all forces acting on the
    body. So, you can now write:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>F</strong></span> = m<span class="strong"><strong>a</strong></span></td></tr></table><p>where <span class="strong"><strong>a</strong></span> represents the <a id="I_indexterm1_id293386" class="indexterm"/><a id="I_indexterm1_id293392" class="indexterm"/>acceleration vector.</p><p>In 3D, the force and acceleration vectors will have
    <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>
    components in the Cartesian reference system. In this case, the component
    equations of motion are written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>∑ F<sub>x</sub> =
      ma<sub>x</sub></td></tr><tr><td>∑ F<sub>y</sub> =
      ma<sub>y</sub></td></tr><tr><td>∑ F<sub>z</sub> =
      ma<sub>z</sub></td></tr></table><p>An alternative way to interpret Newton’s second law is that the sum
    of all forces acting on a body is equal to the rate of change of the
    body’s momentum over time, which is the derivative of momentum with
    respect to time. Momentum equals mass times velocity, and since velocity
    is a vector quantity, so is momentum. Thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>G</strong></span> = m<span class="strong"><strong>v</strong></span></td></tr></table><p>where <span class="strong"><strong>G</strong></span> is linear momentum of
    <a id="I_indexterm1_id293491" class="indexterm"/><a id="I_indexterm1_id293497" class="indexterm"/>the body, <span class="emphasis"><em>m</em></span> is the body’s mass, and
    <span class="strong"><strong>v</strong></span> is velocity of the center of gravity
    of the body. The time rate of change of momentum is the derivative of
    momentum with respect to time:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>G</strong></span>/dt = d/dt (m<span class="strong"><strong>v</strong></span>)</td></tr></table><p>Assuming that the body mass is constant (for now), you can
    write:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>G</strong></span>/dt = m d<span class="strong"><strong>v</strong></span>/dt</td></tr></table><p>Observing that the time rate of change of velocity, d<span class="strong"><strong>v</strong></span>/dt, is acceleration, we arrive at:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>G</strong></span>/dt = m<span class="strong"><strong>a</strong></span></td></tr></table><p>and:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>F</strong></span> = d<span class="strong"><strong>G</strong></span>/dt = m<span class="strong"><strong>a</strong></span></td></tr></table><p>So far we have considered only translation of the body without
    rotation. In generalized 3D motion, you must account for the rotational
    motion of the body and will thus need some additional equations to fully
    describe the body’s motion. Specifically, you will require analogous
    formulas relating the sum of all <a id="I_indexterm1_id293634" class="indexterm"/>moments (torque) on a body to the rate of change in its
    angular momentum over time, or the <a id="I_indexterm1_id293645" class="indexterm"/><a id="I_indexterm1_id293655" class="indexterm"/><a id="I_indexterm1_id293665" class="indexterm"/>derivative of angular momentum with respect to time. This
    gives us:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>M</strong></span><sub>cg</sub>
      = d/dt (<span class="strong"><strong>H</strong></span><sub>cg</sub>)</td></tr></table><p>where <span class="emphasis"><em>∑</em></span> <span class="strong"><strong>M</strong></span><sub>cg</sub> is the sum of all
    moments about the body center of gravity, and <span class="strong"><strong>H</strong></span> is the angular momentum of the body. <span class="strong"><strong>M</strong></span><sub>cg</sub> can be expressed
    as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M</strong></span><sub>cg</sub> =
      <span class="strong"><strong>r</strong></span> × <span class="strong"><strong>F</strong></span></td></tr></table><p>where <span class="strong"><strong>F</strong></span> is a force acting on the
    body, and <span class="strong"><strong>r</strong></span> is the distance vector from
    <span class="strong"><strong>F</strong></span>, perpendicular to the line of action
    of <span class="strong"><strong>F</strong></span> (i.e., perpendicular to the vector
    <span class="strong"><strong>F</strong></span>), to the center of gravity of the
    body, and × is the vector cross-product operator.</p><p>The angular momentum of the body is the sum of the moments of the
    momentum of all particles in the body about the axis of rotation, which in
    this case we assume passes through the center of gravity of the body. This
    can be expressed as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>H</strong></span><sub>cg</sub> =
      ∑ <span class="strong"><strong>r</strong></span><sub>i</sub> ×
      m<sub>i</sub> (<span class="strong"><strong>ω</strong></span> ×
      <span class="strong"><strong>r</strong></span><sub>i</sub>)</td></tr></table><p>where <span class="emphasis"><em>i</em></span> represents the <span class="emphasis"><em>i</em></span>th
    particle making up the body, ω is the angular velocity of the body about
    the axis under consideration, and (<span class="strong"><strong>r</strong></span><sub>i</sub> ×
    <span class="emphasis"><em>m</em></span><sub>i</sub> (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span><sub>i</sub>)) is the angular
    momentum of the <span class="emphasis"><em>i</em></span>th particle, which has a magnitude
    of
    <span class="emphasis"><em>m</em></span><sub>i</sub>ω<span class="emphasis"><em>r</em></span><sub>i</sub><sup>2</sup>.
    For rotation about a given axis, this equation can be rewritten in the
    form:</p><table style="border: 0; " class="simplelist"><tr><td>H<sub>cg</sub> = ∫ ω <span class="strong"><strong>r</strong></span><sup>2</sup> dm</td></tr></table><p>Given that the angular velocity is <a id="I_indexterm1_id293934" class="indexterm"/><a id="I_indexterm1_id293944" class="indexterm"/>the same for all particles making up the rigid body, we
    have:</p><table style="border: 0; " class="simplelist"><tr><td>H<sub>cg</sub> = ω ∫ <span class="strong"><strong>r</strong></span><sup>2</sup> dm</td></tr></table><p>and recalling that <a id="I_indexterm1_id293982" class="indexterm"/>moment of inertia, <span class="emphasis"><em>I</em></span>, equals
    <span class="emphasis"><em>∫</em></span> <span class="strong"><strong>r</strong></span><sup>2</sup>
    <span class="emphasis"><em>dm</em></span>, we get:</p><table style="border: 0; " class="simplelist"><tr><td>H<sub>cg</sub> = Iω</td></tr></table><p>Taking the derivative with respect to time, we obtain:</p><table style="border: 0; " class="simplelist"><tr><td>dH<sub>cg</sub>/dt = d/dt (Iω) = I dω/dt =
      Iα</td></tr></table><p>where <span class="emphasis"><em>α</em></span> is the angular acceleration of the body
    about a given axis.</p><p>Finally, we can write:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>M</strong></span><sub>cg</sub>
      = <span class="strong"><strong>I</strong></span>α</td></tr></table><p>As we stated in our discussion on mass moment of inertia, we will
    have to further generalize our formulas for moment of inertia and angular
    moment to account for rotation about any body axis. Generally, <span class="strong"><strong>M</strong></span> and <span class="emphasis"><em>α</em></span> will be <a id="I_indexterm1_id294096" class="indexterm"/><a id="I_indexterm1_id294106" class="indexterm"/><a id="I_indexterm1_id294116" class="indexterm"/><a id="I_indexterm1_id294125" class="indexterm"/>vector quantities, while <span class="strong"><strong>I</strong></span> will be a <span class="emphasis"><em>tensor</em></span><sup>[<a id="CHP-1-FN-2" href="#ftn.CHP-1-FN-2" epub:type="noteref" class="footnote">6</a>]</sup> since the magnitude of moment of inertia for a body may vary
    depending on the axis of rotation (see the sidebar <a class="xref" href="ch01.html#tensors" title="Tensors">Tensors</a>).</p><div class="sidebar"><a id="tensors"/><div class="sidebar-title">Tensors</div><p>A tensor is a <a id="I_indexterm1_id294180" class="indexterm"/>mathematical expression that has <a id="I_indexterm1_id294191" class="indexterm"/><a id="I_indexterm1_id294201" class="indexterm"/>magnitude and direction, but its magnitude may not be
      unique depending on the direction. Tensors are typically used to
      represent properties of materials where these properties have different
      magnitudes in different directions. Materials with properties that vary
      depending on direction are called <span class="emphasis"><em>anisotropic</em></span>
      <a id="I_indexterm1_id294218" class="indexterm"/>(<span class="emphasis"><em>isotropic</em></span> implies <a id="I_indexterm1_id294230" class="indexterm"/>the same magnitude in all directions). For example,
      consider the elasticity (or strength) of two common materials, a sheet
      of plain paper and a piece of woven or knitted cloth. Take the sheet of
      paper and, holding it flat, pull on it softly from opposing ends. Try
      this length-wise, width-wise, and along a diagonal. You should observe
      that the paper seems just as strong, or stretches about the same, in all
      directions. It is isotropic; therefore, only a single scalar constant is
      required to represent its strength for all directions.</p><p>Now, try to find a piece of cloth with a simple, relatively loose
      weave where the threads in one direction are perpendicular to the
      threads in the other direction. Most neckties will do. Try the same pull
      test that you conducted with the sheet of paper, pulling the cloth along
      each thread direction and then at a diagonal to the threads. You should
      observe that the cloth stretches more when you pull it along a diagonal
      to the threads as opposed to pulling it along the direction of the run
      of the threads. The cloth is anisotropic in that it exhibits different
      elastic (or strength) properties depending on the direction of pull;
      thus, a collection of vector quantities (a tensor) is required to
      represent its strength for all directions.</p><p>In the context of this book, the property under consideration is a
      body’s moment of inertia, which in 3D requires nine components to fully
      describe it for any arbitrary rotation. Moment of inertia is not a
      <a id="I_indexterm1_id294257" class="indexterm"/>strength property as in the paper and cloth example, but
      it is a property of the body that varies with the axis of rotation.
      Since nine components are required, moment of inertia will be
      generalized in the form of a 3×3 matrix (i.e., a
      <span class="emphasis"><em>second-rank</em></span> tensor) later in this book.</p></div><p>We need to mention a few things at this point regarding coordinates,
    which will become important when you’re writing your real-time simulator.
    Both of the equations of motion have, so far, been written in terms of
    global coordinates and not body-fixed coordinates. That’s OK for the
    linear equation of motion, where you can track the body’s location and
    velocity in the global coordinate system. However, from a computational
    point of view, you don’t want to do that for the angular equation of
    motion for bodies that rotate in three dimensions.<sup>[<a id="CHP-1-FN-3" href="#ftn.CHP-1-FN-3" epub:type="noteref" class="footnote">7</a>]</sup> The reason is because the moment of inertia term, when
    calculated with respect to global coordinates, actually changes depending
    on the body’s position and orientation. This means that during your
    simulation you’ll have to recalculate the inertia matrix (and its inverse)
    a lot, which is computationally inefficient. It’s better to rewrite the
    equations of motion in terms of local (attached to the body) coordinates
    so you have to calculate the inertia matrix (and its inverse) only once at
    the start of your simulation.</p><p>In general, the time <a id="I_indexterm1_id294304" class="indexterm"/>derivative of a vector, <span class="strong"><strong>V</strong></span>, in a fixed (nonrotating) coordinate system is
    related to its time derivative in a rotating coordinate system by the
    following:</p><table style="border: 0; " class="simplelist"><tr><td>(d<span class="strong"><strong>V</strong></span>/dt)<sub>fixed</sub> = (d<span class="strong"><strong>V</strong></span>/dt)<sub>rot</sub> + (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>V</strong></span>)</td></tr></table><p>The (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>V</strong></span>) term represents the difference between
    <span class="strong"><strong>V</strong></span>’s time derivative as measured in the
    fixed coordinate system and <span class="strong"><strong>V</strong></span>’s time
    derivative as measured in the rotating coordinate system. We can use this
    relation to rewrite the angular equation of motion in terms of local, or
    body-fixed, coordinates. Further, the vector to consider is the angular
    momentum vector <span class="strong"><strong>H</strong></span><sub>cg</sub>. Recall that <span class="strong"><strong>H</strong></span><sub>cg</sub> = <span class="strong"><strong>Iω</strong></span> and its time derivative are equal to the sum
    of moments about the body’s center of gravity. These are the pieces you
    need for the angular equation of motion, and you can get to that equation
    by substituting <span class="strong"><strong>H</strong></span><sub>cg</sub> in place of <span class="strong"><strong>V</strong></span> in the derivative transform relation as
    follows:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>M</strong></span><sub>cg</sub>
      = d<span class="strong"><strong>H</strong></span><sub>cg</sub>/dt
      <span class="strong"><strong>= I</strong></span> (d<span class="strong"><strong>ω</strong></span>/dt) + (<span class="strong"><strong>ω</strong></span> ×
      (<span class="strong"><strong>I ω</strong></span>))</td></tr></table><p>where the moments, inertia tensor, and angular velocity are all
    expressed in local (body) coordinates. Although this equation looks a bit
    more complicated than the one we showed you earlier, it is much more
    convenient to use since <span class="strong"><strong>I</strong></span> will be
    constant throughout your simulation (unless your body’s mass or geometry
    changes for some reason during your simulation), and the moments are
    relatively easy to calculate in local coordinates. You’ll put this
    equation to use in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a> when we show you how to
    develop a simple 3D rigid-body <a id="I_indexterm1_id294504" class="indexterm"/>simulator.</p></div><div class="sect1" title="Inertia Tensor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="inertia_tensor">Inertia Tensor</h2></div></div></div><p>Take another <a id="I_indexterm1_id294523" class="indexterm"/><a id="te1.8" class="indexterm"/>look at the angular equation of motion and notice that we
    set the inertia term, <span class="strong"><strong>I</strong></span>, in bold,
    implying that it is a vector. You’ve already seen that, for
    two-dimensional problems, this inertia term reduces to a scalar quantity
    representing the moment of inertia about the single axis of rotation.
    However, in three dimensions there are three coordinate axes about which
    the body can rotate. Moreover, in generalized three dimensions, the body
    can rotate about any arbitrary axis. Thus, for three-dimensional problems,
    <span class="strong"><strong>I</strong></span> is actually a 3×3 matrix—a
    second-rank tensor.</p><p>To understand where this inertia matrix comes from, you must look
    again at the <a id="I_indexterm1_id294568" class="indexterm"/><a id="I_indexterm1_id294579" class="indexterm"/><a id="I_indexterm1_id294589" class="indexterm"/>angular momentum equation:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>H</strong></span><sub>cg</sub> =
      ∫ (<span class="strong"><strong>r</strong></span> × (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>))
      dm</td></tr></table><p>where <span class="strong"><strong>ω</strong></span> is the angular velocity
    of the body; <span class="strong"><strong>r</strong></span> is the distance from the
    body’s center of gravity to each elemental mass, <span class="emphasis"><em>dm</em></span>;
    and (<span class="strong"><strong>r</strong></span> × (<span class="strong"><strong>ω</strong></span> <span class="emphasis"><em>×</em></span> <span class="strong"><strong>r</strong></span>))<span class="emphasis"><em>dm</em></span> is the angular
    momentum of each elemental mass. The term in parentheses is <a id="I_indexterm1_id294682" class="indexterm"/>called a <span class="emphasis"><em>triple vector product</em></span> and can
    be expanded by taking the vector cross products. <span class="strong"><strong>r</strong></span> and <span class="strong"><strong>ω</strong></span> are
    vectors that can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>r</strong></span> = x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span> + z
      <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>ω =</strong></span> ω<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + ω<sub>y</sub>
      <span class="strong"><strong>j</strong></span> + ω<sub>z</sub>
      <span class="strong"><strong>k</strong></span></td></tr></table><p>Expanding the triple vector product term yields:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>H</strong></span><sub>cg</sub> =
      ∫ {[(y<sup>2</sup> +
      z<sup>2</sup>)ω<sub>x</sub> −
      xyω<sub>y</sub> - xzω<sub>z</sub><span class="strong"><strong>] i +</strong></span></td></tr><tr><td>[ −yxω<sub>x</sub> + (z<sup>2</sup>
      + x<sup>2</sup>)ω<sub>y</sub> −
      yzω<sub>z</sub>] <span class="strong"><strong>j</strong></span>
      +</td></tr><tr><td>[−zxω<sub>x</sub> − zyω<sub>y</sub> +
      (x<sup>2</sup> + y<sup>2</sup>)ωz]
      <span class="strong"><strong>k</strong></span>} dm</td></tr></table><p>To simplify this equation, let’s replace a few terms by
    letting:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>xx</sub> = ∫ (y<sup>2</sup> +
      z<sup>2</sup>) dm</td></tr><tr><td>I<sub>yy</sub> = ∫ (z<sup>2</sup> +
      x<sup>2</sup>) dm</td></tr><tr><td>I<sub>zz</sub> = ∫ (x<sup>2</sup> +
      y<sup>2</sup>) dm</td></tr><tr><td>I<sub>xy</sub> = I<sub>yx</sub> = ∫ (xy)
      dm</td></tr><tr><td>I<sub>xz</sub> = I<sub>zx</sub> = ∫ (xz)
      dm</td></tr><tr><td>I<sub>yz</sub> = I<sub>zy</sub> = ∫ (yz)
      dm</td></tr></table><p>Substituting these <span class="emphasis"><em>I</em></span> variables, some of which
    should look familiar to you, back into the expanded equation
    yields:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>H</strong></span><sub>cg</sub> =
      [I<sub>xx</sub> ω<sub>x</sub> −
      I<sub>xy</sub> ω<sub>y</sub> −
      I<sub>xz</sub> ω<sub>z</sub>] <span class="strong"><strong>i</strong></span> +</td></tr><tr><td>[−I<sub>yx</sub> ω<sub>x</sub> +
      I<sub>yy</sub> ω<sub>y</sub> −
      I<sub>yz</sub> ω<sub>z</sub>] <span class="strong"><strong>j</strong></span> +</td></tr><tr><td>[−I<sub>zx</sub> ω<sub>x</sub> −
      I<sub>zy</sub> ω<sub>y</sub> +
      I<sub>zz</sub> ω<sub>z</sub>] <span class="strong"><strong>k</strong></span></td></tr></table><p>Simplifying this a step further by letting <span class="strong"><strong>I</strong></span> be a matrix:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>xx</sub> −I<sub>xy</sub>
      −I<sub>xz</sub></td></tr><tr><td><span class="strong"><strong>I</strong></span> =
      −I<sub>yx</sub> I<sub>yy</sub>
      −I<sub>yz</sub></td></tr><tr><td>−I<sub>zx</sub> −I<sub>zy</sub>
      I<sub>zz</sub></td></tr></table><p>yields the following equation:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>H</strong></span><sub>cg</sub> =
      <span class="strong"><strong>I ω</strong></span></td></tr></table><p>You already know that <span class="strong"><strong>I</strong></span>
    represents the moment of inertia, and the terms that should look familiar
    to you already are the moment of inertia terms about the three coordinate
    axes, <span class="emphasis"><em>I</em></span><sub>xx</sub>,
    <span class="emphasis"><em>I</em></span><sub>yy</sub>, and
    <span class="emphasis"><em>I</em></span><sub>zz</sub>. The other terms are
    <a id="I_indexterm1_id295202" class="indexterm"/><a id="I_indexterm1_id295212" class="indexterm"/>called <span class="emphasis"><em>products of inertia</em></span> (see <a class="xref" href="ch01.html#products_of_inertia" title="Figure 1-9. Products of inertia">Figure 1-9</a>):</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>xy</sub> = I<sub>yx</sub> = ∫ (xy)
      dm</td></tr><tr><td>I<sub>xz</sub> = I<sub>zx</sub> = ∫ (xz)
      dm</td></tr><tr><td>I<sub>yz</sub> = I<sub>zy</sub> = ∫ (yz)
      dm</td></tr></table><div class="figure"><a id="products_of_inertia"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id295278"/><img src="httpatomoreillycomsourceoreillyimages1598878.png" alt="Products of inertia"/></div></div><div class="figure-title">Figure 1-9. Products of inertia</div></div><p>Just like the parallel axis theorem, there’s a similar <a id="I_indexterm1_id295299" class="indexterm"/><a id="I_indexterm1_id295305" class="indexterm"/>transfer of axis formula that applies to products of
    inertia:</p><table style="border: 0; " class="simplelist"><tr><td>I<sub>xy</sub> = I<sub>o(xy)</sub> + m
      d<sub>x</sub> d<sub>y</sub></td></tr><tr><td>I<sub>xz</sub> = I<sub>o(xz)</sub> + m
      d<sub>x</sub> d<sub>z</sub></td></tr><tr><td>I<sub>yz</sub> = I<sub>o(yz)</sub> + m
      d<sub>y</sub> d<sub>z</sub></td></tr></table><p>where the <span class="emphasis"><em>I</em></span><sub>o</sub> terms
    represent the local products of inertia (that is, the products of inertia
    of the object about axes that pass through its own center of gravity),
    <span class="emphasis"><em>m</em></span> is the object’s mass, and the
    <span class="emphasis"><em>d</em></span> terms are the distances between the coordinate axes
    that pass through the object’s center of gravity and a parallel set of
    axes some distance away (see <a class="xref" href="ch01.html#transfer_of_axes" title="Figure 1-10. Transfer of axes">Figure 1-10</a>).</p><p>You’ll notice that we did not give you any product of inertia
      formulas for the simple shapes shown earlier in <a class="xref" href="ch01.html#circular_cylinder_colon_ixx_equals_iyy" title="Figure 1-3. Circular cylinder: Ixx = Iyy = (1/4) mr2 + (1/12) ml2; Izz = (1/2) mr2">Figure 1-3</a> through <a class="xref" href="ch01.html#spherical_shell_colon_ixx_equals_iyy_equ" title="Figure 1-7. Spherical shell: Ixx = Iyy = Izz = (2/3) mr2">Figure 1-7</a>. The reason is that
      the given moments of inertia were about the<a id="I_indexterm1_id295411" class="indexterm"/> <span class="emphasis"><em>principal axes</em></span> for these shapes. For
      any body, there exists a set of axes—called the principal axes—oriented
      such that the product of inertia terms in the inertia tensor are all
      zero.</p><div class="figure"><a id="transfer_of_axes"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id295437"/><img src="httpatomoreillycomsourceoreillyimages1598879.png" alt="Transfer of axes"/></div></div><div class="figure-title">Figure 1-10. Transfer of axes</div></div><p>For the simple geometries shown earlier, each coordinate axis
    represented a <a id="I_indexterm1_id295457" class="indexterm"/><a id="I_indexterm1_id295468" class="indexterm"/>plane of symmetry, and products of inertia go to zero about
    axes that represent planes of symmetry. You can see this by examining the
    product of inertia formulas, where, for example, all of the
    <span class="emphasis"><em>(xy)</em></span> terms in the integral will be cancelled out by
    each corresponding <span class="emphasis"><em>−(xy)</em></span> term if the body is
    symmetric about the y-axis, as illustrated in <a class="xref" href="ch01.html#symmetry" title="Figure 1-11. Symmetry">Figure 1-11</a>.</p><div class="figure"><a id="symmetry"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id295502"/><img src="httpatomoreillycomsourceoreillyimages1598880.png" alt="Symmetry"/></div></div><div class="figure-title">Figure 1-11. Symmetry</div></div><p>For composite bodies, however, there may not be any planes of
    symmetry, and the orientation of the principal axes will not be obvious.
    Further, you may not even want to use the principal axes as your local
    coordinate axes for a given rigid body since it may be awkward to do so.
    For example, consider the airplane from the <code class="literal">FlightSim</code> discussion in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>, where you’ll have the local coordinate
    design axes running, relative to the pilot, fore and aft, up and down, and
    left and right. This orientation is convenient for locating the parts of
    the wings, tail, elevators, etc. with respect to one another, but these
    axes don’t necessarily represent the principal axes of the airplane. The
    end result is that you’ll use axes that are convenient and deal with the
    nonzero products of inertia (which, by the way, can be either positive or
    negative).</p><p>We already showed you how to calculate the combined moments of
    inertia for a composite body made up of a few smaller elements. Accounting
    for the product of inertia terms follows the same procedure except that,
    typically, your elements are such that their local product of inertia
    terms are zero. This is the case only if you represent your elements by
    simple geometries such as point masses, spheres, rectangles, etc. That
    being the case, the main contribution to the rigid body’s products of
    inertia will be due to the transfer of axes terms for each element.</p><p>Before looking at some sample code, let’s first revise the element
    structure to include a new term to hold the element’s local <a id="I_indexterm1_id295553" class="indexterm"/>moment of inertia as follows:</p><a id="I_programlisting1_id295565"/><pre class="programlisting">typedef struct _PointMass
{
   float mass;
   Vector designPosition;
   Vector correctedPosition;
   Vector localInertia;
} PointMass;</pre><p>Here we’re using a vector to represent the three local moment of
    inertia terms and we’re also assuming that the local products of inertia
    are zero for each element.</p><p>The following code sample shows how to calculate the <a id="I_indexterm1_id295579" class="indexterm"/>inertia tensor given the component elements:</p><a id="I_programlisting1_id295592"/><pre class="programlisting">float   Ixx, Iyy, Izz, Ixy, Ixz, Iyz;
Matrix3x3 InertiaTensor;

Ixx = 0;  Iyy = 0;  Izz = 0;
Ixy = 0;  Ixz = 0;  Iyz = 0;

for (i = 0; i&lt;_NUMELEMENTS; i++)
{
   Ixx += Element[i].LocalInertia.x +
      Element[i].mass * (Element[i].correctedPosition.y *
      Element[i].correctedPosition.y +
      Element[i].correctedPosition.z *
      Element[i].correctedPosition.z);

   Iyy += Element[i].LocalInertia.y +
      Element[i].mass * (Element[i].correctedPosition.z *
      Element[i].correctedPosition.z +
      Element[i].correctedPosition.x *
      Element[i].correctedPosition.x);

   Izz += Element[i].LocalInertia.z +
      Element[i].mass * (Element[i].correctedPosition.x *
      Element[i].correctedPosition.x +
      Element[i].correctedPosition.y *
      Element[i].correctedPosition.y);

   Ixy += Element[i].mass * (Element[i].correctedPosition.x *
      Element[i].correctedPosition.y);

   Ixz += Element[i].mass * (Element[i].correctedPosition.x *
      Element[i].correctedPosition.z);

   Iyz += Element[i].mass * (Element[i].correctedPosition.y *
      Element[i].correctedPosition.z);
}

// e11 stands for element on row 1 column 1, e12 for row 1 column 2, etc.
InertiaTensor.e11 = Ixx;
InertiaTensor.e12 = -Ixy;
InertiaTensor.e13 = -Ixz;

InertiaTensor.e21 = -Ixy;
InertiaTensor.e22 = Iyy;
InertiaTensor.e23 = -Iyz;

InertiaTensor.e31 = -Ixz;
InertiaTensor.e32 = -Iyz;
InertiaTensor.e33 = Izz;</pre><p>Note that the inertia tensor is calculated about axes that pass
    through the combined center of gravity for the rigid body, so be sure to
    use the corrected coordinates for each element relative to the combined
    center of gravity when applying the transfer of axes formulas.</p><p>We should also mention that this calculation is for the inertia
    tensor in body-fixed coordinates, or local coordinates. As we discussed
    earlier in this chapter, it is better to rewrite the angular equation of
    motion in terms of local coordinates and use the local inertia tensor to
    save some number crunching in your real-time <a id="I_indexterm1_id295620" class="indexterm"/>simulation.</p></div><div class="sect1" title="Relativistic Time"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="relativistic_time">Relativistic Time</h2></div></div></div><p>To allow for a <a id="re1.9" class="indexterm"/><a id="ti1.9" class="indexterm"/>thorough understanding of how advanced space vehicles work
    as well as give you a mechanism by which to alter time in your games, we
    would like to offer a brief introduction to the theory of relativity, and
    particularly its effect on time. In our everyday experience, it is safe to
    assume that the clock on your wall is ticking at the same rate as the
    clock on our wall as we write this. However, the reason we all know the
    name <a id="I_indexterm1_id295675" class="indexterm"/>Albert Einstein is that he had the foresight to abandon time
    as a constant. Instead he postulated that <a id="sp1.9" class="indexterm"/><a id="li1.9" class="indexterm"/>light travels at the same speed regardless of the motion of
    the source.</p><p>That is to say, if you shine a flashlight in a vacuum, the electromagnetic radiation it
      emits in the form of visible light travels at a set velocity of <span class="emphasis"><em>c</em></span>
      (299,792,458 m/s). Now, if you take that same flashlight and put it on the nose of a rocket
      traveling at half that speed directly at you, you might expect that light is traveling at you
      with a velocity of 1.5<span class="emphasis"><em>c</em></span>. Yet, the rocket-powered flashlight would still
      be observed as emitting light at a velocity of <span class="emphasis"><em>c</em></span>. As Einstein’s theory of
      special relativity matured, the postulate has been reformulated to state that there is a
      maximum speed at which information can be transferred in the space-time continuum, a principal <a id="I_indexterm1_id295737" class="indexterm"/>called <span class="emphasis"><em>locality</em></span>. As electromagnetic radiation has <a id="I_indexterm1_id295748" class="indexterm"/>no mass,<sup>[<a id="CHP-1-FN-4" href="#ftn.CHP-1-FN-4" epub:type="noteref" class="footnote">8</a>]</sup> it travels at this maximum speed in a vacuum.</p><p>The most startling consequence of the theory is that time is no
    longer absolute. The postulate that the speed of light is constant for all
    frames of reference requires that time slow down, or
    <span class="emphasis"><em>dilate</em></span>, as velocity increases. It is actually fairly
    easy to demonstrate this result.</p><p>The following example depicts a conceptual clock. A beam of light is
    bouncing between two mirrors. The time it takes for the beam of light to
    start from one mirror, bounce off the second, and return to the first
    constitutes one “tick” of this clock. That tick can be calculated
    as:</p><table style="border: 0; " class="simplelist"><tr><td>Δt = 2L/c</td></tr></table><p>Where <span class="emphasis"><em>L</em></span> is the distance between the mirrors and
    <span class="emphasis"><em>c</em></span> is the speed of light. <a class="xref" href="ch01.html#traveling_with_the_clock" title="Figure 1-12. Traveling with the clock">Figure 1-12</a> shows what the clock would look like
    if you were above it traveling at its velocity.</p><div class="figure"><a id="traveling_with_the_clock"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id295820"/><img src="httpatomoreillycomsourceoreillyimages1598881.png" alt="Traveling with the clock"/></div></div><div class="figure-title">Figure 1-12. Traveling with the clock</div></div><p>Now suppose that you are above the mirrors as they speed past you to
    the right. Then the clock would look something like <a class="xref" href="ch01.html#stationary_with_respect_to_the_clock" title="Figure 1-13. Stationary with respect to the clock">Figure 1-13</a>.</p><div class="figure"><a id="stationary_with_respect_to_the_clock"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id295858"/><img src="httpatomoreillycomsourceoreillyimages1598882.png" alt="Stationary with respect to the clock"/></div></div><div class="figure-title">Figure 1-13. Stationary with respect to the clock</div></div><p>One tick of the clock is now defined as twice the distance of the
    hypotenuse over the speed of light. Clearly <span class="emphasis"><em>H</em></span> must be
    larger than <span class="emphasis"><em>L</em></span>, so we see that the clock with the
    relative velocity will take longer to tick than if you were moving with
    the clock.</p><p>If this isn’t clear, we can also come to the same conclusion a
    different way. If we define the speed of light as the amount of time it
    takes for the light beam to travel the distance between the mirrors
    divided by the time it took to travel that distance, we see that:</p><table style="border: 0; " class="simplelist"><tr><td>c = 2L/Δt</td></tr></table><p>but because the speed of light must be held constant in all frames
    of reference via locality, we also have:</p><table style="border: 0; " class="simplelist"><tr><td>c = 2H/Δt</td></tr></table><p>For the two preceding equations to be equivalent, Δt must be
    different for each system.</p><p>This means that if I were in a rocket moving at high velocity past you as you read this
      book, you would look at the clock on my rocket wall and see it ticking more slowly than your
      clock. Now, it may seem as though I would look out of my rocket and see your clock running
      fast, but in fact the opposite is true. I would consider myself at rest and you speeding past
      me such that I would say <span class="emphasis"><em>your</em></span> clock is running slowly. This may seem
      counterintuitive, but think of it in the same way as visual perspective. If you are at a great
      distance from me, then you appear to be small. That doesn’t imply that I would appear to be
      huge to you!</p><p>Now the amount of dilation for a given velocity
    <span class="emphasis"><em>v</em></span> is <a id="lo1.9" class="indexterm"/>given by the <span class="emphasis"><em>Lorentz
    transformation</em></span>:</p><table style="border: 0; " class="simplelist"><tr><td>Δt’ = γΔt</td></tr></table><p>where:</p><div class="informalequation"><div class="mediaobject"><img src="eq_0101.png" alt="Stationary with respect to the clock"/></div></div><p>is called <a id="I_indexterm1_id295985" class="indexterm"/>the <span class="emphasis"><em>Lorentz factor</em></span>.</p><p>For velocities approaching the speed of light, the effect of time
    dilation is dramatic. Imagine if you had a twin sister. She boards a
    spaceship and is accelerated to three-fourths the speed of light relative
    to you on Earth. Upon her return, according to her clock, 20 years have
    elapsed since she left. However, due to time dilation you will have aged
    30 years. While this seems paradoxical given that you both will have
    observed each other’s time as running slowly compared to your own, the
    paradox is resolved by the fact that special relativity claims only that
    inertial frames of reference are identical. For the spaceship to return to
    Earth, it must accelerate by changing directions or, in other words,
    become a noninertial frame of reference. Once the ship is no longer an
    inertial frame of reference, there will appear to be a jump in the
    stay-at-home twin’s age. Strange but true!</p><p>In addition to time dilation due to relative velocity, time also slows down in the
      presence of strong gravitational fields as a result of Einstein’s theory of general
      relativity. This sort of time dilation is not relative in the sense that if I were closer to a
      black hole than you, we’d both agree that my clock is ticking less often than yours. However,
      given that all physical processes would be slower, there is no way to establish which clock is
      “faster” and which is “slower.” It is all relative!</p><p>As some games require a way to speed up or slow down time, the
    applications of time dilation allow for a physical phenomenon to enable
    time manipulation. Imagine your character needing to be sent to the future
    to complete some task. That character could be put into a centrifuge and
    accelerated near the speed of light. Upon exiting the centrifuge, he would
    essentially have time-traveled into the future. However, if you plan to
    stay within the limits of physics, then it is a one-way trip: there is no
    way to reverse time in relativity! Additionally, if you would like to send
    a character to a nearby star, you can do so within the limits of physics
    as well. By accelerating a spaceship, a human being would be able to
    travel a great distance in a lifetime. In fact, with a constant
    acceleration of 9.8 m/s<sup>2</sup>, which would make the
    astronauts feel like they were on Earth, you could travel the entire
    visible galaxy. However, you would have essentially time-traveled billions
    of years into the future. We are sure that you can imagine any number of
    scenarios where such a mechanism might make your game more interesting
    while always remaining in the realm of the physically possible!</p><p>Now, besides those implications to games involving space flight or
    high-velocity travel, time dilation is also important to some surprising
    digital electronic applications. For instance, the Global Positioning
    System (GPS), described in detail in <a class="xref" href="ch22.html" title="Chapter 22. Gaming from One Place to Another">Chapter 22</a>, must take relativistic time
    dilation into account when calculating position. The satellite’s high
    speed slows the clock compared to your watch on Earth; however, being
    farther up the Earth’s gravity causes it to tick faster than a terrestrial
    clock. The specifics of this combined effect are discussed in <a class="xref" href="ch22.html" title="Chapter 22. Gaming from One Place to Another">Chapter 22</a>.</p><p>Another point you might find interesting is that it is now easy to see how the “you can’t
      travel faster than light” rule is a result of the theory of relativity. Should you accelerate
      such that your velocity, <span class="emphasis"><em>v</em></span>, is equal to <span class="emphasis"><em>c</em></span>, the
      Lorentz transformation attempts to divide by zero. For games where faster-than-light travel is
      a practical necessity, you will have to imagine a mechanism to prevent this but be able to
      break the rules with <a id="I_indexterm1_id296068" class="indexterm"/><a id="I_indexterm1_id296078" class="indexterm"/><a id="I_indexterm1_id296087" class="indexterm"/><a id="I_indexterm1_id296096" class="indexterm"/><a id="I_indexterm1_id296106" class="indexterm"/>style.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-1-FN-1"><p><sup>[<a href="#CHP-1-FN-1" class="para">5</a>] </sup><span class="emphasis"><em>Linear motion</em></span> refers to motion in space
        without regard to rotation; <span class="emphasis"><em>angular motion</em></span> refers
        specifically to the rotation of a body about any axis (the body may or
        may not be undergoing linear motion at the same time).</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-1-FN-2"><p><sup>[<a href="#CHP-1-FN-2" class="para">6</a>] </sup>In this case, <span class="strong"><strong>I</strong></span> will be a
        second-rank tensor, which is essentially a 3×3 matrix. A vector is
        actually a tensor of rank one, and a scalar is actually a tensor of
        rank zero.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-1-FN-3"><p><sup>[<a href="#CHP-1-FN-3" class="para">7</a>] </sup>In two dimensions, it’s OK to leave the angular equation of
        motion as it’s shown here since the moment of inertia term is simply a
        constant scalar quantity.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-1-FN-4"><p><sup>[<a href="#CHP-1-FN-4" class="para">8</a>] </sup>Photons, the particle form of electromagnetic radiation, can have relativistic mass
          but are hypothesized to have no “rest mass.” To avoid getting into quantum
          electrodynamics, here we’ll just consider them without mass.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 2. Kinematics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch01.html" title="Chapter 1. Basic Concepts"/><link rel="next" href="ch03.html" title="Chapter 3. Force"/></head><body><section class="chapter" title="Chapter 2. Kinematics" epub:type="chapter" id="kinematics"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Kinematics</h2></div></div></div><p>In this chapter we’ll explain the <a id="I_indexterm2_id296124" class="indexterm"/>fundamental aspects of the subject of kinematics.
  Specifically, we’ll explain the concepts of linear and angular displacement,
  velocity, and acceleration. We’ve prepared an example program for this
  chapter that shows you how to implement the kinematic equations for particle
  motion. After discussing particle motion, we go on to explain the specific
  aspects of rigid-body motion. This chapter, along with the next chapter on
  force, is prerequisite to understanding the subject of kinetics, which
  you’ll study in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>.</p><p>In the preface, we told you that kinematics is the study of the motion
  of bodies without regard to the forces acting on the body. Therefore, in
  kinematics, attention is focused on position, velocity, and acceleration of
  a body, how these properties are related, and how they change over
  time.</p><p>Here you’ll look at two types of bodies, particles and rigid bodies. A
  <a id="I_indexterm2_id296154" class="indexterm"/>rigid body is a system of particles that remain at fixed
  distances from one another with no relative translation or rotation among
  them. In other words, a rigid body does not change its shape as it moves—or
  any changes in its shape are so small or unimportant that they can safely be
  neglected. When you are considering a rigid body, its dimensions and
  <a id="I_indexterm2_id296169" class="indexterm"/>orientation are important, and you must account for both the
  body’s linear motion and its angular motion.</p><p>A particle, on <a id="I_indexterm2_id296184" class="indexterm"/>the other hand, is a body that has mass but whose dimensions
  are negligible or unimportant in the problem being investigated. For
  example, when considering the path of a projectile or a rocket over a great
  distance, you can safely ignore the body’s dimensions when analyzing its
  trajectory. When you are considering a particle, its linear motion is
  important, but the angular motion of the particle itself is not. Think of it
  this way: when looking at a particle, you are zooming way out to view the
  big picture, so to speak, as opposed to zooming in as you do when looking at
  the rotation of rigid bodies.</p><p>Whether you are looking at problems involving particles or rigid
  bodies, there are some important kinematic properties common to both. These
  are, of course, the object’s position, velocity, and acceleration. The next
  section discusses these properties in detail.</p><div class="sect1" title="Velocity and Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="velocity_and_acceleration">Velocity and Acceleration</h2></div></div></div><p>In general,<a id="ki2.1" class="indexterm"/><a id="ve2.1" class="indexterm"/><a id="vea2.1" class="indexterm"/><a id="ac2.1" class="indexterm"/><a id="I_indexterm2_id296283" class="indexterm"/> velocity is a vector quantity that has magnitude and
    direction. The magnitude of <a id="I_indexterm2_id296294" class="indexterm"/><a id="I_indexterm2_id296304" class="indexterm"/><a id="I_indexterm2_id296314" class="indexterm"/>velocity is speed. Speed is a familiar term—it’s how fast
    your speedometer says you’re going when driving your car down the highway.
    Formally, <a id="I_indexterm2_id296329" class="indexterm"/>speed is the rate of travel, or the ratio of <a id="I_indexterm2_id296340" class="indexterm"/><a id="I_indexterm2_id296350" class="indexterm"/>distance traveled to the time it took to travel that
    distance. In math terms, you can write:</p><table style="border: 0; " class="simplelist"><tr><td>v = Δs/Δt</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is speed, the magnitude of velocity
    <span class="strong"><strong>v</strong></span>, and Δ<span class="emphasis"><em>s</em></span> is
    distance traveled over the time interval Δ<span class="emphasis"><em>t</em></span>. Note
    that this relation reveals that the units for speed are composed of the
    basic dimension’s length divided by time, <span class="emphasis"><em>L/T</em></span>. Some
    common <a id="I_indexterm2_id296398" class="indexterm"/>units for speed are meters per second,
    <span class="emphasis"><em>m/s</em></span>; feet per second, <span class="emphasis"><em>ft/sec</em></span>;
    and miles per hour, <span class="emphasis"><em>mi/hr</em></span>.</p><p>Here’s a simple example (illustrated in <a class="xref" href="ch02.html#example_car_speed" title="Figure 2-1. Example car speed">Figure 2-1</a>): a car is driving down a straight road and
    passes marker one at time <span class="emphasis"><em>t</em></span><sub>1</sub>
    and marker two at time <span class="emphasis"><em>t</em></span><sub>2</sub>,
    where <span class="emphasis"><em>t</em></span><sub>1</sub> equals 0 seconds and
    <span class="emphasis"><em>t</em></span><sub>2</sub> equals 1.136 seconds. The
    distance between these two markers, <span class="emphasis"><em>s</em></span>, is 30 m.
    Calculate the <a id="I_indexterm2_id296458" class="indexterm"/>speed of the car.</p><div class="figure"><a id="example_car_speed"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id296480"/><img src="httpatomoreillycomsourceoreillyimages1598883.png" alt="Example car speed"/></div></div><div class="figure-title">Figure 2-1. Example car speed</div></div><p>You are given that <span class="emphasis"><em>s</em></span> equals 30 m; therefore,
    Δ<span class="emphasis"><em>s</em></span> equals 30 m and Δ<sub>t</sub> equals
    <span class="emphasis"><em>t</em></span><sub>2</sub> <span class="emphasis"><em>−
    t</em></span><sub>1</sub> or 1.136 seconds. The speed of the
    car over this distance is:</p><table style="border: 0; " class="simplelist"><tr><td>v = Δs/Δt = 30 m/1.136 sec = 26.4 m/sec</td></tr></table><p>which is approximately 60 mi/hr. This is a simple one-dimensional
    example, but it brings up an important point, which is that the speed just
    calculated is the average speed of the car over that distance. You don’t
    know anything at this point about the car’s acceleration, or whether or
    not it is traveling at a constant 60 mi/hr. It could very well be that the
    car was accelerating (or decelerating) over that 30 m distance.</p><p>To more precisely analyze the motion of the car in this example, you
    need to understand the concept <a id="I_indexterm2_id296551" class="indexterm"/><a id="I_indexterm2_id296560" class="indexterm"/>of <span class="emphasis"><em>instantaneous</em></span> velocity.
    Instantaneous velocity is the specific velocity at a given instant in
    time, not over a large time interval as in the car example. This means
    that you need to look at very small Δ<span class="emphasis"><em>t</em></span>’s. In math
    terms, you must consider the limit as Δ<span class="emphasis"><em>t</em></span> approaches
    0—that is, as Δ<span class="emphasis"><em>t</em></span> gets infinitesimally small. This is
    written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v = lim<sub>Δt→0</sub> (Δs/Δt)</td></tr></table><p>In differential terms, velocity is the derivative of displacement
    (change in position) with respect to time:</p><table style="border: 0; " class="simplelist"><tr><td>v = ds/dt</td></tr></table><p>You can rearrange this relationship and integrate over the intervals
    from <span class="emphasis"><em>s</em></span><sub>1</sub> to
    <span class="emphasis"><em>s</em></span><sub>2</sub> and
    <span class="emphasis"><em>t</em></span><sub>1</sub> to
    t<sub>2</sub>, as shown here:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds</td></tr><tr><td>∫<sub>(s1 to s2)</sub> ds = ∫<sub>(t1 to
      t2)</sub> v dt</td></tr><tr><td>s2 – s1 = Δs = ∫<sub>(t1 to t2)</sub> v dt</td></tr></table><p>This relation shows that displacement is the integral of velocity
    over time. This gives you a way of working back and forth between
    displacement and velocity.</p><p>Kinematics makes an important distinction between <a id="I_indexterm2_id296680" class="indexterm"/><a id="I_indexterm2_id296690" class="indexterm"/>displacement and distance traveled. In one dimension,
    displacement is the same as distance traveled; however, with vectors in
    space, displacement <a id="I_indexterm2_id296702" class="indexterm"/>is actually the vector from the initial position to the
    final position without regard to the path traveled, while displacement is
    the difference between the starting position coordinates and the ending
    position coordinates. Thus, you need to be careful when calculating
    average velocity given displacement if the path from the starting position
    to the final position is not a straight line. When Δ<span class="emphasis"><em>t</em></span>
    is very small (as it approaches 0), displacement and distance traveled are
    the <a id="I_indexterm2_id296721" class="indexterm"/>same.</p><p>Another important kinematic property is <a id="I_indexterm2_id296736" class="indexterm"/>acceleration, which should also be familiar to you.
    Referring to your driving experience, you know that acceleration is the
    rate at which you can increase your <a id="I_indexterm2_id296748" class="indexterm"/>speed. Your friend who boasts that his brand new XYZ 20II
    can go from 0 to 60 in 4.2 seconds is referring to acceleration.
    Specifically, he is referring to average acceleration.</p><p>Formally, average acceleration<a id="I_indexterm2_id296764" class="indexterm"/><a id="I_indexterm2_id296770" class="indexterm"/> is the rate of change in velocity, or
    Δ<span class="emphasis"><em>v</em></span> over Δ<span class="emphasis"><em>t</em></span>:</p><table style="border: 0; " class="simplelist"><tr><td>a = Δv/Δt</td></tr></table><p>Taking the limit as Δ<span class="emphasis"><em>t</em></span> goes to 0 gives
    <a id="I_indexterm2_id296806" class="indexterm"/><a id="I_indexterm2_id296813" class="indexterm"/>the instantaneous acceleration:</p><table style="border: 0; " class="simplelist"><tr><td>a = lim<sub>Δt→0</sub> Δv/Δt</td></tr><tr><td>a = dv/dt</td></tr></table><p>Thus, acceleration is the time rate of change in velocity, or, the
    derivative of velocity with respect to time.</p><p>Multiplying both sides by <span class="emphasis"><em>dt</em></span> and integrating
    yields:</p><table style="border: 0; " class="simplelist"><tr><td>dv = a dt</td></tr><tr><td>∫<sub>(v1 to v2)</sub> dv = ∫<sub>(t1 to
      t2)</sub> a dt</td></tr><tr><td>v2 – v1 = Δv = ∫<sub>(t1 to t2)</sub> a dt</td></tr></table><p>This relationship provides a means to work back and forth between
    velocity and acceleration.</p><p>Thus, the relationships between displacement, velocity, and
    acceleration are:</p><table style="border: 0; " class="simplelist"><tr><td>a = dv/dt =
      d<sup>2</sup>s/dt<sup>2</sup></td></tr></table><p>and:</p><table style="border: 0; " class="simplelist"><tr><td>v dv = a ds</td></tr></table><p>This is the kinematic differential equation of motion (see the
    sidebar <a class="xref" href="ch02.html#second_derivatives" title="Second Derivatives">Second Derivatives</a> for some helpful
    background). In the next few sections you’ll see some examples of the
    application of these equations for some common classes of problems in
    <a id="I_indexterm2_id296928" class="indexterm"/><a id="I_indexterm2_id296937" class="indexterm"/><a id="I_indexterm2_id296947" class="indexterm"/>kinematics.</p><div class="sidebar"><a id="second_derivatives"/><div class="sidebar-title">Second Derivatives</div><p>In <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>, we <a id="I_indexterm2_id296979" class="indexterm"/><a id="I_indexterm2_id296990" class="indexterm"/>explained that you need not worry about the use of
      derivatives and integrals in this book if you’re unfamiliar with
      calculus since we’ll show you how to implement the code to take care of
      them computationally. That still applies, but here we’ve introduced new
      notation:</p><table style="border: 0; " class="simplelist"><tr><td>d<sup>2</sup>s/dt<sup>2</sup></td></tr></table><p>which is an equation representing <a id="I_indexterm2_id297020" class="indexterm"/>acceleration as the <span class="emphasis"><em>second derivative</em></span>
      of distance traveled with respect to time. You can think of second
      derivatives as just two successive derivatives in the manner we
      explained in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>. In the case of distance
      traveled, <a id="I_indexterm2_id297041" class="indexterm"/><a id="I_indexterm2_id297051" class="indexterm"/>velocity, and acceleration, the first derivative of
      distance traveled with respect to time is velocity and the second
      derivative of distance traveled with respect to time is acceleration,
      which is the same as the first derivative of velocity with respect to
      time.</p></div></div><div class="sect1" title="Constant Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="constant_acceleration">Constant Acceleration</h2></div></div></div><p>One of the <a id="ki2.2" class="indexterm"/><a id="ac2.2" class="indexterm"/><a id="co2.2" class="indexterm"/>simplest classes of problems in kinematics involves constant
    acceleration. A good example of this sort of problem involves the
    acceleration due to gravity, <span class="emphasis"><em>g</em></span>, on objects moving
    relatively near the earth’s surface, where the gravitational acceleration
    is a constant 9.81 m/s<sup>2</sup>. Having constant
    acceleration makes integration over time relatively easy since you can
    pull the acceleration constant out of the integrand, leaving just
    <span class="emphasis"><em>dt</em></span>.</p><p>Integrating the relationship between velocity and acceleration
    described earlier when acceleration is constant yields the following
    equation for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>∫<sub>(v1 to v2)</sub> dv = ∫<sub>(t1 to
      t2)</sub> a dt</td></tr><tr><td>∫<sub>(v1 to v2)</sub> dv = a ∫<sub>(t1 to
      t2)</sub> dt</td></tr><tr><td>v<sub>2</sub> – v<sub>1</sub> = a
      ∫<sub>(t1 to t2)</sub> dt</td></tr><tr><td>v<sub>2</sub> – v<sub>1</sub> = a
      (t<sub>2</sub> − t<sub>1</sub>)</td></tr><tr><td>v<sub>2</sub> = a t<sub>2</sub> − a
      t<sub>1</sub> + v<sub>1</sub></td></tr></table><p>When <span class="emphasis"><em>t</em></span><sub>1</sub> equals 0, you
    can rewrite this equation in the following form:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = a t<sub>2</sub> +
      v<sub>1</sub></td></tr><tr><td>v<sub>2</sub> = v<sub>1</sub> + a
      t<sub>2</sub></td></tr></table><p>This simple equation allows you to calculate the <a id="I_indexterm2_id297267" class="indexterm"/><a id="I_indexterm2_id297277" class="indexterm"/>instantaneous velocity at any given time by knowing the
    elapsed time, the initial velocity, and the constant acceleration.</p><p>You can also derive an equation for velocity as a function of
    displacement instead of time by considering the kinematic differential
    equation of motion:</p><table style="border: 0; " class="simplelist"><tr><td>v dv = a ds</td></tr></table><p>Integrating both sides of this equation yields the following
    alternative function for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>∫<sub>(v1 to v2)</sub> v dv = a ∫<sub>(s1 to
      s2)</sub> ds</td></tr><tr><td>(v<sub>2</sub><sup>2</sup> −
      v<sub>1</sub><sup>2</sup>) / 2 = a
      (s<sub>2</sub> − s<sub>1</sub>)</td></tr><tr><td>v<sub>2</sub><sup>2</sup> = 2a
      (s<sub>2</sub> − s<sub>1</sub>) +
      v<sub>1</sub><sup>2</sup></td></tr></table><p>You can derive a similar formula for <a id="I_indexterm2_id297376" class="indexterm"/>displacement as a function of velocity, acceleration, and
    time by integrating the differential equation:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds</td></tr></table><p>with the formula derived earlier for instantaneous velocity:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = v<sub>1</sub> +
      at</td></tr></table><p>substituted for <span class="emphasis"><em>v</em></span>. Doing so yields the
    formula:</p><table style="border: 0; " class="simplelist"><tr><td>s<sub>2</sub> = s<sub>1</sub> +
      v<sub>1</sub> t + (a t<sup>2</sup>) /
      2</td></tr></table><p>In summary, the three preceding kinematic equations derived
    are:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = v<sub>1</sub> + a
      t<sub>2</sub></td></tr><tr><td>v<sub>2</sub><sup>2</sup> = 2a
      (s<sub>2</sub> − s<sub>1</sub>) +
      v<sub>1</sub><sup>2</sup></td></tr><tr><td>s<sub>2</sub> = s<sub>1</sub> +
      v<sub>1</sub> t + (a t<sup>2</sup>) /
      2</td></tr></table><p>Remember, these equations are valid only when acceleration is
    constant. Note that acceleration can be 0 or even negative in cases where
    the body is decelerating.</p><p>You can rearrange these equations by algebraically solving for
    different variables, and you can also derive other handy equations using
    the approach that we just demonstrated. For your convenience, we’ve
    provided some other useful kinematic equations for constant acceleration
    problems in <a class="xref" href="ch02.html#constant_acceleration_kinematic_formulas" title="Table 2-1. Constant acceleration kinematic formulas">Table 2-1</a>.</p><div class="table"><a id="constant_acceleration_kinematic_formulas"/><div class="table-title">Table 2-1. Constant acceleration kinematic formulas</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To find:</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Given
            these:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a =
            (v<sub>2</sub> – v<sub>1</sub>) /
            Δt</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a = (2 Δs – 2
            v<sub>1</sub> Δt) /
            (Δt)<sup>2</sup></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub>,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>a =
            (v<sub>2</sub><sup>2</sup> –
            v<sub>1</sub><sup>2</sup>) / (2
            Δs)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δs</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δs =
            (v<sub>2</sub><sup>2</sup> –
            v<sub>1</sub><sup>2</sup>) /
            (2a)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δs</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δs = (Δt / 2)
            (v<sub>1</sub> +
            v<sub>2</sub>)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =
            (v<sub>2</sub> – v<sub>1</sub>) /
            a</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>a,
            v<sub>1</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =</p>
              <span class="inlinemediaobject"><img src="inleq_0201.png" alt=""/></span>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub>,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Δt =(2Δs) /
            (v<sub>1</sub> +
            v<sub>2</sub>)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt, a,
            v<sub>2</sub></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub> =
            v<sub>2</sub> – aΔt</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Δt, a, Δs</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>1</sub> =
            Δs/Δt – (aΔt)/2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>v<sub>1</sub></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>a,
            v<sub>2</sub>, Δs</p></td><td style="text-align: left; vertical-align: top; "><p>v<sub>1</sub> = </p>
              <span class="inlinemediaobject"><img src="inleq_0202.png" alt=""/></span>
            </td></tr></tbody></table></div></div><p>In cases where acceleration is not constant, but is some function of
    time, velocity, or position, you can substitute the function for
    acceleration into the differential equations shown earlier to derive new
    equations for instantaneous velocity and displacement. The next section
    considers <a id="I_indexterm2_id298124" class="indexterm"/><a id="I_indexterm2_id298133" class="indexterm"/><a id="I_indexterm2_id298143" class="indexterm"/>such a problem.</p></div><div class="sect1" title="Nonconstant Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="nonconstant_acceleration">Nonconstant Acceleration</h2></div></div></div><p>A common <a id="I_indexterm2_id298165" class="indexterm"/><a id="I_indexterm2_id298175" class="indexterm"/><a id="I_indexterm2_id298181" class="indexterm"/>situation that arises in real-world problems is when drag
    forces act on a body in motion. Typically, drag forces are proportional to
    velocity squared. Recalling the equation of Newton’s second law of motion,
    <span class="emphasis"><em>F</em></span> = <span class="emphasis"><em>ma</em></span>, you can deduce that the
    acceleration induced by these <a id="I_indexterm2_id298201" class="indexterm"/>drag forces is also proportional to velocity squared</p><p>Later we’ll show you some techniques to calculate this sort of drag
    force, but for now let the functional form of drag-induced acceleration
    be:</p><table style="border: 0; " class="simplelist"><tr><td>a = –kv<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>k</em></span> is a constant and the negative sign
    indicates that this acceleration acts in the direction opposing the body’s
    velocity. Now substituting this formula for acceleration into the previous
    equation and then rearranging yields:</p><table style="border: 0; " class="simplelist"><tr><td>a = dv/dt</td></tr><tr><td>–kv<sup>2</sup> = dv/dt</td></tr><tr><td>–k dt = dv/v<sup>2</sup></td></tr></table><p>If you integrate the right side of this equation from
    <span class="emphasis"><em>v</em></span><sub>1</sub> to
    <span class="emphasis"><em>v</em></span><sub>2</sub> and the left side from 0 to
    <span class="emphasis"><em>t</em></span>, and then solve for
    <span class="emphasis"><em>v</em></span><sub>2</sub>, you’ll get this formula
    for the instantaneous velocity as a function of the initial velocity and
    time:</p><table style="border: 0; " class="simplelist"><tr><td>–k ∫<sub>(0 to t)</sub> dt = ∫<sub>(v1 to
      v2)</sub> (1/v<sup>2</sup>) dv</td></tr><tr><td>–k t = 1/v<sub>1</sub> –
      1/v<sub>2</sub></td></tr><tr><td>v<sub>2</sub> = v<sub>1</sub> / (1 +
      v<sub>1</sub>k t)</td></tr></table><p>If you substitute this equation for <span class="emphasis"><em>v</em></span> in the
    relation <span class="emphasis"><em>v</em></span> = <span class="emphasis"><em>ds/dt</em></span> and integrate
    again, you’ll end up with a new equation for displacement as a function of
    initial velocity and time; see the following procedure:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds; <span class="emphasis"><em>where</em></span> v =
      v<sub>1</sub> / (1 + v<sub>1</sub>k t)</td></tr><tr><td>∫<sub>(0 to t)</sub> v dt = ∫<sub>(s1 to
      s2)</sub> ds</td></tr><tr><td>∫<sub>(0 to t)</sub> [v<sub>1</sub> / (1
      + v<sub>1</sub>k t)] dt = ∫<sub>(s1 to s2)</sub>
      ds</td></tr><tr><td>ln(1 + v<sub>1</sub> k t) / k =
      s<sub>2</sub> – s<sub>1</sub></td></tr></table><p>If s<sub>1</sub> equals 0, then:</p><table style="border: 0; " class="simplelist"><tr><td>s = ln(1 + v<sub>1</sub> k t) / k</td></tr></table><p>Note that in this equation, <span class="emphasis"><em>ln</em></span> is the natural
    logarithm operator.</p><p>This example demonstrates the relative complexity of nonconstant
    acceleration problems versus constant acceleration problems. It’s a fairly
    simple example where you are able to derive closed-form equations for
    velocity and displacement. In practice, however, there may be several
    different types of forces acting on a given body in motion, which could
    make the expression for induced acceleration quite complicated. This
    complexity would render a closed-form solution like the preceding one
    impossible to obtain unless you impose some simplifying restrictions on
    the problem, forcing you to rely on other solution techniques like
    numerical integration. We’ll talk about this sort of problem in greater
    depth in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p></div><div class="sect1" title="2D Particle Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="d_particle_kinematics">2D Particle Kinematics</h2></div></div></div><p>When we are <a id="ki2.4" class="indexterm"/><a id="pa2.4" class="indexterm"/><a id="tw2.4" class="indexterm"/>considering motion in one dimension—that is, when the motion
    is restricted to a straight line—it is easy enough to directly apply the
    formulas derived earlier to determine instantaneous velocity,
    acceleration, and displacement. However, in two dimensions, with motion
    possible in any direction on a given plane, you must consider the
    kinematic properties of velocity, acceleration, and displacement as
    vectors.</p><p>Using rectangular coordinates in the standard <a id="I_indexterm2_id298532" class="indexterm"/><a id="I_indexterm2_id298544" class="indexterm"/>Cartesian coordinate system, you must account for the
    <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> components of
    displacement, velocity, and acceleration. Essentially, you can treat the
    <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> components separately
    and then superimpose these components to define the corresponding vector
    quantities.</p><p>To help keep track of these <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>y</em></span> components, let <span class="strong"><strong>i</strong></span> and <span class="strong"><strong>j</strong></span> be
    unit vectors in the x- and y-directions, respectively. Now you can write
    the kinematic property vectors in terms of their components as
    follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = v<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + v<sub>y</sub>
      <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = a<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + a<sub>y</sub>
      <span class="strong"><strong>j</strong></span></td></tr></table><p>If <span class="emphasis"><em>x</em></span> is the displacement in the x-direction and
    <span class="emphasis"><em>y</em></span> is the displacement in the y-direction, then the
    displacement vector is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> = x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span></td></tr></table><p>It follows that:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = d<span class="strong"><strong>s</strong></span>/dt = dx/dt <span class="strong"><strong>i</strong></span> + dy/dt <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = d<span class="strong"><strong>v</strong></span>/dt = d<sup>2</sup><span class="strong"><strong>s</strong></span>/dt<sup>2</sup> =
      d<sup>2</sup>x/dt<sup>2</sup> <span class="strong"><strong>i</strong></span> +
      d<sup>2</sup>y/dt<sup>2</sup> <span class="strong"><strong>j</strong></span></td></tr></table><p>Consider a simple example where you’re writing a <a id="sh2.4" class="indexterm"/>shooting game and you need to figure out the vertical drop
    in a fired bullet from its aim point to the point at which it actually
    hits the target. In this example, assume that there is no wind and no drag
    on the bullet as it flies through the air (we’ll deal with wind and drag
    on projectiles in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>). These assumptions
    reduce the problem to one of constant acceleration, which in this case is
    that due to gravity. It is this gravitational acceleration that is
    responsible for the drop in the bullet as it travels from the rifle to the
    target. <a class="xref" href="ch02.html#a_2d_kinematics_example_problem" title="Figure 2-2. A 2D kinematics example problem">Figure 2-2</a> illustrates the
    problem.</p><div class="figure"><a id="a_2d_kinematics_example_problem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id298826"/><img src="httpatomoreillycomsourceoreillyimages1598884.png" alt="A 2D kinematics example problem"/></div></div><div class="figure-title">Figure 2-2. A 2D kinematics example problem</div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>While we’re talking about guns and shooting here, we should point
      out that these techniques can be applied just as easily to simulating
      the flight of angry birds in <span class="emphasis"><em>Angry Birds</em></span> being shot
      from oversized slingshots, as in the very popular iPhone app. Heck, you
      can use these techniques to simulate flying monkeys, ballistic shoes, or
      coconuts being hurled at Navy combatants! This particle kinematic stuff
      is perfect for diversionary smartphone apps.</p></div><p>Let the origin of the 2D coordinate system be at the end of the
    rifle with the x-axis pointing toward the target and the y-axis pointing
    up. Positive displacements along the x-axis are toward the target, and
    positive displacements along the y-axis are upward. This implies that the
    gravitational acceleration will act in the negative y-direction.</p><p>Treating the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span>
    components separately allows you to break up the problem into small,
    easy-to-manage pieces. Looking at the <span class="emphasis"><em>x</em></span> component
    first, you know that the bullet will leave the rifle with an initial
    muzzle velocity <span class="emphasis"><em>v</em></span><sub>m</sub> in the
    x-direction, and since we are neglecting drag, this speed will be
    constant. Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>x</sub> = 0</td></tr><tr><td>v<sub>x</sub> = v<sub>m</sub></td></tr><tr><td>x = v<sub>x</sub> t = v<sub>m</sub>
      t</td></tr></table><p>Now looking at the <span class="emphasis"><em>y</em></span> component, you know that
    the initial speed in the y-direction, as the bullet leaves the rifle, is
    0, but the y-acceleration is <span class="emphasis"><em>–g</em></span> (due to gravity).
    Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>y</sub> = –g =
      dv<sub>y</sub>/dt</td></tr><tr><td>v<sub>y</sub> = a<sub>y</sub> t = –g
      t</td></tr><tr><td>y = (1/2) a<sub>y</sub>
      t<sup>2</sup> = –(1/2) g
      t<sup>2</sup></td></tr></table><p>The displacement, velocity, and acceleration vectors can now be
    written as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> =
      (v<sub>m</sub> t) <span class="strong"><strong>i</strong></span> –
      (1/2 g t<sup>2</sup>) <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> =
      (v<sub>m</sub>) <span class="strong"><strong>i</strong></span> – (g t)
      <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = – (g) <span class="strong"><strong>j</strong></span></td></tr></table><p>These equations give the instantaneous displacement, velocity, and
    acceleration for any given instant between the time the bullet leaves the
    rifle and the time it hits the target. The magnitudes of these vectors
    give the total displacement, velocity, and acceleration at a given time.
    For example:</p><div class="informalequation"><div class="mediaobject"><img src="eq_0203.png" alt="A 2D kinematics example problem"/></div></div><div class="informalequation"><div class="mediaobject"><img src="eq_0204.png" alt="A 2D kinematics example problem"/></div></div><div class="informalequation"><div class="mediaobject"><img src="eq_0205.png" alt="A 2D kinematics example problem"/></div></div><p>To calculate the bullet’s vertical drop at the instant the bullet
    hits the target, you must first calculate the time required to reach the
    target; then, you can use that time to calculate the
    <span class="emphasis"><em>y</em></span> component of displacement, which is the vertical
    drop. Here are the formulas to use:</p><table style="border: 0; " class="simplelist"><tr><td>t<sub>hit</sub> =
      x<sub>hit</sub>/v<sub>m</sub> =
      n/v<sub>m</sub></td></tr><tr><td>d = y<sub>hit</sub> = –(1/2) g
      (t<sub>hit</sub>)<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>n</em></span> is the distance from the rifle to the
    target and <span class="emphasis"><em>d</em></span> is the vertical drop of the bullet at
    the target.</p><p>If the distance to the target, <span class="emphasis"><em>n</em></span>, equals 500 m
    and the muzzle velocity, <span class="emphasis"><em>v</em></span><sub>m</sub>,
    equals 800 m/sec, then the equations for
    <span class="emphasis"><em>t</em></span><sub>hit</sub> and
    <span class="emphasis"><em>d</em></span> give:</p><table style="border: 0; " class="simplelist"><tr><td>t<sub>hit</sub> = 0.625 sec</td></tr><tr><td>d = 1.9 m</td></tr></table><p>These results tell you that in order to hit the intended target at
    that range, you’ll need to aim for a point about 2 m <a id="I_indexterm2_id299190" class="indexterm"/><a id="I_indexterm2_id299200" class="indexterm"/><a id="I_indexterm2_id299209" class="indexterm"/><a id="I_indexterm2_id299219" class="indexterm"/>above it.</p></div><div class="sect1" title="3D Particle Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="d_particle_kinematics-id1">3D Particle Kinematics</h2></div></div></div><p>Extending the <a id="ki2.5" class="indexterm"/><a id="I_indexterm2_id299257" class="indexterm"/><a id="pa2.5" class="indexterm"/>kinematic property vectors to three dimensions is not very
    difficult. It simply involves the addition of one more component to the
    vector representations shown in the previous section on 2D kinematics.
    Introducing <span class="strong"><strong>k</strong></span> as the unit vector in the
    z-direction, you can now write:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> = x <span class="strong"><strong>i</strong></span> + y <span class="strong"><strong>j</strong></span> + z
      <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> = d<span class="strong"><strong>s</strong></span>/dt = dx/dt <span class="strong"><strong>i</strong></span> + dy/dt <span class="strong"><strong>j</strong></span>
      + dz/dt <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> =
      d<sup>2</sup><span class="strong"><strong>s</strong></span>/dt<sup>2</sup> =
      d<sup>2</sup>x/dt<sup>2</sup> <span class="strong"><strong>i</strong></span> +
      d<sup>2</sup>y/dt<sup>2</sup> <span class="strong"><strong>j</strong></span> +
      d<sup>2</sup>z/dt<sup>2</sup> <span class="strong"><strong>k</strong></span></td></tr></table><p>Instead of treating two components separately and then superimposing
    them, you now treat three components separately and superimpose these.
    This is best illustrated by an example.</p><p>Suppose that instead of a hunting game, you’re now <a id="th2.5" class="indexterm"/><a id="sh2.5" class="indexterm"/>writing a game that involves the firing of a cannon from,
    say, a battleship to a target some distance away—for example, another ship
    or an inland target like a building. To add complexity to this activity
    for your user, you’ll want to give her control of several factors that
    affect the shell’s trajectory—namely, the firing angle of the cannon, both
    horizontal and vertical angles, and the muzzle velocity of the shell,
    which is controlled by the amount of powder packed behind the shell when
    it’s loaded into the cannon. The situation is set up in <a class="xref" href="ch02.html#a_3d_kinematics_example_problem" title="Figure 2-3. A 3D kinematics example problem">Figure 2-3</a>.</p><div class="figure"><a id="a_3d_kinematics_example_problem"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id299483"/><img src="httpatomoreillycomsourceoreillyimages1598885.png" alt="A 3D kinematics example problem"/></div></div><div class="figure-title">Figure 2-3. A 3D kinematics example problem</div></div><p>We’ll show you how to set up the kinematic equations for this
    problem by treating each vector component separately at first and then
    combining these components.</p><div class="sect2" title="X Components"><div class="titlepage"><div><div><h3 class="title" id="x_components">X Components</h3></div></div></div><p>The <span class="emphasis"><em>x</em></span> components <a id="th2.5.1" class="indexterm"/>here are similar to those in the previous section’s rifle
      example in that there is no drag force acting on the shell; thus, the
      <span class="emphasis"><em>x</em></span> component of acceleration is 0, which means that
      the <span class="emphasis"><em>x</em></span> component of velocity is constant and equal
      to the <span class="emphasis"><em>x</em></span> component of the muzzle velocity as the
      shell leaves the cannon. Note that since the cannon barrel may not be
      horizontal, you’ll have to compute the <span class="emphasis"><em>x</em></span> component
      of the muzzle velocity, which is a function of the <a id="di2.5.1" class="indexterm"/>direction in which the cannon is aimed.</p><p>The muzzle velocity vector is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>m</sub> =
        v<sub>mx</sub> <span class="strong"><strong>i</strong></span> +
        v<sub>my</sub> <span class="strong"><strong>j</strong></span> +
        v<sub>mz</sub> <span class="strong"><strong>k</strong></span></td></tr></table><p>and you are given only the direction of <span class="strong"><strong>v</strong></span><sub>m</sub> as determined by the
      direction in which the user points the cannon, and its magnitude as
      determined by the amount of powder the user packs into the cannon. To
      calculate the components of the muzzle velocity, you need to develop
      some equations for these components in terms of the direction angles of
      the cannon and the magnitude of the muzzle velocity.</p><p>You can use the direction cosines of a vector to determine the
      velocity components as follows:</p><table style="border: 0; " class="simplelist"><tr><td>cos θ<sub>x</sub> =
        v<sub>mx</sub>/v<sub>m</sub></td></tr><tr><td>cos θ<sub>y</sub> =
        v<sub>my</sub>/v<sub>m</sub></td></tr><tr><td>cox θ<sub>z</sub> =
        v<sub>mz</sub>/v<sub>m</sub></td></tr></table><p>Refer to <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a> for a description
      and <a id="I_indexterm2_id299703" class="indexterm"/><a id="I_indexterm2_id299709" class="indexterm"/>illustration of vector direction cosines.</p><p>Since the initial muzzle velocity vector direction is the same as
      the direction in which the cannon is aimed, you can treat the cannon as
      a vector with a magnitude of <span class="emphasis"><em>L</em></span>, its length, and
      pointing in a direction defined by the angles given in this problem.
      Using the cannon length, <span class="emphasis"><em>L</em></span>, and its components
      instead of muzzle velocity in the equations for direction cosines
      gives:</p><table style="border: 0; " class="simplelist"><tr><td>cos θ<sub>x</sub> =
        L<sub>x</sub>/L</td></tr><tr><td>cos θ<sub>y</sub> =
        L<sub>y</sub>/L</td></tr><tr><td>cos θ<sub>z</sub> =
        L<sub>z</sub>/L</td></tr></table><p>In this example, you are given the angles <span class="emphasis"><em>α</em></span>
      and <span class="emphasis"><em>γ</em></span> (see <a class="xref" href="ch02.html#cannon_orientation" title="Figure 2-4. Cannon orientation">Figure 2-4</a>)
      that define the <a id="I_indexterm2_id299787" class="indexterm"/>cannon orientation.</p><div class="figure"><a id="cannon_orientation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id299810"/><img src="httpatomoreillycomsourceoreillyimages1598886.png" alt="Cannon orientation"/></div></div><div class="figure-title">Figure 2-4. Cannon orientation</div></div><p>Using these angles, it follows that the projection,
      <span class="emphasis"><em>b</em></span>, of the cannon length, <span class="emphasis"><em>L</em></span>,
      onto the x-z plane is:</p><table style="border: 0; " class="simplelist"><tr><td>b = L cos(90° – α)</td></tr></table><p>and the components of the cannon length, <span class="emphasis"><em>L</em></span>,
      on each coordinate axis are:</p><table style="border: 0; " class="simplelist"><tr><td>Lx = b cos γ</td></tr><tr><td>Ly = L cos α</td></tr><tr><td>Lz = b sin γ</td></tr></table><p>Now that you have the information required to compute direction
      cosines, you can write equations for the initial muzzle velocity
      components as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>mx</sub> = v<sub>m</sub> cos
        θ<sub>x</sub></td></tr><tr><td>v<sub>my</sub> = v<sub>m</sub> cos
        θ<sub>y</sub></td></tr><tr><td>v<sub>mz</sub> = v<sub>m</sub> cos
        θ<sub>z</sub></td></tr></table><p>Finally, you can write the <span class="emphasis"><em>x</em></span> components of
      displacement, velocity, and acceleration as <a id="I_indexterm2_id299933" class="indexterm"/><a id="I_indexterm2_id299943" class="indexterm"/>follows:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>x</sub> = 0</td></tr><tr><td>v<sub>x</sub> = v<sub>mx</sub> =
        v<sub>m</sub> cos θ<sub>x</sub></td></tr><tr><td>x = v<sub>x</sub> t = (v<sub>m</sub>
        cos θ<sub>x</sub>) t</td></tr></table></div><div class="sect2" title="Y Components"><div class="titlepage"><div><div><h3 class="title" id="y_components">Y Components</h3></div></div></div><p>The <span class="emphasis"><em>y</em></span> components are <a id="I_indexterm2_id300012" class="indexterm"/>just like the previous rifle example, again with the
      exception here of the initial velocity in the y-direction:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>my</sub> = v<sub>m</sub> cos
        θ<sub>y</sub></td></tr></table><p>Thus:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>y</sub> = –g</td></tr><tr><td>v<sub>y</sub> = v<sub>my</sub> + a t =
        (v<sub>m</sub> cos θ<sub>y</sub>) – g
        t</td></tr></table><p>Before writing the equation for the <span class="emphasis"><em>y</em></span>
      component of displacement, you need to consider the elevation of the
      base of the cannon, plus the height of the end of the cannon barrel, in
      order to calculate the initial <span class="emphasis"><em>y</em></span> component of
      displacement when the shell leaves the cannon. Let
      <span class="emphasis"><em>y</em></span><sub>b</sub> be the elevation of the
      base of the cannon, and let <span class="emphasis"><em>L</em></span> be the length of the
      cannon barrel; then the initial <span class="emphasis"><em>y</em></span> component of
      displacement, <span class="emphasis"><em>y</em></span><sub>o</sub>, is:</p><table style="border: 0; " class="simplelist"><tr><td>y<sub>o</sub> = y<sub>b</sub> + L cos
        α</td></tr></table><p>Now you can write the equation for <span class="emphasis"><em>y</em></span>
      as:</p><table style="border: 0; " class="simplelist"><tr><td>y = y<sub>o</sub> + v<sub>my</sub> t +
        (1/2) a t<sup>2</sup></td></tr><tr><td>y = (y<sub>b</sub> + L cos α) +
        (v<sub>m</sub> cos θ<sub>y</sub>) t – (1/2) g
        t<sup>2</sup></td></tr></table></div><div class="sect2" title="Z Components"><div class="titlepage"><div><div><h3 class="title" id="z_components">Z Components</h3></div></div></div><p>The <span class="emphasis"><em>z</em></span> components <a id="I_indexterm2_id300194" class="indexterm"/>are largely analogous to the <span class="emphasis"><em>x</em></span>
      components and can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>z</sub> = 0</td></tr><tr><td>v<sub>z</sub> = v<sub>mz</sub> =
        v<sub>m</sub> cos θ<sub>z</sub></td></tr><tr><td>z = v<sub>z</sub> t = (v<sub>m</sub>
        cos θ<sub>z</sub>) t</td></tr></table></div><div class="sect2" title="The Vectors"><div class="titlepage"><div><div><h3 class="title" id="the_vectors">The Vectors</h3></div></div></div><p>With the components <a id="I_indexterm2_id300271" class="indexterm"/><a id="I_indexterm2_id300284" class="indexterm"/>all worked out, you can now combine them to form the
      vector for each kinematic property. Doing so for this example gives the
      displacement, velocity, and acceleration vectors shown here:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>s</strong></span> =
        [(v<sub>m</sub> cos θ<sub>x</sub>) t]
        <span class="strong"><strong>i</strong></span> + [(y<sub>b</sub> + L
        cos α) + (v<sub>m</sub> cos θ<sub>y</sub>) t –
        (1/2) g t<sup>2</sup>] <span class="strong"><strong>j</strong></span> + [(v<sub>m</sub> cos
        θ<sub>z</sub>) t ] <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span> =
        [v<sub>m</sub> cos θ<sub>x</sub> ] <span class="strong"><strong>i</strong></span> + [(v<sub>m</sub> cos
        θ<sub>y</sub>) – g t ] <span class="strong"><strong>j</strong></span> + [v<sub>m</sub> cos
        θ<sub>z</sub> ] <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>a</strong></span> = –g <span class="strong"><strong>j</strong></span></td></tr></table><p>Observe here that the displacement vector essentially gives the
      position of the shell’s center of mass at any given instant in time;
      thus, you can use this vector to plot the shell’s trajectory from the
      cannon to the target.</p></div><div class="sect2" title="Hitting the Target"><div class="titlepage"><div><div><h3 class="title" id="hitting_the_target">Hitting the Target</h3></div></div></div><p>Now that you have the <a id="th2.5.5" class="indexterm"/><a id="tr2.5.5" class="indexterm"/><a id="si2.5.5" class="indexterm"/><a id="pr2.5.5" class="indexterm"/>equations fully describing the shell’s trajectory, you
      need to consider the location of the target in order to determine when a
      direct hit occurs. To show you how to do this, we’ve prepared a sample
      program that implements these kinematic equations along with a simple
      bounding box collision detection method for checking whether or not the
      shell has struck the target. Basically, at each time step where we
      calculate the position of the shell after it has left the cannon, we
      check to see if this position falls within the bounding dimensions of
      the target object represented by a cube.</p><p>The sample program is set up such that you can change all of the
      variables in the simulation and view the effects of your changes. <a class="xref" href="ch02.html#cannon_sample_program_main_window" title="Figure 2-5. Cannon sample program main window">Figure 2-5</a> shows the main screen for
      the cannon example program, with the governing variables shown on the
      left. The upper illustration is a bird’s-eye view looking down on the
      cannon and the target, while the lower illustration is a profile (side)
      view.</p><div class="figure"><a id="cannon_sample_program_main_window"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id300534"/><img src="httpatomoreillycomsourceoreillyimages1598887.png" alt="Cannon sample program main window"/></div></div><div class="figure-title">Figure 2-5. Cannon sample program main window</div></div><p>You can change any of the variables shown on the main window and
      press the Fire button to see the resulting flight path of the shell. A
      message box will appear when you hit the target or when the shell hits
      the ground. The program is set up so you can repeatedly change the
      variables and press Fire to see the result without erasing the previous
      trial. This allows you to gauge how much you need to adjust each
      variable in order to hit the target. Press the Refresh button to redraw
      the views when they get too cluttered.</p><p><a class="xref" href="ch02.html#trial_shots_open_parenthesis_profile_vie" title="Figure 2-6. Trial shots (profile view)">Figure 2-6</a> shows
      a few trial shots that we made before finally hitting the target.</p><div class="figure"><a id="trial_shots_open_parenthesis_profile_vie"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id300579"/><img src="httpatomoreillycomsourceoreillyimages1598888.png" alt="Trial shots (profile view)"/></div></div><div class="figure-title">Figure 2-6. Trial shots (profile view)</div></div><p>The code for this example is really quite simple. Aside from the
      overhead of the window, controls, and illustrations setup, all of the
      action takes place when the Fire button is pressed. In pseudocode, the
      Fire button’s pressed event handler looks something like this:</p><a id="I_programlisting2_id300602"/><pre class="programlisting">    FIRE BUTTON PRESSED EVENT:

        Fetch and store user input values for global variables,
        Vm, Alpha, Gamma, L, Yb, X, Y, Z, Length, Width, Height...

        Initialize the time and status variables...
        <span class="strong"><strong>status = 0;</strong></span>
        <span class="strong"><strong>time = 0;</strong></span>

        Start stepping through time for the simulation
        until the target is hit, the shell hits
        the ground, or the simulation times out...

        <span class="strong"><strong>while(status == 0)</strong></span>
        <span class="strong"><strong>{</strong></span>
            <span class="strong"><strong>// do the next time step</strong></span>
            <span class="strong"><strong>status = DoSimulation();</strong></span>

            <span class="strong"><strong>Update the display...</strong></span>

        <span class="strong"><strong>}</strong></span>

        // Report results
        if (status == 1)
            Display DIRECT HIT message to the user...

        if (status == 2)
            Display MISSED TARGET message to the user...

        if (status == 3)
            Display SIMULATION TIMED OUT message to the user...</pre><p>The first task is to simply get the new values for the variables
      shown on the main window. After that, the program enters a <code class="literal">while</code> loop, stepping through increments of
      time and recalculating the position of the shell projectile using the
      formula for the displacement vector, <span class="strong"><strong>s</strong></span>, shown earlier. The shell position at the
      current time is calculated in the function <code class="literal">DoSimulation</code>. Immediately after calling
      <code class="literal">DoSimulation</code>, the program updates the
      illustrations on the main window, showing the shell’s trajectory.
      <code class="literal">DoSimulation</code> returns <code class="literal">0</code>, keeping the <code class="literal">while</code> loop going, if there has not yet been a
      collision or if the time has not yet reached the preset time-out
      value.</p><p>Once the <code class="literal">while</code> loop terminates
      by <code class="literal">DoSimulation</code> returning nonzero,
      the program checks the return value from this function call to see if a
      hit has occurred between the shell and the ground or the shell and the
      target. Just so the program does not get stuck in this <code class="literal">while</code> loop, <code class="literal">DoSimulation</code> will return a value of <code class="literal">3</code>, indicating that it is taking too
      long.</p><p>Now let’s look at what’s happing in the function <code class="literal">DoSimulation</code> (we’ve also included here the
      global variables that are used in <code class="literal">DoSimulation</code>).</p><a id="I_programlisting2_id300764"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Define a custom type to represent
// the three components of a 3D vector, where
// i represents the x component, j represents
// the y component, and k represents the z
// component
//---------------------------------------------------------------------------//
typedef struct TVectorTag
{
     double i;
     double j;
     double k;
} TVector;

//---------------------------------------------------------------------------//
// Now define the variables required for this simulation
//---------------------------------------------------------------------------//
double          Vm;    // Magnitude of muzzle velocity, m/s
double          Alpha; // Angle from y-axis (upward) to the cannon.
                       // When this angle is 0, the cannon is pointing
                       // straight up, when it is 90 degrees, the cannon
                       // is horizontal
double          Gamma; // Angle from x-axis, in the x-z plane to the cannon.
                       // When this angle is 0, the cannon is pointing in
                       // the positive x-direction, positive values of this angle
                       // are toward the positive z-axis
double          L;     // This is the length of the cannon, m
double          Yb;    // This is the base elevation of the cannon, m

double          X;     // The x-position of the center of the target, m
double          Y;     // The y-position of the center of the target, m
double          Z;     // The z-position of the center of the target, m
double          Length; // The length of the target measured along the x-axis, m
double          Width;  // The width of the target measured along the z-axis, m
double          Height; // The height of the target measure along the y-axis, m

TVector          s;     // The shell position (displacement) vector

double          time;   // The time from the instant the shell leaves
                        // the cannon, seconds
double          tInc;   // The time increment to use when stepping through
                        // the simulation, seconds

double          g;      // acceleration due to gravity, m/s^2

//-----------------------------------------------------------------------------//
// This function steps the simulation ahead in time. This is where the kinematic
// properties are calculated. The function will return 1 when the target is hit,
// and 2 when the shell hits the ground (x-z plane) before hitting the target;
// otherwise, the function returns 0.
//-----------------------------------------------------------------------------//
int    DoSimulation(void)
//-----------------------------------------------------------------------------//
{
    double    cosX;
    double    cosY;
    double    cosZ;
    double    xe, ze;
    double    b, Lx, Ly, Lz;
    double    tx1, tx2, ty1, ty2, tz1, tz2;

    // step to the next time in the simulation
    time+=tInc;

    // First calculate the direction cosines for the cannon orientation.
    // In a real game, you would not want to put this calculation in this
    // function since it is a waste of CPU time to calculate these values
    // at each time step as they never change during the sim. We only put them
     // here in this case so you can see all the calculation steps in a single
    // function.
    b = L * cos((90-Alpha) *3.14/180);  // projection of barrel onto x-z plane
    Lx = b * cos(Gamma * 3.14/180);    // x-component of barrel length
    Ly = L * cos(Alpha * 3.14/180);    // y-component of barrel length
    Lz = b  * sin(Gamma * 3.14/180);    // z-component of barrel length

    cosX = Lx/L;
    cosY = Ly/L;
    cosZ = Lz/L;

    // These are the x and z coordinates of the very end of the cannon barrel
    // we'll use these as the initial x and z displacements
    xe = L * cos((90-Alpha) *3.14/180) * cos(Gamma * 3.14/180);
    ze = L * cos((90-Alpha) *3.14/180) * sin(Gamma * 3.14/180);

    // Now we can calculate the position vector at this time
    s.i =     Vm * cosX * time + xe;
    s.j =     (Yb + L * cos(Alpha*3.14/180)) + (Vm * cosY * time) −
        (0.5 * g * time * time);
    s.k =     Vm * cosZ * time + ze;

    // Check for collision with target
    // Get extents (bounding coordinates) of the target
    tx1 = X - Length/2;
    tx2 = X + Length/2;
    ty1 = Y - Height/2;
    ty2 = Y + Height/2;
    tz1 = Z - Width/2;
    tz2 = Z + Width/2;

    // Now check to see if the shell has passed through the target
    // We're using a rudimentary collision detection scheme here where
    // we simply check to see if the shell's coordinates are within the
    // bounding box of the target. This works for demo purposes, but
    // a practical problem is that you may miss a collision if for a given
    // time step the shell's change in position is large enough to allow
    // it to "skip" over the target.
    // A better approach is to look at the previous time step's position data
    // and to check the line from the previous position to the current position
    // to see if that line intersects the target bounding box.
    if( (s.i &gt;= tx1 &amp;&amp; s.i &lt;= tx2) &amp;&amp;
        (s.j &gt;= ty1 &amp;&amp; s.j &lt;= ty2) &amp;&amp;
        (s.k &gt;= tz1 &amp;&amp; s.k &lt;= tz2) )
        return 1;

    // Check for collision with ground (x-z plane)
    if(s.j &lt;= 0)
        return 2;

    // Cut off the simulation if it's taking too long
    // This is so the program does not get stuck in the while loop
    if(time&gt;3600)
        return 3;

    return 0;
}</pre><p>We’ve commented the code so that you can readily see what’s going
      on. This function essentially does four things: 1) increments the time
      variable by the specified time increment, 2) calculates the initial
      muzzle velocity components in the x-, y-, and z-directions, 3)
      calculates the shell’s new position, and 4) checks for a collision with
      the target using a bounding box scheme or the ground.</p><p>Here’s the code that computes the shell’s position:</p><a id="I_programlisting2_id300827"/><pre class="programlisting">    // Now we can calculate the position vector at this time
    s.i =     Vm * cosX * time + xe;
    s.j =     (Yb + L * cos(Alpha*3.14/180)) + (Vm * cosY * time) −
        (0.5 * g * time * time);
    s.k =     Vm * cosZ * time + ze;</pre><p>This code calculates the three components of the displacement
      vector, <span class="strong"><strong>s</strong></span>, using the formulas that we
      gave you earlier. If you wanted to compute the velocity and acceleration
      vectors as well, just to see their values, you should do so in this
      section of the program. You can set up a couple of new global variables
      to represent the velocity and acceleration vectors, just as we did with
      the displacement vector, and apply the velocity and acceleration
      formulas that we gave you.</p><p>That’s all there is to it. It’s obvious by playing with this
      sample program that the shell’s trajectory is parabolic in shape, which
      is typical <span class="emphasis"><em>projectile motion</em></span>. We’ll take a more
      detailed look at this sort of motion in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>.</p><p>Even though we put a comment in the source code, we must reiterate
      a warning here regarding the collision detection scheme that we used in
      this example. Because we’re checking only the current position
      coordinate to see if it falls within the bounding dimensions of the
      target cube, we run the risk of skipping over the target if the change
      in position is too large for a given time step. A better approach would
      be to keep track of the shell’s previous position and check to see if
      the line connecting the previous position to the new one intersects the
      target <a id="I_indexterm2_id300870" class="indexterm"/><a id="I_indexterm2_id300880" class="indexterm"/><a id="I_indexterm2_id300889" class="indexterm"/><a id="I_indexterm2_id300899" class="indexterm"/><a id="I_indexterm2_id300908" class="indexterm"/><a id="I_indexterm2_id300917" class="indexterm"/><a id="I_indexterm2_id300927" class="indexterm"/><a id="I_indexterm2_id300936" class="indexterm"/>cube.</p></div></div><div class="sect1" title="Kinematic Particle Explosion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="kinematic_particle_explosion">Kinematic Particle Explosion</h2></div></div></div><p>At this <a id="ki2.6" class="indexterm"/><a id="ex2.6" class="indexterm"/><a id="pae2.6" class="indexterm"/><a id="pa2.6" class="indexterm"/><a id="pr2.6" class="indexterm"/>point you might be wondering how particle kinematics can
    help you create realistic game content unless you’re writing a game that
    involves shooting a gun or a cannon. If so, let us offer you a few ideas
    and then show you an example. Say you’re writing a football simulation
    game. You can use particle kinematics to model the <a id="I_indexterm2_id301035" class="indexterm"/><a id="I_indexterm2_id301046" class="indexterm"/><a id="I_indexterm2_id301056" class="indexterm"/><a id="I_indexterm2_id301062" class="indexterm"/><a id="I_indexterm2_id301072" class="indexterm"/>trajectory of the football after it’s thrown or kicked. You
    can also treat the wide receivers as particles when calculating whether or
    not they’ll be able to catch the thrown ball. In this scenario you’ll have
    two particles—the receiver and the ball—traveling independently, and
    you’ll have to calculate when a collision occurs between these two
    particles, indicating a catch (unless, of course, your player is all
    thumbs and fumbles the ball after it hits his hands). You can find similar
    applications for other sports-based games as well.</p><p>What about a 3D “shoot ’em up” game? How <a id="I_indexterm2_id301091" class="indexterm"/>could you use particle kinematics in this genre aside from
    bullets, cannons, grenades, and the like? Well, you could use particle
    kinematics to model your player when she jumps into the air, either from a
    run or from a standing position. For example, your player reaches the
    middle of a catwalk only to find a section missing, so you immediately
    back up a few paces to get a running head start before leaping into the
    air, hoping to clear the gap. This long-jump scenario is perfect for using
    particle kinematics. All you really need to do is define your player’s
    initial velocity, both speed and take-off angle, and then apply the vector
    formula for displacement to calculate whether or not the player makes the
    jump. You can also use the displacement formula to calculate the player’s
    trajectory so that you can move the player’s viewpoint accordingly, giving
    the illusion of leaping into the air. You may in fact already be using
    these principles to model this action in your games, or at least you’ve
    seen it done if you play games of this genre. If your player happens to
    fall short on the jump, you can use the formulas for velocity to calculate
    the player’s impact velocity when she hits the ground below. Based on this
    impact velocity, you can determine an appropriate amount of damage to
    deduct from the player’s health score, or if the velocity is over a
    certain threshold, you can say goodbye to your would-be adventurer!</p><p>Another use for simple particle kinematics is for certain <a id="I_indexterm2_id301118" class="indexterm"/>special effects like particle explosions. This sort of
    effect is quite simple to implement and really adds a sense of realism to
    explosion effects. The particles don’t just fly off in random,
    straight-line trajectories. Instead, they rise and fall under the
    influence of their initial velocity, angle, and the acceleration due to
    gravity, which gives the impression that the particles have mass.</p><p>So, let’s explore an example of a kinematic particle explosion. The
    code for this example is taken from the cannon example discussed
    previously, so a lot of it should look familiar to you. <a class="xref" href="ch02.html#particle_explosion_example_program" title="Figure 2-7. Particle explosion example program">Figure 2-7</a> shows this example
    program’s main window.</p><div class="figure"><a id="particle_explosion_example_program"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id301156"/><img src="httpatomoreillycomsourceoreillyimages1598889.png.jpg" alt="Particle explosion example program"/></div></div><div class="figure-title">Figure 2-7. Particle explosion example program</div></div><p>The explosion effect takes place in the large rectangular area on
    the right. While the black dots representing exploding particles are
    certainly static in the figure, we assure you they move in the most
    spectacular way during the simulation.</p><p>In the edit controls on the left, you specify an x- and y-position
    for the effect, along with the initial velocity of the particles (which is
    a measure of the explosion’s strength), a duration in milliseconds, a
    gravity factor, and finally an angle. The angle parameter can be any
    number between 0 and 360 degrees or 999. When you specify an angle in the
    range of 0 to 360 degrees, all the particles in the explosion will be
    launched generally in that direction. If you specify a value of 999, then
    all the particles will shoot off in random directions. The duration
    parameter is essentially the life of the effect. The particles will fade
    out as they approach that life.</p><p>The first thing you need to do for this example is set up some
    structures and global variables to represent the particle effect and the
    individual particles making up the effect along with the initial
    parameters describing the behavior of the effect as discussed in the
    previous paragraph. Here’s the code:</p><a id="I_programlisting2_id301195"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Define a custom type to represent each particle in the effect.
//---------------------------------------------------------------------------//
typedef     struct _TParticle
{
     float          x;           // x coordinate of the particle
     float          y;           // y coordinate of the particle
     float          vi;          // initial velocity
     float          angle;       // initial trajectory (direction)
     int            life;        // duration in milliseconds
     int            r;           // red component of particle's color
     int            g;           // green component of particle's color
     int            b;           // blue component of particle's color
     int            time;        // keeps track of the effect's time
     float          gravity;     // gravity factor
     BOOL           Active;      // indicates whether this particle
                                 // is active or dead
} TParticle;

#define     _MAXPARTICLES 50

typedef struct _TParticleExplosion
{
     TParticle     p[_MAXPARTICLES];  // list of particles
                                      // making up this effect
     int           V0; // initial velocity, or strength, of the effect
     int           x;  // initial x location
     int           y;  // initial y location
     BOOL          Active;      // indicates whether this effect is
                                //active or dead
} TParticleExplosion;

//---------------------------------------------------------------------------//
// Now define the variables required for this simulation
//---------------------------------------------------------------------------//
TParticleExplosion     Explosion;

int                      xc;         // x coordinate of the effect
int                      yc;         // y coordinate of the effect
int                      V0;         // initial velocity
int                      Duration;   // life in milliseconds
float                    Gravity;    // gravity factor (acceleration)
float                    Angle;      // indicates particles' direction</pre><p>You can see from this code that the particle explosion effect is
    made up of a collection of particles. The behavior of each particle is
    determined by kinematics and the initial parameters set for each
    particle.</p><p>Whenever you press the Go button, the initial parameters that you
    specified are used to initialize the particle explosion (if you press the
    Random button, the program randomly selects these initial values for you).
    This takes place in the function called <code class="literal">CreateParticleExplosion</code>:</p><a id="I_programlisting2_id301235"/><pre class="programlisting">/////////////////////////////////////////////////////////////////////
/*     This function creates a new particle explosion effect.

     x,y:      starting point of the effect
     Vinit:    a measure of how fast the particles will be sent flying
               (it's actually the initial velocity of the particles)
     life:     life of the particles in milliseconds; particles will
               fade and die out as they approach
               their specified life
     gravity:  the acceleration due to gravity, which controls the
               rate at which particles will fall
               as they fly
     angle:    initial trajectory angle of the particles,
               specify 999 to create a particle explosion
               that emits particles in all directions; otherwise,
               0 right, 90 up, 180 left, etc...
*/
void CreateParticleExplosion(int x, int y, int Vinit, int life,
                             float gravity, float angle)
{
     int   i;
     int   m;
     float f;

     Explosion.Active = TRUE;
     Explosion.x = x;
     Explosion.y = y;
     Explosion.V0 = Vinit;

     for(i=0; i&lt;_MAXPARTICLES; i++)
     {
          Explosion.p[i].x = 0;
          Explosion.p[i].y = 0;
          Explosion.p[i].vi = tb_Rnd(Vinit/2, Vinit);

          if(angle &lt; 999)
          {
               if(tb_Rnd(0,1) == 0)
                    m = −1;
               else
                    m = 1;
               Explosion.p[i].angle = -angle + m * tb_Rnd(0,10);
          } else
               Explosion.p[i].angle = tb_Rnd(0,360);

          f = (float) tb_Rnd(80, 100) / 100.0f;
          Explosion.p[i].life = tb_Round(life * f);
          Explosion.p[i].r = 255;//tb_Rnd(225, 255);
          Explosion.p[i].g = 255;//tb_Rnd(85, 115);
          Explosion.p[i].b = 255;//tb_Rnd(15, 45);
          Explosion.p[i].time = 0;
          Explosion.p[i].Active = TRUE;
          Explosion.p[i].gravity = gravity;
     }

}</pre><p>Here you can see that all the particles are set to start off in the
    same position, as specified by the <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>y</em></span> coordinates that you provide; however, you’ll
    notice that the initial velocity of each particle is actually randomly
    selected from a range of <code class="literal">Vinit/2</code> to
    <code class="literal">Vinit</code>. We do this to give the particle
    behavior some variety. We do the same thing for the life parameter of each
    particle so they don’t all fade out and die at the exact same time.</p><p>After the particle explosion is created, the program enters a loop
    to propagate and draw the effect. The loop is a <code class="literal">while</code> loop, as shown here in pseudocode:</p><a id="I_programlisting2_id301295"/><pre class="programlisting">while(status)
{
    Clear the off screen buffer...

    <span class="strong"><strong>status = DrawParticleExplosion( );</strong></span>

    Copy the off screen buffer to the screen...
}</pre><p>The <code class="literal">while</code> loop continues as long
    as <code class="literal">status</code> remains <code class="literal">true</code>, which indicates that the particle effect
    is still alive. After all the particles in the effect reach their set
    life, then the effect is dead and <code class="literal">status</code> will be set to <code class="literal">false</code>. All the calculations for the particle
    behavior actually take place in the function called <code class="literal">DrawParticleExplosion</code>; the rest of the code in
    this <code class="literal">while</code> loop is for clearing the
    off-screen buffer and then copying it to the main window.</p><p><code class="literal">DrawParticleExplosion</code> updates the
    state of each particle in the effect by calling another function, <code class="literal">UpdateParticleState</code>, and then draws the effect
    to the off-screen buffer passed in as a parameter. Here’s what these two
    functions look like:</p><a id="I_programlisting2_id301372"/><pre class="programlisting">//---------------------------------------------------------------------------//
// Draws the particle system and updates the state of each particle.
// Returns false when all of the particles have died out.
//---------------------------------------------------------------------------//

BOOL     DrawParticleExplosion(void)
{
     int      i;
     BOOL     finished = TRUE;
     float    r;

     if(Explosion.Active)
       for(i=0; i&lt;_MAXPARTICLES; i++)
       {
          if(Explosion.p[i].Active)
          {
               finished = FALSE;

               // Calculate a color scale factor to fade the particle's color
               // as its life expires
               r = ((float)(Explosion.p[i].life-
                     Explosion.p[i].time)/(float)(Explosion.p[i].life));

               ...
               Draw the particle as a small circle...
               ...

               Explosion.p[i].Active = UpdateParticleState(&amp;(Explosion.p[i]),
                                                           10);
          }
       }

     if(finished)
          Explosion.Active = FALSE;

     return !finished;
}

//---------------------------------------------------------------------------//
/*  This is generic function to update the state of a given particle.
     p:         pointer to a particle structure
     dtime:     time increment in milliseconds to
                advance the state of the particle

     If the total elapsed time for this particle has exceeded the particle's
     set life, then this function returns FALSE, indicating that the particle
     should expire.
*/
BOOL     UpdateParticleState(TParticle* p, int dtime)
{
     BOOL retval;
     float     t;

     p-&gt;time+=dtime;
     t = (float)p-&gt;time/1000.0f;
     p-&gt;x = p-&gt;vi * cos(p-&gt;angle*PI/180.0f) * t;
     p-&gt;y = p-&gt;vi * sin(p-&gt;angle*PI/180.0f) * t + (p-&gt;gravity*t*t)/2.0f;

     if (p-&gt;time &gt;= p-&gt;life)
          retval = FALSE;
     else
          retval = TRUE;

     return retval;
}</pre><p><code class="literal">UpdateParticleState</code> uses the
    kinematic formulas that we’ve already shown you to update the particle’s
    position as a function of its initial velocity, time, and the acceleration
    due to gravity. After <code class="literal">UpdateParticleState</code> is called, <code class="literal">DrawParticleExplosion</code> scales down each
    particle’s color, fading it to black, based on the life of each particle
    and elapsed time. The <a id="I_indexterm2_id301417" class="indexterm"/><a id="I_indexterm2_id301424" class="indexterm"/>fade effect is simply to show the particles dying slowly
    over time instead of disappearing from the screen. The effect resembles
    the behavior of <a id="I_indexterm2_id301437" class="indexterm"/>fireworks as they explode in the <a id="I_indexterm2_id301444" class="indexterm"/><a id="I_indexterm2_id301453" class="indexterm"/><a id="I_indexterm2_id301463" class="indexterm"/><a id="I_indexterm2_id301472" class="indexterm"/><a id="I_indexterm2_id301481" class="indexterm"/>night sky.</p></div><div class="sect1" title="Rigid-Body Kinematics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="rigid-body_kinematics">Rigid-Body Kinematics</h2></div></div></div><p>The formulas for <a id="I_indexterm2_id301500" class="indexterm"/><a id="I_indexterm2_id301511" class="indexterm"/>displacement, velocity, and acceleration discussed in the
    previous sections apply equally well for rigid bodies as they do for
    particles. The difference is that with rigid bodies, the point on the
    rigid body that you track, in terms of linear motion, is the body’s
    <a id="I_indexterm2_id301520" class="indexterm"/>center of mass (gravity).</p><p>When a rigid body translates with no rotation, all of the particles
    making up the rigid body move on parallel paths since the body does not
    change its shape. Further, when a rigid body does rotate, it generally
    rotates about axes that pass through its center of mass, unless the body
    is hinged at some other point about which it’s forced to rotate. These
    facts make the center of mass a convenient point to use to track its
    linear motion. This is good news for you since you can use all of the
    material you learned on particle kinematics here in your study of
    rigid-body kinematics.</p><p>The procedure for dealing with rigid bodies involves two distinct
    aspects: 1) tracking the translation of the body’s center of mass, and 2)
    tracking the body’s rotation. The first aspect is old hat by now—just
    treat the body as a particle. The second aspect, however, requires you to
    consider a few more concepts—namely, local coordinates, angular
    displacement, angular velocity, and angular acceleration.</p><p>For most of the remainder of this chapter, we’ll discuss
    <span class="emphasis"><em>plane</em></span> kinematics of rigid bodies. Plane motion
    <a id="I_indexterm2_id301556" class="indexterm"/><a id="I_indexterm2_id301562" class="indexterm"/>simply means that the body’s motion is restricted to a flat
    plane in space where the only axis of rotation about which the body can
    rotate is perpendicular to the plane. Plane motion is essentially
    two-dimensional. This allows us to focus on the new kinematic concepts of
    angular displacement, velocity, and acceleration without getting lost in
    the math required to describe arbitrary rotation in three
    dimensions.</p><p>You might be surprised by how many problems lend themselves to plane
    kinematic solutions. For example, in some popular 3D “shoot ’em up” games,
    your character is able to push objects, such as boxes and barrels, around
    on the floor. While the game world here is three dimensions, these
    particular objects may be restricted to sliding on the floor—a plane—and
    thus can be treated like a 2D problem. Even if the player pushes on these
    objects at some angle instead of straight on, you’ll be able to simulate
    the sliding and rotation of these objects using 2D kinematics (and
    kinetics) techniques.</p></div><div class="sect1" title="Local Coordinate Axes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="local_coordinate_axes">Local Coordinate Axes</h2></div></div></div><p>Earlier, we <a id="I_indexterm2_id301601" class="indexterm"/><a id="I_indexterm2_id301611" class="indexterm"/><a id="I_indexterm2_id301617" class="indexterm"/><a id="I_indexterm2_id301628" class="indexterm"/>defined the Cartesian coordinate system to use for your
    fixed global reference, or world coordinates. This world coordinate system
    is all that’s required when treating particles; however, for rigid bodies
    you’ll also use a set of local coordinates fixed to the body.
    Specifically, this local coordinate system will be fixed at the body’s
    center-of-mass location. You’ll use this coordinate system to track the
    <a id="I_indexterm2_id301642" class="indexterm"/>orientation of the body as it rotates.</p><p>For plane motion, we require only one scalar quantity to describe
    the body’s orientation. This is illustrated in <a class="xref" href="ch02.html#local_coordinate_axes-id1" title="Figure 2-8. Local coordinate axes">Figure 2-8</a>.</p><div class="figure"><a id="local_coordinate_axes-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id301675"/><img src="httpatomoreillycomsourceoreillyimages1598890.png" alt="Local coordinate axes"/></div></div><div class="figure-title">Figure 2-8. Local coordinate axes</div></div><p>Here the orientation, Ω, is defined as the angular difference
    between the two sets of coordinate axes: the fixed world axes and the
    local body axes. This is the so-called Euler angle. In general 3D motion
    there is a total of <a id="I_indexterm2_id301712" class="indexterm"/>three Euler angles, which are usually called
    <span class="emphasis"><em>yaw</em></span>, <span class="emphasis"><em>pitch</em></span>, and
    <span class="emphasis"><em>roll</em></span> in <a id="I_indexterm2_id301736" class="indexterm"/><a id="I_indexterm2_id301746" class="indexterm"/><a id="I_indexterm2_id301756" class="indexterm"/>aerodynamic and hydrodynamic jargon. While these angular
    representations are easy to visualize in terms of their physical meaning,
    they aren’t so nice from a numerical point of view, so you’ll have to look
    for alternative representations when writing your 3D real-time simulator.
    These issues are addressed in <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>.</p></div><div class="sect1" title="Angular Velocity and Acceleration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="angular_velocity_and_acceleration">Angular Velocity and Acceleration</h2></div></div></div><p>In two-dimensional <a id="ki2.9" class="indexterm"/><a id="av2.9" class="indexterm"/><a id="aa2.9" class="indexterm"/><a id="va2.9" class="indexterm"/><a id="aca2.9" class="indexterm"/>plane motion, as the body rotates, Ω will change, and the
    rate at which it changes is the angular velocity, ω. Likewise, the rate at
    which ω changes is the angular acceleration, α. These angular properties
    are analogous to the linear properties of displacement, <a id="I_indexterm2_id301873" class="indexterm"/><a id="I_indexterm2_id301883" class="indexterm"/>velocity, and acceleration. The units for angular
    displacement, velocity, and acceleration are radians (rad), radians per
    sec (rad/s), and radians per second-squared
    (rad/s<sup>2</sup>), respectively.</p><p>Mathematically, you can write these relations between angular
    displacement, angular velocity, and angular acceleration as:</p><table style="border: 0; " class="simplelist"><tr><td>ω = dΩ/dt</td></tr><tr><td>α = dω/dt =
      d<sup>2</sup>Ω/dt<sup>2</sup></td></tr><tr><td>ω = ∫ α dt</td></tr><tr><td>Ω = ∫ ω dt</td></tr><tr><td>ω dω = α dΩ</td></tr></table><p>In fact, you can substitute the angular properties Ω, ω, and α for
    the linear properties <span class="emphasis"><em>s</em></span>, <span class="emphasis"><em>v</em></span>, and
    <span class="emphasis"><em>a</em></span> in the equations derived earlier for particle
    kinematics to obtain similar kinematic equations for rotation. For
    constant angular acceleration, you’ll end up with the following
    equations:</p><table style="border: 0; " class="simplelist"><tr><td>ω<sub>2</sub> = ω<sub>1</sub> + α
      t</td></tr><tr><td>ω<sub>2</sub><sup>2</sup> =
      ω<sub>1</sub><sup>2</sup> + 2 α
      (Ω<sub>2</sub> − Ω<sub>1</sub>)</td></tr><tr><td>Ω<sub>2</sub> = Ω<sub>1</sub> +
      ω<sub>1</sub>t + (1/2) α
      t<sup>2</sup></td></tr></table><p>When a rigid body rotates about a given axis, every point on the
    rigid body sweeps out a circular path around the axis of rotation. You can
    think of the body’s rotation as causing additional linear motion of each
    particle making up the body—that is, this linear motion is in addition to
    the linear motion of the body’s center of mass. To get the total linear
    motion of any particle or point on the rigid body, you must be able to
    relate the angular motion of the body to the linear motion of the particle
    or point as it sweeps its circular path about the axis of rotation.</p><p>Before we show you how to do this, we’ll explain why you would even
    want to perform such a calculation. Basically, in dynamics, knowing that
    two objects have collided is not always enough, and you’ll often want to
    know how hard, so to speak, these two objects have collided. When you’re
    dealing with interacting rigid bodies that may at some point make contact
    with one another or with other fixed objects, you need to determine not
    only the location of the points of contact, but also the relative velocity
    or acceleration between the contact points. This information will allow
    you to calculate the interaction forces between the colliding
    bodies.</p><p>The arc length of the path swept by a particle on the rigid body is
    a function of the distance from the axis of rotation to the particle and
    the angular displacement, Ω. We’ll use <span class="emphasis"><em>c</em></span> to denote
    arc length and <span class="emphasis"><em>r</em></span> to denote the distance from the axis
    of rotation to the particle, as <a id="I_indexterm2_id302037" class="indexterm"/>shown in <a class="xref" href="ch02.html#circular_path_of_particles_making_up" title="Figure 2-9. Circular path of particles making up a rigid body">Figure 2-9</a>.</p><div class="figure"><a id="circular_path_of_particles_making_up"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302065"/><img src="httpatomoreillycomsourceoreillyimages1598891.png" alt="Circular path of particles making up a rigid body"/></div></div><div class="figure-title">Figure 2-9. Circular path of particles making up a rigid body</div></div><p>The formula relating arc length to <a id="I_indexterm2_id302085" class="indexterm"/><a id="I_indexterm2_id302095" class="indexterm"/>angular displacement is:</p><table style="border: 0; " class="simplelist"><tr><td>c = r Ω</td></tr></table><p>where Ω must be in radians, not degrees. If you differentiate this
    formula with respect to time:</p><table style="border: 0; " class="simplelist"><tr><td>dc/dt = r dΩ/dt</td></tr></table><p>you get an equation relating the <a id="I_indexterm2_id302131" class="indexterm"/><a id="I_indexterm2_id302140" class="indexterm"/>linear velocity of the particle as it moves along its
    circular path to the angular velocity of the rigid body. This equation is
    written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v = r ω</td></tr></table><p>This velocity as a vector is tangent to the circular path swept by
    the particle. Imagine this particle as a ball at the end of a rod where
    the other end of the rod is fixed to a rotating axis. If the ball is
    released from the end of the rod as it rotates, the ball will fly off in a
    direction tangent to the circular path it was taking when attached to the
    rod. This is in the same direction as the tangential linear velocity given
    by the preceding equation. <a class="xref" href="ch02.html#linear_velocity_due_to_angular_velocity" title="Figure 2-10. Linear velocity due to angular velocity">Figure 2-10</a> illustrates the
    <a id="I_indexterm2_id302176" class="indexterm"/><a id="I_indexterm2_id302182" class="indexterm"/>tangential velocity.</p><div class="figure"><a id="linear_velocity_due_to_angular_velocity"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302205"/><img src="httpatomoreillycomsourceoreillyimages1598892.png" alt="Linear velocity due to angular velocity"/></div></div><div class="figure-title">Figure 2-10. Linear velocity due to angular velocity</div></div><p>Differentiating the equation, <span class="emphasis"><em>v</em></span> =
    <span class="emphasis"><em>r</em></span> ω:</p><table style="border: 0; " class="simplelist"><tr><td>dv/dt = r dω/dt</td></tr></table><p>yields this formula for the tangential linear acceleration as a
    function of angular acceleration:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>t</sub> = r α</td></tr></table><p>Note that there is another component of acceleration for the
    particle that results from the rotation of the rigid body. This <a id="I_indexterm2_id302268" class="indexterm"/><a id="I_indexterm2_id302274" class="indexterm"/>component—the <span class="emphasis"><em>centripetal</em></span>
    acceleration—is normal, or perpendicular, to the circular path of the
    particle and is always directed toward the axis of rotation. Remember that
    velocity is a vector and since acceleration is the rate of change in the
    velocity vector, there are two ways that acceleration can be produced. One
    way is by a change in the magnitude of the velocity vector—that is, a
    change in speed—and the other way is a change in the direction of the
    velocity vector. The change in speed gives rise to the <a id="I_indexterm2_id302293" class="indexterm"/><a id="I_indexterm2_id302299" class="indexterm"/>tangential acceleration component, while the direction
    change gives rise to the centripetal acceleration component. The resultant
    acceleration vector is the vector sum of the tangential and centripetal
    accelerations (see <a class="xref" href="ch02.html#tangential_and_centripetal_acceleration" title="Figure 2-11. Tangential and centripetal acceleration">Figure 2-11</a>). Centripetal
    acceleration is what you feel when you take your car around a tight curve
    even though your speed is constant.</p><div class="figure"><a id="tangential_and_centripetal_acceleration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302328"/><img src="httpatomoreillycomsourceoreillyimages1598893.png" alt="Tangential and centripetal acceleration"/></div></div><div class="figure-title">Figure 2-11. Tangential and centripetal acceleration</div></div><p>The formula for the magnitude of centripetal acceleration,
    <span class="emphasis"><em>a</em></span><sub>n</sub>, is:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>n</sub> =
      v<sup>2</sup>/r</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is the tangential velocity.
    Substituting the equation for tangential velocity into this equation for
    centripetal acceleration gives the following alternative form:</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>n</sub> = r
      ω<sup>2</sup></td></tr></table><p>In two dimensions you can easily get away with using these scalar
    equations; however, in three dimensions you’ll have to use the vector
    forms of these equations. Angular velocity as a vector is parallel with
    the axis of rotation. In <a class="xref" href="ch02.html#linear_velocity_due_to_angular_velocity" title="Figure 2-10. Linear velocity due to angular velocity">Figure 2-10</a> the angular velocity
    would be pointing out of the page directly at you. Its sense, or direction
    of <a id="I_indexterm2_id302409" class="indexterm"/>rotation, is determined by the <span class="emphasis"><em>right hand
    rule</em></span>. If you curl the fingers of your right hand in an arc
    around the axis of rotation with your fingers pointing toward the
    direction in which the body is rotating, then your thumb will stick up in
    the direction of the angular velocity vector.</p><p>If you take the vector cross product (refer to the sidebar <a class="xref" href="ch02.html#vector_cross_product" title="Vector Cross Product">Vector Cross Product</a> for background and to <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a> for a review of vector math) of the angular
    velocity vector and the vector from the axis of rotation to the particle
    under consideration, you’ll end up with the linear, tangential velocity
    vector. This is written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span> = <span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span></td></tr></table><p>Note that this gives both the magnitude and direction of the linear,
    tangential velocity. Also, be sure to preserve the order of the vectors
    when taking the cross product—that is, <span class="strong"><strong>ω</strong></span> cross <span class="strong"><strong>r</strong></span>, and
    not the other way around, which would give the wrong direction for
    <span class="strong"><strong>v</strong></span>.</p><div class="sidebar"><a id="vector_cross_product"/><div class="sidebar-title">Vector Cross Product</div><p>Given any two <a id="I_indexterm2_id302510" class="indexterm"/><a id="I_indexterm2_id302516" class="indexterm"/>vectors <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span>, the cross product <span class="strong"><strong>A</strong></span> × <span class="strong"><strong>B</strong></span> is
      defined by a third vector <span class="strong"><strong>C</strong></span> with a
      magnitude equal to AB sin θ, where θ is the angle between the two
      vectors <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span>, as illustrated in the following
      figure.</p><div class="informalfigure"><a id="image_no_caption"/><div class="mediaobject"><a id="I_mediaobject2_id302577"/><img src="httpatomoreillycomsourceoreillyimages1598894.png" alt="image with no caption"/></div></div><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>C</strong></span> = <span class="strong"><strong>A</strong></span> × <span class="strong"><strong>B</strong></span></td></tr><tr><td><span class="strong"><strong>C</strong></span> = <span class="strong"><strong>AB</strong></span> sin θ</td></tr></table><p>The direction of <span class="strong"><strong>C</strong></span> is
      determined by the right hand rule. As noted previously, the right hand
      rule is a simple trick to help you keep track of vector directions.
      Assume that <span class="strong"><strong>A</strong></span> and <span class="strong"><strong>B</strong></span> lie in a plane and let an axis of rotation
      extend perpendicular to this plane through a point located at the tail
      of <span class="strong"><strong>A</strong></span>. Pretend to curl the fingers of
      your right hand around the axis of rotation from vector <span class="strong"><strong>A</strong></span> toward <span class="strong"><strong>B</strong></span>.
      Now extend your thumb (as though you are giving a thumbs up) while
      keeping your fingers curled around the axis. The direction that your
      thumb is pointing indicates the direction of vector <span class="strong"><strong>C</strong></span>.</p><p>In the preceding figure, a parallelogram is formed by A and B (the
      shaded region). The area of this parallelogram is the magnitude of C,
      which is AB sin θ.</p></div><p>There are two equations that you’ll need in order to determine the
    vectors for tangential and centripetal acceleration. They are:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>n</sub> =
      <span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr><tr><td><span class="strong"><strong>a</strong></span><sub>t</sub> =
      <span class="strong"><strong>α</strong></span> × <span class="strong"><strong>r</strong></span></td></tr></table><p>Another way to look at the quantities <span class="strong"><strong>v</strong></span>, <span class="strong"><strong>a</strong></span><sub>n</sub>, and <span class="strong"><strong>a</strong></span><sub>t</sub> is that they are the
    velocity and acceleration of the particle under consideration, on the
    rigid body, relative to the point about which the rigid body is
    rotating—for example, the body’s center-of-mass location. This is very
    convenient because, as we said earlier, you’ll want to track the motion of
    the rigid body as a particle when viewing the big picture without having
    to worry about what each particle making up the rigid body is doing all
    the time. Thus, you treat the rigid body’s linear motion and its angular
    motion separately. When you do need to take a close look at specific
    particles of—or points on—the rigid body, you can do so by taking the
    motion of the rigid body as a particle and then adding to it the relative
    motion of the point under consideration.</p><p><a class="xref" href="ch02.html#relative_velocity" title="Figure 2-12. Relative velocity">Figure 2-12</a> shows a rigid body that is
    traveling at a speed <span class="strong"><strong>v</strong></span><sub>cg</sub>, where <span class="strong"><strong>v</strong></span><sub>cg</sub> is the speed of the
    rigid body’s center of mass (or center of gravity). Remember, the center
    of mass is the point to track when treating a rigid body as a particle.
    This rigid body is also rotating with an angular velocity <span class="strong"><strong>ω</strong></span> about an axis that passes through the body’s
    center of <a id="I_indexterm2_id302818" class="indexterm"/><a id="I_indexterm2_id302829" class="indexterm"/>mass. The vector <span class="strong"><strong>r</strong></span> is the
    vector from the rigid body’s center of mass to the particular point of
    interest, <span class="emphasis"><em>P</em></span>, located on the rigid body.</p><div class="figure"><a id="relative_velocity"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id302861"/><img src="httpatomoreillycomsourceoreillyimages1598895.png" alt="Relative velocity"/></div></div><div class="figure-title">Figure 2-12. Relative velocity</div></div><p>In this case, we can find the resultant velocity of the point,
    <span class="emphasis"><em>P</em></span>, by taking the vector sum of the velocity of the
    body’s center of mass and the tangential velocity of point
    <span class="emphasis"><em>P</em></span> due to the body’s angular velocity <span class="strong"><strong>ω</strong></span>. Here’s what the vector equation looks
    like:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>R</sub> =
      <span class="strong"><strong>v</strong></span><sub>cg</sub> +
      <span class="strong"><strong>v</strong></span><sub>t</sub></td></tr></table><p>or:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>R</sub> =
      <span class="strong"><strong>v</strong></span><sub>cg</sub> +
      (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr></table><p>You can do the same thing with acceleration to determine point
    <span class="emphasis"><em>P</em></span>’s resultant acceleration. Here you’ll take the
    vector sum of the acceleration of the rigid body’s center of mass, the
    tangential acceleration due to the body’s angular acceleration, and the
    centripetal acceleration due to the change in direction of the tangential
    velocity. In equation form, this <a id="I_indexterm2_id302993" class="indexterm"/><a id="I_indexterm2_id302999" class="indexterm"/>looks like:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>R</sub> =
      <span class="strong"><strong>a</strong></span><sub>cg</sub> +
      <span class="strong"><strong>a</strong></span><sub>n</sub> + <span class="strong"><strong>a</strong></span><sub>t</sub></td></tr></table><p><a class="xref" href="ch02.html#relative_acceleration" title="Figure 2-13. Relative acceleration">Figure 2-13</a> illustrates what’s
    happening here.</p><div class="figure"><a id="relative_acceleration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id303071"/><img src="httpatomoreillycomsourceoreillyimages1598896.png" alt="Relative acceleration"/></div></div><div class="figure-title">Figure 2-13. Relative acceleration</div></div><p>You can rewrite the equation for the resultant acceleration in the
    following form:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span><sub>R</sub> =
      <span class="strong"><strong>a</strong></span><sub>cg</sub> +
      (<span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)) +
      (<span class="strong"><strong>α</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr></table><p>As you can see, using these principles of relative velocity and
    acceleration allows you to calculate the resultant kinematic properties of
    any point on a rigid body at any given time by determining what the body’s
    center of mass is doing along with how the body is <a id="I_indexterm2_id303153" class="indexterm"/><a id="I_indexterm2_id303163" class="indexterm"/><a id="I_indexterm2_id303172" class="indexterm"/><a id="I_indexterm2_id303181" class="indexterm"/><a id="I_indexterm2_id303191" class="indexterm"/>rotating.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 3. Force</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch02.html" title="Chapter 2. Kinematics"/><link rel="next" href="ch04.html" title="Chapter 4. Kinetics"/></head><body><section class="chapter" title="Chapter 3. Force" epub:type="chapter" id="force"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Force</h2></div></div></div><p>This chapter is a prerequisite to <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, which addresses the subject of
    kinetics. The aim here is to provide you with enough of a background on forces so you can
    readily appreciate the subject of kinetics. This chapter is not meant to be the final word on
    the subject of force. In fact, we feel that the subject of force is so important to realistic
    simulations that we’ll revisit it several times in various contexts throughout the remainder of
    this book. In this chapter, we’ll discuss the two fundamental categories of force and briefly
    explain some important specific types of force. We’ll also explain the relationship between
    force and torque.</p><div class="sect1" title="Forces"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="forces">Forces</h2></div></div></div><p>As we mentioned in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, you need to <a id="I_indexterm3_id303234" class="indexterm"/>understand the concept of force before you can fully understand the subject of
      kinetics. Kinematics is only half the battle. You are already familiar with the concept of
      force from your daily experiences. You exert a force on this book as you hold it in your
      hands, counteracting gravity. You exert force on your mouse as you move it from one point to
      another. When you play soccer, you exert force on the ball as you kick it. In general, force
      is what makes an object move, or more precisely, what produces an acceleration that changes
      the velocity. Even as you hold this book, although it may not be moving, you’ve effectively
      produced an acceleration that cancels the acceleration from gravity. When you kick that soccer
      ball, you change its velocity from, say, 0 when the ball is at rest to some positive value as
      the ball leaves your foot. These are some examples of externally <a id="I_indexterm3_id303254" class="indexterm"/>applied <span class="emphasis"><em>contact</em></span> forces.</p><p>There’s another broad category of forces, in addition to contact forces, <a id="I_indexterm3_id303272" class="indexterm"/>called <span class="emphasis"><em>field</em></span> forces or <a id="I_indexterm3_id303286" class="indexterm"/>sometimes <span class="emphasis"><em>forces at a distance</em></span>. These forces can act on a
      body without actually having to make contact with it. A good example is the gravitational
      attraction between objects. Another example is the electromagnetic attraction between charged
      particles. The concept of a force field was developed long ago to help us visualize the
      interaction between objects subject to forces at a distance. You can say that an object is
      subjected to the gravitational field of another object. Thinking in terms of force fields can
      help you grasp the fact that an object can exert a force on another object without having to
      physically touch it.</p><p>Within these two broad categories of forces, there are specific types of forces related to
      various physical phenomena—forces due to friction, buoyancy, and pressure, among others. We’ll
      discuss idealizations of several of these types of forces in this chapter. Later in this book,
      we’ll revisit these forces from a more practical point of view.</p><p>Before going further, we need to explain the implications of Newton’s <a id="I_indexterm3_id303313" class="indexterm"/>third law as introduced in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>. Remember, Newton’s
      third law states that for every force acting on a body, there is an equal and opposite
      reacting force. This means that forces must exist in pairs—a single force can’t exist by
      itself.</p><p>Consider the gravitational attraction between the earth and yourself. The earth is
      exerting a force—your weight—on you, accelerating you toward its center. Likewise, you are
      exerting a force on the earth, accelerating it toward you. The huge difference between your
      mass and the earth’s makes the acceleration of the earth in this case so small that it’s
      negligible. Earlier we said you are exerting a force on this book to hold it up; likewise,
      this book is exerting a force on your hands equal in magnitude but opposite in direction to
      the force you are exerting on it. You feel this reaction force as the book’s weight.</p><p>This phenomenon of action-reaction is the basis for rocket propulsion. A rocket engine
      exerts force on the fuel molecules that are accelerated out of the engine exhaust nozzle. The
      force required to accelerate these molecules is exerted back against the rocket as a reaction
      force <a id="I_indexterm3_id303347" class="indexterm"/>called <span class="emphasis"><em>thrust</em></span>. Throughout the remainder of this book, you’ll
      see many other examples of action-reaction, which is an important phenomenon in rigid-body
      dynamics. It is especially important when we are dealing with collisions and objects in
      contact, as you’ll see later.</p></div><div class="sect1" title="Force Fields"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="force_fields">Force Fields</h2></div></div></div><p>The best example of a <a id="I_indexterm3_id303377" class="indexterm"/><a id="I_indexterm3_id303388" class="indexterm"/>force field or force at a distance is the gravitational attraction between
      objects. <span class="emphasis"><em>Newton’s law of gravitation</em></span>
      <a id="I_indexterm3_id303399" class="indexterm"/><a id="I_indexterm3_id303409" class="indexterm"/>states that the force of attraction between two masses is directly proportional to
      the product of the masses and inversely proportional to the square of the distances separating
      the centers of each mass. Further, this law states that the line of action of the force of
      attraction is along the line that connects the centers of the two masses. This is written as
      follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>a</sub> = (G m<sub>1</sub> m<sub>2</sub>) /
          r<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>G</em></span> is the gravitational constant, Newton’s so-called<a id="I_indexterm3_id303457" class="indexterm"/>
      <span class="emphasis"><em>universal constant</em></span>. <span class="emphasis"><em>G</em></span> was first measured
      experimentally by Sir Henry Cavendish <a id="I_indexterm3_id303472" class="indexterm"/>in 1798 and equals 6.673×10<sup>−11</sup>
        (N–m<sup>2</sup>)/kg<sup>2</sup> in metric units or
        3.436×10<sup>−8</sup>
        ft<sup>4</sup>/(lb-s<sup>4</sup>) in English units.</p><p>So far in this book, I’ve been using the acceleration due to gravity,
        <span class="emphasis"><em>g</em></span>, as a constant 9.8 m/s<sup>2</sup> (32.174
        ft/s<sup>2</sup>). This is true when you are near the earth’s surface—for
      example, at sea level. In reality, <span class="emphasis"><em>g</em></span> varies with <a id="I_indexterm3_id303520" class="indexterm"/>altitude—maybe not by much for our purposes, but it does. Consider Newton’s second
      law along with the <a id="I_indexterm3_id303533" class="indexterm"/>law of gravitation for a body near the earth. Equating these two laws, in equation
      form, yields:</p><table style="border: 0; " class="simplelist"><tr><td>m a = (G M<sub>e</sub> m) / (R<sub>e</sub> +
          h)<sup>2</sup></td></tr></table><p>where <span class="emphasis"><em>m</em></span> is the mass of the body, <span class="emphasis"><em>a</em></span> is the
      acceleration of the body due to the gravitational attraction between it and the earth,
        <span class="emphasis"><em>M</em></span><sub>e</sub> is the earth’s mass,
        <span class="emphasis"><em>R</em></span><sub>e</sub> is the radius of the earth, and
        <span class="emphasis"><em>h</em></span> is the altitude of the body. If you solve this equation for
        <span class="emphasis"><em>a</em></span>, you’ll have a formula for the acceleration due to gravity as a
      function of altitude:</p><table style="border: 0; " class="simplelist"><tr><td>a = g’ = (G M<sub>e</sub>) / (R<sub>e</sub> +
          h)<sup>2</sup></td></tr></table><p>The radius of the earth is approximately 6.38×10<sup>6</sup> m, and its
      mass is about 5.98×10<sup>24</sup> kgs. Substituting these values in the
      preceding equation and assuming 0 altitude (sea level) yields the constant
        <span class="emphasis"><em>g</em></span> that we’ve been using so far—that is, <span class="emphasis"><em>g</em></span> at sea
      level equals 9.8 m/s<sup>2</sup>.</p></div><div class="sect1" title="Friction"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="friction">Friction</h2></div></div></div><p>Frictional forces (friction) <a id="fr3.3" class="indexterm"/>always resist motion and are due to the interaction between contacting surfaces.
      Thus, friction is a <a id="co3.3" class="indexterm"/>contact force. Friction is always parallel to the contacting surfaces at the point
      of contact—that is, friction is tangential to the contacting surfaces. The magnitude of the
      frictional force is a function of the normal force between the contacting surfaces and the
      surface roughness.</p><p>This is easiest to visualize by looking at a simple block on a horizontal surface, as
      shown in <a class="xref" href="ch03.html#friction_colon_block_in_contact_with_hor" title="Figure 3-1. Friction: block in contact with horizontal surface">Figure 3-1</a>.</p><div class="figure"><a id="friction_colon_block_in_contact_with_hor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id303713"/><img src="httpatomoreillycomsourceoreillyimages1598897.png" alt="Friction: block in contact with horizontal surface"/></div></div><div class="figure-title">Figure 3-1. Friction: block in contact with horizontal surface</div></div><p>In <a class="xref" href="ch03.html#friction_colon_block_in_contact_with_hor" title="Figure 3-1. Friction: block in contact with horizontal surface">Figure 3-1</a>, the block is resting on the
      horizontal surface with a small force, <span class="emphasis"><em>F</em></span><sub>a</sub>, applied
      to the block on a line of action through the block’s center of mass. As this applied force
      increases, a frictional force will develop between the block and the horizontal surface,
      tending to resist the motion of the block. The maximum value of this <a id="I_indexterm3_id303746" class="indexterm"/>frictional force is:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>fmax</sub> = µ<sub>s</sub> N</td></tr></table><p>where µ<sub>s</sub> is the experimentally determined coefficient <a id="I_indexterm3_id303786" class="indexterm"/><a id="I_indexterm3_id303792" class="indexterm"/>of static<sup>[<a id="CHP-3-FN-1" href="#ftn.CHP-3-FN-1" epub:type="noteref" class="footnote">9</a>]</sup> friction and <span class="emphasis"><em>N</em></span> is the normal (perpendicular) force between
      the block and the surface, which equals the weight of the block in this case. As the applied
      force increases but is still less than <span class="emphasis"><em>F</em></span><sub>fmax</sub>, the
      block will remain static and <span class="emphasis"><em>F</em></span><sub>f</sub> will be equal in
      magnitude to the applied force. The block is in static equilibrium. When the applied force
      becomes greater than <span class="emphasis"><em>F</em></span><sub>fmax</sub>, the frictional force
      can no longer impede the block’s motion and the block will accelerate under the influence of
      the applied force. Immediately after the block starts its motion, the frictional force will
      decrease from <span class="emphasis"><em>F</em></span><sub>fmax</sub> to
        <span class="emphasis"><em>F</em></span><sub>fk</sub>, where
        <span class="emphasis"><em>F</em></span><sub>fk</sub> is:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>fk</sub> = µ<sub>k</sub> N</td></tr></table><p>Here <span class="emphasis"><em>k</em></span> means kinetic since the block is in motion, <a id="I_indexterm3_id303886" class="indexterm"/><a id="I_indexterm3_id303892" class="indexterm"/>and µ<sub>k</sub>, the coefficient of kinetic friction,<sup>[<a id="CHP-3-FN-2" href="#ftn.CHP-3-FN-2" epub:type="noteref" class="footnote">10</a>]</sup> is less than µ<sub>s</sub>. Like the static coefficient of friction,
      the kinetic coefficient of friction is determined experimentally. <a class="xref" href="ch03.html#coefficients_of_friction_of_common_surfa" title="Table 3-1. Coefficients of friction of common surfaces">Table 3-1</a> shows typical coefficients of friction
      for several surfaces in contact.</p><div class="table"><a id="coefficients_of_friction_of_common_surfa"/><div class="table-title">Table 3-1. Coefficients of friction of common surfaces</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Surface condition</p>
            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Μ<sub>s</sub></p>
            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Μ<sub>u</sub></p>
            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
              <p>% difference</p>
            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry glass on glass</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.94</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.4</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>54%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry iron on iron</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>1.1</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.15</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>86%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry rubber on pavement</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.55</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.4</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>27%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry steel on steel</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.78</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.42</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>46%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry Teflon on Teflon</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.04</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.04</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>—</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Dry wood on wood</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.38</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.2</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>47%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Ice on ice</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.1</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0.03</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>70%</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>Oiled steel on steel</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>0.10</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>0.08</p>
            </td><td style="text-align: left; vertical-align: top; ">
              <p>20%</p>
            </td></tr></tbody></table></div></div><p>The data in <a class="xref" href="ch03.html#coefficients_of_friction_of_common_surfa" title="Table 3-1. Coefficients of friction of common surfaces">Table 3-1</a> is provided here to
      show you the magnitude of some typical friction coefficients and the relative difference
      between the static and kinetic coefficients for certain surface conditions. Other data is
      available for these and other surface conditions in the technical literature (see the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a> for sources). Note that experimentally determined
      friction coefficient data will vary, even for the same surface conditions, depending on the
      specific condition of the material used in the experiments and the execution of the <a id="I_indexterm3_id304475" class="indexterm"/><a id="I_indexterm3_id304485" class="indexterm"/>experiment itself.</p></div><div class="sect1" title="Fluid Dynamic Drag"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="fluid_dynamic_drag">Fluid Dynamic Drag</h2></div></div></div><p>Fluid dynamic <a id="I_indexterm3_id304509" class="indexterm"/><a id="I_indexterm3_id304519" class="indexterm"/><a id="I_indexterm3_id304529" class="indexterm"/>drag forces oppose motion like friction. In fact, a major component of fluid
      dynamic drag is friction that results from the relative flow of the fluid over (and in contact
      with) the body’s surface. Friction is not the only component of fluid dynamic drag, though.
      Depending on the shape of the body, its speed, and the nature of the fluid, fluid dynamic drag
      will have additional components due to pressure variations in the fluid as it flows around the
      body. If the body is located at the interface between two fluids (like a ship on the ocean
      where the two fluids are air and water), an additional component of drag will exist due to the
      wave generation.</p><p>In general, fluid dynamic drag is a complicated phenomenon that is a function of several
      factors. We won’t go into detail in this section on all these factors, since we’ll revisit
      this subject later. However, we do want to discuss how <a id="I_indexterm3_id304552" class="indexterm"/>the <span class="emphasis"><em>viscous</em></span> (frictional) component of these drag forces is
      typically idealized.</p><p>Ideal viscous drag is a function of velocity and some experimentally <a id="I_indexterm3_id304570" class="indexterm"/><a id="I_indexterm3_id304580" class="indexterm"/>determined <span class="emphasis"><em>drag coefficient</em></span> that’s supposed to take into
      account the surface conditions of the body, the fluid properties (density and viscosity), and
      the flow conditions. You’ll typically see a formula for viscous drag force in the form:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>v</sub> = –C<sub>f</sub> v</td></tr></table><p>where <span class="emphasis"><em>C</em></span><sub>f</sub> is the drag coefficient,
        <span class="emphasis"><em>v</em></span> is the body’s speed, and the minus sign means that the force opposes
      motion. This formula is valid for slow-moving objects in a viscous fluid. “Slow moving”
      implies that the <a id="I_indexterm3_id304631" class="indexterm"/><a id="I_indexterm3_id304637" class="indexterm"/>flow around the body is <span class="emphasis"><em>laminar</em></span>, which means that the flow
      streamlines are undisturbed and parallel.</p><p>For fast-moving objects, you’ll use the formula for
        <span class="emphasis"><em>F</em></span><sub>v</sub> written as a function of speed squared as
      follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>v</sub> = –C<sub>f</sub>
        v<sup>2</sup></td></tr></table><p>“Fast moving” implies that the flow around the <a id="I_indexterm3_id304687" class="indexterm"/><a id="I_indexterm3_id304693" class="indexterm"/>object is <span class="emphasis"><em>turbulent</em></span>, which means that the flow streamlines
      are no longer parallel and there is a sort of mixing effect in the flow around the object.
      Note that the values of <span class="emphasis"><em>C</em></span><sub>f</sub> are generally not the
      same for these two equations. In addition to the factors mentioned earlier,
        <span class="emphasis"><em>C</em></span><sub>f</sub> depends significantly on whether the flow is
      laminar or turbulent.</p><p>Both of these equations are very simplified and inadequate for practical analysis of fluid
      flow problems. However, they do offer certain advantages in computer game simulations. Most
      obviously, these formulas are easy to implement—you need only know the velocity of the body
      under consideration, which you get from your kinematic equations, and an assumed value for the
      drag coefficient. This is convenient, as your game world will typically have many different
      types of objects of all sizes and shapes that would make rigorous analysis of each of their
      drag properties impractical. If the illusion of realism is all you need, not real-life
      accuracy, then these formulas may be sufficient.</p><p>Another advantage of using these idealized formulas is that you can tweak the drag
      coefficients as you see fit to help reduce numerical instabilities when solving the equations
      of motion, while maintaining the illusion of realistic behavior. If real-life accuracy is what
      you’re going for, then you’ll have no choice but to consider a more involved (read:
      complicated) approach for determining fluid dynamic drag. We’ll talk more about drag in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> through <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>.</p></div><div class="sect1" title="Pressure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="pressure">Pressure</h2></div></div></div><p>Many people confuse <a id="I_indexterm3_id304761" class="indexterm"/><a id="I_indexterm3_id304771" class="indexterm"/>pressure with force. You have probably heard people say, when explaining a
      phenomenon, something like, “It pushed with a force of 100 pounds per square inch.” While you
      understand what they mean, they are technically referring to pressure, not force. Pressure is
      force per unit area, thus the <a id="I_indexterm3_id304785" class="indexterm"/><a id="I_indexterm3_id304797" class="indexterm"/><a id="I_indexterm3_id304804" class="indexterm"/>units <span class="emphasis"><em>pounds per square inch</em></span> (psi) or <span class="emphasis"><em>pounds per
        square foot</em></span> (psf) <a id="I_indexterm3_id304818" class="indexterm"/><a id="I_indexterm3_id304824" class="indexterm"/>and so on. Given the pressure, you’ll need to know the total area acted on by this
      pressure in order to determine the resultant force. Force equals pressure times area:</p><table style="border: 0; " class="simplelist"><tr><td>F = PA</td></tr></table><p>This formula tells you that for constant pressure, the greater the area acted upon, the
      greater the resultant force. If you rearrange this equation solving for pressure, you’ll see
      that pressure is inversely proportional to area—that is, the greater the area for a given
      applied force, the smaller the resulting pressure and vice versa.</p><table style="border: 0; " class="simplelist"><tr><td>P = F/A</td></tr></table><p>An important characteristic of pressure is that it always acts normally (perpendicularly)
      to the surface of the body or object it is acting on. This fact gives you a clue as to the
      direction of the resultant force vector.</p><p>We wanted to mention pressure here because you’ll be working with it to calculate forces
      when you get to the chapters in this book that cover the mechanics of ships, boats, and
      hovercraft. There, the pressures that you’ll consider are <a id="I_indexterm3_id304868" class="indexterm"/><a id="I_indexterm3_id304875" class="indexterm"/>hydrostatic pressure (buoyancy) and aerostatic lift. We’ll take a brief look at
      buoyancy next.</p></div><div class="sect1" title="Buoyancy"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="buoyancy">Buoyancy</h2></div></div></div><p>You’ve no doubt felt the <a id="fo3.6" class="indexterm"/><a id="bu3.6" class="indexterm"/>effects of buoyancy when immersing yourself in the bathtub. Buoyancy is why you
      feel lighter in water than you do in air and why some people can float on their backs in a
      swimming pool.</p><p>Buoyancy is a force that develops when an object is immersed in a fluid. It’s a function
      of the volume of the object and the density of the fluid and results from the pressure
      differential between the fluid just above the object and the fluid just below the object.
      Pressure <a id="I_indexterm3_id304939" class="indexterm"/><a id="I_indexterm3_id304949" class="indexterm"/>increases the deeper you go in a fluid, thus the pressure is greater at the bottom
      of an object of a given height than it is at the top of the object. Consider the cube shown in
        <a class="xref" href="ch03.html#immersed_cube" title="Figure 3-2. Immersed cube">Figure 3-2</a>.</p><div class="figure"><a id="immersed_cube"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id304978"/><img src="httpatomoreillycomsourceoreillyimages1598898.png" alt="Immersed cube"/></div></div><div class="figure-title">Figure 3-2. Immersed cube</div></div><p>Let <span class="emphasis"><em>s</em></span> denote the cube’s length, width, and height, which are all
      equal. Further, let <span class="emphasis"><em>h</em></span><sub>t</sub> denote the depth to the top
      of the cube and <span class="emphasis"><em>h</em></span><sub>b</sub> the depth to the bottom of the
      cube. The pressure at the top of the cube is <span class="emphasis"><em>P</em></span><sub>t</sub>
      <span class="emphasis"><em>=</em></span> ρ <span class="emphasis"><em>g h</em></span><sub>t</sub>, which acts over the
      entire surface area of the top of the cube, normal to the surface in the downward direction.
      The pressure at the bottom of the cube is <span class="emphasis"><em>P</em></span><sub>b</sub>
      <span class="emphasis"><em>=</em></span> ρ <span class="emphasis"><em>g h</em></span><sub>b</sub>, which acts over the
      entire surface area of the bottom of the cube, normal to the surface in the upward direction.
      Note that the pressure acting on the sides of the cube increases linearly with submergence,
      from <span class="emphasis"><em>P</em></span><sub>t</sub> to
        <span class="emphasis"><em>P</em></span><sub>b</sub>. Also, note that since the side pressure is
      symmetric, equal and opposite, the net side pressure is 0, which means that the net side force
      (due to pressure) is also 0. The same is not true of the top and bottom pressures, which are
      obviously not equal, although they are opposite.</p><p>The force acting down on the top of the cube is equal to the pressure at the top of the
      cube times the surface area of the top. This can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>t</sub> = P<sub>t</sub>
        A<sub>t</sub></td></tr><tr><td>F<sub>t</sub> = (ρ g h<sub>t</sub>)
          (s<sup>2</sup>)</td></tr></table><p>Similarly, the force acting upward on the bottom of the cube is equal to the pressure at
      the bottom times the surface area of the bottom.</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>b</sub> = P<sub>b</sub>
        A<sub>b</sub></td></tr><tr><td>F<sub>b</sub> = (ρ g h<sub>b</sub>)
          (s<sup>2</sup>)</td></tr></table><p>The net vertical force (buoyancy) equals the difference between the top and bottom
      forces:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>B</sub> = F<sub>b</sub> –
        F<sub>t</sub></td></tr><tr><td>F<sub>B</sub> = (ρ g h<sub>b</sub>)
          (s<sup>2</sup>) – (ρ g h<sub>t</sub>)
          (s<sup>2</sup>)</td></tr><tr><td>F<sub>B</sub> = (ρ g) (s<sup>2</sup>)
          (h<sub>b</sub> – h<sub>t</sub>)</td></tr></table><p>This formula gives the magnitude of the buoyancy force. Its direction is straight up,
      counteracting the weight of the object.</p><p>There is an important observation we need to make here. Notice that
        (<span class="emphasis"><em>h</em></span><sub>b</sub>
      <span class="emphasis"><em>– h</em></span><sub>t</sub>) is simply the height of the cube, which is
        <span class="emphasis"><em>s</em></span> in this case. Substituting <span class="emphasis"><em>s</em></span> in place of
        (<span class="emphasis"><em>h</em></span><sub>b</sub>
      <span class="emphasis"><em>– h</em></span><sub>t</sub>) reveals that the buoyancy force is a
      function of the volume of the cube.</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>B</sub> = (ρ g) (s<sup>3</sup>)</td></tr></table><p>This is great since it means that all you need to do in order to calculate <a id="I_indexterm3_id305275" class="indexterm"/>buoyancy is to first calculate the volume of the object and then multiply that
      volume by the specific <a id="I_indexterm3_id305287" class="indexterm"/>weight<sup>[<a id="CHP-3-FN-3" href="#ftn.CHP-3-FN-3" epub:type="noteref" class="footnote">11</a>]</sup> (ρ <span class="emphasis"><em>g</em></span>) of the fluid. In truth, that’s a little easier said
      than done for all but the simplest geometries. If you’re dealing with spheres, cubes,
      cylinders, and the like, then calculating volume is easy. However, if you’re dealing with any
      arbitrary geometry, then the volume calculation becomes more difficult. There are two ways to
      handle this difficulty. The first way is to simply divide the object into a number of smaller
      objects of simpler geometry, calculate their volumes, and then add them all up. The second way
      is to use numerical integration techniques to calculate volume by integrating over the surface
      of the object.</p><p>You should also note that buoyancy is a function of fluid density, and you don’t have to
      be in a fluid as dense as water to experience the force of buoyancy. In fact, there are
      buoyant forces acting on you right now, although they are very small, due to the fact that you
      are immersed in air. Water is many times more dense than air, which is why you notice the
      force of buoyancy when in water and not in air. Keep in mind, though, that for very light
      objects with relatively large volumes, the buoyant forces in air may be significant. For
      example, consider simulating a large <a id="I_indexterm3_id305332" class="indexterm"/><a id="I_indexterm3_id305341" class="indexterm"/>balloon.</p></div><div class="sect1" title="Springs and Dampers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="springs_and_dampers">Springs and Dampers</h2></div></div></div><p>Springs are <a id="I_indexterm3_id305365" class="indexterm"/><a id="I_indexterm3_id305375" class="indexterm"/>structural elements that, when connected between two objects, apply equal and
      opposite forces to each object. This spring force follows <a id="I_indexterm3_id305388" class="indexterm"/>Hooke’s law and is a function of the stretched or compressed length of the spring
      relative to the rest length of the spring and the spring constant of the spring. Hooke’s law
      states that the amount of stretch or compression is directly proportional to the force being
      applied. The spring <a id="I_indexterm3_id305397" class="indexterm"/>constant is a quantity that relates the force exerted by the spring to its
      deflection:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>s</sub> = k<sub>s</sub> (L – r)</td></tr></table><p>Here, <span class="emphasis"><em>F</em></span><sub>s</sub> is the spring force,
        <span class="emphasis"><em>k</em></span><sub>s</sub> is the spring constant,
        <span class="emphasis"><em>L</em></span> is the stretched or compressed length of the spring, and
        <span class="emphasis"><em>r</em></span> is the rest length of the spring. In the metric system of units,
        <span class="emphasis"><em>F</em></span><sub>s</sub> would be measured in newtons (1 N = 1
        kg-m/s<sup>2</sup>), <span class="emphasis"><em>L</em></span> and <span class="emphasis"><em>r</em></span> in
      meters, and <span class="emphasis"><em>k</em></span><sub>s</sub> in
      kg/s<sup>2</sup>. If the spring is connected between two objects, it exerts a
      force of <span class="emphasis"><em>F</em></span><sub>s</sub> on one object and
        –<span class="emphasis"><em>F</em></span><sub>s</sub> on the other; these<a id="I_indexterm3_id305492" class="indexterm"/><a id="I_indexterm3_id305502" class="indexterm"/><a id="I_indexterm3_id305511" class="indexterm"/> are <span class="emphasis"><em>equal and opposite</em></span> forces.</p><p>Dampers are usually <a id="I_indexterm3_id305523" class="indexterm"/>used in conjunction with springs in numerical simulations. They act like viscous
      drag in that they act against velocity. In this case, if the damper is connected between two
      objects that are moving toward or away from each other, the damper acts to slow the relative
      velocity between the two objects. The force developed by a damper is proportional to the
      relative velocity of the connected objects and a damping constant,
        <span class="emphasis"><em>k</em></span><sub>d</sub>, that relates relative velocity to damping
      force.</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>d</sub> = k<sub>d</sub> (v<sub>1</sub> –
          v<sub>2</sub>)</td></tr></table><p>This equation shows the <a id="I_indexterm3_id305573" class="indexterm"/>damping force, <span class="emphasis"><em>F</em></span><sub>d</sub>, as a function of
      the damping constant and the relative velocity of the connected points on the two connected
      bodies. In metric units, where the damping force is measured in newtons and velocity in m/s,
        <span class="emphasis"><em>k</em></span><sub>d</sub> has units of kg/s.</p><p>Typically, springs and dampers are combined into a single spring-damper element, where a
      single formula represents the combined force. Using vector notation, we can write the formula
      for a <a id="I_indexterm3_id305603" class="indexterm"/>spring-damper element connecting two bodies as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>1</sub> =
          –{k<sub>s</sub> (L – r) + k<sub>d</sub> ((<span class="strong"><strong>v</strong></span><sub>1</sub> – <span class="strong"><strong>v</strong></span><sub>2</sub>) • <span class="strong"><strong>L</strong></span>)/L}
          <span class="strong"><strong>L</strong></span>/L</td></tr></table><p>Here, <span class="strong"><strong>F</strong></span><sub>1</sub> is the force exerted on
      body 1, while the force, <span class="strong"><strong>F</strong></span><sub>2</sub>, exerted
      on body 2 is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>2</sub> = –<span class="strong"><strong>F</strong></span><sub>1</sub></td></tr></table><p><span class="strong"><strong>L</strong></span> is the length of the spring-damper
        (<span class="emphasis"><em>L</em></span>, not in bold print, is the magnitude of the vector <span class="strong"><strong>L</strong></span>), which is equal to the vector difference in position between the
      connected points on bodies 1 and 2. If the connected objects are particles, then <span class="strong"><strong>L</strong></span> is equal to the position of body 1 minus the position of body 2.
      Similarly, <span class="strong"><strong>v</strong></span><sub>1</sub> and <span class="strong"><strong>v</strong></span><sub>2</sub> are the velocities of the connected
      points on bodies 1 and 2. The quantity (<span class="strong"><strong>v</strong></span><sub>1</sub> – <span class="strong"><strong>v</strong></span><sub>2</sub>) represents the relative velocity between the
      connected bodies.</p><p>Springs and dampers are useful when you want to <a id="I_indexterm3_id305773" class="indexterm"/><a id="I_indexterm3_id305785" class="indexterm"/><a id="I_indexterm3_id305795" class="indexterm"/>simulate collections of connected particles or rigid bodies. The spring force
      provides the structure, or glue, that holds the bodies together (or keeps them separated by a
      certain distance), while the damper helps smooth out the motion between the connected bodies
      so it’s not too jerky or springy. These dampers are also very important from a numerical
      stability point of view in that they help keep your simulations from blowing up. We’re getting
      a little ahead of ourselves here, but we’ll show you how to use these spring-dampers in
      real-time simulations in <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>.</p></div><div class="sect1" title="Force and Torque"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="force_and_torque">Force and Torque</h2></div></div></div><p>We need to make the <a id="fo3.8" class="indexterm"/><a id="to3.8" class="indexterm"/>distinction here between force and torque.<sup>[<a id="CHP-3-FN-4" href="#ftn.CHP-3-FN-4" epub:type="noteref" class="footnote">12</a>]</sup> Force is what causes <a id="I_indexterm3_id305877" class="indexterm"/><a id="I_indexterm3_id305887" class="indexterm"/><a id="I_indexterm3_id305897" class="indexterm"/><a id="I_indexterm3_id305907" class="indexterm"/><a id="I_indexterm3_id305917" class="indexterm"/><a id="I_indexterm3_id305926" class="indexterm"/>linear acceleration, while <a id="I_indexterm3_id305934" class="indexterm"/>torque is what causes rotational acceleration. Torque is force times distance.
      Specifically, to calculate the <a id="I_indexterm3_id305946" class="indexterm"/>torque applied by a force acting on an object, you need to calculate the
      perpendicular distance from the axis of rotation to the line of action of the force and then
      multiply this distance by the magnitude of the force.</p><p>This calculation gives the magnitude of the torque. Typical units for force are pounds,
      newtons, and tons. Since torque is force times a distance, its units take the form of a length
      unit times a force unit (e.g., foot-pounds, newton-meters, or foot-tons).</p><p>Since both force and torque are vector quantities, you must also determine the direction
      of the torque vector. The force vector is easy to visualize: its line of action passes through
      the point of application of the force, with its direction determined by the direction in which
      the force is applied. As a vector, the torque’s line of action is along the axis of rotation,
      with the direction determined by the <a id="I_indexterm3_id305973" class="indexterm"/>direction of rotation and <a id="I_indexterm3_id305986" class="indexterm"/>the <span class="emphasis"><em>right hand rule</em></span> (see <a class="xref" href="ch03.html#force_and_torque-id1" title="Figure 3-3. Force and torque">Figure 3-3</a>). As noted in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, the right hand rule is a simple trick to help
      you keep track of vector directions—in this case, the torque vector. Pretend to curl the
      fingers of your right hand around the axis of rotation with your fingertips pointing in the
      direction of rotation. Now extend your thumb, as though you are giving a thumbs up, while
      keeping your fingers curled around the axis. The direction that your thumb is pointing
      indicates the direction of the torque vector. Note that this makes the torque vector
      perpendicular to the applied force vector, as shown in <a class="xref" href="ch03.html#force_and_torque-id1" title="Figure 3-3. Force and torque">Figure 3-3</a>.</p><div class="figure"><a id="force_and_torque-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id306026"/><img src="httpatomoreillycomsourceoreillyimages1598899.png" alt="Force and torque"/></div></div><div class="figure-title">Figure 3-3. Force and torque</div></div><p>We said earlier that you find the magnitude of <a id="I_indexterm3_id306047" class="indexterm"/><a id="I_indexterm3_id306057" class="indexterm"/>torque by multiplying the magnitude of the applied force times the perpendicular
      distance between the axis of rotation and the line of action of the force. This calculation is
      easy to perform in two dimensions where the perpendicular distance (<span class="emphasis"><em>d</em></span> in
        <a class="xref" href="ch03.html#force_and_torque-id1" title="Figure 3-3. Force and torque">Figure 3-3</a>) is readily calculable.</p><p>However, in three dimensions you’ll want to be able to calculate torque by knowing only
      the force vector and the coordinates of its point of application on the body relative to the
      axis of rotation. You can accomplish this by using the following formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M</strong></span> = <span class="strong"><strong>r</strong></span> ×
          <span class="strong"><strong>F</strong></span></td></tr></table><p>The torque, <span class="strong"><strong>M</strong></span>, is the vector cross product of the
      position vector, <span class="strong"><strong>r</strong></span>, and the force vector, <span class="strong"><strong>F</strong></span>.</p><p>In rectangular coordinates you can write the distance, force, and torque vectors as
      follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>r</strong></span> = x <span class="strong"><strong>i</strong></span> + y
          <span class="strong"><strong>j</strong></span> + z <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>F</strong></span> = F<sub>x</sub>
        <span class="strong"><strong>i</strong></span> + F<sub>y</sub>
        <span class="strong"><strong>j</strong></span> + F<sub>z</sub>
        <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>M</strong></span> = M<sub>x</sub>
        <span class="strong"><strong>i</strong></span> + M<sub>y</sub>
        <span class="strong"><strong>j</strong></span> + M<sub>z</sub>
        <span class="strong"><strong>k</strong></span></td></tr></table><p>The scalar components of <span class="strong"><strong>r</strong></span> (<span class="emphasis"><em>x</em></span>,
        <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>) are the coordinate distances from the
      axis of rotation to the point of application of the force, <span class="strong"><strong>F</strong></span>. The scalar components of the torque vector, <span class="strong"><strong>M</strong></span>, are defined by the following:</p><table style="border: 0; " class="simplelist"><tr><td>M<sub>x</sub> = y F<sub>z</sub> – z
        F<sub>y</sub></td></tr><tr><td>M<sub>y</sub> = z F<sub>x</sub> – x
        F<sub>z</sub></td></tr><tr><td>M<sub>z</sub> = x F<sub>y</sub> – y
        F<sub>x</sub></td></tr></table><p>Consider the rigid body shown in <a class="xref" href="ch03.html#torque_example" title="Figure 3-4. Torque example">Figure 3-4</a> acted upon by the force
        <span class="strong"><strong>F</strong></span> at a point away from the body’s center of mass.</p><div class="figure"><a id="torque_example"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id306350"/><img src="httpatomoreillycomsourceoreillyimages1598900.png" alt="Torque example"/></div></div><div class="figure-title">Figure 3-4. Torque example</div></div><p>In this example <span class="strong"><strong>F</strong></span>, <span class="emphasis"><em>a</em></span>, and
        <span class="emphasis"><em>b</em></span> are given and are as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span> = (−90 lbs) <span class="strong"><strong>i</strong></span>
        + (156 lbs) <span class="strong"><strong>j</strong></span> + (0) <span class="strong"><strong>k</strong></span></td></tr><tr><td>a = 0.66 ft</td></tr><tr><td>b = 0.525 ft</td></tr></table><p>Calculate the torque about the body’s center of mass due to the force <span class="strong"><strong>F</strong></span>.</p><p>The first step is to put together the distance vector from the point of application of
        <span class="strong"><strong>F</strong></span> to the body’s center of mass. Since the local
      coordinates <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span> are given, <span class="strong"><strong>r</strong></span> is simply:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>r</strong></span> = (0.66 ft) <span class="strong"><strong>i</strong></span>
        + (0.525 ft) <span class="strong"><strong>j</strong></span> + (0) <span class="strong"><strong>k</strong></span></td></tr></table><p>Now using the formula <span class="strong"><strong>M</strong></span> = <span class="strong"><strong>r</strong></span> × <span class="strong"><strong>F</strong></span> (or the formulas for the components of
      the torque vector shown earlier), you can write:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M</strong></span> = [(0.66 ft) <span class="strong"><strong>i</strong></span>
        + (0.525 ft) <span class="strong"><strong>j</strong></span> + (0) <span class="strong"><strong>k</strong></span>] × [(−90 lbs) <span class="strong"><strong>i</strong></span> + (156 lbs) <span class="strong"><strong>j</strong></span> + (0) <span class="strong"><strong>k</strong></span>]</td></tr><tr><td><span class="strong"><strong>M</strong></span> = [(0.66 ft) (156 lbs) – (0.525 ft) (−90 lbs)]
          <span class="strong"><strong>k</strong></span></td></tr><tr><td><span class="strong"><strong>M</strong></span> = (150.2 ft-lbs) <span class="strong"><strong>k</strong></span></td></tr></table><p>Note that the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> components of the torque
      vector are 0; thus, the torque moment is pointing directly along the z-axis. The torque vector
      would be pointing out of the page of this book in this case.</p><p>In dynamics you need to consider the sum, or total, of all forces acting on an object
      separately from the sum of all torques acting on a body. When summing forces, you simply add,
      vectorally, all of the forces without regard to their point of application. However, when
      summing torques you must take into account the point of application of the forces to calculate
      the torques, as shown in the previous example. Then you can take the vector sum of all torques
      acting on the body.</p><p>When you are considering rigid bodies that are not physically constrained to rotate about
      a fixed axis, any force acting through <a id="I_indexterm3_id306615" class="indexterm"/>the body’s center of mass will not produce a torque on the body about its center
      of gravity. In this case, the axis of rotation passes through the center of mass of the body
      and the vector <span class="strong"><strong>r</strong></span> would be 0 (all components 0). When a
      force acts through a point on the body some distance away from its center of mass, a torque on
      the body will develop, and the angular motion of the body will be affected. Generally, <a id="I_indexterm3_id306636" class="indexterm"/><a id="I_indexterm3_id306646" class="indexterm"/>field forces, which are forces at a distance, are assumed to act through a body’s
      center of mass; thus, only the body’s linear motion will be affected unless the body is
      constrained to rotate about a fixed point. Other contact forces, however, generally do not act
      through a body’s center of mass (they could but aren’t necessarily assumed to) and tend to
      affect the body’s angular motion as well as its <a id="I_indexterm3_id306660" class="indexterm"/><a id="I_indexterm3_id306668" class="indexterm"/>linear motion.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary">Summary</h2></div></div></div><p>As we said earlier, this chapter on forces is your bridge from kinematics to kinetics.
      Here you’ve looked at the major force categories—contact forces and force fields—and some
      important specific types of forces. This chapter was meant to give you enough theoretical
      background on forces so you can fully appreciate the subject of kinetics that’s covered in the
      next chapter. In <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a> through <a class="xref" href="ch19.html" title="Chapter 19. Sports">Chapter 19</a>, you’ll revisit the subject of forces from a
      much more practical point of view when we investigate specific real-life problems. We’ll also
      introduce some new specific types of force in those chapters that we didn’t cover here.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-3-FN-1"><p><sup>[<a href="#CHP-3-FN-1" class="para">9</a>] </sup><span class="emphasis"><em>Static</em></span> here implies that there is no motion; the block is sitting
          still with all forces balancing.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-3-FN-2"><p><sup>[<a href="#CHP-3-FN-2" class="para">10</a>] </sup>The term <span class="emphasis"><em>dynamic</em></span> is sometimes used here instead of
            <span class="emphasis"><em>kinetic</em></span>.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-3-FN-3"><p><sup>[<a href="#CHP-3-FN-3" class="para">11</a>] </sup>Specific weight is density times the acceleration due to gravity. Typical units are
            lbs/ft<sup>3</sup> and N/m<sup>3</sup>.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-3-FN-4"><p><sup>[<a href="#CHP-3-FN-4" class="para">12</a>] </sup>Another common term for torque is <span class="emphasis"><em>moment</em></span>.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 4. Kinetics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch03.html" title="Chapter 3. Force"/><link rel="next" href="ch05.html" title="Chapter 5. Collisions"/></head><body><section class="chapter" title="Chapter 4. Kinetics" epub:type="chapter" id="kinetics"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Kinetics</h2></div></div></div><p>Recall that kinetics is the study of <a id="ki4.0" class="indexterm"/>the motion of bodies, including the forces that act on them.
  It’s now time that we combine the material presented in the earlier
  chapters—namely, kinematics and forces—to study the subject of kinetics. As
  in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> on kinematics, we’ll first discuss particle
  kinetics and then go on to discuss rigid-body kinetics.</p><p>In kinetics, the most important equation that you must <a id="I_indexterm4_id306742" class="indexterm"/>consider is Newton’s second law:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span> = m<span class="strong"><strong>a</strong></span></td></tr></table><p>When rigid bodies are involved, you must also consider that the forces
  acting on the body will tend to cause rotation of the body in addition to
  translation. The basic relationship here is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>M</strong></span><sub>cg</sub> =
    <span class="strong"><strong>I α</strong></span></td></tr></table><p>where <span class="strong"><strong>M</strong></span><sub>cg</sub> is
  the vector sum of all moments (torques) acting on the body, <span class="strong"><strong>I</strong></span> is the body moment of inertia tensor, and
  <span class="strong"><strong>α</strong></span> is the angular acceleration.</p><p>Collectively, these two equations are referred to as <a id="I_indexterm4_id306828" class="indexterm"/>the <span class="emphasis"><em>equations of motion</em></span>.</p><p>There are two types of problems that you will encounter in kinetics. One type is where you
    know the force(s) acting on the body, or you can estimate them, and you must solve for the
    resulting acceleration of the body (and subsequently its velocity and displacement). Another
    type is where you know the body’s acceleration, or can readily determine it using kinematics,
    and you must solve for the force(s) acting on the body.</p><p>This chapter will primarily discuss the first type of problem, where you know the force(s)
    acting on the body, which is more common to in-game physics. The second type of problem has
    become important with the advent of motion-based controllers such as the Sony SixAxis and
    Nintendo Wii Remote. These controllers rely <a id="I_indexterm4_id306859" class="indexterm"/><a id="I_indexterm4_id306868" class="indexterm"/>on <span class="emphasis"><em>digital accelerometers</em></span> to directly measure the acceleration
    of a controller. While this is most often used to find the controller’s orientation, it is also
    possible to integrate the time history of these sensor values to determine velocity and
    position. Additionally, if you know the mass of the controller or device, you can find the
    force. Accelerometers are found in most smartphones as well, which also allows for the use of
    kinematic-based input. So as to not confuse the two types of problems, we’ll discuss the second
    type, with the acceleration as input, in detail in <a class="xref" href="ch21.html" title="Chapter 21. Accelerometers">Chapter 21</a>.</p><p>Let us stress that you must consider the sum of
  <span class="emphasis"><em>all</em></span> of the forces acting on the body when solving
  kinetics problems. These include all applied forces and all reaction forces.
  Aside from the computational difficulties of solving the equations of
  motion, one of the more challenging aspects of kinetics is identifying and
  properly accounting for all of these forces. In later chapters, you’ll look
  at specific problems where we’ll investigate the particular forces involved.
  <a id="I_indexterm4_id306900" class="indexterm"/>For now, and for the purpose of generality, let’s stick with
  the idealized forces introduced in the previous chapter.</p><p>Here is the general procedure for solving kinetics problems of
  interest to us:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Calculate the body’s mass properties (mass, center of mass, and
      moment of inertia).</p></li><li class="listitem"><p>Identify and quantify all forces and moments acting on the
      body.</p></li><li class="listitem"><p>Take the vector sum of all forces and moments.</p></li><li class="listitem"><p>Solve the equations of motion for linear and angular
      accelerations.</p></li><li class="listitem"><p>Integrate with respect to time to find linear and angular
      velocity.</p></li><li class="listitem"><p>Integrate again with respect to time to find linear and angular
      displacement.</p></li></ol></div><p>This outline makes the solution to kinetics problems seem easier than
  it actually is because there are a number of complicating factors that
  you’ll have to overcome. For example, in many cases the forces acting on a
  body are functions of displacement, velocity, or acceleration. This means
  that you’ll have to use iterative techniques in order to solve the equations
  of motion. Further, since you most likely will not be able to derive
  closed-form solutions for acceleration, you’ll have to numerically integrate
  in order to estimate velocity and displacement at each instant of time under
  consideration. These computational aspects will be addressed <a id="I_indexterm4_id306982" class="indexterm"/>further in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> through
  <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>.</p><div class="sect1" title="Particle Kinetics in 2D"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="particle_kinetics_in_2d">Particle Kinetics in 2D</h2></div></div></div><p>As in particle <a id="ki4.1" class="indexterm"/><a id="pa4.1" class="indexterm"/><a id="tw4.1" class="indexterm"/>kinematics, in particle kinetics you need to consider only
    the linear motion of the particle. Thus, the equations of motion will
    consist of equations of the form <span class="strong"><strong>F</strong></span> =
    <span class="emphasis"><em>m</em></span><span class="strong"><strong>a</strong></span>, where motion
    in each coordinate direction will have its own equation. The equations for
    2D particle motion are:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF<sub>x</sub> = m
      a<sub>x</sub></td></tr><tr><td>ΣF<sub>y</sub> = m
      a<sub>y</sub></td></tr></table><p>where ΣF<sub>x</sub> means the sum of all forces in the
    x-direction, ΣF<sub>y</sub> means the sum of all forces in the
    y-direction, a<sub>x</sub> is the acceleration in the
    x-direction, and a<sub>y</sub> is the acceleration in the
    y-direction.</p><p>The resultant force and acceleration vectors are:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span> = a<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + a<sub>y</sub>
      <span class="strong"><strong>j</strong></span></td></tr></table><div class="informalequation"><div class="mediaobject"><img src="eq_0401.png" alt="Particle Kinetics in 2D"/></div></div><table style="border: 0; " class="simplelist"><tr><td>Σ<span class="strong"><strong>F</strong></span> =
      ΣF<sub>x</sub> <span class="strong"><strong>i</strong></span> +
      ΣF<sub>y</sub> <span class="strong"><strong>j</strong></span></td></tr><tr><td>ΣF =   
      <span class="inlinemediaobject"><img src="inleq_0402.png" alt=""/></span>
      </td></tr></table><p>Let’s look at an example that appears simple but demonstrates the
    complexity of finding closed-form solutions. <a id="sh4.1" class="indexterm"/>A ship floating in water, initially at rest, starts up its
    propeller generating a thrust, <span class="emphasis"><em>T</em></span>, which starts the
    ship moving forward. Assume that the ship’s forward speed is slow and the
    <a id="I_indexterm4_id307254" class="indexterm"/>resistance to its motion can be approximated by:</p><table style="border: 0; " class="simplelist"><tr><td>R = –C v</td></tr></table><p>where <span class="emphasis"><em>R</em></span> is the total resistance,
    <span class="emphasis"><em>C</em></span> is a drag coefficient, <span class="emphasis"><em>v</em></span> is
    the ship speed, and the minus sign indicates that this resistive force
    opposes the forward motion of the ship. Find formulas for the ship’s
    speed, acceleration, and distance traveled as functions of time, assuming
    that the propeller thrust and resistance force vectors act on a line of
    action passing through the ship’s center of gravity. This assumption lets
    you treat the ship as a particle instead of a rigid body.</p><p>The first step in solving this problem is to identify all of the
    forces acting on the ship. <a class="xref" href="ch04.html#free-body_diagram_of_ship" title="Figure 4-1. Free-body diagram of ship">Figure 4-1</a>
    shows a <span class="emphasis"><em>free-body diagram</em></span> of the ship with all of the
    forces acting on it—namely, the propeller thrust, <span class="emphasis"><em>T</em></span>;
    resistance, <span class="emphasis"><em>R</em></span>; the ship’s weight,
    <span class="emphasis"><em>W</em></span>; and buoyancy, <span class="emphasis"><em>B</em></span>.</p><div class="figure"><a id="free-body_diagram_of_ship"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id307335"/><img src="httpatomoreillycomsourceoreillyimages1598901.png" alt="Free-body diagram of ship"/></div></div><div class="figure-title">Figure 4-1. Free-body diagram of ship</div></div><p>Notice here that the buoyancy force is exactly equal in magnitude to
    the ship’s weight and opposite in direction; thus, these forces cancel
    each other out and there will be no motion in the y-direction. This must
    be the case if the ship is to stay afloat. This observation effectively
    reduces the problem to a one-dimensional problem with motion in the
    x-direction, only where the forces acting in the x-direction are the
    propeller thrust and resistance.</p><p>Now you can write the equation (for motion in the x-direction) <a id="I_indexterm4_id307363" class="indexterm"/><a id="eq4.1" class="indexterm"/>using Newton’s second law, as follows:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF = m a</td></tr><tr><td>T – R = m a</td></tr><tr><td>T – (C v) = m a</td></tr></table><p>Where <span class="emphasis"><em>a</em></span> is the acceleration in the x-direction,
    and <span class="emphasis"><em>v</em></span> is the speed in the x-direction.</p><p>The next step is to integrate this equation of motion in order to
    derive a formula for the speed of the ship as a function of time. To do
    this, you must make the substitution <span class="emphasis"><em>a</em></span> =
    <span class="emphasis"><em>dv</em></span>/<span class="emphasis"><em>dt</em></span>, rearrange, integrate,
    <a id="I_indexterm4_id307434" class="indexterm"/>and then solve for speed as follows:</p><table style="border: 0; " class="simplelist"><tr><td>T – (C v) = m (dv/dt)</td></tr><tr><td>dt = (m / (T–Cv)) dv</td></tr><tr><td>∫<sub>(0 to t)</sub> dt = ∫<sub>(v1 to v2)</sub> (m / (T–Cv))
        dv</td></tr><tr><td>t – 0 = –(m/C) ln(T–Cv) | <sub>(v1 to v2)</sub></td></tr><tr><td>t = –(m/C) ln(T–Cv<sub>2</sub>) + (m/C)
        ln(T–Cv<sub>1</sub>)</td></tr><tr><td>t = (m/C) [ln(T–Cv<sub>1</sub>) –
        ln(T–Cv<sub>2</sub>)]</td></tr><tr><td>(C/m) t = ln [(T–Cv<sub>1</sub>) /
        (T–Cv<sub>2</sub>)]</td></tr><tr><td>e<sup>(C/m) t</sup> = e <sup>ln [(T–Cv1) /
          (T–Cv2)]</sup></td></tr><tr><td>e<sup>(C/m) t</sup> = (T–Cv<sub>1</sub>) /
          (T–Cv<sub>2</sub>)</td></tr><tr><td>(T–Cv<sub>2</sub>) = (T–Cv<sub>1</sub>)
          e<sup>–(C/m)t</sup></td></tr><tr><td>v<sub>2</sub> = (T/C) – e<sup>–(C/m) t</sup> (T/C –
          v<sub>1</sub>)</td></tr></table><p>where <span class="emphasis"><em>v</em></span><sub>1</sub> is the initial
    ship speed (which is constant) and
    <span class="emphasis"><em>v</em></span><sub>2</sub> is the ship speed at time
    <span class="emphasis"><em>t</em></span>. <span class="emphasis"><em>v</em></span><sub>2</sub> is
    what you’re after here, since it tells you how fast the ship is traveling
    at any instant of time.</p><p>Now that you have an equation for speed as a function of time, you
    can derive an equation for <a id="I_indexterm4_id307595" class="indexterm"/>displacement (distance traveled, in this case) as a function
    of time. Here, you’ll have to recall the formula <span class="emphasis"><em>v dt</em></span>
    = <span class="emphasis"><em>ds</em></span>, substitute the previous formula for speed,
    integrate, rearrange, and solve for distance traveled. These steps are
    shown here:</p><table style="border: 0; " class="simplelist"><tr><td>v dt = ds</td></tr><tr><td>v<sub>2</sub> dt = ds</td></tr><tr><td>((T/C) – e<sup>–(C/m) t</sup> (T/C –
      v<sub>1</sub>)) dt = ds</td></tr><tr><td>∫<sub>(0 to t)</sub> (T/C) – e<sup>–(C/m)
      t</sup> (T/C – v<sub>1</sub>) dt = ∫<sub>(s1
      to s2)</sub> ds</td></tr><tr><td>(T/C) ∫<sub>(0 to t)</sub> dt – (T/C –
      v<sub>1</sub>) ∫<sub>(0 to t)</sub>
      e<sup>–(C/m) t</sup> dt = s<sub>2</sub> –
      s<sub>1</sub></td></tr><tr><td>[(T/C) t + ((T/C) – v<sub>1</sub>)(m/C)
      e<sup>–(C/m) t</sup>] <sub>(0 to t)</sub> =
      s<sub>2</sub> – s<sub>1</sub></td></tr><tr><td>[(T/C) t + ((T/C) – v<sub>1</sub>)(m/C)
      e<sup>–(C/m) t</sup>] – [0 + ((T/C) –
      v<sub>1</sub>)(m/C)] = s<sub>2</sub> –
      s<sub>1</sub></td></tr><tr><td>(T/C) t + (T/C – v<sub>1</sub>) (m/C)
      e<sup>–(C/m) t</sup> – (T/C – v<sub>1</sub>)
      (m/C) = s<sub>2</sub> – s<sub>1</sub></td></tr><tr><td>s<sub>2</sub> = s<sub>1</sub> + (T/C) t
      + (T/C – v<sub>1</sub>) (m/C) e<sup>–(C/m)
      t</sup> – (T/C – v<sub>1</sub>) (m/C)</td></tr></table><p>Finally you can write an equation for <a id="I_indexterm4_id307778" class="indexterm"/>acceleration by going back to the original equation of
    motion and solving for acceleration:</p><table style="border: 0; " class="simplelist"><tr><td>T – (C v) = m a</td></tr><tr><td>a = (T – (C v)) / m</td></tr></table><p>where:</p><table style="border: 0; " class="simplelist"><tr><td>v = v<sub>2</sub> = (T/C) – e<sup>–(C/m)
      t</sup> (T/C – v<sub>1</sub>)</td></tr></table><p>In summary, the equations for velocity, distance traveled, and
    acceleration are as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = (T/C) – e<sup>–(C/m)
      t</sup> (T/C – v<sub>1</sub>)</td></tr><tr><td>s<sub>2</sub> = s<sub>1</sub> + (T/C) t
      + (T/C – v<sub>1</sub>) (m/C) e<sup>–(C/m)
      t</sup> – (T/C – v<sub>1</sub>) (m/C)</td></tr><tr><td>a = (T – (C v)) / m</td></tr></table><p>To illustrate the motion of the ship further, we’ve plotted the
    ship’s speed, distance traveled, and acceleration versus time, as shown in
    <a class="xref" href="ch04.html#speed_versus_time" title="Figure 4-2. Speed versus time">Figure 4-2</a>, <a class="xref" href="ch04.html#distance_versus_time" title="Figure 4-3. Distance versus time">Figure 4-3</a>, and <a class="xref" href="ch04.html#acceleration_versus_time" title="Figure 4-4. Acceleration versus time">Figure 4-4</a>. To facilitate these illustrations,
    we’ve assumed the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The initial ship speed and displacement are 0 at time 0.</p></li><li class="listitem"><p>The propeller thrust is 20,000 thrust units.</p></li><li class="listitem"><p>The ship’s mass is 10,000 mass units.</p></li><li class="listitem"><p>The drag coefficient is 1,000.</p></li></ul></div><div class="figure"><a id="speed_versus_time"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id307946"/><img src="httpatomoreillycomsourceoreillyimages1598902.png" alt="Speed versus time"/></div></div><div class="figure-title">Figure 4-2. Speed versus time</div></div><div class="figure"><a id="distance_versus_time"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id307974"/><img src="httpatomoreillycomsourceoreillyimages1598903.png" alt="Distance versus time"/></div></div><div class="figure-title">Figure 4-3. Distance versus time</div></div><div class="figure"><a id="acceleration_versus_time"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id308003"/><img src="httpatomoreillycomsourceoreillyimages1598904.png" alt="Acceleration versus time"/></div></div><div class="figure-title">Figure 4-4. Acceleration versus time</div></div><p>You’ll notice that the ship’s speed approaches <a id="I_indexterm4_id308024" class="indexterm"/><a id="I_indexterm4_id308034" class="indexterm"/><a id="I_indexterm4_id308044" class="indexterm"/><a id="I_indexterm4_id308054" class="indexterm"/>the steady state speed of 20 speed units, assuming that the
    propeller thrust remains constant. This corresponds to a reduction in
    acceleration from a maximum acceleration at time 0 to no acceleration once
    the steady speed is achieved.</p><p>This example illustrates how to set up the differential equations of
    motion and integrate them to find velocity, displacement, and
    acceleration. In this case, you were able to find a closed-form
    solution—that is, you were able to integrate the equations symbolically to
    derive new ones. You could do this because we imposed enough constraints
    on the problem to make it manageable. But you can readily see that if
    there were more forces acting on the ship, or if the thrust were not held
    constant but was some function of speed, or if the resistance were a
    function of speed squared, and so on, the problem gets increasingly
    complicated—making a closed-form solution much more difficult, if not
    <a id="I_indexterm4_id308076" class="indexterm"/><a id="I_indexterm4_id308086" class="indexterm"/><a id="I_indexterm4_id308095" class="indexterm"/><a id="I_indexterm4_id308105" class="indexterm"/><a id="I_indexterm4_id308114" class="indexterm"/>impossible.</p></div><div class="sect1" title="Particle Kinetics in 3D"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="particle_kinetics_in_3d">Particle Kinetics in 3D</h2></div></div></div><p>As in kinematics, <a id="ki4.2" class="indexterm"/><a id="pa4.2" class="indexterm"/><a id="th4.2" class="indexterm"/><a id="I_indexterm4_id308188" class="indexterm"/>extending the equations of motion for a particle to three
    dimensions is easy to do. You simply need to add one more component and
    will end up with three equations as follows:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF<sub>x</sub> = m
      a<sub>x</sub></td></tr><tr><td>ΣF<sub>y</sub> = m
      a<sub>y</sub></td></tr><tr><td>ΣF<sub>z</sub> = m
      a<sub>z</sub></td></tr></table><p>The resultant force and acceleration vectors are now:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>a</strong></span> = a<sub>x</sub>
      <span class="strong"><strong>i</strong></span> + a<sub>y</sub>
      <span class="strong"><strong>j</strong></span> + a<sub>z</sub>
      <span class="strong"><strong>k</strong></span></td></tr><tr><td>a = 
        <span class="inlinemediaobject"><img src="inleq_0403.png" alt=""/></span>
      </td></tr><tr><td>Σ<span class="strong"><strong>F</strong></span> =
      ΣF<sub>x</sub> <span class="strong"><strong>i</strong></span> +
      ΣF<sub>y</sub> <span class="strong"><strong>j</strong></span> +
      ΣF<sub>z</sub> <span class="strong"><strong>k</strong></span></td></tr><tr><td>ΣF = 
        <span class="inlinemediaobject"><img src="inleq_0404.png" alt=""/></span>
      </td></tr></table><p>To hammer these concepts home, we want to present another
    example.</p><p>Let’s go back to the cannon example <a id="sh4.2" class="indexterm"/><a id="the4.2" class="indexterm"/>program discussed in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. In that
    example, we made some simplifying assumptions so we could focus on the
    kinematics of the problem without complicating it too much. One of the
    more significant assumptions we made was that there was no drag acting on
    the projectile as it flew through the air. Physically, this would be valid
    only if the projectile were moving through a vacuum, which, of course, is
    unlikely here on Earth. Another significant assumption we made was that
    there was no wind to act on the projectile and affect its course. These
    two considerations, drag and wind, are important in real-life projectile
    problems, so to make this example a little more interesting—and more
    challenging to the user if this were an actual game—we’ll add these two
    considerations now.</p><p>First, assume that the projectile is a sphere and the drag force
    acting on it as it flies through the air is a function of some drag
    coefficient and the speed of the projectile. This drag force <a id="I_indexterm4_id308408" class="indexterm"/>can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>d</sub> =
      –C<sub>d</sub> <span class="strong"><strong>v</strong></span></td></tr><tr><td><span class="strong"><strong>F</strong></span><sub>d</sub> =
      –C<sub>d</sub> v<sub>x</sub> <span class="strong"><strong>i</strong></span> – C<sub>d</sub>
      v<sub>y</sub> <span class="strong"><strong>j</strong></span> –
      C<sub>d</sub> v<sub>z</sub> <span class="strong"><strong>k</strong></span></td></tr></table><p>where <span class="emphasis"><em>C</em></span><sub>d</sub> is the drag
    coefficient, <span class="emphasis"><em>v</em></span> is the velocity of the projectile
    (<span class="emphasis"><em>v</em></span><sub>x</sub>,
    <span class="emphasis"><em>v</em></span><sub>y</sub>, and
    <span class="emphasis"><em>v</em></span><sub>z</sub> are its components), and
    the minus sign means that this drag force opposes the projectile’s motion.
    Actually, we’re cheating a bit here since in reality the fluid dynamic
    drag would be more a function of speed squared. We’re doing this here to
    facilitate a closed-form solution. Also, the drag coefficient here would
    be determined experimentally for each shape. Later, we’ll discuss how
    experimental data is used on basic shapes to give data for similar
    ships.</p><p>Second, assume that the projectile is subjected to a blowing wind,
    the force of which is a function of some drag coefficient and the wind
    speed. This force can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>w</sub> =
      –C<sub>w</sub> <span class="strong"><strong>v</strong></span><sub>w</sub></td></tr><tr><td><span class="strong"><strong>F</strong></span><sub>w</sub> =
      –C<sub>w</sub> <span class="strong"><strong>v</strong></span><sub>wx</sub> <span class="strong"><strong>i</strong></span> – C<sub>w</sub> <span class="strong"><strong>v</strong></span><sub>wz</sub> <span class="strong"><strong>k</strong></span></td></tr></table><p>where <span class="emphasis"><em>C</em></span><sub>w</sub> is the drag
    coefficient, <span class="emphasis"><em>v</em></span><sub>w</sub> is the wind
    speed, and the minus sign means that this force opposes the projectile’s
    motion when the wind is blowing in a direction opposite of the
    projectile’s direction of motion. When the wind is blowing with the
    projectile—say, from behind it—then the wind will actually help the
    projectile along instead of impede its motion. In general,
    <span class="emphasis"><em>C</em></span><sub>w</sub> is not necessarily equal to
    the <span class="emphasis"><em>C</em></span><sub>d</sub> shown in the drag
    formula. Referring to <a class="xref" href="ch02.html#a_3d_kinematics_example_problem" title="Figure 2-3. A 3D kinematics example problem">Figure 2-3</a>,
    we’ll define the wind direction <a id="I_indexterm4_id308651" class="indexterm"/>as measured by the angle γ. The <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>z</em></span> components of <a id="I_indexterm4_id308669" class="indexterm"/>the wind force can now be written in terms of the wind
    direction, γ, as follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>wx</sub> = F<sub>w</sub> cos γ =
      –(C<sub>w</sub> v<sub>w</sub>) cos γ</td></tr><tr><td>F<sub>wz</sub> = F<sub>w</sub> sin γ =
      –(C<sub>w</sub> v<sub>w</sub>) sin γ</td></tr></table><p>We ignored the y-direction as we assume the wind is flowing parallel
    to the ground. Finally, let’s apply a gravitational force to the
    projectile instead of specifying the effect of gravity as a constant
    acceleration, as we did in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. This allows you
    to include the force due to gravity in the equations of motion. Assuming
    that the projectile is relatively close to sea level, the gravitational
    force can be written as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>g</sub> =
      –m g <span class="strong"><strong>j</strong></span></td></tr></table><p>where the minus sign indicates that it acts in the negative
    y-direction (pulling the projectile toward the earth), and
    <span class="emphasis"><em>g</em></span> on the righthand side of this equation is the
    acceleration due to gravity at sea level.</p><p>Now that all of the forces have been identified, you can write the
    equations of motion in each coordinate direction:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF<sub>x</sub> = F<sub>wx</sub> +
      F<sub>dx</sub> = m (dv<sub>x</sub>/dt)</td></tr><tr><td>ΣF<sub>y</sub> = F<sub>dy</sub> +
      F<sub>gy</sub> = m (dv<sub>y</sub>/dt)</td></tr><tr><td>ΣF<sub>z</sub> = F<sub>wz</sub> +
      F<sub>dz</sub> = m (dv<sub>z</sub>/dt)</td></tr></table><p>Note here that we already made the substitution
    <span class="emphasis"><em>dv</em></span>/<span class="emphasis"><em>dt</em></span> for acceleration in each
    equation. Following the same procedure shown in the previous section, you
    now need to integrate each equation of motion twice—once to find an
    equation for velocity as a function of time, and another to find an
    equation for displacement as a function of time. As before, we’ll show you
    how this is done component by component.</p><p>You might be asking yourself, where’s the thrust force from the
    cannon that propels the projectile in the first place? In this example,
    we’re looking specifically at the motion of the projectile after it has
    left the muzzle of the cannon, where there is no longer a thrust force
    acting on the projectile; it isn’t self-propelled. To account for the
    effect of the cannon thrust force, which acts over a very short period of
    time while the projectile is within the cannon, you have to consider the
    muzzle velocity of the projectile when it initially leaves the cannon. The
    components of the muzzle velocity in the coordinate directions will become
    initial velocities in each direction, and they will be included in the
    equations of motion once they’ve been integrated. The initial velocities
    will show up in the velocity and displacement equations just like they did
    in the example in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. You’ll see this in the
    following <a id="I_indexterm4_id308860" class="indexterm"/>sections.</p><div class="sect2" title="X Components"><div class="titlepage"><div><div><h3 class="title" id="x_components-id1">X Components</h3></div></div></div><p>The first step is <a id="I_indexterm4_id308884" class="indexterm"/>to make the appropriate substitutions for the force terms
      in the equation of motion, and then integrate to find an equation for
      velocity.</p><table style="border: 0; " class="simplelist"><tr><td>–F<sub>wx</sub> – F<sub>dx</sub> =
        m(dv<sub>x</sub>/dt)</td></tr><tr><td>–(C<sub>w</sub> v<sub>w</sub> cos γ) –
        C<sub>d</sub> v<sub>x</sub> = m
        dv<sub>x</sub>/dt</td></tr><tr><td>dt = m dv<sub>x</sub> /
        [–(C<sub>w</sub> v<sub>w</sub> cos γ) –
        C<sub>d</sub> v<sub>x</sub>]</td></tr><tr><td>∫<sub>(0 to t)</sub> dt = ∫<sub>(vx1 to
        vx2)</sub> –m / [(C<sub>w</sub>
        v<sub>w</sub> cos γ) + C<sub>d</sub>
        v<sub>x</sub>] dv<sub>x</sub></td></tr><tr><td>t = –(m/C<sub>d</sub>)
        ln((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x</sub>)| <sub>(vx1
        to vx2)</sub></td></tr><tr><td>t = –(m/C<sub>d</sub>)
        ln((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x2</sub>) +
        (m/C<sub>d</sub>) ln((C<sub>w</sub>
        v<sub>w</sub> cos γ) + C<sub>d</sub>
        v<sub>x1</sub>)</td></tr><tr><td>(C<sub>d</sub>/m) t =
        ln[((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x1</sub>) /
        ((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x2</sub>)]</td></tr><tr><td>e<sup>(C</sup><sub>d</sub>
        <sup>/m) t</sup> =
        e<sup>ln[((C</sup><sub>w</sub>
        <sup>v</sup><sub>w</sub> <sup>cos
        γ) + Cd v</sup><sub>x1</sub><sup>) / ((Cw
        vw cos γ) + C</sup><sub>d</sub>
        <sup>v</sup><sub>x2</sub><sup>)]</sup></td></tr><tr><td>e<sup>(Cd/m) t</sup> =
        ((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x1</sub>) /
        ((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x2</sub>)</td></tr><tr><td>((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x2</sub>) =
        ((C<sub>w</sub> v<sub>w</sub> cos γ) +
        C<sub>d</sub> v<sub>x1</sub>)
        e<sup>–(C</sup><sub>d</sub><sup>/m)
        t</sup></td></tr><tr><td>v<sub>x2</sub> = (1/C<sub>d</sub>) [
        e<sup>(–C</sup>d<sup>/m) t</sup>
        (c<sub>w</sub> v<sub>w</sub> cos γ +
        C<sub>d</sub> v<sub>x1</sub>) –
        (C<sub>w</sub> v<sub>w</sub> cos γ)]</td></tr></table><p>To get an equation for displacement as a function of time, you
      need to recall the equation <span class="emphasis"><em>v dt</em></span> =
      <span class="emphasis"><em>ds</em></span>, make the substitution for
      <span class="emphasis"><em>v</em></span> (using the preceding equation) and then integrate
      one more time.</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>x2</sub> dt =
        ds<sub>x</sub></td></tr><tr><td>(1/C<sub>d</sub>)
        [e<sup>(–C</sup><sub>d</sub><sup>/m)
        t</sup> (c<sub>w</sub> v<sub>w</sub>
        cos γ + C<sub>d</sub> v<sub>x1</sub>) –
        (c<sub>w</sub> v<sub>w</sub> cos γ)] dt =
        ds<sub>x</sub></td></tr><tr><td>∫<sub>(0 to t)</sub> (1/C<sub>d</sub>)
        [e<sup>(–C</sup><sub>d</sub><sup>/m)
        t</sup> (c<sub>w</sub> v<sub>w</sub>
        cos γ + C<sub>d</sub> v<sub>x1</sub>) –
        (c<sub>w</sub> v<sub>w</sub> cos γ)] dt
        =</td></tr><tr><td>= ∫<sub>(sx1 to sx2)</sub>
        ds<sub>x</sub></td></tr><tr><td>s<sub>x2</sub> = [(m/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)
        t</sup> (–(C<sub>w</sub> v<sub>w</sub>
        cos γ) / C<sub>d</sub> – v<sub>x1</sub>) –
        ((C<sub>w</sub> v<sub>w</sub> cos γ) /
        C<sub>d</sub>) t] –</td></tr><tr><td>[(m/C<sub>d</sub>) (–(C<sub>w</sub>
        v<sub>w</sub> cos γ) / C<sub>d</sub> –
        v<sub>x1</sub>)] + s<sub>x1</sub></td></tr></table><p>Yes, these equations are ugly. Just imagine if we hadn’t made the
      simplifying assumption that drag is proportional to speed and not speed
      squared! You would have ended up with some really nice equations with an
      <span class="emphasis"><em>arctan</em></span> term or two thrown in.</p></div><div class="sect2" title="Y Components"><div class="titlepage"><div><div><h3 class="title" id="y_components-id1">Y Components</h3></div></div></div><p>For the <span class="emphasis"><em>y</em></span> components, <a id="I_indexterm4_id309490" class="indexterm"/>you need to follow the same procedure shown earlier for
      the <span class="emphasis"><em>x</em></span> components, but with the appropriate
      y-direction forces. Here’s what it looks like:</p><table style="border: 0; " class="simplelist"><tr><td>–F<sub>dy</sub> – F<sub>gy</sub> = m
        (dv<sub>y</sub>/dt)</td></tr><tr><td>–C<sub>d</sub> v<sub>y</sub> – m g = m
        (dv<sub>y</sub>/dt)</td></tr><tr><td>∫<sub>(0 to t)</sub> dt = –m ∫<sub>(vy1 to
        vy2)</sub> 1/(C<sub>d</sub>
        v<sub>y</sub> + m g) dv<sub>y</sub></td></tr><tr><td>v<sub>y2</sub> = (1/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        (C<sub>d</sub> v<sub>y1</sub> + m g) – (m
        g)/C<sub>d</sub></td></tr></table><p>Now that you have an equation for velocity, you can proceed to get
      an equation for displacement as before:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>y2</sub> dt =
        ds<sub>y</sub></td></tr><tr><td>[(1/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        (C<sub>d</sub> v<sub>y1</sub> + m g) – (m
        g)/C<sub>d</sub>] dt = ds<sub>y</sub></td></tr><tr><td>∫<sub>(0 to t)</sub>
        [(1/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        (C<sub>d</sub> v<sub>y1</sub> + m g) – (m
        g)/C<sub>d</sub>] dt = ∫<sub>(sy1 to
        sy2)</sub> ds<sub>y</sub></td></tr><tr><td>s<sub>y2</sub> = s<sub>y1</sub> +
        [–(v<sub>y1</sub> + (m g)/C<sub>d</sub>)
        (m/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        – t (m g)/C<sub>d</sub>] +
        [(m/C<sub>d</sub>)(v<sub>y1</sub> + (m
        g)/C<sub>d</sub>)]</td></tr></table><p>OK, that’s two down and only one more to go.</p></div><div class="sect2" title="Z Components"><div class="titlepage"><div><div><h3 class="title" id="z_components-id1">Z Components</h3></div></div></div><p>With the <span class="emphasis"><em>z</em></span> component, <a id="I_indexterm4_id309752" class="indexterm"/>you get a break. You’ll notice that the equations of
      motion for the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>z</em></span>
      components look almost the same with the exception of the
      <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>z</em></span> subscripts and the
      sine versus cosine terms. Taking advantage of this fact, you can simply
      copy the <span class="emphasis"><em>x</em></span> component equations and replace the
      <span class="emphasis"><em>x</em></span> subscript with a <span class="emphasis"><em>z</em></span> and the
      cosine terms with sines and be done with it:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>z2</sub> = (1/C<sub>d</sub>)
        [e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        (c<sub>w</sub> v<sub>w</sub> sin γ +
        C<sub>d</sub> v<sub>z1</sub>) –
        (c<sub>w</sub> v<sub>w</sub> sin γ)]</td></tr><tr><td>s<sub>z2</sub> = [(m/C<sub>d</sub>)
        e<sup>(–C</sup><sub>d</sub><sup>/m)t</sup>
        (–(C<sub>w</sub> v<sub>w</sub> sin γ) /
        C<sub>d</sub> – v<sub>z1</sub>) –
        ((C<sub>w</sub> v<sub>w</sub> sin
        γ)/C<sub>d</sub>) t] –</td></tr><tr><td>[(m/C<sub>d</sub>) (–(C<sub>w</sub>
        v<sub>w</sub> sin γ)/C<sub>d</sub> –
        v<sub>z1</sub>)] + s<sub>z1</sub></td></tr></table></div><div class="sect2" title="Cannon Revised"><div class="titlepage"><div><div><h3 class="title" id="cannon_revised">Cannon Revised</h3></div></div></div><p>Now that you have some new equations for the projectile’s
      displacement in each coordinate direction, you can go to the cannon
      example source code and replace the old displacement calculation
      formulas with the new ones. Make the changes in the <code class="literal">DoSimulation</code> function as follows:</p><a id="I_programlisting4_id309937"/><pre class="programlisting">//--------------------------------------------------------------------------------//
int     DoSimulation(void)
//--------------------------------------------------------------------------------//
{
     .
     .
     .

     // new local variables:
     double     sx1, vx1;
     double     sy1, vy1;
     double     sz1, vz1;

     .
     .
     .

     // Now we can calculate the position vector at this time

     // Old position vector commented out:
     //s.i = Vm * cosX * time + xe;
     //s.j = (Yb + L * cos(Alpha*3.14/180)) + (Vm * cosY * time) −
          (0.5 * g * time * time);
     //s.k = Vm * cosZ * time + ze;

     // New position vector calculations:
     sx1 = xe;
     vx1 = Vm * cosX;

     sy1 = Yb + L * cos(Alpha * 3.14/180);
     vy1 = Vm * cosY;

     sz1 = ze;
     vz1 = Vm * cosZ;

     s.i =((m/Cd) * exp(-(Cd * time)/m) * ((-Cw * Vw * cos(GammaW * 3.14/180))/Cd −
          vx1) - (Cw * Vw * cos(GammaW * 3.14/180) * time) / Cd ) -
          ( (m/Cd) * ((-Cw * Vw * cos(GammaW * 3.14/180))/Cd - vx1) ) + sx1;

     s.j = sy1 + ( -(vy1 + (m * g)/Cd) * (m/Cd) * exp(-(Cd*time)/m) −
          (m * g * time) / Cd ) +  ( (m/Cd) * (vy1 + (m * g)/Cd) );

     s.k =((m/Cd) * exp(-(Cd * time)/m) * ((-Cw * Vw * sin(GammaW * 3.14/180))/Cd −
          vz1) - (Cw * Vw * sin(GammaW * 3.14/180) * time) / Cd ) -
          ( (m/Cd) * ((-Cw * Vw * sin(GammaW * 3.14/180))/Cd - vz1) ) + sz1;
     .
     .
     .
}</pre><p>To take into account the cross wind and drag, you’ll need to add
      some new global variables to store the wind speed and direction, the
      mass of the projectile, and the drag coefficients. You’ll also have to
      add some controls in the dialog window so that you can change these
      variables when you run the program. <a class="xref" href="ch04.html#revised_cannon_example_screenshot" title="Figure 4-5. Revised cannon example screenshot">Figure 4-5</a> shows how we added these
      interface controls in the upper-right corner of the main window.</p><div class="figure"><a id="revised_cannon_example_screenshot"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id309975"/><img src="httpatomoreillycomsourceoreillyimages1598905.png" alt="Revised cannon example screenshot"/></div></div><div class="figure-title">Figure 4-5. Revised cannon example screenshot</div></div><p>We also added these lines to the <code class="literal">DemoDlgProc</code> function to handle the new wind
      speed and direction values:</p><a id="I_programlisting4_id310002"/><pre class="programlisting">//---------------------------------------------------------------------------------//
LRESULT CALLBACK DemoDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
//---------------------------------------------------------------------------------//
{
     .
     .
     .

          case WM_INITDIALOG:
     .
     .
     .
               // New variables:
               sprintf( str, "%f", m );
               SetDlgItemText(hDlg, IDC_M, str);

               sprintf( str, "%f", Cd );
               SetDlgItemText(hDlg, IDC_CD, str);

               sprintf( str, "%f", Vw );
               SetDlgItemText(hDlg, IDC_VW, str);

               sprintf( str, "%f", GammaW );
               SetDlgItemText(hDlg, IDC_GAMMAW, str);

               sprintf( str, "%f", Cw );
               SetDlgItemText(hDlg, IDC_CW, str);
     .
     .
     .

                    case IDC_REFRESH:
     .
     .
     .
                         // New variables:
                         GetDlgItemText(hDlg, IDC_M, str, 15);
                         m = atof(str);

                         GetDlgItemText(hDlg, IDC_CD, str, 15);
                         Cd = atof(str);

                         GetDlgItemText(hDlg, IDC_VW, str, 15);
                         Vw = atof(str);

                         GetDlgItemText(hDlg, IDC_GAMMAW, str, 15);
                         GammaW = atof(str);

                         GetDlgItemText(hDlg, IDC_CW, str, 15);
                         Cw = atof(str);
     .
     .
     .

                    case IDC_FIRE:
     .
     .
     .
                         // New variables:
                         GetDlgItemText(hDlg, IDC_M, str, 15);
                         m = atof(str);

                         GetDlgItemText(hDlg, IDC_CD, str, 15);
                         Cd = atof(str);

                         GetDlgItemText(hDlg, IDC_VW, str, 15);
                         Vw = atof(str);

                         GetDlgItemText(hDlg, IDC_GAMMAW, str, 15);
                         GammaW = atof(str);

                         GetDlgItemText(hDlg, IDC_CW, str, 15);
                         Cw = atof(str);
     .
     .
     .
}</pre><p>After playing with this example program, you should readily see
      that the trajectory of the projectile is noticeably different from that
      typically obtained in the original example. By adjusting the values of
      the wind speed, direction, and drag coefficients, you can dramatically
      affect the projectile’s trajectory. If you set the wind speed to 0 and
      the drag coefficients to 1, the trajectory will look like that obtained
      in the original example, where wind and drag were not taken into
      account. Be careful, though: don’t set the drag coefficient to 0 because
      this will result in a “divide by zero” error. We didn’t put the
      exception handler in the program, but you can see that it will happen by
      looking at the displacement vector formulas where the drag coefficient
      appears in the denominator of several terms.</p><p>From a user’s perspective, if this were a video game, the problem
      of hitting the target becomes much more challenging when wind and drag
      are taken into account. The wind element is particularly interesting
      because you can change the wind speed and direction during game play,
      forcing the user to pay careful attention to the wind in order to
      accurately hit the <a id="I_indexterm4_id310043" class="indexterm"/><a id="I_indexterm4_id310051" class="indexterm"/><a id="I_indexterm4_id310060" class="indexterm"/><a id="I_indexterm4_id310069" class="indexterm"/>target.</p></div></div><div class="sect1" title="Rigid-Body Kinetics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="rigid-body_kinetics">Rigid-Body Kinetics</h2></div></div></div><p>You already know <a id="ki4.3" class="indexterm"/><a id="ri4.3" class="indexterm"/>from your study of kinematics in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> that dealing with rigid bodies adds rotation, or
    <a id="an4.3" class="indexterm"/><a id="mo4.3" class="indexterm"/>angular motion, into the mix of things to consider. As we
    stated earlier, the equations of motion now consist of a set of equations
    that relate forces to linear accelerations and another set of equations
    that relate moments to angular accelerations. Alternatively, you can think
    of the equations of motion as relating forces to the rate of change in
    linear momentum, and moments to the rate of change in angular momentum, as
    discussed in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>.</p><p>As in kinematics, the procedure for dealing with rigid-body kinetics
    problems involves two distinct aspects: 1) tracking the translation of the
    body’s center of mass, where the body is treated as a particle, and 2)
    tracking the body’s rotation, where you’ll utilize the principles of local
    coordinates and relative angular velocity and acceleration, as discussed
    in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. Really, the only difference between
    rigid-body kinematics and kinetics problems is that in kinetics problems
    we have forces to consider (including their resulting moments).</p><p>The vector equations are repeated here for convenience:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span> = m<span class="strong"><strong>a</strong></span></td></tr><tr><td><span class="strong"><strong>M</strong></span><sub>cg</sub> =
      <span class="strong"><strong>I α</strong></span></td></tr></table><p>where in two dimensions:</p><table style="border: 0; " class="simplelist"><tr><td>Σ<span class="strong"><strong>F</strong></span> =
      ΣF<sub>x</sub> <span class="strong"><strong>i</strong></span> +
      ΣF<sub>y</sub> <span class="strong"><strong>j</strong></span></td></tr><tr><td>ΣF =   
        <span class="inlinemediaobject"><img src="inleq_0405.png" alt=""/></span>
      </td></tr></table><p>Going from two-dimensional particle problems to two-dimensional
    rigid-body problems involves only the addition of one more equation. This
    equation is, of course, the moment equation relating the sum of all
    moments acting on the body to the body’s <a id="I_indexterm4_id310274" class="indexterm"/>moment of inertia and its angular acceleration. In plane
    motion, the axis of rotation of the rigid body is always perpendicular to
    the coordinate plane. And since there is only one axis of rotation, there
    is only one inertia term and one <a id="I_indexterm4_id310288" class="indexterm"/><a id="I_indexterm4_id310297" class="indexterm"/>angular acceleration term to consider. Thus, you can
    write:</p><table style="border: 0; " class="simplelist"><tr><td>M<sub>cg</sub> = I α</td></tr></table><p>where <span class="emphasis"><em>M</em></span><sub>cg</sub> is the total
    moment and is calculated with the formulas discussed in the section <a class="xref" href="ch03.html#force_and_torque" title="Force and Torque">Force and Torque</a> in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>, and
    <span class="emphasis"><em>I</em></span> is calculated about the axis of rotation using the
    techniques discussed in the section <a class="xref" href="ch01.html#mass_comma_center_of_mass_comma_and_mome" title="Mass, Center of Mass, and Moment of Inertia">Mass, Center of Mass, and Moment of Inertia</a> in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>.</p><p>In their component forms, the set of equations of motion for
    two-dimensional kinetics problems are:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF<sub>x</sub> = m
      a<sub>x</sub></td></tr><tr><td>ΣF<sub>y</sub> = m
      a<sub>y</sub></td></tr><tr><td>ΣM<sub>cg</sub> = I α</td></tr></table><p>Since these equations indicate linear motion on the xy-plane, the
    angular acceleration will be about the z-axis perpendicular to the
    xy-plane. Likewise, the moment of inertia, <span class="emphasis"><em>I</em></span>, will be
    taken about the z-axis.</p><p>Recall from <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> that we calculate moment by
    taking the cross product of the position vector for the force under
    consideration and the force vector. This means that, unlike with particle
    kinetics, you now have to keep track of exactly where on the body each
    force is applied. This is best illustrated with an example.</p><p>Consider the box of uniform density shown in <a class="xref" href="ch04.html#box-free_body_diagram" title="Figure 4-6. Box-free body diagram">Figure 4-6</a>. Uniform density <a id="I_indexterm4_id310422" class="indexterm"/><a id="I_indexterm4_id310428" class="indexterm"/>means that its center of gravity is at the box’s geometric
    center. Find the value of the minimum force,
    <span class="emphasis"><em>F</em></span><sub>p</sub>, applied at the upper edge
    of the box, required to start tipping the box over.</p><div class="figure"><a id="box-free_body_diagram"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id310458"/><img src="httpatomoreillycomsourceoreillyimages1598906.png" alt="Box-free body diagram"/></div></div><div class="figure-title">Figure 4-6. Box-free body diagram</div></div><p>In <a class="xref" href="ch04.html#box-free_body_diagram" title="Figure 4-6. Box-free body diagram">Figure 4-6</a>,
    <span class="emphasis"><em>F</em></span><sub>p</sub> is the applied force,
    <span class="emphasis"><em>R</em></span><sub>1</sub> and
    <span class="emphasis"><em>R</em></span><sub>2</sub> are the reaction forces at
    supports one and two, <span class="emphasis"><em>F</em></span><sub>f1</sub> and
    <span class="emphasis"><em>F</em></span><sub>f2</sub> are the forces due to
    friction at points one and two, and <span class="emphasis"><em>mg</em></span> is the weight
    of the box.</p><p>This is an example of the type of problem where you know something
    about the motion of the object and have to find the value of one or more
    forces acting on it. To find the value of the force that will be just
    enough to start tipping the box, you need to look at the instant when the
    reaction force at support two is 0. This implies that all of the weight of
    the box is now supported at point one and the box is starting to rotate
    over. At this instant, just before it starts to rotate, the angular
    acceleration of the box is 0. Note that the box’s linear acceleration
    isn’t necessarily 0—that is, you can push on the box and it may slide
    without actually tipping over.</p><p>The equations of motion for this problem are:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF<sub>x</sub> = F<sub>p</sub> −
      F<sub>f1</sub> − F<sub>f2</sub> = m
      a<sub>x</sub></td></tr><tr><td>ΣF<sub>y</sub> = R<sub>1</sub> +
      R<sub>2</sub> − m g = m a<sub>y</sub> =
      0</td></tr><tr><td>ΣM<sub>cg</sub> = F<sub>p</sub> (h/2) +
      R<sub>2</sub> (w/2) − R<sub>1</sub> (w/2) +
      F<sub>f2</sub> (h/2) + F<sub>f1</sub> (h/2) = I
      α = 0</td></tr></table><p>Rewriting the second preceding equation when
    <span class="emphasis"><em>R</em></span><sub>2</sub> is 0 shows that
    <span class="emphasis"><em>R</em></span><sub>1</sub> is equal to the weight of
    the box. Further, when <span class="emphasis"><em>R</em></span><sub>2</sub> is
    0, the <span class="emphasis"><em>R</em></span><sub>2</sub>
    (<span class="emphasis"><em>w</em></span>/<span class="emphasis"><em>2</em></span>) term drops out of the
    moment equation, which can be rewritten by solving for
    <span class="emphasis"><em>F</em></span><sub>p</sub> in terms of
    <span class="emphasis"><em>R</em></span><sub>1</sub>. Note that when
    <span class="emphasis"><em>R</em></span><sub>2</sub> goes to 0, so does
    <span class="emphasis"><em>F</em></span><sub>f2</sub>. After some algebra, the
    equation looks as follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>p</sub> = mg (w/h) –
      F<sub>f1</sub></td></tr></table><p>Here you can see that the tipping force, applied to the upper edge,
    is proportional to the weight and size of the box (actually the ratio of
    its width to its height), which you can readily appreciate from a physical
    point of view. The friction term is important here because the existence
    of the friction force actually helps the box to tip. If the box were on a
    frictionless surface, it would tend to slide rather than tip.</p><p>In the case of plane motion, or 2D motion, of rigid bodies as
    discussed here, you are able to readily set up the equations of motion and
    investigate both the linear as well as angular motion of the body. In
    generalized three-dimensional motion, the linear motion of rigid bodies is
    no different from that of particles; you simply track the motion of the
    rigid body’s center of gravity. In three dimensions, however, rotation
    gives us some grief, as it is no longer a simple matter of treating
    rotation about a single axis as in plane motion. In 3D you’ll have to
    consider rotation about any axis, which leads to some difficulties in
    representing arbitrary rotations (Euler angles won’t work for us) as well
    as to complications with determining moments of inertia for rotation about
    any axis. We’ll discuss these issues <a id="I_indexterm4_id310701" class="indexterm"/><a id="I_indexterm4_id310711" class="indexterm"/><a id="I_indexterm4_id310720" class="indexterm"/><a id="I_indexterm4_id310730" class="indexterm"/>in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>
    through <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 5. Collisions</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch04.html" title="Chapter 4. Kinetics"/><link rel="next" href="ch06.html" title="Chapter 6. Projectiles"/></head><body><section class="chapter" title="Chapter 5. Collisions" epub:type="chapter" id="collisions"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Collisions</h2></div></div></div><p>Now that you understand the <a id="I_indexterm5_id310757" class="indexterm"/>motion of particles and rigid bodies, you need to consider
  what happens when they run into each other. That’s what we’ll address in
  this chapter; specifically, we’ll show you how to handle particle and, more
  interestingly, rigid-body collision response.</p><p>Before moving forward, we need to make a distinction between collision
  <span class="emphasis"><em>detection</em></span> and collision <span class="emphasis"><em>response</em></span>.
  <a id="I_indexterm5_id310783" class="indexterm"/>Collision detection is a computational geometry problem
  involving the determination of whether and where two or more objects have
  collided. <a id="I_indexterm5_id310796" class="indexterm"/>Collision response is a kinetics problem involving the motion
  of two or more objects after they have collided. While the two problems are
  intimately related, we’ll focus solely on the problem of collision response
  in this chapter. Later, in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> through
  <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>, we’ll show you how to implement
  collision detection and response in various real-time simulations, which
  draw upon concepts presented in this chapter.</p><p>Our treatment of rigid-body collision response in this chapter is
  based on classical (Newtonian) impact principles. Here, colliding bodies are
  treated as rigid irrespective of their construction and material. As in
  earlier chapters, the rigid bodies discussed here do not change shape even
  upon impact. This, of course, is an idealization. You know from your
  everyday experience that when objects collide they dent, bend, compress, or
  crumple. For example, when a baseball strikes a bat, it may compress as much
  as three-quarters of an inch during the millisecond of impact.
  Notwithstanding this reality, we’ll rely on well-established analytical and
  empirical methods to approximate rigid-body collisions.</p><p>This classical approach is widely used in engineering machine design, analysis, and
    simulations; however, for <a id="I_indexterm5_id310834" class="indexterm"/>rigid-body simulations there is another class of methods, known <a id="I_indexterm5_id310845" class="indexterm"/>as <span class="emphasis"><em>penalty methods</em></span>, at your disposal.<sup>[<a id="CHP-5-FN-1" href="#ftn.CHP-5-FN-1" epub:type="noteref" class="footnote">13</a>]</sup> In penalty methods, the force at impact is represented by a temporary spring that
    gets compressed between the objects at the point of impact. This spring compresses over a very
    short time and applies equal and opposite forces to the colliding bodies to simulate collision
    response. Proponents of this method say it has the advantage of ease of implementation. However,
    one of the difficulties encountered in its implementation is numerical instability. There are
    other arguments for and against the use of penalty methods, but we won’t get into the debate
    here. Instead, we’ve included several references in the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a> for you to review if you are so inclined. Other methods of modeling
    collisions exist as well. For example, nonlinear finite element simulations are commonly used to
    model collisions during product design, such as the impact of a cellphone with the ground. These
    methods can be quite accurate; however, they are too slow for real-time applications. Further,
    they are overkill for games.</p><div class="sect1" title="Impulse-Momentum Principle"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="impulse-momentum_principle">Impulse-Momentum Principle</h2></div></div></div><p>Impulse is defined <a id="I_indexterm5_id310906" class="indexterm"/><a id="I_indexterm5_id310916" class="indexterm"/><a id="I_indexterm5_id310922" class="indexterm"/><a id="I_indexterm5_id310931" class="indexterm"/><a id="I_indexterm5_id310941" class="indexterm"/>as a force that acts over a very short period of time. For
    example, the force exerted on a <a id="I_indexterm5_id310953" class="indexterm"/>bullet when fired from a gun is an impulse force. The
    collision forces between two colliding objects are impulse forces, as when
    you kick a football or hit a baseball with a bat.</p><p>More specifically, impulse is a vector quantity equal to the change in momentum. The
      so-called <span class="emphasis"><em>impulse-momentum principle</em></span> says that the change in moment is
      equal to the applied impulse. For problems involving constant <a id="I_indexterm5_id310974" class="indexterm"/><a id="I_indexterm5_id310986" class="indexterm"/><a id="I_indexterm5_id310998" class="indexterm"/><a id="I_indexterm5_id311007" class="indexterm"/>mass and moment of inertia, you can write:</p><table style="border: 0; " class="simplelist"><tr><td>Linear impulse = ȫ <sub>(t– to t+)</sub> <span class="strong"><strong>F</strong></span> dt = m (<span class="strong"><strong>v</strong></span><sub>+</sub> – <span class="strong"><strong>v</strong></span><sub>–</sub>)</td></tr><tr><td>Angular impulse = ȫ <sub>(t– to t+)</sub> <span class="strong"><strong>M</strong></span> dt = <span class="strong"><strong>I</strong></span>
      (<span class="strong"><strong>ω</strong></span><sub>+</sub> –
      <span class="strong"><strong>ω</strong></span><sub>–</sub>)</td></tr></table><p>In these equations, <span class="strong"><strong>F</strong></span> is the
    impulsive force, <span class="strong"><strong>M</strong></span> is the impulsive
    torque<a id="I_indexterm5_id311110" class="indexterm"/><a id="I_indexterm5_id311119" class="indexterm"/> (or moment), <span class="emphasis"><em>t</em></span> is time, <span class="strong"><strong>v</strong></span> is velocity, the subscript – refers to the
    instant just prior to impact, and the subscript + refers to the instant
    just after impact. You can calculate the average impulse force and torque
    using the following equations:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span> = m (<span class="strong"><strong>v</strong></span><sub>+</sub> – <span class="strong"><strong>v</strong></span><sub>–</sub>) /
      (t<sub>+</sub> – t<sub>–</sub>)</td></tr><tr><td><span class="strong"><strong>M</strong></span> = <span class="strong"><strong>I</strong></span> (<span class="strong"><strong>ω</strong></span><sub>+</sub> – <span class="strong"><strong>ω</strong></span><sub>–</sub>) /
      (t<sub>+</sub> – t<sub>–</sub>)</td></tr></table><p>Consider this simple example: a 150 gram (0.15 kg) bullet is fired
    from a gun at a muzzle velocity of 756 m/s. The bullet takes 0.0008
    seconds to travel through the 610 mm (0.610 m) rifle barrel. Calculate the
    impulse and the average impulsive force exerted on the bullet. In this
    example, the bullet’s mass is a constant 150 grams and its initial
    velocity is 0, thus its initial momentum is 0. Immediately after the gun
    is fired, the bullet’s momentum is its mass times the muzzle velocity,
    which yields a momentum of 113.4 kg-m/s. The impulse is equal to the
    change in momentum, and is simply 113.4 kg-m/s. The average impulse force
    is equal to the impulse divided by the duration of application of the
    force, or in this case:</p><table style="border: 0; " class="simplelist"><tr><td>Average impulse force = (113.4 kg-m/s) / (0.0008 s)</td></tr><tr><td>Average impulse force = 141,750 N</td></tr></table><p>This is a simple but important illustration of the concept of impulse, and you’ll use the
      same principle when dealing with rigid-body impacts. During impacts, the forces of impact are
      usually very high and the duration of impact is usually very short. When two objects collide,
      each applies an impulse force to the other; these forces are equal in magnitude but opposite
      in direction. In the gun example, the impulse applied to the bullet to set it in motion is
      also applied in the opposite direction to the gun, giving you a nice kick in the shoulder.
      This is simply <a id="I_indexterm5_id311246" class="indexterm"/>Newton’s third law in action.</p></div><div class="sect1" title="Impact"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="impact">Impact</h2></div></div></div><p>In addition to the impulse momentum principle discussed in the
    previous section, our classical impact, or <a id="co5.2" class="indexterm"/><a id="fo5.2" class="indexterm"/><a id="I_indexterm5_id311312" class="indexterm"/><a id="I_indexterm5_id311322" class="indexterm"/>collision response, analysis relies on another fundamental
    principle: Newton’s principle of <a id="I_indexterm5_id311333" class="indexterm"/><a id="I_indexterm5_id311339" class="indexterm"/><a id="I_indexterm5_id311349" class="indexterm"/><a id="im5.2" class="indexterm"/>conservation of momentum, which states that when a system of
    <a id="I_indexterm5_id311374" class="indexterm"/>rigid bodies collide, momentum is conserved. This means that
    for bodies of constant mass, the sum of their masses times their
    respective velocities before the impact is equal to the sum of their
    masses times their respective velocities after the impact:</p><table style="border: 0; " class="simplelist"><tr><td>m<sub>1</sub>v<sub>1–</sub> +
      m<sub>2</sub>v<sub>2–</sub> =
      m<sub>1</sub>v<sub>1+</sub> +
      m<sub>2</sub>v<sub>2+</sub></td></tr></table><p>Here, <span class="emphasis"><em>m</em></span> refers to mass, <span class="emphasis"><em>v</em></span>
    refers to velocity, subscript 1 refers to body one, subscript 2 refers to
    body two, subscript – refers to the instant just prior to impact, and
    subscript + refers to the instant just after impact.</p><p>A crucial assumption of this method is that during the instant of
    impact the only force that matters is the impact force; all other forces
    are assumed negligible over that very short duration. Remember this
    assumption, because in <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>
    we’ll rely on it when implementing collision response in an example 2D
    real-time simulation.</p><p>We’ve already stated that rigid bodies don’t change shape during
    impacts, and you know from your own experience that real objects do change
    shape during impacts. What’s happening in real life is <a id="I_indexterm5_id311454" class="indexterm"/>that <span class="emphasis"><em>kinetic energy</em></span> is being converted
    to<a id="I_indexterm5_id311468" class="indexterm"/> strain energy to cause the objects to deform. (See the
    sidebar <a class="xref" href="ch05.html#kinetic_energy" title="Kinetic Energy">Kinetic Energy</a> for further details on this
    topic.) When the deformation in the objects is permanent, energy is lost
    and thus kinetic energy is not conserved.</p><div class="sidebar"><a id="kinetic_energy"/><div class="sidebar-title">Kinetic Energy</div><p>Kinetic energy is a <a id="I_indexterm5_id311500" class="indexterm"/>form of energy associated with moving bodies. It is equal
      to the energy required to accelerate the body from rest, which is also
      equal to the energy required to bring the moving body to a stop. As you
      might expect, kinetic energy is a function of the body’s speed, or
      velocity, in addition to its mass. The formula for <a id="I_indexterm5_id311514" class="indexterm"/>linear kinetic energy is:</p><table style="border: 0; " class="simplelist"><tr><td>KE<sub>linear</sub> = (1/2) m
        v<sup>2</sup></td></tr></table><p>Angular, or rotational, <a id="I_indexterm5_id311541" class="indexterm"/>kinetic energy is a function of the body’s inertia and
      angular velocity:</p><table style="border: 0; " class="simplelist"><tr><td>KE<sub>angular</sub> = (1/2) I
        ω<sup>2</sup></td></tr></table><p>Conservation of kinetic energy between two colliding bodies means
      that the sum of kinetic energy of both bodies prior to impact is equal
      to the sum of the kinetic energy of both bodies after impact:</p><table style="border: 0; " class="simplelist"><tr><td>m<sub>1</sub>v<sup>2</sup><sub>1–</sub>
        +
        m<sub>2</sub>v<sup>2</sup><sub>2–</sub>
        =
        m<sub>1</sub>v<sup>2</sup><sub>1+</sub>
        +
        m<sub>2</sub>v<sup>2</sup><sub>2+</sub></td></tr></table></div><p>Collisions that involve losses in kinetic energy are <a id="I_indexterm5_id311624" class="indexterm"/><a id="I_indexterm5_id311631" class="indexterm"/><a id="I_indexterm5_id311641" class="indexterm"/><a id="I_indexterm5_id311647" class="indexterm"/>said to be <span class="emphasis"><em>inelastic</em></span>, or
    <span class="emphasis"><em>plastic</em></span>, collisions. For example, if you throw two
    clay balls against each other, their kinetic energy is converted to
    permanent strain energy in deforming the clay balls, and their collision
    response—that is, their motion after impact—is less than spectacular. If
    the collision is <span class="emphasis"><em>perfectly inelastic</em></span>, then the two
    balls of clay will stick to each other and move together at the same
    velocity after impact. Collisions where kinetic energy is conserved are
    called <span class="emphasis"><em>perfectly elastic</em></span>. In these collisions, the
    sum of kinetic energy of all objects before the impact is equal to the sum
    of kinetic energy of all objects after the impact. A good example of
    elastic impact (though not <span class="emphasis"><em>perfectly</em></span> elastic) is the
    collision between two billiard balls where the ball deformation is
    negligible and certainly not permanent under normal circumstances.</p><p>Of course, in reality, impacts are somewhere between perfectly
    elastic and perfectly inelastic. This means that for rigid bodies, which
    don’t change shape at all, we’ll have to rely on an empirical relation to
    quantify the degree of elasticity of the impact(s) that we’re trying to
    simulate. The relation that we’ll use is the ratio of the relative
    separation velocity to the relative approach velocity of the colliding
    objects:</p><table style="border: 0; " class="simplelist"><tr><td>e = −(v<sub>1+</sub> − v<sub>2+</sub>) /
      (v<sub>1−</sub> − v<sub>2−</sub>)</td></tr></table><p>Here <span class="emphasis"><em>e</em></span> is known as the <span class="emphasis"><em>coefficient of
    restitution</em></span> and <a id="I_indexterm5_id311727" class="indexterm"/><a id="I_indexterm5_id311737" class="indexterm"/>is a function of the colliding objects’ material,
    construction, and geometry. This coefficient can be experimentally
    determined for specific impact scenarios—for example, the collision
    between a baseball and bat, or a golf club and ball. For perfectly
    inelastic collisions, <span class="emphasis"><em>e</em></span> is 0, and for perfectly
    elastic collisions, <span class="emphasis"><em>e</em></span> is 1. For collisions that are
    neither perfectly inelastic nor perfectly elastic, <span class="emphasis"><em>e</em></span>
    can be any value between 0 and 1. In this regard, the velocities
    considered are along the <span class="emphasis"><em>line of action</em></span> of the
    <a id="I_indexterm5_id311765" class="indexterm"/>collision.</p><p>In frictionless collisions, the line of action of impact is a line
    perpendicular (or normal) to the colliding surfaces. When the velocity of
    the bodies is along the line of action, the impact is said to be
    <span class="emphasis"><em>direct</em></span>. <a id="I_indexterm5_id311787" class="indexterm"/><a id="I_indexterm5_id311793" class="indexterm"/>When the line of action passes through the center of mass of
    the bodies, the collision is said to <a id="I_indexterm5_id311805" class="indexterm"/><a id="I_indexterm5_id311815" class="indexterm"/>be <span class="emphasis"><em>central</em></span>. Particles and spheres of
    uniform mass distribution always experience central impact.
    <span class="emphasis"><em>Direct central</em></span> impact <a id="I_indexterm5_id311831" class="indexterm"/><a id="I_indexterm5_id311837" class="indexterm"/>occurs when the line of action passes through the centers of
    mass of the colliding bodies and their velocity is along the line of
    action. When the velocities of the bodies are not along the line of
    action, the impact is said to <a id="I_indexterm5_id311850" class="indexterm"/><a id="I_indexterm5_id311856" class="indexterm"/>be <span class="emphasis"><em>oblique</em></span>. You can analyze oblique
    impacts in terms of component coordinates where the component parallel to
    the line of action experiences the impact, but the component perpendicular
    to the line of action does not. <a class="xref" href="ch05.html#types_of_impact" title="Figure 5-1. Types of impact">Figure 5-1</a>
    illustrates these impacts.</p><div class="figure"><a id="types_of_impact"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id311887"/><img src="httpatomoreillycomsourceoreillyimages1598907.png" alt="Types of impact"/></div></div><div class="figure-title">Figure 5-1. Types of impact</div></div><p>As an example, consider the collision between two <a id="sp5.2" class="indexterm"/><a id="bi5.2" class="indexterm"/><a id="cob5.2" class="indexterm"/>billiard balls illustrated in <a class="xref" href="ch05.html#example_billiard_ball_collision" title="Figure 5-2. Example billiard ball collision">Figure 5-2</a>.</p><div class="figure"><a id="example_billiard_ball_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id311973"/><img src="httpatomoreillycomsourceoreillyimages1598908.png" alt="Example billiard ball collision"/></div></div><div class="figure-title">Figure 5-2. Example billiard ball collision</div></div><p>Both balls are a standard 57 mm in diameter, and each weighs 156
    grams. Assume that the collision is nearly perfectly elastic and the
    coefficient of restitution is 0.9. If the velocity of ball 1 when it
    strikes ball 2 is 6 m/s in the x-direction, as shown in <a class="xref" href="ch05.html#example_billiard_ball_collision" title="Figure 5-2. Example billiard ball collision">Figure 5-2</a>, calculate the velocities of
    both balls after the collision assuming that this is a frictionless
    collision.</p><p>The first thing you need to do is recognize that the line of action
    of impact is along the line connecting the centers of gravity of both
    balls, which, since these are spheres, is also normal to both surfaces.
    You can then write the unit normal vector as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>n</strong></span> = <span class="inlinemediaobject"><img src="inleq_0501.png" alt=""/></span>
      </td></tr><tr><td><span class="strong"><strong>n</strong></span> = (0.866) i –
      (0.5)j</td></tr></table><p>where <span class="strong"><strong>n</strong></span> is the unit normal
    vector, <span class="emphasis"><em>r</em></span> is the ball radius, and <span class="strong"><strong>i</strong></span> and <span class="strong"><strong>j</strong></span>
    represent unit vectors in the x- and y-directions, respectively.</p><p>Now that you have the line of action of the collision, or the unit
    normal vector, you can calculate the relative normal velocity between the
    balls at the instant of collision.</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>rn</sub> = [<span class="strong"><strong>v</strong></span><sub>1–</sub> – <span class="strong"><strong>v</strong></span><sub>2–</sub>] • <span class="strong"><strong>n</strong></span></td></tr><tr><td>v<sub>rn</sub> = [(6 m/s) <span class="strong"><strong>i</strong></span> + (0 m/s) <span class="strong"><strong>j</strong></span> ] • [ (0.864) <span class="strong"><strong>i</strong></span> – (0.5) <span class="strong"><strong>j</strong></span>]</td></tr><tr><td>v<sub>rn</sub> = 5.18 m/s</td></tr></table><p>This will be used as
    <span class="emphasis"><em>v</em></span><sub>1n–</sub> in the following
    equations. Notice here that since ball 2 is initially at rest,
    <span class="emphasis"><em>v</em></span><sub>2–</sub> is 0.</p><p>Now you can apply the principle of conservation of momentum in the
    normal direction as follows:</p><table style="border: 0; " class="simplelist"><tr><td>m<sub>1</sub> v<sub>1n–</sub> +
      m<sub>2</sub> v<sub>2n–</sub> =
      m<sub>1</sub> v<sub>1n+</sub> +
      m<sub>2</sub> v<sub>2n+</sub></td></tr></table><p>Noting that <span class="emphasis"><em>m</em></span><sub>1</sub> equals
    <span class="emphasis"><em>m</em></span><sub>2</sub> since the balls are
    identical, and that <span class="emphasis"><em>v</em></span><sub>2n–</sub> is 0,
    and then solving for <span class="emphasis"><em>v</em></span><sub>1n+</sub>
    yields:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>1n+</sub> = v<sub>1n–</sub> –
      v<sub>2n+</sub></td></tr></table><p>To actually solve for these velocities, you need to use the equation
    for coefficient of restitution and make the substitution for
    <span class="emphasis"><em>v</em></span><sub>1n+</sub>. Then, you’ll be able to
    solve for <span class="emphasis"><em>v</em></span><sub>2n+</sub>. Here’s how to
    proceed:</p><table style="border: 0; " class="simplelist"><tr><td>e = (–v<sub>1n+</sub> + v<sub>2n+</sub>)
      / (v<sub>1n–</sub> – v<sub>2n–</sub>)</td></tr><tr><td>e v<sub>1n–</sub> = –(v<sub>1n–</sub> –
      v<sub>2n+</sub>) + v<sub>2n+</sub></td></tr><tr><td>v<sub>2n+</sub> = v<sub>1n–</sub> (e +
      1) / 2</td></tr><tr><td>v<sub>2n+</sub> = (5.18 m/s)(1.9) / 2 = 4.92
      m/s</td></tr></table><p>Using this result and the formula for
    <span class="emphasis"><em>v</em></span><sub>1n+</sub> yields:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>1n+</sub> = 5.18 m/s – 4.92 m/s = 0.26
      m/s</td></tr></table><p>Since the collision is frictionless, there is no impulse acting in
    the tangential direction. This means that momentum is conserved in that
    direction too and that the final tangential speed of ball 1 is equal to
    its initial tangential speed, which in this case is equal to 3 m/s (this
    equals (6m/s) sin 30°). Since ball 2 had no initial tangential speed, its
    velocity after impact is solely in the normal direction. Converting these
    results back to <span class="emphasis"><em>x</em></span>-<span class="emphasis"><em>y</em></span> coordinates
    instead of normal and tangential coordinates yields the following
    velocities for each ball after impact:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>2+</sub> =
      (4.92 m/s) sin 60° <span class="strong"><strong>i</strong></span> – (4.92 m/s) cos
      60 ° <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      [(0.26 m/s) cos 30° + (3 m/s) sin 30°] <span class="strong"><strong>i</strong></span> +</td></tr><tr><td>+ [(−0.26 m/s) sin 30° + (3 m/s) cos 30°)] <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      (1.72 m/s) <span class="strong"><strong>i</strong></span> + (2.47 m/s) <span class="strong"><strong>j</strong></span></td></tr></table><p>To further <a id="I_indexterm5_id312452" class="indexterm"/><a id="I_indexterm5_id312461" class="indexterm"/><a id="I_indexterm5_id312471" class="indexterm"/>illustrate the application of these collision response
    principles, consider another example, this time the collision between a
    <a id="cobb5.2" class="indexterm"/><a id="ba5.2" class="indexterm"/><a id="sb5.2" class="indexterm"/>baseball bat and baseball (as shown in <a class="xref" href="ch05.html#example_baseball_and_bat_collision" title="Figure 5-3. Example baseball and bat collision">Figure 5-3</a>). We are looking at a side
    view, staring down the barrel of the bat.</p><div class="figure"><a id="example_baseball_and_bat_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id312542"/><img src="httpatomoreillycomsourceoreillyimages1598909.png" alt="Example baseball and bat collision"/></div></div><div class="figure-title">Figure 5-3. Example baseball and bat collision</div></div><p>To a reasonable degree of accuracy, the motion of a baseball bat at
    the instant of collision can generally be described as independent of the
    batter—in other words, you can assume that the bat is moving freely and
    pivoting about a point located near the handle end of the bat. Assume that
    the ball strikes the bat on the sweet spot—that is, a point near
    the<a id="I_indexterm5_id312566" class="indexterm"/><a id="I_indexterm5_id312572" class="indexterm"/> center of percussion.<sup>[<a id="CHP-5-FN-2" href="#ftn.CHP-5-FN-2" epub:type="noteref" class="footnote">14</a>]</sup> Further assume that the bat is swung in the horizontal plane
    and that the baseball is traveling in the horizontal plane when it strikes
    the bat. The bat is of standard dimensions with a maximum diameter of 70
    mm and a weight of 1.02 kg. The ball is also of standard dimensions with a
    radius of 37 mm and a weight of 0.15 kg. The ball reaches a speed of 40
    m/s (90 mph) at the instant it strikes the bat, and the speed of the bat
    at the point of impact is 31 m/s (70 mph). For this collision, the
    coefficient of restitution is 0.46. In the millisecond of impact that
    occurs, the baseball compresses quite a bit; however, in this analysis
    assume that both the bat and the ball are rigid. Finally, assume that this
    impact is frictionless.</p><p>As in the previous example, the line of action of impact is along
    the line connecting the <a id="I_indexterm5_id312604" class="indexterm"/><a id="I_indexterm5_id312614" class="indexterm"/>centers of gravity of the bat and ball; thus, the unit
    normal vector is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>n</strong></span> = <span class="inlinemediaobject"><img src="inleq_0502.png" alt=""/></span>
      </td></tr><tr><td><span class="strong"><strong>n</strong></span> = (0.875) <span class="strong"><strong>i</strong></span> + (0.484) <span class="strong"><strong>j</strong></span></td></tr></table><p>Here the subscripts 1 and 2 denote the bat and ball,
    respectively.</p><p>The relative normal velocity between the bat and ball is:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>rn</sub> = [<span class="strong"><strong>v</strong></span><sub>1−</sub> − <span class="strong"><strong>v</strong></span><sub>2−</sub>] • <span class="strong"><strong>n</strong></span></td></tr><tr><td>v<sub>rn</sub> = [(71 m/s) <span class="strong"><strong>i</strong></span> + (0 m/s) <span class="strong"><strong>j</strong></span> ] • [ (0.875) <span class="strong"><strong>i</strong></span> − (0.484) <span class="strong"><strong>j</strong></span>]</td></tr><tr><td>v<sub>rn</sub> = 62.1 m/s</td></tr></table><p>The velocity components of the bat and ball in the normal direction
    are:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>1n−</sub> = <span class="strong"><strong>v</strong></span><sub>1−</sub> • <span class="strong"><strong>n</strong></span> = 27.1 m/s</td></tr><tr><td>v<sub>2n−</sub> = <span class="strong"><strong>v</strong></span><sub>2−</sub> • <span class="strong"><strong>n</strong></span> = −35.0 m/s</td></tr></table><p>Applying the principle of conservation of momentum <a id="I_indexterm5_id312813" class="indexterm"/><a id="I_indexterm5_id312819" class="indexterm"/><a id="I_indexterm5_id312828" class="indexterm"/><a id="I_indexterm5_id312838" class="indexterm"/><a id="I_indexterm5_id312848" class="indexterm"/><a id="I_indexterm5_id312858" class="indexterm"/>in the normal direction and solving for
    <span class="emphasis"><em>v</em></span><sub>1n+</sub> yields:</p><table style="border: 0; " class="simplelist"><tr><td>m<sub>1</sub> v<sub>1n−</sub> +
      m<sub>2</sub> v<sub>2n−</sub> =
      m<sub>1</sub> v<sub>1n+</sub> +
      m<sub>2</sub> v<sub>2n+</sub></td></tr><tr><td>(1.02 kg) (27.1 m/s) + (0.15 kg) (−35.2 m/s) =</td></tr><tr><td>=(1.02 kg) v<sub>1n+</sub> + (0.15 kg)
      v<sub>2n+</sub></td></tr><tr><td>v<sub>1n+</sub> = 21.92 m/s − (0.14 m/s)
      v<sub>2n+</sub></td></tr></table><p>As in the previous example, applying the formula for coefficient of
    restitution<a id="I_indexterm5_id312940" class="indexterm"/> with the preceding formula for v<sub>1n+</sub>
    yields:</p><table style="border: 0; " class="simplelist"><tr><td>e = (−v<sub>1n+</sub> + v<sub>2n+</sub>)
      / (v<sub>1n−</sub> − v<sub>2n−</sub>)</td></tr><tr><td>0.46 = [−21.92 m/s + (0.14 m/s) v<sub>2n+</sub> +
      v<sub>2n+</sub>] / [27.1 m/s + 35.2 m/s]</td></tr><tr><td>v<sub>2n+</sub> = 44.4 m/s <span class="emphasis"><em>and</em></span>
      v<sub>1n+</sub> = 15.7 m/s</td></tr></table><p>Here again, since this impact is frictionless, each object retains
    its original <a id="I_indexterm5_id313010" class="indexterm"/><a id="I_indexterm5_id313017" class="indexterm"/>tangential velocity component. For the bat, this component
    is 15 m/s, while for the ball it’s −19.3 m/s. Converting these normal and
    tangential components to <span class="emphasis"><em>x</em></span>-<span class="emphasis"><em>y</em></span>
    coordinates yields the following bat and ball velocities for the instant
    just after impact:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      21.0 m/s <span class="strong"><strong>i</strong></span> − 5.5 m/s <span class="strong"><strong>j</strong></span></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>2+</sub> =
      30 m/s <span class="strong"><strong>i</strong></span> + 38.7 m/s <span class="strong"><strong>j</strong></span></td></tr></table><p>Both of these examples illustrate fundamental impact analysis using the classical
      approach. They also share an important assumption—that the impacts are frictionless. In
      reality, you know that billiard balls and baseballs and bats collide with friction; otherwise,
      you would not be able to apply <span class="emphasis"><em>English</em></span> in billiards or create
      lift-generating spin on baseballs. Later in this chapter we’ll discuss how to include friction
      in your impact<a id="I_indexterm5_id313098" class="indexterm"/><a id="I_indexterm5_id313107" class="indexterm"/><a id="I_indexterm5_id313117" class="indexterm"/><a id="I_indexterm5_id313126" class="indexterm"/><a id="I_indexterm5_id313135" class="indexterm"/><a id="I_indexterm5_id313145" class="indexterm"/> analysis.</p></div><div class="sect1" title="Linear and Angular Impulse"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="linear_and_angular_impulse">Linear and Angular Impulse</h2></div></div></div><p>In the previous <a id="co5.3" class="indexterm"/><a id="li5.3" class="indexterm"/><a id="an5.3" class="indexterm"/><a id="il5.3" class="indexterm"/><a id="ia5.3" class="indexterm"/><a id="coa5.3" class="indexterm"/>section, you were able to work through the specific examples
    by hand using the principle of conservation of momentum and the
    coefficient of restitution. This approach will suffice if you’re writing
    games where the collision events are well defined and anticipated.
    However, if you’re writing a real-time simulation where objects,
    especially arbitrarily shaped rigid bodies, may or may not collide, then
    you’ll want to use a more general approach. This approach involves the use
    of formulas to calculate the actual impulse between colliding objects so
    that you can apply this impulse to each object, instantly changing its
    velocity. In this section, we’ll derive the equations for impulse, both
    linear and angular, and we’ll show you how to implement these equations in
    code in <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>.</p><p>When you’re dealing with particles or spheres, the only impulse
    formula that you’ll need is that for linear impulse, which will allow you
    to calculate the new linear velocities of the objects after impact. So,
    the first formula that we’ll derive for you is that for linear impulse
    between two colliding objects, as shown in <a class="xref" href="ch05.html#two_colliding_particles_open_parenthesis" title="Figure 5-4. Two colliding particles (or spheres)">Figure 5-4</a>.</p><div class="figure"><a id="two_colliding_particles_open_parenthesis"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id313292"/><img src="httpatomoreillycomsourceoreillyimages1598910.png" alt="Two colliding particles (or spheres)"/></div></div><div class="figure-title">Figure 5-4. Two colliding particles (or spheres)</div></div><p>For now, assume the collision is frictionless and the line of action
    of the impulse is along the line connecting the centers of mass of the two
    objects. This line is normal to the surfaces of both objects.</p><p>To derive the formula for linear impulse, you have to consider the
    formula from the definition of impulse along with the formula for
    coefficient of restitution. Here let <span class="emphasis"><em>J</em></span> represent the
    impulse:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>J</strong></span>| = m (|<span class="strong"><strong>v</strong></span><sub>+</sub>| − |<span class="strong"><strong>v</strong></span><sub>−</sub>|)</td></tr><tr><td>e = −(|<span class="strong"><strong>v</strong></span><sub>1+</sub>| − |<span class="strong"><strong>v</strong></span><sub>2+</sub>|)/(|<span class="strong"><strong>v</strong></span><sub>1−</sub>| − |<span class="strong"><strong>v</strong></span><sub>2−</sub>|)</td></tr></table><p>In these equations the velocities are those along the line of action
    of the impact, which in this case is a line connecting the centers of mass
    of the two objects. Since the same impulse applies to each object (just in
    opposite directions), you actually have three equations to deal
    with:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>J</strong></span>| =
      m<sub>1</sub> (|<span class="strong"><strong>v</strong></span><sub>1+</sub>| − |<span class="strong"><strong>v</strong></span><sub>1−</sub>|)</td></tr><tr><td>|<span class="strong"><strong>−J</strong></span>| =
      m<sub>2</sub> (|<span class="strong"><strong>v</strong></span><sub>2+</sub>| − |<span class="strong"><strong>v</strong></span><sub>2−</sub>|)</td></tr><tr><td>e = −(|<span class="strong"><strong>v</strong></span><sub>1+</sub>|− |<span class="strong"><strong>v</strong></span><sub>2+</sub>|)/(|<span class="strong"><strong>v</strong></span><sub>1−</sub>| − |<span class="strong"><strong>v</strong></span><sub>2-</sub>|)</td></tr></table><p>Notice we’ve assumed that <span class="emphasis"><em>J</em></span> acts positively on body 1 and its
      negation, <span class="emphasis"><em>–J</em></span>, acts on body 2. Also notice that there are three unknowns
      in these equations: the impulse and the velocities of both bodies after the impact. Since
      there are three equations and three unknowns, you can solve for each unknown by rearranging
      the two impulse equations and substituting them into the equation for <span class="emphasis"><em>e</em></span>.
      After some algebra, you’ll end up with a formula for <span class="emphasis"><em>J</em></span> that you can then
      use to determine the velocities of each body just after impact. Here’s how that’s done:</p><table style="border: 0; " class="simplelist"><tr><td>For body 1: |<span class="strong"><strong>v</strong></span><sub>1+</sub>| =
      |J|/m<sub>1</sub> + |<span class="strong"><strong>v</strong></span><sub>1–</sub>|</td></tr><tr><td>For body 2: |<span class="strong"><strong>v</strong></span><sub>2+</sub>| =
      –|J|/m<sub>2</sub> + |<span class="strong"><strong>v</strong></span><sub>2–</sub>|</td></tr></table><p>Substituting |<span class="emphasis"><em>v</em></span><sub>1+</sub>| and
    |<span class="emphasis"><em>v</em></span><sub>2+</sub>| into the equation for
    <span class="emphasis"><em>e</em></span> yields:</p><table style="border: 0; " class="simplelist"><tr><td>e (|<span class="strong"><strong>v</strong></span><sub>1–</sub>| – |<span class="strong"><strong>v</strong></span><sub>2–</sub>|) = –[( |<span class="strong"><strong>J</strong></span>|/m<sub>1</sub> +
      |v<sub>1–</sub>|) – (–|<span class="strong"><strong>J</strong></span>|/m<sub>2</sub> +
      |v<sub>2–</sub>|)]</td></tr><tr><td>e (|<span class="strong"><strong>v</strong></span><sub>1-</sub>| – |<span class="strong"><strong>v</strong></span><sub>2–</sub>|) + |<span class="strong"><strong>v</strong></span><sub>1–</sub>| – |<span class="strong"><strong>v</strong></span><sub>2–</sub>| = –J
      (1/m<sub>1</sub> + 1/m<sub>2</sub>)</td></tr></table><p>Let |<span class="strong"><strong>v</strong></span><sub>r</sub>| =
    (|<span class="strong"><strong>v</strong></span><sub>1–</sub>| –
    |<span class="strong"><strong>v</strong></span><sub>2–</sub>|);
    then:</p><table style="border: 0; " class="simplelist"><tr><td>e |<span class="strong"><strong>v</strong></span><sub>r</sub>|
      + |<span class="strong"><strong>v</strong></span><sub>r</sub>| =
      –|<span class="strong"><strong>J</strong></span>| (1/m<sub>1</sub> +
      1/m<sub>2</sub>)</td></tr><tr><td>|<span class="strong"><strong>J</strong></span>| = –|<span class="strong"><strong>v</strong></span><sub>r</sub>|(e +
      1)/(1/m<sub>1</sub> + 1/m<sub>2</sub>)</td></tr></table><p>Since the line of action is normal to the colliding surfaces,
    <span class="strong"><strong>v</strong></span><sub>r</sub> is the
    relative velocity along the line of action of impact, and <span class="strong"><strong>J</strong></span> acts along the line of action of impact, which
    in this case is normal to the surfaces, as we’ve already stated.</p><p>Now that you have a formula for the impulse, you can use the
    definition of impulse along with this formula to calculate the change in
    linear velocity of the objects involved in the impact. Here’s how that’s
    done in the case of two objects colliding:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      <span class="strong"><strong>v</strong></span><sub>1–</sub> +
      (|<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/m<sub>1</sub></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>2+</sub> =
      <span class="strong"><strong>v</strong></span><sub>2–</sub> +
      (–|<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/m<sub>2</sub></td></tr></table><p>Notice that for the second object, the negative of the impulse is
    applied since it acts on both objects equally but in opposite
    directions.</p><p>When dealing with rigid bodies that rotate, you’ll have to derive a
    new equation for impulse that includes angular effects. You’ll use this
    impulse to calculate new linear and angular velocities of the objects just
    after impact. Consider the two objects colliding at point
    <span class="emphasis"><em>P</em></span>, as shown in <a class="xref" href="ch05.html#two_colliding_rigid_bodies" title="Figure 5-5. Two colliding rigid bodies">Figure 5-5</a>.</p><div class="figure"><a id="two_colliding_rigid_bodies"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id313927"/><img src="httpatomoreillycomsourceoreillyimages1598911.png" alt="Two colliding rigid bodies"/></div></div><div class="figure-title">Figure 5-5. Two colliding rigid bodies</div></div><p>There’s a crucial distinction between this collision and that
    discussed earlier. In this case, the velocity at the point of contact on
    each body is a function of not only the objects’ linear velocity but also
    their angular velocities, and you’ll have to recall from <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> the following formula in order to calculate the
    velocities at the impact point on each body:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>p</sub> =
      <span class="strong"><strong>v</strong></span><sub>g</sub> +
      (<span class="strong"><strong>ω</strong></span> × <span class="strong"><strong>r</strong></span>)</td></tr></table><p>In this relation, <span class="strong"><strong>r</strong></span> is the vector
    from the body’s center of gravity to the point
    <span class="emphasis"><em>P</em></span>.</p><p>Using this formula, you can rewrite the two formulas relating the
    linear velocity after impact to the impulse and initial velocity as
    follows:</p><table style="border: 0; " class="simplelist"><tr><td>For body 1: <span class="strong"><strong>v</strong></span><sub>1g+</sub> + (<span class="strong"><strong>ω</strong></span><sub>1+</sub> × <span class="strong"><strong>r</strong></span><sub>1</sub>) = <span class="strong"><strong>J</strong></span>/m<sub>1</sub> + <span class="strong"><strong>v</strong></span><sub>1g–</sub> + (<span class="strong"><strong>ω</strong></span><sub>1–</sub> × <span class="strong"><strong>r</strong></span><sub>1</sub>)</td></tr><tr><td>For body 2: <span class="strong"><strong>v</strong></span><sub>2g+</sub> + (<span class="strong"><strong>ω</strong></span><sub>2+</sub> × <span class="strong"><strong>r</strong></span><sub>2</sub>) = –<span class="strong"><strong>J</strong></span>/m<sub>2</sub> + <span class="strong"><strong>v</strong></span><sub>2g–</sub> + (<span class="strong"><strong>ω</strong></span><sub>2–</sub> × <span class="strong"><strong>r</strong></span><sub>2</sub>)</td></tr></table><p>There are two additional unknowns here, the angular velocities after
    impact, which means that you need two additional equations. You can get
    these equations from the definition of angular impulse:</p><table style="border: 0; " class="simplelist"><tr><td>For body 1: (<span class="strong"><strong>r</strong></span><sub>1</sub> × <span class="strong"><strong>J</strong></span>) = <span class="strong"><strong>I</strong></span><sub>1</sub> (<span class="strong"><strong>ω</strong></span><sub>1+</sub> – <span class="strong"><strong>ω</strong></span><sub>1–</sub>)</td></tr><tr><td>For body 2: (<span class="strong"><strong>r</strong></span><sub>2</sub> × –<span class="strong"><strong>J</strong></span>) = <span class="strong"><strong>I</strong></span><sub>2</sub> (<span class="strong"><strong>ω</strong></span><sub>2+</sub> – <span class="strong"><strong>ω</strong></span><sub>2–</sub>)</td></tr></table><p>Here we calculate the moment due to the impulse by taking the vector
    cross product of the impulse with the distance from the body’s center of
    gravity to the point of application of the impulse.</p><p>By combining all of these equations with the equation for
    <span class="emphasis"><em>e</em></span> and following the same procedure used when deriving
    the linear impulse formula, you’ll end up with a formula for |<span class="strong"><strong>J</strong></span>| that takes into account both linear and
    angular effects, which you can then use to find the linear and angular
    velocities of each body immediately after impact. Here’s the
    result:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>J</strong></span>| = –(<span class="strong"><strong>v</strong></span><sub>r</sub>• <span class="strong"><strong>n</strong></span>)(e + 1)/[1/m<sub>1</sub> +
      1/m<sub>2</sub> + <span class="strong"><strong>n</strong></span>
      •((<span class="strong"><strong>r</strong></span><sub>1</sub> ×
      <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>1</sub>) × <span class="strong"><strong>r</strong></span><sub>1</sub> + <span class="strong"><strong>n</strong></span> • ((<span class="strong"><strong>r</strong></span><sub>2</sub> × <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>2</sub>) × <span class="strong"><strong>r</strong></span><sub>2</sub>]</td></tr></table><p>Here <span class="strong"><strong>v</strong></span><sub>r</sub> is
    the relative velocity along the line of action at the impact point
    <span class="emphasis"><em>P</em></span>, and <span class="strong"><strong>n</strong></span> is a unit
    vector along the line of action at the impact point pointing out from body
    1.</p><p>With this new formula for |<span class="strong"><strong>J</strong></span>|,
    you can calculate the change in linear and angular velocities of the
    objects involved in the collision using these formulas:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      <span class="strong"><strong>v</strong></span><sub>1−</sub> +
      (|<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/m<sub>1</sub></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>2+</sub> =
      <span class="strong"><strong>v</strong></span><sub>2−</sub> +
      (−|<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/m<sub>2</sub></td></tr><tr><td><span class="strong"><strong>ω</strong></span><sub>1+</sub> =
      <span class="strong"><strong>ω</strong></span><sub>1−</sub> +
      (<span class="strong"><strong>r</strong></span><sub>1</sub> ×
      |<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>1</sub></td></tr><tr><td><span class="strong"><strong>ω</strong></span><sub>2+</sub> =
      <span class="strong"><strong>ω</strong></span><sub>2−</sub> +
      (<span class="strong"><strong>r</strong></span><sub>2</sub> ×
      −|<span class="strong"><strong>J</strong></span>| <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>2</sub></td></tr></table><p>As we said earlier, we’ll show you how to implement these formulas
    for <a id="I_indexterm5_id314587" class="indexterm"/><a id="I_indexterm5_id314597" class="indexterm"/><a id="I_indexterm5_id314607" class="indexterm"/><a id="I_indexterm5_id314616" class="indexterm"/><a id="I_indexterm5_id314625" class="indexterm"/><a id="I_indexterm5_id314635" class="indexterm"/>impulse in code when you get to <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>.</p></div><div class="sect1" title="Friction"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="friction-id1">Friction</h2></div></div></div><p>Friction acts between <a id="co5.4" class="indexterm"/><a id="fr5.4" class="indexterm"/>contacting surfaces to resist motion. When objects collide in any type of
      collision except direct impact, for that very brief moment of contact, they will experience a
      friction force that acts tangentially to the contacting surfaces. Not only will this
      tangential force change the linear velocities of the colliding objects in the tangential
      direction, but it will also create a moment (torque) on the objects, which tends to change
      their angular velocities. This tangential impulse combined with the normal impulse results in
      an effective line of action of the total collision impulse that is no longer perpendicular to
      the contacting surfaces.</p><p>In practice, it is very difficult to quantify this collision
    friction force due to the fact that the friction force is not necessarily
    constant if the collision is such that the friction force does not develop
    beyond the maximum static friction force. Further complications stem from
    the fact that objects do tend to deform when they collide, creating an
    additional source of resistance. That said, since the friction force is a
    function of the normal force between the contacting surfaces, you know
    that the ratio of the normal force to the friction force is equal to the
    coefficient of friction. If you assume that the collisions are such that
    the kinetic coefficient of friction is applicable, then this ratio is
    constant.</p><table style="border: 0; " class="simplelist"><tr><td>µ<sub>k</sub> = F<sub>f</sub> /
      F<sub>n</sub></td></tr></table><p>Here, <span class="emphasis"><em>F</em></span><sub>f</sub> is the
    tangential friction force and
    <span class="emphasis"><em>F</em></span><sub>n</sub> is the normal impact force.
    You can extend this to say that the ratio of the tangential impulse to
    normal impulse is equal to the coefficient of friction.</p><p>Consider the collision between the <a id="go5.4" class="indexterm"/><a id="cg5.4" class="indexterm"/><a id="sp5.4" class="indexterm"/>golf club head and golf ball illustrated in <a class="xref" href="ch05.html#golf_clubngolf_ball_collision" title="Figure 5-6. Golf club–golf ball collision">Figure 5-6</a>.</p><div class="figure"><a id="golf_clubngolf_ball_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id314813"/><img src="httpatomoreillycomsourceoreillyimages1598912.png" alt="Golf club–golf ball collision"/></div></div><div class="figure-title">Figure 5-6. Golf club–golf ball collision</div></div><p>In the upper velocity diagram,
    <span class="emphasis"><em>v</em></span><sub>–</sub> represents the relative
    velocity between the ball and club head at the instant of impact,
    <span class="emphasis"><em>v</em></span><sub>+</sub> represents the velocity of
    the ball just after impact,
    <span class="emphasis"><em>v</em></span><sub>t–</sub> and
    <span class="emphasis"><em>v</em></span><sub>t+</sub> represent the tangential
    components of the ball velocity at and just after the instant of impact,
    respectively.</p><p>If this were a frictionless collision,
    <span class="emphasis"><em>v</em></span><sub>t–</sub> and
    <span class="emphasis"><em>v</em></span><sub>t+</sub> would be equal, as would
    the angles α and θ. However, with friction the tangential velocity of the
    ball is reduced, making <span class="emphasis"><em>v</em></span><sub>t+</sub>
    less than <span class="emphasis"><em>v</em></span><sub>t–</sub>, which also
    means that α will be less than θ.</p><p>The lower force diagram in <a class="xref" href="ch05.html#golf_clubngolf_ball_collision" title="Figure 5-6. Golf club–golf ball collision">Figure 5-6</a> illustrates the forces involved
    in this collision with friction. Since the ratio of the tangential
    friction force to the normal collision force is equal to the coefficient
    of friction, you can develop an equation relating the angle φ to the
    coefficient of friction.</p><table style="border: 0; " class="simplelist"><tr><td>tan φ = F<sub>f</sub> / F<sub>n</sub> =
      µ</td></tr></table><p>In addition to this friction force changing the linear velocity of
    the ball in the tangential direction, it will also change the angular
    velocity of the ball. Since the friction force is acting on the ball’s
    surface some distance from its center of gravity, it creates a moment
    (torque) about the ball’s center of gravity, which causes the ball to
    spin. You can develop an equation for the new angular velocity of the ball
    in terms of the normal impact force or impulse:</p><table style="border: 0; " class="simplelist"><tr><td>Σ M<sub>cg</sub> = F<sub>f</sub> r =
      I<sub>cg</sub> dω/dt</td></tr><tr><td>µ F<sub>n</sub> r = I<sub>cg</sub>
      dω/dt</td></tr><tr><td>µ F<sub>n</sub> r dt = I<sub>cg</sub>
      dω</td></tr><tr><td>ȫ<sub>(t– to t+)</sub> F<sub>n</sub> dt
      = I<sub>cg</sub> / (µ r) ȫ<sub>(ω– to ω+)</sub>
      ω dω</td></tr></table><p>Notice here that the integral on the left is the normal impulse;
    thus:</p><table style="border: 0; " class="simplelist"><tr><td>Impulse = I<sub>cg</sub> / (µ r)
      (ω<sub>+</sub> – ω<sub>–</sub>)</td></tr><tr><td>ω<sub>+</sub> = (Impulse) (µ r) /
      I<sub>cg</sub> + ω<sub>–</sub></td></tr></table><p>This relation looks very similar to the <a id="I_indexterm5_id315035" class="indexterm"/><a id="I_indexterm5_id315044" class="indexterm"/><a id="I_indexterm5_id315054" class="indexterm"/>angular impulse equation that we showed you earlier in this
    chapter, and you can use it to approximate the friction-induced spin in
    specific collision problems.</p><p>Turn back to the equation for impulse, <span class="emphasis"><em>J</em></span>, in
    the last section that includes both linear and angular effects. Here it is
    again for convenience:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>J</strong></span>| = –(<span class="strong"><strong>v</strong></span><sub>r</sub>• <span class="strong"><strong>n</strong></span>)(e + 1) / [1/m<sub>1</sub> +
      1/m<sub>2</sub> + <span class="strong"><strong>n</strong></span>
      •((<span class="strong"><strong>r</strong></span><sub>1</sub> ×
      <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>1</sub>) × <span class="strong"><strong>r</strong></span><sub>1</sub> + <span class="strong"><strong>n</strong></span> • ((<span class="strong"><strong>r</strong></span><sub>2</sub> × <span class="strong"><strong>n</strong></span>)/<span class="strong"><strong>I</strong></span><sub>2</sub>) × <span class="strong"><strong>r</strong></span><sub>2</sub>]</td></tr></table><p>This formula gives you the collision impulse in the normal
    direction. To see how friction fits in you must keep in mind that friction
    acts tangentially to the contacting surfaces, that combining the friction
    force with the normal impact force yields a new effective line of action
    for the collision, and that the friction force (and impulse) is a function
    of the normal force (impulse) and coefficient of friction. Considering all
    these factors, the new equations to calculate the change in linear and
    angular velocities of two colliding objects are as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span><sub>1+</sub> =
      <span class="strong"><strong>v</strong></span><sub>1–</sub> + (J
      <span class="strong"><strong>n</strong></span> + (µ J) <span class="strong"><strong>t</strong></span>) / m<sub>1</sub></td></tr><tr><td><span class="strong"><strong>v</strong></span><sub>2+</sub> =
      <span class="strong"><strong>v</strong></span><sub>2–</sub> + (–J
      <span class="strong"><strong>n</strong></span> + (µ J) <span class="strong"><strong>t</strong></span>) / m<sub>2</sub></td></tr><tr><td><span class="strong"><strong>ω</strong></span><sub>1+</sub> =
      <span class="strong"><strong>ω</strong></span><sub>1–</sub> +
      (<span class="strong"><strong>r</strong></span><sub>1</sub> × (J
      <span class="strong"><strong>n</strong></span>+ (µ J) <span class="strong"><strong>t</strong></span>)) / <span class="strong"><strong>I</strong></span><sub>cg</sub></td></tr><tr><td><span class="strong"><strong>ω</strong></span><sub>2+</sub> =
      <span class="strong"><strong>ω</strong></span><sub>2–</sub> +
      (<span class="strong"><strong>r</strong></span><sub>2</sub> × (–J
      <span class="strong"><strong>n</strong></span>+ (µ J) <span class="strong"><strong>t</strong></span>)) / <span class="strong"><strong>I</strong></span><sub>cg</sub></td></tr></table><p>In these equations, <span class="strong"><strong>t</strong></span> is the unit
    tangent vector, which is tangent to the collision surfaces and at a right
    angle to the unit normal vector. You can calculate the tangent vector if
    you know the unit normal vector and the relative velocity vector in the
    same plane as the normal vector.</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>t</strong></span> = (<span class="strong"><strong>n</strong></span> × <span class="strong"><strong>v</strong></span><sub>r</sub>) × <span class="strong"><strong>n</strong></span></td></tr><tr><td><span class="strong"><strong>t</strong></span> = <span class="strong"><strong>t</strong></span> / |<span class="strong"><strong>t</strong></span>|</td></tr></table><p>For many problems that you’ll face, you may be able to reasonably
    neglect friction in your collision response routines since its effect may
    be small compared to the effect of the normal impulse itself. However, for
    some types of problems, friction is crucial. For example, the flight
    trajectory of a golf ball depends greatly on the spin imparted to it as a
    result of the club–ball collision. We’ll discuss how spin affects
    trajectory in the next chapter, which covers projectile <a id="I_indexterm5_id315440" class="indexterm"/><a id="I_indexterm5_id315449" class="indexterm"/><a id="I_indexterm5_id315459" class="indexterm"/><a id="I_indexterm5_id315468" class="indexterm"/><a id="I_indexterm5_id315477" class="indexterm"/>motion.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-5-FN-1"><p><sup>[<a href="#CHP-5-FN-1" class="para">13</a>] </sup>We use the classical approach in this book and are mentioning penalty methods only to
        let you know that the method we’re going to show is not the only one. Roughly speaking, the
          <span class="emphasis"><em>penalty</em></span> in <span class="emphasis"><em>penalty methods</em></span> refers to the
        numerical spring constants, which are usually large, that are used to represent the
        stiffness of the springs and thus the hardness (or softness) of the colliding bodies. These
        constants are used in the system of equations of motion describing the motion of all the
        bodies under consideration before and after the collision.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-5-FN-2"><p><sup>[<a href="#CHP-5-FN-2" class="para">14</a>] </sup>The center of percussion is a point located near one of the
        nodes of natural vibration, and is the point at which, when the bat
        strikes the ball, no force is transmitted to the handle of the bat. If
        you’ve ever hit a baseball incorrectly such that you get a painful
        vibrating sensation in your hands, then you know what it feels like to
        miss the center of percussion.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 6. Projectiles</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Fundamentals"/><link rel="prev" href="ch05.html" title="Chapter 5. Collisions"/><link rel="next" href="pt02.html" title="Part II. Rigid-Body Dynamics"/></head><body><section class="chapter" title="Chapter 6. Projectiles" epub:type="chapter" id="projectiles"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Projectiles</h2></div></div></div><p>This chapter is the first <a id="pr6.0" class="indexterm"/>in a series of chapters that discuss specific real-world
  phenomena and systems, such as projectile motion and airplanes, with the
  goal of giving you a solid understanding of their real-life behavior. This
  understanding will help you to model these or similar systems accurately in
  your games. Instead of relying on purely idealized formulas, we’ll present a
  wide variety of practical formulas and data that you can use. We’ve chosen
  the examples in this and later chapters to illustrate common forces and
  phenomena that exists in many systems, not just the ones we’ll be discussing
  here. For example, while <a class="xref" href="ch16.html" title="Chapter 16. Ships and Boats">Chapter 16</a>, “Ships and
  Boats,” discusses buoyancy in detail, buoyancy is not limited to ships; any
  object immersed in a fluid experiences buoyant forces. The same applies for
  the topics discussed in this chapter and <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>, <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a>, <a class="xref" href="ch18.html" title="Chapter 18. Guns and Explosions">Chapter 18</a>,
  and <a class="xref" href="ch19.html" title="Chapter 19. Sports">Chapter 19</a>.</p><p>Once you understand what’s supposed to happen with these and similar
  systems, you’ll be in a better position to interpret your simulation results
  to determine if they make sense—that is, if they are realistic enough.
  You’ll also be better educated on what factors are most important for a
  given system such that you can make appropriate simplifying assumptions to
  help ease your effort. Basically, when designing and optimizing your code,
  you’ll know where to cut things out without sacrificing realism. This gets
  into the subject <a id="I_indexterm6_id315553" class="indexterm"/>of <span class="emphasis"><em>parameter tuning</em></span>.</p><p>Over the next few chapters, we want to give you enough of an
  understanding of certain physical phenomenon such that you can tune your
  models for the desired behavior. If you are modeling several similar objects
  in your simulation but want each one to behave slightly differently, then
  you have to tune the forces that get applied to each object in order to
  achieve the varying behavior. Since forces govern the behavior of objects in
  your simulations, we’ll be focusing on force calculations with the intent of
  showing you how and why certain forces are what they are instead of simply
  using the idealized formulas discussed in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>.
  Parameter tuning isn’t just limited to tuning your model’s behavior—it also
  involves dealing with numerical issues, such as numerical stability in your
  integration algorithms. We’ll discuss these issues more when we show you
  several simulation examples in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>
  through <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14</a>.</p><p>We’ve devoted this entire chapter to projectile motion because so many
  physical problems that may find their way into your games fall in this
  category. Further, the forces governing projectile motion affect many other
  systems that aren’t necessarily projectiles—for example, the drag force
  experienced by projectiles is similar to that experienced by airplanes,
  cars, or any other object moving through a fluid such as air or
  water.</p><p>A projectile is an object that is placed in motion by a force acting
  over a very short period of time, which, as you know from <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>, is also called an impulse. <a id="I_indexterm6_id315606" class="indexterm"/>After the projectile is set in motion by the initial impulse
  during the launching phase, the projectile enters into the projectile motion
  phase, where there is no longer a thrust or propulsive force acting on it.
  As you know already from the examples presented in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> and <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, there are other
  forces that act on projectiles. (For the moment, we’re not talking about
  self-propelled “projectiles” such as rockets since, due to their propulsive
  force, they don’t follow “classical” projectile motion until after they’ve
  expended their fuel.)</p><p>In the simplest case, neglecting aerodynamic effects, the only force
  acting on a projectile other than the initial impulsive force is <a id="I_indexterm6_id315636" class="indexterm"/>gravitation. For situations where the projectile is near the
  earth’s surface, the problem reduces to a constant acceleration problem.
  Assuming that the earth’s surface is flat—that is, that its curvature is
  large compared to the range of the projectile—the following statements
  describe projectile motion:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The trajectory is parabolic.</p></li><li class="listitem"><p>The maximum range, for a given launch velocity, occurs when the
      launch angle is 45°.</p></li><li class="listitem"><p>The velocity at impact is equal to the launch velocity when the
      launch point and impact point are at the same level.</p></li><li class="listitem"><p>The vertical component of velocity is 0 at the apex of the
      trajectory.</p></li><li class="listitem"><p>The time required to reach the apex is equal to the time required
      to descend from the apex to the point of impact assuming that the launch
      point and impact point are at the same level.</p></li><li class="listitem"><p>The time required to descend from the apex to the point of impact
      equals the time required for an object to fall the same vertical
      distance when dropped straight down from a height equal to the height of
      the <a id="I_indexterm6_id315700" class="indexterm"/>apex.</p></li></ul></div><div class="sect1" title="Simple Trajectories"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="simple_trajectories">Simple Trajectories</h2></div></div></div><p>There are four simple <a id="pr6.1" class="indexterm"/><a id="tr6.1" class="indexterm"/>classes of projectile motion problems that we’ll
    summarize:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When the target and launch point are at the same level</p></li><li class="listitem"><p>When the target is at a level higher than the launch
        point</p></li><li class="listitem"><p>When the target is at a level lower than the launch point</p></li><li class="listitem"><p>When the projectile is dropped from a moving system (like an
        airplane) above the target</p></li></ul></div><p>In the first type of problem, the launch point and the target point
    are located on the same horizontal plane. In <a class="xref" href="ch06.html#target_and_launch_point_at_same_level" title="Figure 6-1. Target and launch point at same level">Figure 6-1</a>,
    <span class="emphasis"><em>v</em></span><sub>0</sub> is the initial velocity of
    the projectile at the time of launch, φ is the launch angle,
    <span class="emphasis"><em>R</em></span> is the range of the projectile, and
    <span class="emphasis"><em>h</em></span> is the height of the apex of the trajectory.</p><div class="figure"><a id="target_and_launch_point_at_same_level"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id315831"/><img src="httpatomoreillycomsourceoreillyimages1598913.png" alt="Target and launch point at same level"/></div></div><div class="figure-title">Figure 6-1. Target and launch point at same level</div></div><p>To solve this type of problem, use the formulas shown in <a class="xref" href="ch06.html#formulasmtarget_and_launch_point_at_same" title="Table 6-1. Formulas—target and launch point at same level">Table 6-1</a>. Note, in these
    formulas <span class="emphasis"><em>t</em></span> represents any time instant after launch,
    and <span class="emphasis"><em>T</em></span> represents the total time from launch to
    impact.</p><div class="table"><a id="formulasmtarget_and_launch_point_at_same"/><div class="table-title">Table 6-1. Formulas—target and launch point at same level</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To
            calculate:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this
            formula:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            cos φ) t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>y(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            sin φ) t – (g t<sup>2</sup>) / 2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>x</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>y</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            sin φ – g t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>
              <span class="inlinemediaobject"><img src="inleq_0601.png" alt=""/></span>   
            </p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub><sup>2</sup>
            sin<sup>2</sup> φ) / (2 g)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub> T
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; "><p>(2
            v<sub>o</sub> sin φ) / g</p></td></tr></tbody></table></div></div><p>Remember to keep your units consistent when applying these formulas.
    If you are working in the SI (metric) system, length and distance values
    should be in meters (m); time should be in seconds (s); speed should be in
    meters per second (m/s); and acceleration should be in meters per second
    squared (m/s<sup>2</sup>). In the SI system,
    <span class="emphasis"><em>g</em></span> is 9.8 m/s<sup>2</sup>.</p><p>In the second type of problem, the launch point is located on a
    lower horizontal plane than the target. In <a class="xref" href="ch06.html#target_higher_than_launch_point" title="Figure 6-2. Target higher than launch point">Figure 6-2</a>, the launch point’s
    <span class="emphasis"><em>y</em></span> coordinate is lower than the target’s
    <span class="emphasis"><em>y</em></span> coordinate.</p><div class="figure"><a id="target_higher_than_launch_point"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id316206"/><img src="httpatomoreillycomsourceoreillyimages1598914.png" alt="Target higher than launch point"/></div></div><div class="figure-title">Figure 6-2. Target higher than launch point</div></div><p>For this type of problem, use the formulas shown in <a class="xref" href="ch06.html#formulasmtarget_higher_than_launch_point" title="Table 6-2. Formulas—target higher than launch point">Table 6-2</a>. Notice that most of
    these formulas are the same as those shown in <a class="xref" href="ch06.html#formulasmtarget_and_launch_point_at_same" title="Table 6-1. Formulas—target and launch point at same level">Table 6-1</a>.</p><div class="table"><a id="formulasmtarget_higher_than_launch_point"/><div class="table-title">Table 6-2. Formulas—target higher than launch point</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To
            calculate:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this
            formula:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            cos φ) t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>y(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            sin φ) t – (g t<sup>2</sup>) / 2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>x</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>y</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            sin φ – g t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>
              <span class="inlinemediaobject"><img src="inleq_0602.png" alt=""/></span>   
              
            </p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub><sup>2</sup>
            sin<sup>2</sup> φ) / (2 g)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub> T
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; "><p>(v<sub>o</sub>
            sin φ) / g + 
              <span class="inlinemediaobject"><img src="inleq_0603.png" alt=""/></span> 
            </p></td></tr></tbody></table></div></div><p>Actually, the only formula that has changed is that for
    <span class="emphasis"><em>T</em></span>, where it has been revised to account for the
    difference in elevation between the target and the launch point.</p><p>In the third type of problem, the target is located on a plane lower
    than the launch point; in <a class="xref" href="ch06.html#target_lower_than_launch_point" title="Figure 6-3. Target lower than launch point">Figure 6-3</a>, the target’s
    <span class="emphasis"><em>y</em></span> coordinate is lower than the launch point’s
    <span class="emphasis"><em>y</em></span> coordinate.</p><div class="figure"><a id="target_lower_than_launch_point"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id316578"/><img src="httpatomoreillycomsourceoreillyimages1598915.png" alt="Target lower than launch point"/></div></div><div class="figure-title">Figure 6-3. Target lower than launch point</div></div><p><a class="xref" href="ch06.html#formulasmtarget_lower_than_launch_point" title="Table 6-3. Formulas—target lower than launch point">Table 6-3</a> shows the
    formulas to use for this type of problem. Here again, almost all of the
    formulas are the same as those shown in <a class="xref" href="ch06.html#formulasmtarget_and_launch_point_at_same" title="Table 6-1. Formulas—target and launch point at same level">Table 6-1</a>.</p><div class="table"><a id="formulasmtarget_lower_than_launch_point"/><div class="table-title">Table 6-3. Formulas—target lower than launch point</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To
            calculate:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this
            formula:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            cos φ) t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>y(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(v<sub>o</sub>
            sin φ) t – (g t<sup>2</sup>) / 2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>x</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>y</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            sin φ – g t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p><span class="inlinemediaobject"><img src="inleq_0604.png" alt=""/></span>   </p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>b +
            (v<sub>o</sub><sup>2</sup>
            sin<sup>2</sup> φ) / (2 g)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub> T
            cos φ</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; "><p>(v<sub>o</sub>
              sin φ) / g + <span class="inlinemediaobject"><img src="inleq_0605.png" alt=""/></span>   </p></td></tr></tbody></table></div></div><p>The only formulas that have changed are the formulas for
    <span class="emphasis"><em>h</em></span> and <span class="emphasis"><em>T</em></span>, which have been revised
    to account for the difference in elevation between the target and the
    launch point (except this time the target is lower than the launch
    point).</p><p>Finally, the fourth type of problem involves dropping the projectile
    from a moving system, such as an airplane. In this case, the initial
    velocity of the projectile is horizontal and equal to the speed of the
    vehicle dropping it. <a class="xref" href="ch06.html#projectile_dropped_from_a_moving_system" title="Figure 6-4. Projectile dropped from a moving system">Figure 6-4</a> illustrates this type
    of problem.</p><div class="figure"><a id="projectile_dropped_from_a_moving_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id316947"/><img src="httpatomoreillycomsourceoreillyimages1598916.png" alt="Projectile dropped from a moving system"/></div></div><div class="figure-title">Figure 6-4. Projectile dropped from a moving system</div></div><p><a class="xref" href="ch06.html#formulasmprojectile_dropped_from_a_movin" title="Table 6-4. Formulas—projectile dropped from a moving system">Table 6-4</a> shows
    the formulas to use to solve this type of problem. Note here that when
    v<sub>o</sub> is 0, the problem reduces to a simple free-fall
    problem in which the projectile drops straight down.</p><div class="table"><a id="formulasmprojectile_dropped_from_a_movin"/><div class="table-title">Table 6-4. Formulas—projectile dropped from a moving system</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To
            calculate:</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Use this
            formula:</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>x(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>y(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>h – (g
            t<sup>2</sup>) / 2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>x</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v<sub>y</sub>(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>– g t</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>v(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>
              <span class="inlinemediaobject"><img src="inleq_0606.png" alt=""/></span>   
              
            </p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>h</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>(g
            t<sup>2</sup>) / 2</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>R</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>v<sub>o</sub>
            T</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>T</p></td><td style="text-align: left; vertical-align: top; "><p><span class="inlinemediaobject"><img src="inleq_0607.png" alt=""/></span>  </p></td></tr></tbody></table></div></div><p>These formulas are useful if you’re writing a game that does not
    require a more accurate treatment of projectile motion—that is, if you
    don’t need or want to consider the other forces that can act on a
    projectile when in motion. If you are going for more accuracy, you’ll have
    to consider these other forces and treat the problem as we <a id="I_indexterm6_id317266" class="indexterm"/><a id="I_indexterm6_id317276" class="indexterm"/>did in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>’s example.</p></div><div class="sect1" title="Drag"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="drag">Drag</h2></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> and <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, we
    <a id="pr6.2" class="indexterm"/><a id="fl6.2" class="indexterm"/>showed you the idealized formulas for viscous fluid dynamic
    drag as well as how to implement drag in the equations of motion for a
    projectile. This was illustrated in the example program discussed in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>. Recall that the drag force is a vector just like
    any other force and that it acts on the line of action of the velocity
    vector but in a direction opposing velocity. While those formulas work in
    a game simulation, as we said before, they don’t tell the whole story.
    While we can’t treat the subject of fluid dynamics in its entirety in this
    book, we do want to give you a better understanding of drag than just the
    simple idealized equation presented earlier.</p><p>Analytical methods can show that the drag on an object moving
    through a fluid is proportional to its speed, size, shape, and the density
    and viscosity of the fluid through which it is moving. You can also come
    to these conclusions by drawing on your own real-life experience. For
    example, when waving your hand through the air, you feel very little
    resistance; however, if you put your hand out of a car window traveling at
    100 km/h, then you feel much greater resistance (drag force) on your hand.
    This is because drag is <a id="I_indexterm6_id317370" class="indexterm"/><a id="I_indexterm6_id317380" class="indexterm"/>speed dependent. When you wave your hand underwater—say, in
    a swimming pool—you’ll feel a greater drag force on your hand than you do
    when waving it in the air. This is because water is more dense and viscous
    than air. As you wave your hand underwater, you’ll notice a significant
    difference in drag depending on the orientation of your hand. If your palm
    is in line with the direction of motion—that is, you are leading with your
    palm—then you’ll feel a greater drag force than you would if your hand
    were turned 90 degrees as though you were executing a karate chop through
    the water. This tells you that drag is a function of the shape of the
    object. You get the idea.</p><p>To facilitate our discussion of fluid dynamic drag, let’s look at
    the flow around a <a id="sp6.2" class="indexterm"/><a id="fls6.2" class="indexterm"/>sphere moving through a fluid such as air or water. If the
    sphere is moving slowly through the fluid, the flow pattern around the
    sphere would look something like <a class="xref" href="ch06.html#flow_pattern_around_slowly_moving_sphere" title="Figure 6-5. Flow pattern around slowly moving sphere">Figure 6-5</a>.</p><div class="figure"><a id="flow_pattern_around_slowly_moving_sphere"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id317450"/><img src="httpatomoreillycomsourceoreillyimages1598917.png" alt="Flow pattern around slowly moving sphere"/></div></div><div class="figure-title">Figure 6-5. Flow pattern around slowly moving sphere</div></div><p><span class="emphasis"><em>Bernoulli’s equation</em></span>, which <a id="I_indexterm6_id317473" class="indexterm"/><a id="I_indexterm6_id317479" class="indexterm"/><a id="I_indexterm6_id317489" class="indexterm"/>relates pressure to velocity in fluid flow, says that as the
    fluid moves around the sphere and speeds up, the pressure in the fluid
    (locally) will go down. The equation, presented by Daniel <a id="I_indexterm6_id317502" class="indexterm"/><a id="I_indexterm6_id317508" class="indexterm"/>Bernoulli in 1738, applies to frictionless incompressible
    fluid flow and looks like this:<sup>[<a id="CHP-6-FN-1" href="#ftn.CHP-6-FN-1" epub:type="noteref" class="footnote">15</a>]</sup></p><table style="border: 0; " class="simplelist"><tr><td>P / γ + z + V<sup>2</sup> / (2g) =
      constant</td></tr></table><p>where <span class="emphasis"><em>P</em></span> is the pressure at a point in the fluid
    volume under consideration, γ is the specific weight of the fluid,
    <span class="emphasis"><em>z</em></span> is the elevation of the point under consideration,
    <span class="emphasis"><em>V</em></span> is the fluid velocity at that point, and
    <span class="emphasis"><em>g</em></span> is the acceleration due to gravity. As you can see,
    if the expression on the left is to remain constant, and assuming that
    <span class="emphasis"><em>z</em></span> is constant, then if velocity increases the
    pressure must decrease. Likewise, if pressure increases, then velocity
    must decrease.</p><p>As you can see in <a class="xref" href="ch06.html#flow_pattern_around_slowly_moving_sphere" title="Figure 6-5. Flow pattern around slowly moving sphere">Figure 6-5</a>, the pressure will
    be greatest at the stagnation point,
    <span class="emphasis"><em>S</em></span><sub>l</sub>, and will decrease around
    the leading side of the sphere and then start to increase again around the
    back of the sphere. In an ideal fluid with no friction, the pressure is
    fully recovered behind the sphere and there is a trailing stagnation
    point, <span class="emphasis"><em>S</em></span><sub>t</sub>, whose pressure is
    equal to the pressure at the leading stagnation point. Since the pressure
    fore and aft of the sphere is equal and opposite, there is no net drag
    force acting on the sphere.</p><p>The pressure on the top and bottom of the sphere will be lower than
    at the stagnation points since the fluid velocity is greater over the top
    and bottom. Since this is a case of symmetric flow around the sphere,
    there will be no net pressure difference between the top and bottom of the
    sphere.</p><p>In a real fluid there is friction, which affects the flow around the
    sphere such that the pressure is never fully recovered on the aft side of
    the sphere. As the fluid flows around the sphere, a thin layer sticks to
    the surface of the sphere due to friction. In <a id="I_indexterm6_id317607" class="indexterm"/><a id="I_indexterm6_id317617" class="indexterm"/>this <span class="emphasis"><em>boundary layer</em></span>, the speed of the
    fluid varies from 0 at the sphere surface to the ideal free stream
    velocity, as illustrated in <a class="xref" href="ch06.html#velocity_gradient_within_boundary_layer" title="Figure 6-6. Velocity gradient within boundary layer">Figure 6-6</a>.</p><div class="figure"><a id="velocity_gradient_within_boundary_layer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id317646"/><img src="httpatomoreillycomsourceoreillyimages1598918.png" alt="Velocity gradient within boundary layer"/></div></div><div class="figure-title">Figure 6-6. Velocity gradient within boundary layer</div></div><p>This velocity gradient represents a momentum transfer from the
    sphere to the fluid and gives rise to the frictional component of drag.
    Since a certain amount of fluid is <span class="emphasis"><em>sticking</em></span> to the
    sphere, you can think of this as the energy required to accelerate the
    fluid and move it along with the sphere. (If the flow within this boundary
    layer is laminar, then the viscous shear stress between fluid “layers”
    gives rise to friction drag. When the flow is turbulent, the velocity
    gradient and thus the transfer of momentum gives rise to friction
    drag.)</p><p>Moving further aft along the sphere, the boundary layer grows in
    thickness and will not be able to maintain its adherence to the sphere
    surface, and it will separate at some point. Beyond <a id="I_indexterm6_id317685" class="indexterm"/><a id="I_indexterm6_id317695" class="indexterm"/>this <span class="emphasis"><em>separation point</em></span>, the flow will be
    turbulent, and this is called <a id="I_indexterm6_id317706" class="indexterm"/><a id="I_indexterm6_id317716" class="indexterm"/>the <span class="emphasis"><em>turbulent wake</em></span>. In this region, the
    fluid pressure is lower than that at the front of the sphere. This
    pressure differential gives rise to the pressure component of drag. <a class="xref" href="ch06.html#flow_pattern_around_sphere_showing_separ" title="Figure 6-7. Flow pattern around sphere showing separation">Figure 6-7</a> shows how the flow
    might look.</p><div class="figure"><a id="flow_pattern_around_sphere_showing_separ"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id317744"/><img src="httpatomoreillycomsourceoreillyimages1598919.png" alt="Flow pattern around sphere showing separation"/></div></div><div class="figure-title">Figure 6-7. Flow pattern around sphere showing separation</div></div><p>For a slowly moving sphere, the separation point will be
    approximately 80° from the leading edge.</p><p>Now, if you were to roughen the surface of the sphere, you’ll affect
    the flow around it. As you would expect, this roughened sphere will have a
    higher friction drag component. However, more importantly, the flow will
    adhere to the sphere longer and the separation point will be pushed
    further back to approximately 115°, as shown in <a class="xref" href="ch06.html#flow_around_a_roughened_sphere" title="Figure 6-8. Flow around a roughened sphere">Figure 6-8</a>.</p><div class="figure"><a id="flow_around_a_roughened_sphere"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id317789"/><img src="httpatomoreillycomsourceoreillyimages1598920.png" alt="Flow around a roughened sphere"/></div></div><div class="figure-title">Figure 6-8. Flow around a roughened sphere</div></div><p>This will reduce the size of the turbulent wake and the pressure
    differential, thus decreasing the pressure drag. It’s paradoxical but true
    that, all other things being equal, a slightly roughened sphere will have
    less <span class="emphasis"><em>total</em></span> drag than a smooth one. Ever wonder why
    golf balls have dimples? If so, there’s your answer.</p><p>The total drag on the sphere depends very much on the nature of the
    flow around the sphere—that is, whether the flow is laminar or turbulent.
    This is best illustrated by looking at some experimental data. <a class="xref" href="ch06.html#total_drag_coefficient_for_a_smooth_sphe" title="Figure 6-9. Total drag coefficient for a smooth sphere versus Reynolds number">Figure 6-9</a> shows a typical
    curve of the total drag coefficient for a sphere plotted as a<a id="I_indexterm6_id317827" class="indexterm"/><a id="I_indexterm6_id317836" class="indexterm"/> function of the <span class="emphasis"><em>Reynolds
    number</em></span>.</p><div class="figure"><a id="total_drag_coefficient_for_a_smooth_sphe"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id317881"/><img src="httpatomoreillycomsourceoreillyimages1598921.png" alt="Total drag coefficient for a smooth sphere versus Reynolds numberThe curve shown here is intended to demonstrate the trend of Cd versus Rn for a smooth sphere. For more accurate drag coefficient data for spheres and other shapes, refer to any college-level fluid mechanics text, such as Robert L. Daugherty, Joseph B. Franzini, and E. John Finnemore’s Fluid Mechanics with Engineering Applications (McGraw-Hill)."/></div></div><div class="figure-title">Figure 6-9. Total drag coefficient for a smooth sphere versus Reynolds
      number<sup>[<a id="CHP-6-FN-2" href="#ftn.CHP-6-FN-2" epub:type="noteref" class="footnote">16</a>]</sup></div></div><p>The Reynolds number (commonly denoted
    <span class="emphasis"><em>N</em></span><sub>r</sub> or
    <span class="emphasis"><em>R</em></span><sub>n</sub>) is a dimensionless number
    that represents the speed of fluid flow around an object. It’s a little
    more than just a speed measure, since it includes a characteristic length
    for the object and the viscosity and density of the fluid. <a id="I_indexterm6_id317916" class="indexterm"/><a id="I_indexterm6_id317924" class="indexterm"/>The formula for the Reynolds number is:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>n</sub> = (v L)/υ</td></tr></table><p>or,</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>n</sub> = (v L ρ)/µ</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is speed, <span class="emphasis"><em>L</em></span> is a
    characteristic length of the object (diameter for a sphere),
    <span class="emphasis"><em>υ</em></span> is the kinematic viscosity of the fluid, ρ is the
    fluid mass density, and µ is the absolute viscosity of the fluid. For the
    Reynolds number to work out as a dimensionless number velocity, length and
    kinematic viscosity must have units of m/s, m, and
    m<sup>2</sup>/s, respectively, within the SI
    system.</p><p>This number is useful for non-dimensionalizing data measured from
    tests on an object of given size (like a model) such that you can scale
    the data to estimate the data for similar objects of different size. Here
    “similar” means that the objects are geometrically similar, just different
    scales, and that the flow pattern around the objects is similar. For a
    sphere the characteristic length is diameter, so you can use drag data
    obtained from a small model sphere of given diameter to estimate the drag
    for a larger sphere of different diameter. A more useful application of
    this scaling technique is estimating the viscous drag on ship or airplane
    appendages based on model test data obtained from wind tunnel or tow tank
    experiments.</p><p>The Reynolds number is used as an indicator of the nature of fluid
    flow. A low Reynolds number generally indicates laminar flow, while a high
    Reynolds number generally indicates turbulent flow. Somewhere in between,
    there is a transition range where the flow makes the transition from
    laminar to turbulent flow. For carefully controlled experiments, this
    transition (<span class="emphasis"><em>critical</em></span>) Reynolds number can
    consistently be determined. However, in general the ambient flow field
    around an object—that is, whether it has low or high turbulence—will
    affect when this transition occurs. Further, the transition Reynolds
    number is specific to the type of problem being investigated (for example,
    whether you’re looking at flow within pipes, the flow around a ship, or
    the flow around an airplane, etc.).</p><p>We calculate the total <a id="I_indexterm6_id318014" class="indexterm"/><a id="I_indexterm6_id318025" class="indexterm"/>drag coefficient,
    <span class="emphasis"><em>C</em></span><sub>d</sub>, by measuring the total
    resistance, <span class="emphasis"><em>R</em></span><sub>t</sub>, from tests and
    using the following formula:</p><table style="border: 0; " class="simplelist"><tr><td>C<sub>d</sub> = R<sub>t</sub> / (0.5 ρ
      v<sup>2</sup> A)</td></tr></table><p>where <span class="emphasis"><em>A</em></span> is a characteristic area that depends
    on the object being studied. For a sphere, <span class="emphasis"><em>A</em></span> is
    typically the projected frontal area of the sphere, which is equal to the
    area of a circle of diameter equal to that of the sphere. By comparison,
    for ship hulls, <span class="emphasis"><em>A</em></span> is typically taken as the
    underwater surface area of the hull. If you work out the units on the
    righthand side of this equation, you’ll see that the drag coefficient is
    nondimensional (i.e., it has no units).</p><p>Given the total drag coefficient, you can estimate the total
    resistance (drag) using the following formula:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>t</sub> = (0.5 ρ v<sup>2</sup>
      A) C<sub>d</sub></td></tr></table><p>This is a better equation to use than the ones given in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>, assuming you have sufficient information
    available—namely, the total drag coefficient, density, velocity, and area.
    Note the dependence of total resistance on velocity squared. To get
    <span class="emphasis"><em>R</em></span><sub>t</sub> in units of newtons (N),
    you must have velocity in m/s, area in m<sup>2</sup>, and
    density in kg/m<sup>3</sup> (remember
    C<sub>d</sub> is dimensionless).</p><p>Turning back now to <a class="xref" href="ch06.html#total_drag_coefficient_for_a_smooth_sphe" title="Figure 6-9. Total drag coefficient for a smooth sphere versus Reynolds number">Figure 6-9</a>, you can make a
    couple of observations. First, you can see that the total drag coefficient
    decreases as the Reynolds number increases. This is due to the formation
    of the separation point and its subsequent move aft on the sphere as the
    Reynolds number increases and the relative reduction in pressure drag, as
    discussed previously. At a Reynolds number of approximately 250,000, there
    is a dramatic reduction in drag. This is a result of the flow becoming
    fully turbulent with a corresponding reduction in pressure <a id="I_indexterm6_id318155" class="indexterm"/>drag.</p><p>In the <code class="literal">Cannon2</code> example in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, we <a id="I_indexterm6_id318182" class="indexterm"/><a id="I_indexterm6_id318191" class="indexterm"/><a id="I_indexterm6_id318201" class="indexterm"/>implemented the ideal formula for air drag on the
    projectile. In that case we used a constant value of drag coefficient that
    was arbitrarily defined. As we said earlier, it would be better to use the
    formula presented in this chapter for total drag along with the total drag
    coefficient data shown in <a class="xref" href="ch06.html#total_drag_coefficient_for_a_smooth_sphe" title="Figure 6-9. Total drag coefficient for a smooth sphere versus Reynolds number">Figure 6-9</a> to estimate the drag
    on the projectile. While this is more “accurate,” it does complicate
    matters for you. Specifically, the drag coefficient is now a function of
    the <a id="I_indexterm6_id318221" class="indexterm"/>Reynolds number, which is a function of velocity. You’ll
    have to set up a table of drag coefficients versus the Reynolds number and
    interpolate this table given the Reynolds number calculated at each time
    step. As an alternative, you can fit the drag coefficient data to a curve
    to derive a formula that you can use instead; however, the drag
    coefficient data may be such that you’ll have to use a piecewise approach
    and derive curve fits for each segment of the drag coefficient curve. The
    sphere data presented herein is one such case. The data does not lend
    itself nicely to a single polynomial curve fit over the full range of the
    Reynolds number. In such cases, you’ll end up with a handful of formulas
    for drag coefficient, with each formula valid over a limited range of
    Reynolds numbers.</p><p>While the <code class="literal">Cannon2</code> example does
    have its limitations, it is useful to see the effects of drag on the
    trajectory of the projectile. The obvious effect is that the trajectory is
    no longer parabolic. You can see in <a class="xref" href="ch06.html#cannon2_example_comma_trajectories" title="Figure 6-10. Cannon2 example, trajectories">Figure 6-10</a> that the trajectory
    appears to drop off much more sharply when the projectile is making its
    descent after reaching its apex height.</p><div class="figure"><a id="cannon2_example_comma_trajectories"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id318267"/><img src="httpatomoreillycomsourceoreillyimages1598922.png" alt="Cannon2 example, trajectories"/></div></div><div class="figure-title">Figure 6-10. Cannon2 example, trajectories</div></div><p>Another important effect of drag on trajectory (this applies to
    objects in free fall as well) is the fact that drag will limit the maximum
    vertical velocity attainable. This limit is the so-called
    <span class="emphasis"><em>terminal velocity</em></span>. <a id="I_indexterm6_id318292" class="indexterm"/><a id="I_indexterm6_id318299" class="indexterm"/><a id="I_indexterm6_id318309" class="indexterm"/><a id="I_indexterm6_id318318" class="indexterm"/>Consider an object in free fall for a moment. As the object
    accelerates toward the earth at the gravitation acceleration, its velocity
    increases. As velocity increases, so does drag since drag is a function of
    velocity. At some speed the drag force retarding the object’s motion will
    increase to a point where it is equal to the gravitational force that’s
    pulling the object toward the earth. In the absence of any other forces
    that may affect motion, the net acceleration on the object is 0, and it
    continues its descent at the constant terminal velocity.</p><p>Let us illustrate this further. Go back to the formula we derived
    for the <span class="emphasis"><em>y</em></span> component (vertical component) of velocity
    for the projectile modeled in the <code class="literal">Cannon2</code> example. Here it is again so you don’t
    have to flip back to <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>y2</sub> = (1 / C<sub>d</sub>)
      e<sup>(–C</sup>d<sup>/m)t</sup>
      (C<sub>d</sub> v<sub>y1</sub> + m g) – (m g) /
      C<sub>d</sub></td></tr></table><p>It isn’t obvious from looking at this equation, but the velocity
    component, <span class="emphasis"><em>v</em></span><sub>y2</sub>, asymptotes to
    some constant value as time increases. To help you visualize this, we’ve
    plotted this equation, as shown in <a class="xref" href="ch06.html#terminal_velocity" title="Figure 6-11. Terminal velocity">Figure 6-11</a>.</p><div class="figure"><a id="terminal_velocity"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id318416"/><img src="httpatomoreillycomsourceoreillyimages1598923.png" alt="Terminal velocity"/></div></div><div class="figure-title">Figure 6-11. Terminal velocity</div></div><p>As you can see, over time the velocity reaches a maximum absolute
    value of about −107.25 speed units. The negative velocities indicate that
    the velocity is in the negative y-direction—that is, the object is falling
    toward the earth in this case. (For this calculation we arbitrarily
    assumed a mass of 100, a drag coefficient of 30, and an initial velocity
    of 0.)</p><p>Assuming an initial velocity of 0 and equating the formula for total
    resistance shown earlier to the weight of an object, you can derive the
    following formula for terminal velocity for an object in free fall:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>t</sub> = 
        <span class="inlinemediaobject"><img src="inleq_0608.png" alt=""/></span>   
      
      </td></tr></table><p>The trick in applying this formula is in determining the right value
    for the <a id="I_indexterm6_id318473" class="indexterm"/>drag coefficient. Just for fun, let’s assume a drag
    coefficient of 0.5 and calculate the terminal velocity for several
    different objects. This exercise will allow you to see the influence of
    the object’s size on terminal velocity. <a class="xref" href="ch06.html#terminal_velocities_for_various_objects" title="Table 6-5. Terminal velocities for various objects">Table 6-5</a> gives the terminal
    velocities for various objects in free fall using an air density of 1.225
    kg/m<sup>3</sup> (air at standard atmospheric pressure at
    15°C). Using this equation with density in
    kg/m<sup>3</sup> means that <span class="emphasis"><em>m</em></span> must be
    in kg, <span class="emphasis"><em>g</em></span> in m/s<sup>2</sup>, and
    <span class="emphasis"><em>A</em></span> in m<sup>2</sup> in order to get
    the terminal speed in m/s. We went ahead and converted from m/s to
    kilometers per hour (km/h) to present the results in <a class="xref" href="ch06.html#terminal_velocities_for_various_objects" title="Table 6-5. Terminal velocities for various objects">Table 6-5</a>. The weight of each
    object shown in this table is simply its mass, <span class="emphasis"><em>m</em></span>,
    times <span class="emphasis"><em>g</em></span>.</p><div class="table"><a id="terminal_velocities_for_various_objects"/><div class="table-title">Table 6-5. Terminal velocities for various objects</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Object<sup/></p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Weight
            (N<sup/>)</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Area
            (m<sup>2</sup>)</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Terminal velocity
            (km/h<sup/>)</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skydiver in free
            fall</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>801</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.84</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>201</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Skydiver with open
            parachute</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>801</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21.02</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>40</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Baseball (2.88 in
            diameter)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.42</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4.19×10<sup>−3</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>121</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Golf ball (1.65 in
            diameter)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.5</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.40×10<sup>−3</sup></p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>116</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Raindrop (0.16 in
            diameter)</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>3.34×10<sup>−4</sup></p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>1.29×10<sup>−5</sup></p></td><td style="text-align: left; vertical-align: top; "><p>32</p></td></tr></tbody></table></div></div><p>Although we’ve talked mostly about spheres in this section, the discussions on fluid flow
      generally apply to any object moving through a fluid. Of course, the more complex the object’s
      geometry, the harder it is to analyze the drag forces on it. Other factors such as surface
      condition, and whether or not the object is at the interface between two fluids (such as a
      ship in the ocean) further complicate the analysis. In practice, scale model tests are
      particularly useful. In the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a>, we give several
      sources where you can find more practical drag data for objects other than <a id="I_indexterm6_id318868" class="indexterm"/>spheres.</p></div><div class="sect1" title="Magnus Effect"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="magnus_effect">Magnus Effect</h2></div></div></div><p>The <span class="emphasis"><em>Magnus effect</em></span> (also known as the
    <span class="emphasis"><em>Robbins effect</em></span>) is<a id="pr6.3" class="indexterm"/><a id="ro6.3" class="indexterm"/><a id="ma6.3" class="indexterm"/> quite an interesting phenomenon. You know from the previous
    section that an object moving through a fluid encounters drag. What would
    happen if that object were now spinning as it moved through the fluid? For
    example, consider the <a id="I_indexterm6_id318935" class="indexterm"/><a id="I_indexterm6_id318945" class="indexterm"/>sphere that we talked about earlier and assume that while
    moving through a fluid such as air or water, it spins about an axis
    passing through its center of mass. What happens when the sphere spins is
    the interesting part—it actually generates lift! That’s right,
    <span class="emphasis"><em>lift</em></span>. <a id="li6.3" class="indexterm"/>From everyday experience, most people usually associate lift
    with a wing-like shape such as an airplane wing or a hydrofoil. It is far
    less well known that cylinders and spheres can produce lift as well—that
    is, as long as they are spinning. We’ll use the moving sphere to explain
    what’s happening here.</p><p>From the previous section on drag, you know that for a fast-moving
    sphere there will be some point on the sphere where the flow separates,
    creating a turbulent wake behind the sphere. Recall that the pressure
    acting on the sphere within this turbulent wake is lower than the pressure
    acting on the leading surface of the sphere, and this pressure
    differential gives rise to the pressure drag component. When the sphere is
    spinning—say, clockwise—about a horizontal axis passing through its
    center, as shown in <a class="xref" href="ch06.html#spinning_sphere" title="Figure 6-12. Spinning sphere">Figure 6-12</a>, the fluid passing
    over the top of the sphere will be sped up while the fluid passing under
    the sphere will be retarded.</p><div class="figure"><a id="spinning_sphere"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id319007"/><img src="httpatomoreillycomsourceoreillyimages1598924.png" alt="Spinning sphere"/></div></div><div class="figure-title">Figure 6-12. Spinning sphere</div></div><p>Remember, because of friction, there is a thin boundary layer of
    fluid that attaches to the sphere’s surface. At the sphere’s surface, the
    velocity of the fluid in the boundary layer is 0 relative to the sphere.
    The velocity increases within the boundary layer as you move further away
    from the sphere’s surface. In the case of the spinning sphere, there is
    now a difference in fluid pressure above and below the sphere due to the
    increase in velocity above the sphere and the decrease in velocity below
    the sphere. Further, the separation point on the top side of the sphere
    will be pushed further back along the sphere. The end result is an
    asymmetric flow pattern around the sphere with a net lift force (due to
    the pressure differential) perpendicular to the direction of flow. If the
    surface of the sphere is roughened a little, not only will frictional drag
    increase, but this lift effect will increase as well.</p><p>Don’t let the term <span class="emphasis"><em>lift</em></span> confuse you into
    thinking that this force always acts to lift, or elevate, the sphere. The
    effect of this lift force on the sphere’s trajectory is very much tied to
    the axis of rotation about which the sphere is spinning as related to the
    direction in which the sphere is traveling (that is, its angular
    velocity).</p><p>The magnitude of the Magnus force is proportional to the speed of travel, rate of spin,
      density of fluid, size of the object, and nature of the fluid flow. This force is not easy to
      calculate analytically, and as with many problems in fluid dynamics, you must rely on
      experimental data to accurately estimate it for a specific object under specific conditions.
      There are, however, some analytical techniques that will allow you to approximate the Magnus
      force. Without going into the theoretical details, you can apply the <span class="emphasis"><em>Kutta-Joukouski
        theroem</em></span> to estimate the lift force on rotating objects such as cylinders and
      spheres. The Kutta-Joukouski theorem is <a id="I_indexterm6_id319058" class="indexterm"/>based on a frictionless idealization of fluid flow involving the concept of
      circulation around the object (like a vortex around the object). You can find the details of
      this theory in any fluid dynamics text (we give some references in the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a>), so we won’t go into the details here. However,
      we will give you some results.</p><p>For a spinning circular cylinder moving through a fluid, you can use
    this formula to estimate the Magnus lift force:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>L</sub> = 2 π ρ L v
      r<sup>2</sup> ω</td></tr></table><p>where <span class="emphasis"><em>v</em></span> is the speed of travel,
    <span class="emphasis"><em>L</em></span> is the length of the cylinder,
    <span class="emphasis"><em>r</em></span> is its radius, and ω is its angular velocity in
    radians per second (rad/s). If you have spin, <span class="emphasis"><em>n</em></span>, in
    revolutions per second (rps), then ω = 2 π <span class="emphasis"><em>n</em></span>. If you
    have spin, <span class="emphasis"><em>n</em></span>, in revolutions per minute (rpm), then ω
    = (2 π <span class="emphasis"><em>n</em></span>) / 60.</p><p>For a spinning sphere moving through a fluid, you can use this
    formula:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>L</sub> = (2 π ρ v
      r<sup>4</sup> ω) / (2 r)</td></tr></table><p>where <span class="emphasis"><em>r</em></span> is the radius of the sphere. Consistent
    units for these equations would yield lift force in pounds in the English
    system or newtons in the SI system. In the SI system, the appropriate
    units for these quantities are kg/m<sup>3</sup>, m/s, and
    m, respectively.</p><p>Keep in mind that these formulas only approximate the Magnus force;
    they’ll get you in the ballpark, but they are not exact and actually could
    be off by up to 50% depending on the situation. These formulas assume that
    1) there is no slip between the fluid and the rotating surface of the
    object, 2) there is no friction, 3) surface roughness is not taken into
    account, and 4) there is no boundary layer.</p><p>At any rate, these equations will allow you to approximate the
    Magnus effect for flying objects in your games, where you’ll be able to
    model the relative differences between objects of different size that may
    be traveling at different speeds with different spin rates. You’ll get the
    look right. If numerical accuracy is what you’re looking for, then you’ll
    have to turn to experimental data for your <a id="I_indexterm6_id319174" class="indexterm"/>specific problem.</p><p>Similar to the drag data shown in the previous section, experimental
    lift data is generally presented in terms of lift coefficient. Using an
    equation similar to the drag equation, you can calculate the <a id="I_indexterm6_id319190" class="indexterm"/>lift force with the following equation:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>L</sub> = (0.5 ρ v<sup>2</sup>
      A) C<sub>L</sub></td></tr></table><p>As usual, it’s not as simple as this equation makes it appear. The
    trick is in determining the lift coefficient, C<sub>L</sub>,
    which is a function of surface conditions, the Reynolds number, velocity,
    and spin rate. Further, experiments show that the drag coefficient is also
    affected by spin.</p><p>For example, consider a <a id="I_indexterm6_id319234" class="indexterm"/><a id="I_indexterm6_id319244" class="indexterm"/>golf ball struck perfectly (right!) such that the ball spins
    about a horizontal axis perpendicular to its direction of travel while in
    flight. In this case the Magnus force will tend to lift the ball higher in
    the air, increasing its flight time and range. For a golf ball struck such
    that its initial velocity is 58 m/s with a take-off angle of 10 degrees,
    the increase in range due to Magnus lift is on the order of 59 meters;
    thus, it’s clear that this effect is significant. In fact, over the long
    history of the game of golf, people have attempted to maximize this
    effect. In the late 1800s, when golf balls were still made with smooth
    surfaces, players observed that used balls with roughened surfaces flew
    even better than smooth balls. This observation prompted manufacturers to
    start making balls with rough surfaces so as to maximize the Magnus lift
    effect. The dimples that you see on modern golf balls are the result of
    many decades of experience and research and are thought to be
    optimum.</p><p>Typically a golf ball takes off from the club with an initial
    velocity on the order of 76 m/s, with a backspin on the order of 60
    revolutions per second (rps). For these initial conditions, the
    corresponding Magnus lift coefficient is within the range of 0.1 to 0.35.
    Depending on the spin rate, this lift coefficient can be as high as 0.45,
    and the lift force acting on the ball can be as much as 50% of the ball’s
    weight.</p><p>If the golf ball is struck with a less-than-perfect stroke (that’s
    more like it), the Magnus lift force may work against you. For example, if
    your swing is such that the ball leaves the club head spinning about an
    axis that is not horizontal, then the ball’s trajectory will curve,
    resulting in a slice or a draw. If you top the ball such that the upper
    surface of the ball is spinning away from you, then the ball will tend to
    curve downward much more rapidly, significantly reducing the range of your
    shot.</p><p>As another example, consider a <a id="I_indexterm6_id319283" class="indexterm"/><a id="I_indexterm6_id319293" class="indexterm"/>baseball pitched such that it’s spinning with topspin about
    a horizontal axis perpendicular to its direction of travel. Here the
    Magnus force will tend to cause the ball to curve in a downward direction,
    making it drop more rapidly than it otherwise would without spin. If the
    pitcher spins the ball such that the axis of rotation is not horizontal,
    then the ball will curve out of the vertical plane. Another trick that
    pitchers use is to give the ball backspin, making it appear (to the
    batter) to actually rise. This rising fastball does not
    <span class="emphasis"><em>actually</em></span> rise, but because of the Magnus lift force
    it falls much less rapidly than it would without spin.</p><p>For a typical pitched speed and spin rate of 45 m/s and 30 rps,
    respectively, the lift force can be up to 33% of the ball’s weight. For a
    typical curveball, the lift coefficient is within the range of 0.1 to 0.2,
    and for flyballs it can be up to 0.4.</p><p>These are only two examples; however, you need not look far to find
    other examples of the Magnus force in action. Think about the behavior of
    cricket balls, soccer balls, tennis balls, or ping-pong balls when they
    spin in flight. Bullets fired from a gun with a rifling barrel also spin
    and are affected by this Magnus force. There have even been sailboats
    built with tall, vertical, rotating cylindrical “sails” that use the
    Magnus force for propulsion. We’ve also seen technical articles describing
    a propeller with spinning cylindrical blades instead of airfoil-type
    blades.</p><p>To further illustrate the Magnus effect, we’ve prepared a simple
    example program that simulates a ball being thrown with varying amounts of
    backspin (or topspin). This example is based on the cannon example, so
    here again, the code should look familiar to you. In this example we’ve
    neglected drag, so the only forces that the ball will see are due to
    gravity and the Magnus effect. We did this to isolate the lift-generating
    effect of spin and to keep the equations of motion clearer.</p><p>Since most of the code for this example is identical, or very
    similar, to the previous cannon examples, we won’t repeat it here. We
    will, however, show you the global variables used in this simulation along
    with a revised <code class="literal">DoSimulation</code> function
    that takes care of the equations of motion:</p><a id="I_programlisting6_id319348"/><pre class="programlisting">//----------------------------------------------------------------------------//
// Global variables required for this simulation
//----------------------------------------------------------------------------//
TVector          V1;     // Initial velocity (given), m/s
TVector          V2;     // Velocity vector at time t, m/s
double           m;      // Projectile mass (given), kg
TVector          s1;     // Initial position (given), m
TVector          s2;     // The projectile's position (displacement) vector, m
double           time;   // The time from the instant the projectile
                         // is launched, s
double           tInc;   // The time increment to use when stepping
                         // through the simulation, s
double           g;      // acceleration due to gravity (given), m/s^2
double           spin;   // spin in rpm (given)
double           omega;  // spin in radians per second
double           radius; // radius of projectile (given), m

#define          PI     3.14159f
#define          RHO     1.225f       // kg/m^3

//----------------------------------------------------------------------------//
int     DoSimulation(void)
//----------------------------------------------------------------------------//
{
     double     C = PI * PI * RHO * radius * radius * radius * omega;
     double     t;

     // step to the next time in the simulation
     time+=tInc;
     t = time;

     // Calc. V2:
     V2.i = 1.0f/(1.0f-(t/m)*(t/m)*C*C) * (V1.i + C * V1.j * (t/m) −
            C * g * (t*t)/m);
     V2.j = V1.j + (t/m)*C*V2.i - g*t;

     // Calc. S2:
     s2.i = s1.i + V1.i * t + (1.0f/2.0f) * (C/m * V2.j) * (t*t);
     s2.j = s1.j + V1.j * t + (1.0f/2.0f) * ( ((C*V2.i) - m*g)/m ) * (t*t);


     // Check for collision with ground (x-z plane)
     if(s2.j &lt;= 0)
          return 2;

     // Cut off the simulation if it's taking too long
     // This is so the program does not get stuck in the while loop
     if(time&gt;60)
          return 3;

     return 0;
}</pre><p>The heart of this simulation is the lines that calculate <code class="literal">V2</code> and <code class="literal">s2</code>,
    the instantaneous velocity and position of the projectile, respectively.
    The equations of motion here come from the 2D kinetic equations of motion
    including gravity, as discussed in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, combined
    with the following formula (shown earlier) for estimating the Magnus lift
    on a spinning sphere:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>L</sub> = (2 π<sup>2</sup> ρ v
      r<sup>4</sup> ω) / (2 r)</td></tr></table><p>You can see the effect of spin on the projectile’s trajectory by
    providing the sample program with different values for spin in revolutions
    per minute. The program converts this to radians per second and stores
    this value in the variable <code class="literal">omega</code>. A
    positive spin value indicates bottom spin such that the bottom of the
    sphere is spinning away from you, while a negative spin indicates topspin,
    where the top of the ball spins away from you. Bottom spin generates a
    positive lift force that will tend to extend the range of the projectile,
    while topspin generates negative lift that will force the projectile
    toward the ground, shortening its range. (Note that this example assumes
    that the spin axis is horizontal and perpendicular to the plane of the
    screen.) <a class="xref" href="ch06.html#magnus_effect_sample_program" title="Figure 6-13. Magnus effect sample program">Figure 6-13</a> illustrates this
    <a id="I_indexterm6_id319436" class="indexterm"/><a id="I_indexterm6_id319445" class="indexterm"/><a id="I_indexterm6_id319455" class="indexterm"/>behavior.</p><div class="figure"><a id="magnus_effect_sample_program"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id319477"/><img src="httpatomoreillycomsourceoreillyimages1598925.png" alt="Magnus effect sample program"/></div></div><div class="figure-title">Figure 6-13. Magnus effect sample program</div></div></div><div class="sect1" title="Variable Mass"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="variable_mass">Variable Mass</h2></div></div></div><p>In <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a> we <a id="I_indexterm6_id319509" class="indexterm"/><a id="I_indexterm6_id319519" class="indexterm"/><a id="I_indexterm6_id319529" class="indexterm"/>mentioned that some problems in dynamics involve variable
    mass. We’ll look at variable mass here since it applies to self-propelled
    projectiles such as rockets. When a rocket is producing thrust to
    accelerate, it loses mass (fuel) at some rate. When all of the fuel is
    consumed (burnout), the rocket no longer produces thrust and has reached
    its maximum speed. After burnout you can treat the trajectory of the
    rocket just as you would a non-self-propelled projectile, as discussed
    earlier. However, while the rocket is producing thrust, you need to
    consider its mass change since this will affect its motion.</p><p>In cases where the mass change of the object under consideration is
    such that the mass being expelled or taken in has 0 absolute velocity—like
    a ship consuming fuel, for example—you can set up the equations of motion
    as you normally would, where the sum of the forces equals the rate of
    change in momentum. However, in this case mass will be a function of time,
    and your equations of motion will look like this:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF = m a = d/dt (m v) =m (dv/dt) + (dm/dt) v</td></tr></table><p>You can proceed to solve them just as you would normally, but keep
    in mind the time dependence of mass.</p><p>A rocket, on the other hand, expels mass at some nonzero velocity,
    and you can’t use the preceding approach to properly account for its mass
    change. In this case, you need to consider the relative velocity between
    the expelled mass and the rocket itself. The linear equation of motion now
    looks like this:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF = m dv/dt + dm/dt u</td></tr></table><p>where <span class="emphasis"><em>u</em></span> is the relative velocity between the
    expelled mass and the object (the rocket in this case).</p><p>For a rocket traveling straight up, neglecting air resistance and
    the pressure at the exhaust nozzle, the only force acting on the rocket is
    due to gravity. But the rocket is expelling mass (burning fuel). How it
    expels this mass is not important here, since the forces involved are
    internal to the rocket; we need to consider only the external forces. Let
    the fuel burn rate be <span class="emphasis"><em>–m’</em></span>. The equation of motion (in
    the vertical direction) for the rocket is as follows:</p><table style="border: 0; " class="simplelist"><tr><td>ΣF = m dv/dt + dm/dt u</td></tr><tr><td>−mg = m dv/dt − m’ u</td></tr></table><p>If you rearrange this so that it looks like there’s only an
    <span class="emphasis"><em>ma</em></span> term on the right of this equation, you
    get:</p><table style="border: 0; " class="simplelist"><tr><td>m’ u − mg = m dv/dt = ma</td></tr></table><p>Here you can see that the thrust that propels the rocket into the
    air is equal to <span class="emphasis"><em>m’u</em></span>. Since the fuel burn rate is
    constant, the mass of the rocket at any instant in time is equal
    to:</p><table style="border: 0; " class="simplelist"><tr><td>m = m<sub>o</sub> − m’ t</td></tr></table><p>where <span class="emphasis"><em>m</em></span><sub>o</sub> is the initial
    mass, and the burn rate, <span class="emphasis"><em>m’</em></span>, is in the form mass per
    unit time.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-6-FN-1"><p><sup>[<a href="#CHP-6-FN-1" class="para">15</a>] </sup>In a real fluid with friction, this equation will have extra
        terms that account for energy losses due to friction.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-6-FN-2"><p><sup>[<a href="#CHP-6-FN-2" class="para">16</a>] </sup>The curve shown here is intended to demonstrate the trend of
          C<sub>d</sub> versus R<sub>n</sub> for a
          smooth sphere. For more accurate drag coefficient data for spheres
          and other shapes, refer to any college-level fluid mechanics text,
          such as Robert L. Daugherty, Joseph B. Franzini, and E. John
          Finnemore’s <span class="emphasis"><em>Fluid Mechanics with Engineering
          Applications</em></span> (McGraw-Hill).</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 7. Real-Time Simulations</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="next" href="ch08.html" title="Chapter 8. Particles"/></head><body><section class="chapter" title="Chapter 7. Real-Time Simulations" epub:type="chapter" id="real-time_simulations"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Real-Time Simulations</h2></div></div></div><p>This chapter is the first in a <a id="I_indexterm1_id319702" class="indexterm"/><a id="si7.0" class="indexterm"/>series of chapters designed to give you a thorough
  introduction to the subject of real-time simulation. We say
  <span class="emphasis"><em>introduction</em></span> because the subject is too vast and
  complex to adequately treat in a few chapters; however, we say
  <span class="emphasis"><em>thorough</em></span> because we’ll do more than touch on real-time
  simulations. In fact, we’ll walk you through the development of two simple
  simulations, one in two dimensions and the other in three dimensions.</p><p>What we hope to do is give you enough of an understanding of this
  subject so that you can pursue it further with confidence. In other words,
  we want you to have a solid understanding of the fundamentals before jumping
  in to use someone else’s physics engine, or venturing out to write your
  own.</p><p>In the context of this book, a real-time simulation is a process
  whereby you calculate the state of the object (or objects) you’re trying to
  represent on the fly. You don’t rely on prescripted motion sequences to
  animate your object, but instead you rely on your physics model, the
  equations of motion, and your differential equation solver to take care of
  the motion of your object as the simulation progresses. This sort of
  simulation can be used to model rigid bodies like the airplane in our
  <code class="literal">FlightSim</code> example, or flexible bodies
  such as cloth and human figures. Perhaps one of the most fundamental aspects
  of implementing a real-time rigid-body simulator is solving the equations of
  motion using numerical integration techniques. For this reason, we’ll spend
  this entire chapter explaining the numerical integration techniques that
  you’ll use later in the 2D and 3D simulators that we’ll develop.</p><p>If you refer back for a moment to <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, where
  we outlined a generic procedure for solving kinetics problems, you’ll see
  that we’ve covered a lot of ground so far. The preceding chapters have shown
  you how to estimate mass properties and develop the governing equations of
  motion. This chapter will show you how to solve the equations of motion in
  order to determine acceleration, velocity, and displacement. We’ll follow
  this chapter up with several showing you how to implement both 2D and 3D
  rigid-body simulations.</p><div class="sect1" title="Integrating the Equations of Motion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="integrating_the_equations_of_motion">Integrating the Equations of Motion</h2></div></div></div><p>By now you should <a id="re7.1" class="indexterm"/><a id="eq7.1" class="indexterm"/>have a thorough understanding of the dynamic equations of
    motion for particles and rigid bodies. If not, you may want to go back and
    review <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a> through <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a> before reading this one. The next aspect of dealing
    with the equations of motion is actually solving them in your simulation.
    The equations of motion that we’ve been discussing can be classified as
    ordinary differential equations. In <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> and
    <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, you were able to solve these differential
    equations explicitly since you were dealing with simple functions for
    acceleration, velocity, and displacement. This won’t be the case for your
    simulations. As you’ll see in later chapters, force and moment
    calculations for your system can get pretty complicated and may even rely
    on tabulated empirical data, which will prevent you from writing simple
    mathematical functions that can be easily integrated. This means that you
    have to use numerical integration techniques to approximately integrate
    the equations of motion. We say <span class="emphasis"><em>approximately</em></span> because
    solutions based on numerical integration won’t be exact and will have a
    certain amount of error depending on the chosen method.</p><p>We’re going to start with a rather informal explanation of how we’ll
    apply numerical integration because it will be easier to grasp. Later
    we’ll get into some of the formal mathematics. Take a look at the
    differential equation of linear motion for a particle (or rigid body’s
    center of mass):</p><table style="border: 0; " class="simplelist"><tr><td>F = m dv/dt</td></tr></table><p>Recall that this equation is a statement of force equals mass times acceleration, where
        <span class="emphasis"><em>F</em></span> is force, <span class="emphasis"><em>m</em></span> is mass, and
        <span class="emphasis"><em>dv</em></span>/<span class="emphasis"><em>dt</em></span> is the time derivative of velocity, which is
      acceleration. In the simple examples of the earlier chapters of this book, we rewrote this
      equation in the following form so it could be integrated explicitly:</p><table style="border: 0; " class="simplelist"><tr><td>dv/dt = F/m</td></tr><tr><td>dv = (F/m) dt</td></tr></table><p>One way to interpret this equation is that an infinitesimally small
    change in velocity, <span class="emphasis"><em>dv</em></span>, is equal to
    (<span class="emphasis"><em>F</em></span>/<span class="emphasis"><em>m</em></span>) times an infinitesimally
    small change in time. In earlier examples, we integrated explicitly by
    taking the definite integral of the left side of this equation with
    respect to velocity and the right side with respect to time. In numerical
    integration you have to take finite steps in time, thus
    <span class="emphasis"><em>dt</em></span> goes from being infinitely small to some discrete
    time increment, ∆<span class="emphasis"><em>t</em></span>, and you end up with a discrete
    change in velocity, ∆<span class="emphasis"><em>v</em></span>:</p><table style="border: 0; " class="simplelist"><tr><td>∆v = (F/m) ∆t</td></tr></table><p>It is important to notice here that this does not give a formula for
    instantaneous velocity; instead, it gives you only an approximation of the
    change in velocity. Thus, to approximate the actual velocity of your
    particle (or rigid body), you have to know what its velocity was before
    the time change ∆<span class="emphasis"><em>t</em></span>. At the start of your simulation,
    at time 0, you have to know the starting velocity of your particle. This
    is an initial condition and is required in order to uniquely define your
    particle’s velocity as you step <a id="I_indexterm1_id319956" class="indexterm"/>through time using this equation:<sup>[<a id="CHP-7-FN-1" href="#ftn.CHP-7-FN-1" epub:type="noteref" class="footnote">17</a>]</sup></p><table style="border: 0; " class="simplelist"><tr><td>v<sub>t+∆t</sub> = v<sub>t</sub> + (F/m)
      ∆t</td></tr></table><p>where the initial condition is:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>t=0</sub> = v<sub>0</sub></td></tr></table><p>Here <span class="emphasis"><em>v</em></span><sub>t</sub> is velocity at
    some time <span class="emphasis"><em>t</em></span>,
    <span class="emphasis"><em>v</em></span><sub>t+∆t</sub> is velocity at some time
    plus the time step, ∆<span class="emphasis"><em>t</em></span> is the time step, and
    <span class="emphasis"><em>v</em></span><sub>0</sub> is the initial velocity at
    time 0.</p><p>You can integrate the linear equation of motion one more time in
    order to approximate your particle’s displacement (or position). Once
    you’ve determined the new velocity value, at time <span class="emphasis"><em>t</em></span> +
    ∆<span class="emphasis"><em>t</em></span>, you can approximate displacement using:</p><table style="border: 0; " class="simplelist"><tr><td>s<sub>t+∆t</sub> = s<sub>t</sub> + ∆t
      (v<sub>t+∆t</sub>)</td></tr></table><p>where the initial condition on displacement is:</p><table style="border: 0; " class="simplelist"><tr><td>s<sub>t=0</sub> = s<sub>0</sub></td></tr></table><p>The integration technique discussed here is known as Euler’s method,
    and it is the most basic integration method. While Euler’s method is easy
    to grasp and fairly straightforward to implement, it isn’t necessarily the
    most accurate method.</p><p>You can reason that the smaller you make your time step—that is, as
        ∆<span class="emphasis"><em>t</em></span> approaches <span class="emphasis"><em>dt</em></span>—the closer you’ll get to the
      exact solution. There are, however, computational problems associated with using very small
      time steps. Specifically, you’ll need a huge number of calculations at very small
        ∆<span class="emphasis"><em>t</em></span>’s, and since your calculations won’t be exact (depending on
      numerical precision you’ll be rounding off and truncating numbers), you’ll end up with a
      buildup of round-off error. This means that there is a practical limit as to how small a time
      step you can take. Fortunately, there are several numerical integration techniques at your
      disposal that are designed to increase accuracy for reasonable step sizes.</p><p>Even though we used the linear equation of motion for a particle,
    this integration technique (and the ones we’ll show you later) applies
    equally well to the angular equations of <a id="I_indexterm1_id320129" class="indexterm"/><a id="I_indexterm1_id320139" class="indexterm"/>motion.</p></div><div class="sect1" title="Euler’s Method"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="euleras_method">Euler’s Method</h2></div></div></div><p>The preceding <a id="re7.2" class="indexterm"/><a id="eu7.2" class="indexterm"/>explanation of Euler’s method was, as we said, informal. To
    treat Euler’s method in a more mathematically rigorous way, we’ll look at
    the Taylor series expansion of a general function,
    <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>x</em></span>). Taylor’s theorem<a id="I_indexterm1_id320206" class="indexterm"/><a id="I_indexterm1_id320212" class="indexterm"/> lets you approximate the value of a function at some point
    by knowing something about that function and its derivatives at some other
    point. This approximation is expressed as an infinite polynomial series of
    the form:</p><table style="border: 0; " class="simplelist"><tr><td>y(x + ∆x) = y(x) + (∆x) y'(x) +
      ((∆x)<sup>2</sup> / 2!) y''(x) +
      ((∆x)<sup>3</sup> / 3!) y'''(x) + · · ·</td></tr></table><p>where <span class="emphasis"><em>y</em></span> is some function of
    <span class="emphasis"><em>x</em></span>, (x + ∆<span class="emphasis"><em>x</em></span>) is the new value of
    <span class="emphasis"><em>x</em></span> at which you want to approximate
    <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>y</em></span>' is the first derivative of
    <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>y</em></span>'' is the second derivative
    of <span class="emphasis"><em>y</em></span>, and so on.</p><p>In the case of the equation of motion discussed in the preceding
    section, the function that you are trying to approximate is the velocity
    as a function of time. Thus, you can write
    <span class="emphasis"><em>v</em></span>(<span class="emphasis"><em>t</em></span>) instead of
    <span class="emphasis"><em>y</em></span>(<span class="emphasis"><em>x</em></span>), which yields the Taylor
    expansion:</p><table style="border: 0; " class="simplelist"><tr><td>v(t + ∆t) = v(t) + (∆t) v'(t) +
      ((∆t)<sup>2</sup> / 2!) v''(t) +
      ((∆t)<sup>3</sup> / 3!) v'''(t) + · · ·</td></tr></table><p>Note here that <span class="emphasis"><em>v</em></span>'(<span class="emphasis"><em>t</em></span>) is
    equal to <span class="emphasis"><em>dv</em></span>/<span class="emphasis"><em>dt</em></span>, which equals
    <span class="emphasis"><em>F</em></span>/<span class="emphasis"><em>m</em></span> in the example equation of
    motion discussed in the preceding section. Note also that you know the
    value of <span class="emphasis"><em>v</em></span> at time <span class="emphasis"><em>t</em></span>. What you
    want to find is the value of <span class="emphasis"><em>v</em></span> at time
    <span class="emphasis"><em>t</em></span> + ∆<span class="emphasis"><em>t</em></span> knowing
    <span class="emphasis"><em>v</em></span> at time <span class="emphasis"><em>t</em></span> and its derivative
    at time <span class="emphasis"><em>t</em></span>. As a first approximation, and since you
    don’t know anything about <span class="emphasis"><em>v</em></span>’s second, third, or
    higher derivatives, you can truncate the polynomial series after the term
    (∆<span class="emphasis"><em>t</em></span>) <span class="emphasis"><em>v</em></span>'(<span class="emphasis"><em>t</em></span>),
    which yields:</p><table style="border: 0; " class="simplelist"><tr><td>v(t + ∆t) = v(t) + (∆t) v'(t)</td></tr></table><p>This is the Euler integration formula that you saw in the last
    section. Since Euler’s formula goes out only to the term that includes the
    first derivative, the rest of the series that was left off<a id="tr7.2" class="indexterm"/> is the <span class="emphasis"><em>truncation error</em></span>. These terms
    that were left off are called<a id="I_indexterm1_id320424" class="indexterm"/> <span class="emphasis"><em>higher-order terms</em></span>, and getting rid of
    them results in a first-order approximation. The rationale behind this
    approximation is that the further you go in the series, the smaller the
    terms and the less influence they have on the approximation. Since
    ∆<span class="emphasis"><em>t</em></span> is presumed to be a small number,
    ∆<span class="emphasis"><em>t</em></span><sup>2</sup> is even smaller,
    ∆<span class="emphasis"><em>t</em></span><sup>3</sup> even smaller, and so
    on, and since these ∆<span class="emphasis"><em>t</em></span> terms appear in the
    numerators, each successively higher-order term gets smaller and smaller.
    In this case, the first truncated term,
    ((∆<span class="emphasis"><em>t</em></span>)<sup>2</sup> /
    <span class="emphasis"><em>2</em></span>!) <span class="emphasis"><em>v</em></span>''(<span class="emphasis"><em>t</em></span>),
    dominates the truncation error, and this method is said to have an error
    of order (∆<span class="emphasis"><em>t</em></span>)<sup>2</sup>.</p><p>Geometrically, Euler’s method approximates a new value, at the
    current step, for the function under consideration by extrapolating in the
    direction of the derivative of the function at the previous step. This is
    illustrated in <a class="xref" href="ch07.html#euler_integration_step" title="Figure 7-1. Euler integration step">Figure 7-1</a>.</p><div class="figure"><a id="euler_integration_step"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id320505"/><img src="httpatomoreillycomsourceoreillyimages1598926.png" alt="Euler integration step"/></div></div><div class="figure-title">Figure 7-1. Euler integration step</div></div><p><a class="xref" href="ch07.html#euler_integration_step" title="Figure 7-1. Euler integration step">Figure 7-1</a> illustrates the truncation error and shows that
      Euler’s method will result in a polygonal approximation of the smooth function under
      consideration. Clearly, if you decrease the step size, you increase the number of polygonal
      segments and better approximate the function. As we said before, though, this isn’t always
      efficient to do since the number of computations in your simulation will increase and
      round-off error will accumulate more rapidly.</p><p>To illustrate Euler’s method in practice, let’s examine the linear
    equation of motion for the ship example of <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>:</p><table style="border: 0; " class="simplelist"><tr><td>T – (C v) = ma</td></tr></table><p>where <span class="emphasis"><em>T</em></span> is the propeller’s thrust,
    <span class="emphasis"><em>C</em></span> is a drag coefficient, <span class="emphasis"><em>v</em></span> is
    the ship’s velocity, <span class="emphasis"><em>m</em></span> its mass, and
    <span class="emphasis"><em>a</em></span> its acceleration.</p><p><a class="xref" href="ch07.html#euler_integration_comparison" title="Figure 7-2. Euler integration comparison">Figure 7-2</a> shows the Euler
    integration solution, using a 0.5s time step, superimposed over the exact
    solution derived in <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a> for the ship’s speed over
    time.</p><div class="figure"><a id="euler_integration_comparison"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id320600"/><img src="httpatomoreillycomsourceoreillyimages1598927.png" alt="Euler integration comparison"/></div></div><div class="figure-title">Figure 7-2. Euler integration comparison</div></div><p>Zooming in on this graph allows you to see the error in the Euler
    approximation. This is shown in <a class="xref" href="ch07.html#euler_error" title="Figure 7-3. Euler error">Figure 7-3</a>.</p><div class="figure"><a id="euler_error"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id320637"/><img src="httpatomoreillycomsourceoreillyimages1598928.png" alt="Euler error"/></div></div><div class="figure-title">Figure 7-3. Euler error</div></div><p><a class="xref" href="ch07.html#exact_solution_versus_euler_solution" title="Table 7-1. Exact solution versus Euler solution">Table 7-1</a> shows the
    numerical values of speed versus time for the range shown in <a class="xref" href="ch07.html#euler_error" title="Figure 7-3. Euler error">Figure 7-3</a>. Also shown in <a class="xref" href="ch07.html#exact_solution_versus_euler_solution" title="Table 7-1. Exact solution versus Euler solution">Table 7-1</a> is the percent
    difference, the error, between the exact solution and the Euler solution
    at each time step.</p><div class="table"><a id="exact_solution_versus_euler_solution"/><div class="table-title">Table 7-1. Exact solution versus Euler solution</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time
            (s)</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Velocity, exact
            (m/s)</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Velocity, Euler
            (m/s)</p></td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Error</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6.5</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9.559084</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9.733158</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1.82%</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.06829</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.2465</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1.77%</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7.5</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.55267</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10.73418</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1.72%</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11.01342</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11.19747</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1.67%</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>8.5</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>11.4517</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>11.63759</p></td><td style="text-align: left; vertical-align: top; "><p>1.62%</p></td></tr></tbody></table></div></div><p>As you can see, the truncation error in this example isn’t too bad.
    It could be better, though, and we’ll show you some more accurate methods
    in a moment. Before that, however, you should notice that in this example
    Euler’s method is also stable—that is, it converges well with the exact
    solution as shown in <a class="xref" href="ch07.html#convergence" title="Figure 7-4. Convergence">Figure 7-4</a>, where we’ve carried
    the time <a id="I_indexterm1_id320986" class="indexterm"/>range out further.</p><div class="figure"><a id="convergence"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id321009"/><img src="httpatomoreillycomsourceoreillyimages1598929.png" alt="Convergence"/></div></div><div class="figure-title">Figure 7-4. Convergence</div></div><p>Here’s a code snippet that implements Euler’s method for this
    example:</p><a id="I_programlisting1_id321030"/><pre class="programlisting">// Global Variables
float     T;     // thrust
float     C;     // drag coefficient
float     V;     // velocity
float     M;     // mass
float     S;     // displacement

.
.
.

// This function progresses the simulation by dt seconds using
// Euler's basic method
void StepSimulation(float dt)
{
     float     F;     // total force
     float     A;     // acceleration
     float     Vnew;  // new velocity at time t + dt
     float     Snew;  // new position at time t + dt

     // Calculate the total force
     F = (T − (C * V));

     // Calculate the acceleration
     A = F / M;

     // Calculate the new velocity at time t + dt
     // where V is the velocity at time t
     Vnew = V + A * dt;

     // Calculate the new displacement at time t + dt
     // where S is the displacement at time t
     Snew = S + Vnew * dt;

     // Update old velocity and displacement with the new ones
     V = Vnew;
     S = Snew;
}</pre><p>Although Euler’s method is stable in this example, that isn’t always so, depending on the
      problem you’re trying to solve. This is something that you must keep in mind when implementing
      any numerical integration scheme. What we mean by <span class="emphasis"><em>stable</em></span> here is that, in
      this case, the Euler solution converges with the exact solution. An unstable solution could
      manifest errors in two ways. First, successive values could oscillate above and below the
      exact solution, never quite converging on it. Second, successive values could diverge from the
      exact solution, creating a greater and greater error over time.</p><p>Take a look at <a class="xref" href="ch07.html#unstable_results_using_euleras_method" title="Figure 7-5. Unstable results using Euler’s method">Figure 7-5</a>. This figure shows how
    Euler’s method can become very unstable. What you see in the graph
    represents the vibratory motion of a spring-mass system. This is a simple
    dynamical system that should exhibit regular sinusoidal motion.</p><div class="figure"><a id="unstable_results_using_euleras_method"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id321077"/><img src="httpatomoreillycomsourceoreillyimages1598930.png" alt="Unstable results using Euler’s method"/></div></div><div class="figure-title">Figure 7-5. Unstable results using Euler’s method</div></div><p>It’s clear from the figure that using Euler’s method yields terribly
    unstable results. You can see how the motion amplitude continues to grow.
    If this were a game, say, where you have a few objects connected by
    springs interacting with one another, then this sort of instability would
    manifest itself by wildly unrealistic motion of those objects. Worse yet,
    the simulation could blow up, numerically speaking.</p><p>Often, your choice of step size affects stability where smaller step
    sizes tend to eliminate or minimize instability and larger steps aggravate
    the problem. If you’re working with a particularly unwieldy function, you
    might find that you have to decrease your step size substantially in order
    to achieve stability. This, however, increases the number of computations
    you need to make. One way around this difficulty is to employ what’s
    called an <span class="emphasis"><em>adaptive step size method</em></span>, in which
    <a id="I_indexterm1_id321116" class="indexterm"/>you change your step size on the fly depending on the
    magnitude of a predicted amount of truncation error from one step to the
    next. If the truncation error is too large, then you back up a step,
    decrease your step size, and try again.</p><p>One way to implement this for Euler’s method is to first take a step
    of size ∆<span class="emphasis"><em>t</em></span> to obtain an estimate at time
    <span class="emphasis"><em>t</em></span> + ∆<span class="emphasis"><em>t</em></span>, and then take two steps
    (starting from time <span class="emphasis"><em>t</em></span> again) of size
    ∆<span class="emphasis"><em>t</em></span>/<span class="emphasis"><em>2</em></span> to obtain another estimate
    at time <span class="emphasis"><em>t</em></span> + ∆<span class="emphasis"><em>t</em></span>. Since we’ve been
    talking velocity in the examples so far, let’s call the first estimate
    <span class="emphasis"><em>v</em></span><sub>1</sub> and the second estimate
    <span class="emphasis"><em>v</em></span><sub>2</sub>.<sup>[<a id="CHP-7-FN-2" href="#ftn.CHP-7-FN-2" epub:type="noteref" class="footnote">18</a>]</sup> A measure of the truncation error is then:</p><table style="border: 0; " class="simplelist"><tr><td>e<sub>t</sub> = |v<sub>1</sub> –
      v<sub>2</sub>|</td></tr></table><p>If you wish to keep the truncation error within a specified limit,
    <span class="emphasis"><em>e</em></span><sub>to</sub>, then you can use the
    following formula to find out what your step size should be in order to
    maintain the desired accuracy:</p><table style="border: 0; " class="simplelist"><tr><td>∆t<sub>new</sub> = ∆t<sub>old</sub>
      (e<sub>to</sub> / e<sub>t</sub>)
      <sup>(1/2)</sup></td></tr></table><p>Here, ∆<span class="emphasis"><em>t</em></span><sub>old</sub> is the old
    time step and ∆<span class="emphasis"><em>t</em></span><sub>new</sub> is the new
    one that you should use to maintain the desired accuracy. You’ll have to
    make this check for each time step, and if you find that the error
    warrants a smaller time step, then you’ll have to back up a step and
    repeat it with the new time step.</p><p>Here’s a revised <code class="literal">StepSimulation</code>
    function that implements this adaptive step size technique, checking the
    truncation error on <a id="I_indexterm1_id321272" class="indexterm"/><a id="I_indexterm1_id321282" class="indexterm"/>the velocity integration:</p><a id="I_programlisting1_id321293"/><pre class="programlisting">// New global variable
float     eto;     // truncation error tolerance

// This function progresses the simulation by dt seconds using
// Euler's basic method with an adaptive step size
void StepSimulation(float dt)
{
     float     F;     // total force
     float     A;     // acceleration
     float     Vnew;  // new velocity at time t + dt
     float     Snew;  // new position at time t + dt
     float     V1, V2; // temporary velocity variables
     float     dtnew;  // new time step
     float     et;     // truncation error

     // Take one step of size dt to estimate the new velocity
     F = (T − (C * V));
     A = F / M;
     V1 = V + A * dt;

     // Take two steps of size dt/2 to estimate the new velocity
     F = (T − (C * V));
     A = F / M;
     V2 = V + A * (dt/2);

     F = (T − (C * V2));
     A = F / M;
     V2 = V2 + A * (dt/2);

     // Estimate the truncation error
     et = absf(V1 − V2);

     // Estimate a new step size
     dtnew = dt * SQRT(eto/et);


     if (dtnew &lt; dt)
     { // take at step at the new smaller step size
          F = (T − (C * V));
          A = F / M;
          Vnew = V + A * dtnew;
          Snew = S + Vnew * dtnew;
     } else
     { // original step size is okay
          Vnew = V1;
          Snew = S + Vnew * dt;
     }

     // Update old velocity and displacement with the new ones
     V = Vnew;
     S = Snew;
}</pre></div><div class="sect1" title="Better Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="better_methods">Better Methods</h2></div></div></div><p>At this point, you might <a id="im7.3" class="indexterm"/><a id="eu7.3" class="indexterm"/><a id="re7.3" class="indexterm"/>be wondering why you can’t simply use more terms in the
    Taylor series to reduce the truncation error of Euler’s method. In fact,
    this is the basis for several integration methods that offer greater
    accuracy than Euler’s basic method for a given step size. Part of the
    difficulty associated with picking up more terms in the Taylor’s series
    expansion is in being able to determine the second, third, fourth, and
    higher derivatives of the function you’re trying to integrate. The way
    around this problem is to perform additional Taylor series expansions to
    approximate the derivatives of the function under consideration and then
    substitute those values back into your original expansion.</p><p>Taking this approach to include one <a id="I_indexterm1_id321376" class="indexterm"/><a id="I_indexterm1_id321382" class="indexterm"/>more Taylor term beyond the basic Euler method yields a
    so-called <span class="emphasis"><em>improved Euler method</em></span> that has a reduced
    truncation error on the order of
    (∆<span class="emphasis"><em>t</em></span>)<sup>3</sup> instead of
    (∆<span class="emphasis"><em>t</em></span>)<sup>2</sup>. The formulas for
    this method are:</p><table style="border: 0; " class="simplelist"><tr><td>k<sub>1</sub> = (∆t) y'(t, y)</td></tr><tr><td>k<sub>2</sub> = (∆t) y'(t + ∆t, y +
      k<sub>1</sub>)</td></tr><tr><td>y(t + ∆t) = y(t) + ½ (k<sub>1</sub> +
      k<sub>2</sub>)</td></tr></table><p>Here <span class="emphasis"><em>y</em></span> is a function of <span class="emphasis"><em>t</em></span>,
    and <span class="emphasis"><em>y</em></span>' is the derivative as a function of
    <span class="emphasis"><em>t</em></span> and possibly of <span class="emphasis"><em>y</em></span> depending on
    the equations you’re trying to solve, and ∆<span class="emphasis"><em>t</em></span> the step
    size.</p><p>To make this clearer for you, we’ll show these formulas in terms of
    the ship example equation of motion of <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, the
    same example that we discussed in the previous section. In this case,
    velocity is approximated by the following formulas:</p><table style="border: 0; " class="simplelist"><tr><td>k<sub>1</sub> = ∆t [1/m (T – C
      v<sub>t</sub>)]</td></tr><tr><td>k<sub>2</sub> = ∆t [1/m (T – C
      (v<sub>t</sub> + k<sub>1</sub>))]</td></tr><tr><td>v<sub>t+∆t</sub> = v<sub>t</sub> +
      ½(k<sub>1</sub> + k<sub>2</sub>)</td></tr></table><p>where <span class="emphasis"><em>v</em></span><sub>t</sub> is the velocity
    at time <span class="emphasis"><em>t</em></span>, and
    <span class="emphasis"><em>v</em></span><sub>t+∆t</sub> is the new velocity at
    time <span class="emphasis"><em>t</em></span>+∆<span class="emphasis"><em>t</em></span>.</p><p>Here is the revised <code class="literal">StepSimulation</code> function showing how to implement
    this method in code:</p><a id="I_programlisting1_id321573"/><pre class="programlisting">// This function progresses the simulation by dt seconds using
// the "improved" Euler method
void StepSimulation(float dt)
{
     float     F;     // total force
     float     A;     // acceleration
     float     Vnew;  // new velocity at time t + dt
     float     Snew;  // new position at time t + dt
     float     k1, k2;


     F = (T - (C * V));
     A = F/M;
     k1 = dt * A;

     F = (T - (C * (V + k1)));
     A = F/M;
     k2 = dt * A;

     // Calculate the new velocity at time t + dt
     // where V is the velocity at time t
     Vnew = V + (k1 + k2) / 2;

     // Calculate the new displacement at time t + dt
     // where S is the displacement at time t
     Snew = S + Vnew * dt;

     // Update old velocity and displacement with the new ones
     V = Vnew;
     S = Snew;
}</pre><p>We can carry out this procedure of taking on more Taylor terms even
    further. The <a id="ru7.3" class="indexterm"/><a id="ret7.3" class="indexterm"/>popular Runge-Kutta method takes such an approach to reduce
    the truncation error to the order of
    (∆<span class="emphasis"><em>t</em></span>)<sup>5</sup>. The integration
    formulas for this method are as follows:</p><table style="border: 0; " class="simplelist"><tr><td>k<sub>1</sub> = (∆t) y'(t, y)</td></tr><tr><td>k<sub>2</sub> = (∆t) y'(t + ∆t/2, y +
      k<sub>1</sub>/2)</td></tr><tr><td>k<sub>3</sub> = (∆t) y'(t + ∆t/2, y +
      k<sub>2</sub>/2)</td></tr><tr><td>k<sub>4</sub> = (∆t) y'(t + ∆t, y +
      k<sub>3</sub>)</td></tr><tr><td>y(t + ∆t) = y(t) + 1/6 (k<sub>1</sub> + 2
      (k<sub>2</sub>) + 2 (k<sub>3</sub>) +
      k<sub>4</sub>)</td></tr></table><p>Applying these formulas to our ship example yields:</p><table style="border: 0; " class="simplelist"><tr><td>k<sub>1</sub> = ∆t [1/m (T – C
      v<sub>t</sub>)]</td></tr><tr><td>k<sub>2</sub> = ∆t [1/m (T – C
      (v<sub>t</sub> + k<sub>1</sub>/2))]</td></tr><tr><td>k<sub>3</sub> = ∆t [1/m (T – C
      (v<sub>t</sub> + k<sub>2</sub>/2))]</td></tr><tr><td>k<sub>4</sub> = ∆t [1/m (T – C
      (v<sub>t</sub> + k<sub>3</sub>))]</td></tr><tr><td>v<sub>t+∆t</sub> = v<sub>t</sub> + 1/6
      (k<sub>1</sub> + 2 (k<sub>2</sub>) + 2
      (k<sub>3</sub>) + k<sub>4</sub>)</td></tr></table><p>For our example, the Runge-Kutta method is implemented as
    follows:</p><a id="I_programlisting1_id321789"/><pre class="programlisting">// This function progresses the simulation by dt seconds using
// the Runge-Kutta method
void StepSimulation(float dt)
{
     float     F;     // total force
     float     A;     // acceleration
     float     Vnew;  // new velocity at time t + dt
     float     Snew;  // new position at time t + dt
     float     k1, k2, k3, k4;


     F = (T - (C * V));
     A = F/M;
     k1 = dt * A;

     F = (T - (C * (V + k1/2)));
     A = F/M;
     k2 = dt * A;

     F = (T - (C * (V + k2/2)));
     A = F/M;
     k3 = dt * A;

     F = (T - (C * (V + k3)));
     A = F/M;
     k4 = dt * A;

     // Calculate the new velocity at time t + dt
     // where V is the velocity at time t
     Vnew = V + (k1 + 2*k2 + 2*k3 + k4) / 6;

     // Calculate the new displacement at time t + dt
     // where S is the displacement at time t
     Snew = S + Vnew * dt;

     // Update old velocity and displacement with the new ones
     V = Vnew;
     S = Snew;
}</pre><p>To show you how accuracy is improved over the basic Euler method,
    we’ve superimposed integration results for the ship example using these
    two methods over those shown in <a class="xref" href="ch07.html#euler_integration_comparison" title="Figure 7-2. Euler integration comparison">Figure 7-2</a> and <a class="xref" href="ch07.html#euler_error" title="Figure 7-3. Euler error">Figure 7-3</a>. <a class="xref" href="ch07.html#method_comparison" title="Figure 7-6. Method comparison">Figure 7-6</a> and <a class="xref" href="ch07.html#a_closer_look" title="Figure 7-7. A closer look">Figure 7-7</a> show the results, where <a class="xref" href="ch07.html#a_closer_look" title="Figure 7-7. A closer look">Figure 7-7</a> is a zoomed view of 7-6.</p><div class="figure"><a id="method_comparison"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id321842"/><img src="httpatomoreillycomsourceoreillyimages1598931.png" alt="Method comparison"/></div></div><div class="figure-title">Figure 7-6. Method comparison</div></div><div class="figure"><a id="a_closer_look"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id321871"/><img src="httpatomoreillycomsourceoreillyimages1598932.png" alt="A closer look"/></div></div><div class="figure-title">Figure 7-7. A closer look</div></div><p>As you can see from these figures, it’s impossible to discern the curves for the improved
      Euler and Runge-Kutta methods from the exact solution because they fall almost right on top of
      each other. These results clearly show the improvement in accuracy over the basic Euler
      method, whose curve is distinct from the other three. Over the interval from 6.5 to 8.5
      seconds, the average truncation error is 1.72%, 0.03%, and
      3.6×10<sup>−6</sup>% for Euler’s method, the improved Euler method, the
      Runge-Kutta method, respectively. It is obvious, based on these results, that for this
      problem, the Runge-Kutta method yields substantially better results for a given step size than
      the other two methods. Of course, you pay for this accuracy, since you have several more
      computations per step in the Runge-Kutta method.</p><p>Both of these methods are generally more stable than Euler’s method,
    which is a huge benefit in real-time applications. Recall our discussion
    earlier about the stability of Euler’s method. <a class="xref" href="ch07.html#unstable_results_using_euleras_method" title="Figure 7-5. Unstable results using Euler’s method">Figure 7-5</a> showed the results of
    applying Euler’s method to an oscillating dynamical system. There, the
    motion results that should be sinusoidal were wildly erratic (i.e.,
    unstable). Applying the improved Euler method, or the Runge-Kutta method,
    to the same problem yields stable results, as shown in <a class="xref" href="ch07.html#stable_results_using_the_improved_euler" title="Figure 7-8. Stable results using the improved Euler or the Runge-Kutta methods">Figure 7-8</a>.</p><div class="figure"><a id="stable_results_using_the_improved_euler"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id321932"/><img src="httpatomoreillycomsourceoreillyimages1598933.png" alt="Stable results using the improved Euler or the Runge-Kutta methods"/></div></div><div class="figure-title">Figure 7-8. Stable results using the improved Euler or the Runge-Kutta
      methods</div></div><p>Here the oscillatory motion is clearly sinusoidal, as it should be.
    The results for this particular problem are almost identical whether you
    use the improved Euler method or the Runge-Kutta method. Since for this
    problem the results of both methods are virtually the same, you can save
    computational time and memory using the improved Euler method versus the
    Runge-Kutta method. This can be a significant advantage for real-time
    games. Remember the Runge-Kutta method requires four derivative
    computations per time step.</p><p>These methods aren’t the only ones at your disposal, but they are the most common. The
      Runge-Kutta method is particularly popular as a general-purpose numerical integration scheme.
      Other methods attempt to improve computational efficiency even further—that is, they are
      designed to minimize truncation error while still allowing you to take relatively large step
      sizes so as to reduce the number of steps you have to take in your integration. Still other
      methods are especially tailored for specific problem types. We cite some pretty good
      references for further reading on this subject in the <a id="I_indexterm1_id321970" class="indexterm"/><a id="I_indexterm1_id321980" class="indexterm"/><a id="I_indexterm1_id321989" class="indexterm"/><a id="I_indexterm1_id321998" class="indexterm"/><a id="I_indexterm1_id322008" class="indexterm"/><a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a>.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id1">Summary</h2></div></div></div><p>At this point you should be comfortable with the terms that appear in the equations of
      motion and be able to calculate terms like the sum of forces and moments, mass, and inertia.
      You should also have a solid understanding of basic numerical integration techniques.
      Implementing these techniques in code is really straightforward since they are composed of
      simple polynomial functions. The hard part is developing the derivative function for your
      problem. In the case of the equations of motion, the derivative function will include all your
      force and moment calculations for the particle or rigid body that you are modeling. You’ll see
      some more numerical integration <a id="I_indexterm1_id322037" class="indexterm"/>code when you get to <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>, <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>, and <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-7-FN-1"><p><sup>[<a href="#CHP-7-FN-1" class="para">17</a>] </sup>In mathematics, this sort of problem is termed an
        <span class="emphasis"><em>initial value problem</em></span>.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-7-FN-2"><p><sup>[<a href="#CHP-7-FN-2" class="para">18</a>] </sup>Even though we’re talking about velocity and time here, these
        techniques apply to any function—for example, displacement versus
        time, etc.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 8. Particles</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch07.html" title="Chapter 7. Real-Time Simulations"/><link rel="next" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator"/></head><body><section class="chapter" title="Chapter 8. Particles" epub:type="chapter" id="particles"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Particles</h2></div></div></div><p>In this chapter we’ll show <a id="si8.0" class="indexterm"/><a id="pa8.0" class="indexterm"/>you how to apply what you’ve learned in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> in a
    simple particle simulator. Before getting to the specifics of the example we’ll present, let’s
    consider particles in general. Particles are simple idealizations that can be used to simulate
    all sorts of phenomena or special effects within a game. For example, particle simulations are
    often used to simulate smoke, fire, and explosions. They can also be used to simulate water,
    dust clouds, and swarms of insects, among many other things. Really, your imagination is the
    only limit. Particles lend themselves to simulating both discrete objects like bouncing balls
    and continua like water. Plus, you can easily ascribe an array of attributes to particles
    depending on what you’re modeling.</p><p>For example, say, you’re modeling fire using particles. Each particle will rise in the air,
    and as it cools its color will change until it fades away. You can tie the particle’s color to
    its temperature, which is modeled using thermodynamics. The attribute you’d want to track is the
    particle’s temperature. In a previous work, <a class="ulink" href="http://shop.oreilly.com/product/9780596005559.do" target="_top"><span class="emphasis"><em>AI for Game
        Programmers</em></span></a> (O’Reilly), this book’s coauthor <a id="I_indexterm2_id322138" class="indexterm"/>David M. Bourg used particles to represent swarms of insects that would swarm,
    flock, chase, and evade depending on the artificial intelligence (AI). The AI controlled their
    behavior, which was then implemented as a system of particles using principles very similar to
    what you’ll see in this chapter.</p><p>Particles are not limited to collections of independent objects either. Later in this book,
    you’ll learn how to connect particles together using springs to create deformable objects such
    as cloth. Particles are extremely versatile, and you’ll do well to learn how to leverage their
    simplicity.</p><p>You can use <a id="I_indexterm2_id322157" class="indexterm"/>particles to model sand in a simple phone application that simulates an hourglass.
    Couple this sand model with the accelerometer techniques you’ll learn about in <a class="xref" href="ch21.html" title="Chapter 21. Accelerometers">Chapter 21</a>, and you’ll be able to make the sand flow by turning the phone
    over.</p><p>You can easily use particles to simulate bullets flying out of a gun. Imagine a Gatling gun
    spewing forth a hail of lead, all simulated using simple particles. Speaking of spewing, how
    about using particles to simulate debris flung from an erupting volcano as a special effect in
    your adventure game set in prehistoric times? Remember the Wooly Willy toy? To make particles a
    direct part of game play, consider a diversionary application where you drag piles of virtual
    magnetic particles around a portrait photograph, giving someone a lovely beard or mustache much
    like Wooly Willy.</p><p>Hopefully, you’re now thinking of creative ways to use particles in your games. So, let’s
    address implementation. There are two basic ingredients to implementing a particle simulator:
    the particle <span class="emphasis"><em>model</em></span> and the <span class="emphasis"><em>integrator</em></span>. (Well, you
    could argue that a third basic ingredient is <a id="I_indexterm2_id322196" class="indexterm"/>the <span class="emphasis"><em>renderer</em></span>, where you actually draw the particles, but that’s
    more graphics than physics, and we’re focusing on modeling and integrating in this book.)</p><p>The model very <a id="I_indexterm2_id322217" class="indexterm"/>simply describes the attributes of the particles in the simulation along with their
    rules of behavior. We mean this in the physics sense and not the AI sense in this book, although
    in general the model you implement may very well include suitable AI rules. Now, the integrator
    is <a id="I_indexterm2_id322230" class="indexterm"/>responsible for updating the state of the particles throughout the simulation. In
    this chapter, the particles’ states will be described by their position and velocity at any
    given time. The integrator will update each particle’s state under the influence of several
    external stimuli—forces such as gravity, aerodynamic drag, and collisions.</p><p>The rest of this chapter will walk you through the details of a simple particle simulation
    in an incremental manner. The first task will be to simulate a set of particles falling under
    the influence of gravity alone. Even though this sounds elementary, such an example encompasses
    all of the basic ingredients mentioned earlier. Once gravity is under control, we’ll show you
    how to implement still air drag and wind forces to influence the particles’ motion. Then, we’ll
    make things more interesting by showing you how to implement collision response between the
    particles and a ground plane plus random obstacles. This collision stuff will draw on material
    presented in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>, so be sure to read that chapter first if you have not
    already done so.</p><p><a class="xref" href="ch08.html#particles_falling_under_the_influence_of" title="Figure 8-1. Particles falling under the influence of gravity">Figure 8-1</a> through <a class="xref" href="ch08.html#particles_coming_to_rest_on_the_ground" title="Figure 8-4. Particles coming to rest on the ground plane">Figure 8-4</a> show a few frames of this example
    simulation complete with obstacles and collisions. Use your imagination here to visualize the
    particles falling under the influence of gravity until they impact the circular objects, at
    which time they bounce around and ultimately settle on the ground.</p><div class="figure"><a id="particles_falling_under_the_influence_of"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id322285"/><img src="httpatomoreillycomsourceoreillyimages1598934.png" alt="Particles falling under the influence of gravity"/></div></div><div class="figure-title">Figure 8-1. Particles falling under the influence of gravity</div></div><div class="figure"><a id="particles_impacting_circular_objects"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id322314"/><img src="httpatomoreillycomsourceoreillyimages1598935.png" alt="Particles impacting circular objects"/></div></div><div class="figure-title">Figure 8-2. Particles impacting circular objects</div></div><div class="figure"><a id="more_collisions"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id322343"/><img src="httpatomoreillycomsourceoreillyimages1598936.png" alt="More collisions"/></div></div><div class="figure-title">Figure 8-3. More collisions</div></div><div class="figure"><a id="particles_coming_to_rest_on_the_ground"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id322373"/><img src="httpatomoreillycomsourceoreillyimages1598937.png" alt="Particles coming to rest on the ground plane"/></div></div><div class="figure-title">Figure 8-4. Particles coming to rest on the ground plane</div></div><p>While working through this chapter, keep in mind that everything you’re learning here will
    be directly applicable to 2D and 3D simulations. Chapters following this one will build on the
    material covered here. We’ll focus on two dimensions in this chapter and later in the book we’ll
    show you how to extend the simulation to 3D. Actually, for particle simulations it’s almost
    trivial to make the leap from 2D to 3D. Trust us on this <a id="I_indexterm2_id322397" class="indexterm"/>for now.</p><div class="sect1" title="Simple Particle Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="simple_particle_model">Simple Particle Model</h2></div></div></div><p>The particle model <a id="pa8.1" class="indexterm"/><a id="mo8.1" class="indexterm"/>we’ll begin with is very simple. All we want to achieve at first is to have the
      particles fall under the <a id="gr8.1" class="indexterm"/>influence of gravity. The particles will be initialized with an altitude above a
      ground plane. Upon the start of the simulation, gravity will act on each particle,
      continuously causing each to accelerate toward the ground plane, gaining speed as it goes.
      Imagine holding a handful of small rocks up high and then releasing them. Simple, huh?</p><p>There are several particle attributes we must consider even for this simple example. Our
      model assumes that each particle has mass, and a set diameter (we’re assuming our particles
      are circles in 2D or spheres in 3D), occupies some position in space, and is traveling at some
      velocity. Additionally, each particle is acted upon by some net external force, which is the
      aggregate of all forces acting on the particle. These forces will be gravity alone to start
      with, but will eventually include drag and impact forces. We set up a <code class="literal">Particle</code> class to encapsulate these attributes as follows:</p><a id="I_programlisting2_id322489"/><pre class="programlisting">class Particle {
public:
  float   fMass;      // Total mass
  Vector  vPosition;  // Position
  Vector  vVelocity;  // Velocity
  float   fSpeed;     // Speed (magnitude of the velocity)
  Vector  vForces;    // Total force acting on the particle
  float   fRadius;    // Particle radius used for collision detection
  Vector  vGravity;   // Gravity force vector

  Particle(void);     // Constructor
  void  CalcLoads(void);  // Aggregates forces acting on the particle
  void  UpdateBodyEuler(double dt); // Integrates one time step
  void  Draw(void);   // Draws the particle
};</pre><p>Most of these attributes are self-explanatory given the comments we’ve included. Notice
      that several of these attributes are <code class="literal">Vector</code> types. These
      vectors are defined in the custom math library we’ve included in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>. This type makes managing vectors and performing arithmetic
      operations with them a breeze. Take a look at <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a> to see what
      this custom type does. We’ll just remind you of the data structure <code class="literal">Vector</code> uses: <a id="I_indexterm2_id322527" class="indexterm"/>three scalars called <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and
        <span class="emphasis"><em>z</em></span> representing the three dimensions of a location or of a movement in
      some direction. The <span class="emphasis"><em>z</em></span> component will always be set to 0 in this chapter’s
      examples.</p><p>You should have noticed the <code class="literal">fSpeed</code> property in the
        <code class="literal">Particle</code> class. This property stores the magnitude of the
      velocity vector, the particle’s speed. We’ll use this later when computing aerodynamic drag
      forces. We’ve also included a <code class="literal">Vector</code> type property called
        <code class="literal">vGravity</code>, which stores the gravity force vector defining
      the magnitude and the direction in which the gravity force acts. This is not really necessary,
      as you could hardcode the gravity force vector or use a global variable; however, we’ve
      included it here to illustrate some creative flexibility. For example, you could redefine the
      gravity vector in a game that uses <a id="I_indexterm2_id322589" class="indexterm"/><a id="I_indexterm2_id322599" class="indexterm"/>accelerometer input to determine gravity’s direction with respect to a particular
      device’s orientation (see <a class="xref" href="ch21.html" title="Chapter 21. Accelerometers">Chapter 21</a>). And you may have a game where
      some particles react to different gravities depending on their type, which can be of your own
      concoction.</p><p>Aside from properties, you’ll notice several methods in the <code class="literal">Particle</code> class. The constructor is trivial. It sets everything to 0 except the
      particle’s mass, radius, and the gravity force vector. The following code illustrates how
      everything is initialized:</p><a id="I_programlisting2_id322628"/><pre class="programlisting">Particle::Particle(void)
{
  fMass = 1.0;
  vPosition.x = 0.0;
  vPosition.y = 0.0;
  vPosition.z = 0.0;
  vVelocity.x = 0.0;
  vVelocity.y = 0.0;
  vVelocity.z = 0.0;
  fSpeed = 0.0;
  vForces.x = 0.0;
  vForces.y = 0.0;
  vForces.z = 0.0;
  fRadius = 0.1;
  vGravity.x = 0;
  vGravity.y = fMass * _GRAVITYACCELERATION;
}</pre><p>Now is probably a good time to explain the <a id="I_indexterm2_id322640" class="indexterm"/>coordinate system we’ve assumed. Our world origin is located at the lower-left
      corner of the example program’s window with positive <span class="emphasis"><em>x</em></span> pointing to the
      right and positive <span class="emphasis"><em>y</em></span> pointing up. The acceleration due to gravity acts
      downward (i.e., in the negative y-direction). We’re using the SI system of units and have
      defined the acceleration due to gravity as follows:</p><a id="I_programlisting2_id322665"/><pre class="programlisting">#define  _GRAVITYACCELERATION  −9.8f</pre><p>That’s 9.8 m/s<sup>2</sup> in the negative y-direction. We’ve set the mass
      of each particle to 1 kg by default, which means the force due to gravity is 1 kg times 9.8
        m/s<sup>2</sup>, or 9.8 newtons of force. We’ve set the radius of each
      particle to one-tenth of a meter. These masses and radii are really arbitrary; you can set
      them to anything suitable for what you’re modeling.</p><p>The <code class="literal">CalcLoads</code> method is responsible for computing all
      the loads—forces—acting on the particle, with the exception of impact forces (we’ll handle
      those later). For now, the only force acting on the particles is that due to gravity, or
      simply, the weight of each particle. <code class="literal">CalcLoads</code> is very
      simple at this point:</p><a id="I_programlisting2_id322702"/><pre class="programlisting">void  Particle::CalcLoads(void)
{
  // Reset forces:
  vForces.x = 0.0f;
  vForces.y = 0.0f;

  // Aggregate forces:
  vForces += vGravity;
}</pre><p>The first order of business is to reset the <code class="literal">vForces</code>
      vector. <code class="literal">vForces</code> is the vector containing the net force
      acting on the particle. All of these forces are aggregated in <code class="literal">CalcLoads</code>, as shown by the line <code class="literal">vForces +=
        vGravity</code>. Again, so far, the only force to aggregate is that due <a id="I_indexterm2_id322739" class="indexterm"/><a id="I_indexterm2_id322749" class="indexterm"/><a id="I_indexterm2_id322758" class="indexterm"/>to gravity.</p><div class="sect2" title="Integrator"><div class="titlepage"><div><div><h3 class="title" id="integrator">Integrator</h3></div></div></div><p>The <code class="literal">UpdateBodyEuler</code> method <a id="I_indexterm2_id322789" class="indexterm"/><a id="I_indexterm2_id322799" class="indexterm"/><a id="I_indexterm2_id322809" class="indexterm"/>integrates the equations of motion<a id="I_indexterm2_id322820" class="indexterm"/> for each particle. Since we’re dealing with particles, the only equation of
        motion we need concern ourselves with is that for translation; rotation does not matter for
        particles (at least not for us here). The following code sample shows <code class="literal">UpdateBodyEuler</code>.</p><a id="I_programlisting2_id322841"/><pre class="programlisting">void  Particle::UpdateBodyEuler(double dt)
{
    Vector a;
    Vector dv;
    Vector ds;

    // Integrate equation of motion:
    a = vForces / fMass;

    dv = a * dt;
    vVelocity += dv;

    ds = vVelocity * dt;
    vPosition += ds;

    // Misc. calculations:
    fSpeed = vVelocity.Magnitude();
}</pre><p>As the name of this method implies, we’ve implemented Euler’s method <a id="I_indexterm2_id322852" class="indexterm"/>of integration as described in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>. Using
        this method, we simply need to divide the aggregate forces acting on a particle by the mass
        of the particle to get the particle’s acceleration. The line of code <code class="literal">a = vForces / fMass</code> does just this. Notice here that <code class="literal">a</code> is a <code class="literal">Vector</code>, as is <code class="literal">vForces</code>. <code class="literal">fMass</code> is a scalar,
        and the <code class="literal">/</code> operator defined in the <code class="literal">Vector</code> class takes care of dividing each component of the
          <code class="literal">vForces</code> vector by <code class="literal">fMass</code> and setting the corresponding components in <code class="literal">a</code>. The change in velocity, <code class="literal">dv</code>, is equal to
        acceleration times the change in time, <code class="literal">dt</code>. The particle’s
        new velocity is then computed by the line <code class="literal">vVelocity +=
        dv</code>. Here again, <code class="literal">vVelocity</code> and <code class="literal">dv</code> are <code class="literal">Vectors</code> and the
          <code class="literal">+=</code> operator takes care of the vector arithmetic. This
        is the first actual integration.</p><p>The second integration takes place in the next few lines, where we determine the
        particle’s displacement and new position by integrating its velocity. The line <code class="literal">ds = vVelocity * dt</code> determines the displacement, or change in
        the particle’s position, and the line <code class="literal">vPosition += ds</code>
        computes the new position by adding the displacement to the particle’s old position.</p><p>The last line in <code class="literal">UpdateBodyEuler</code> computes the
        particle’s speed by taking the magnitude of its velocity vector.</p><p>For demonstration purposes, using Euler’s method is just fine. In an actual game, the
        more robust method described in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> is advised.</p></div><div class="sect2" title="Rendering"><div class="titlepage"><div><div><h3 class="title" id="rendering">Rendering</h3></div></div></div><p>In this example, rendering <a id="I_indexterm2_id323027" class="indexterm"/><a id="I_indexterm2_id323038" class="indexterm"/><a id="I_indexterm2_id323048" class="indexterm"/>the particles is rather trivial. All we do is draw little circles using Windows
        API calls wrapped in our own functions to hide some of the Windows-specific code. The
        following code snippet is all we need to render the particles.</p><a id="I_programlisting2_id323062"/><pre class="programlisting">void  Particle::Draw(void)
{
  RECT   r;
  float  drawRadius = max(2, fRadius);

  SetRect(&amp;r, vPosition.x − drawRadius,
          _WINHEIGHT − (vPosition.y − drawRadius),
          vPosition.x + drawRadius,
      _WINHEIGHT − (vPosition.y + drawRadius));
  DrawEllipse(&amp;r, 2, RGB(0,0,0));
}</pre><p>You can use your own rendering code here, of course, and all you really need to pay
        close attention to is converting from world coordinates to window coordinates. Remember,
        we’ve assumed our world coordinate system origin is in the lower-left corner of the window,
        whereas the window drawing coordinate system has its origin in the upper-left corner of the
        window. To transform coordinates in this example, all you need to do is subtract the
        particle’s y-position from the height of the window.</p></div></div><div class="sect1" title="The Basic Simulator"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_basic_simulator">The Basic Simulator</h2></div></div></div><p>The heart of this <a id="pa8.2" class="indexterm"/>simulation is handled by the <code class="literal">Particle</code> class
      described earlier. However, we need to show you how that class is used in the context of the
      main program.</p><p>First, we define a few global variables as follows:</p><a id="I_programlisting2_id323120"/><pre class="programlisting">// Global Variables:
int      FrameCounter = 0;
Particle Units[_MAX_NUM_UNITS];</pre><p><code class="literal">FrameCounter</code> counts the number of time steps integrated
      before the graphics display is updated. How many time steps you allow the simulation to
      integrate before updating the display is a matter of tuning. You’ll see how this is used
      momentarily when we discuss the <code class="literal">UpdateSimulation</code> function.
        <code class="literal">Units</code> is an array of <code class="literal">Particle</code> types. These will represent moving particles in the simulation—the ones
      that fall from above and bounce off the circular objects we’ll add later.</p><p>For the most part, each unit is initialized in accordance with the <code class="literal">Particle</code> constructor shown earlier. However, their positions are
      all at the origin, so we make a call to the following <code class="literal">Initialize</code> function to randomly distribute the particles in the upper-middle
      portion of the screen within a rectangle of width <code class="literal">_SPAWN_AREA_R*4</code> and a height of <code class="literal">_SPAWN_AREA_R</code>,
      where <code class="literal">_SPAWN_AREA_R</code> is just a global <code class="literal">define</code> we made up.</p><a id="I_programlisting2_id323198"/><pre class="programlisting">bool  Initialize(void)
{
  int i;

  GetRandomNumber(0, _WINWIDTH, true);

  for(i=0; i&lt;_MAX_NUM_UNITS; i++)
  {
    Units[i].vPosition.x = GetRandomNumber(_WINWIDTH/2-_SPAWN_AREA_R*2,
                           _WINWIDTH/2+_SPAWN_AREA_R*2, false);
    Units[i].vPosition.y = _WINHEIGHT −
                          GetRandomNumber(_WINHEIGHT/2-_SPAWN_AREA_R,
                          _WINHEIGHT/2, false);
  }

  return true;
}</pre><p>OK, now let’s consider <code class="literal">UpdateSimulation</code> as shown in the
      code snippet that follows. This function gets called every cycle through the program’s main
      message loop and is responsible for cycling through all the <code class="literal">Units</code>, making appropriate function calls to update their positions, and rendering
      the scene.</p><a id="I_programlisting2_id323225"/><pre class="programlisting">void  UpdateSimulation(void)
{
  double dt = _TIMESTEP;
  int    i;

  // initialize the back buffer
  if(FrameCounter &gt;= _RENDER_FRAME_COUNT)
  {
    ClearBackBuffer();
  }

  // update the particles (Units)
  for(i=0; i&lt;_MAX_NUM_UNITS; i++)
  {
    Units[i].CalcLoads();
    Units[i].UpdateBodyEuler(dt);

    if(FrameCounter &gt;= _RENDER_FRAME_COUNT)
    {
      Units[i].Draw();
    }

    if(Units[i].vPosition.x &gt; _WINWIDTH) Units[i].vPosition.x = 0;
    if(Units[i].vPosition.x &lt; 0) Units[i].vPosition.x = _WINWIDTH;
    if(Units[i].vPosition.y &gt; _WINHEIGHT) Units[i].vPosition.y = 0;
    if(Units[i].vPosition.y &lt; 0) Units[i].vPosition.y = _WINHEIGHT;
  }

  // Render the scene if required
  if(FrameCounter &gt;= _RENDER_FRAME_COUNT) {
    CopyBackBufferToWindow();
    FrameCounter = 0;
  }  else
    FrameCounter++;
}</pre><p>The two local variables in <code class="literal">UpdateSimulation</code> are
        <code class="literal">dt</code> and <code class="literal">i</code>. <code class="literal">i</code> is trivial and serves as a counter variable. <code class="literal">dt</code> represents the small yet finite amount of time, in seconds,
      over which each integration step is taken. The global <code class="literal">define_TIMESTEP</code> stores the time step, which we have set to 0.1 seconds. This
      value is subject to tuning, which we’ll discuss toward the end of this chapter in the section
        <a class="xref" href="ch08.html#tuning" title="Tuning">Tuning</a>.</p><p>The next segment of code checks the value of the frame counter, and if the frame counter
      has reached the defined number of frames, stored in <code class="literal">_RENDER_FRAME_COUNT</code>, then the back buffer is cleared to prepare it for drawing
      upon and ultimately copying to the screen.</p><p>The next section of code under the comment <code class="literal">update the
        particles</code> does just that by calling the <code class="literal">CalcLoads</code> and <code class="literal">UpdateBodyEuler</code> methods of each
        <code class="literal">Unit</code>. These two lines are responsible for updating all
      the forces acting on each particle and then integrating the equation of motion for each
      particle.</p><p>The next few lines within the <code class="literal">for</code> loop draw each
      particle if required and wrap each particle’s position around the window extents should they
      progress beyond the edges of the window. Note that we’re using window coordinates in this
        <a id="I_indexterm2_id323336" class="indexterm"/>example.</p></div><div class="sect1" title="Implementing External Forces"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="implementing_external_forces">Implementing External Forces</h2></div></div></div><p>We’ll add a <a id="pa8.3" class="indexterm"/>couple of simple external forces to start with—<a id="I_indexterm2_id323377" class="indexterm"/><a id="wi8.3" class="indexterm"/>still air drag, and wind force. We’ll use the formulas presented in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> to approximate these forces, treating them in a similar manner. Recall
      that still air drag is the aerodynamic drag force acting against an object moving at some
      speed through still air. Drag always acts to resist motion. While we’ll use the same formulas
      to compute a wind force, recall that wind force may not necessarily act to impede motion. You
      could have a tailwind pushing an object along, or the wind could come from any direction with
      components that push the object sideways. In this example we’ll assume a side wind from left
      to right, acting to push the particles sideways, with the still air drag resisting their
      falling motion. When we add collisions later, this same drag formulation will act to resist
      particle motion in any direction in which they travel as they bounce around.</p><p>The formula we’ll use to model still air drag is:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>d</sub> = ½
        ρV<sup>2</sup>AC<sub>d</sub></td></tr></table><p>Here <span class="emphasis"><em>F</em></span><sub>d</sub> is the magnitude of the drag force.
      Its direction is directly opposite the velocity of the moving particle. ρ is the density of
      air through which the particle moves, <span class="emphasis"><em>V</em></span> is the magnitude of the
      particle’s velocity (its speed), <span class="emphasis"><em>A</em></span> is the projected area of the particle
      as though it’s a sphere, and <span class="emphasis"><em>C</em></span><sub>d</sub> is a drag
      coefficient.</p><p>We can use this same formula to estimate the wind force pushing the particle sideways. The
      only difference this time is that <span class="emphasis"><em>V</em></span> is the wind speed, and the direction
      of the resulting wind force is from our assumed left-to-right direction.</p><p>To add these two forces to our simulation, we need to make a few additions to the <code class="literal">Particle</code> class’s <code class="literal">CalcLoads</code>
      method. The following code shows how <code class="literal">CalcLoads</code> looks now.
      Remember, all we had in here originally were the first three lines of executable code shown
      next—the code that initializes the aggregate force vector and then the line of code that adds
      the force due to gravity to the aggregate force. All the rest of the code in this method is
      new.</p><a id="I_programlisting2_id323501"/><pre class="programlisting">void  Particle::CalcLoads(void)
{
  // Reset forces:
  vForces.x = 0.0f;
  vForces.y = 0.0f;

  // Aggregate forces:

  // Gravity
  vForces += vGravity;

  // Still air drag
  Vector  vDrag;
  Float   fDrag;

  vDrag-=vVelocity;
  vDrag.Normalize();
  fDrag = 0.5 * _AIRDENSITY * fSpeed * fSpeed *
          (3.14159 * fRadius * fRadius) * _DRAGCOEFFICIENT;

  vDrag*=fDrag;

  vForces += vDrag;

  // Wind
  Vector  vWind;
  vWind.x = 0.5 * _AIRDENSITY * _WINDSPEED *
            _WINDSPEED * (3.14159 * fRadius * fRadius) *
            _DRAGCOEFFICIENT;
  vForces += vWind;
}</pre><p>So after the force due to gravity is added to the aggregate, two new local variables are
      declared. <code class="literal">vDrag</code> is a vector that will represent the still
      air drag force. <code class="literal">fDrag</code> is the magnitude of that drag force.
      Since we know the drag force vector is exactly opposite to the particle’s velocity vector, we
      can equate <code class="literal">vDrag</code> to negative <code class="literal">vVelocity</code> and then normalize <code class="literal">vDrag</code> to obtain a
      unit vector pointing in a direction opposite of the particle’s velocity. Next we compute the
      magnitude of the drag force using the formula shown earlier. This line handles that:</p><a id="I_programlisting2_id323550"/><pre class="programlisting">fDrag = 0.5 * _AIRDENSITY * fSpeed * fSpeed *
        (3.14159 * fRadius * fRadius) * _DRAGCOEFFICIENT;</pre><p>Here, <code class="literal">_AIRDENSITY</code> is a global <code class="literal">define</code> representing the density of air, which we have set to 1.23
        kg/m<sup>3</sup> (standard air at 15°C). <code class="literal">fSpeed</code> is the particle’s speed: the magnitude of its velocity. The <code class="literal">3.14159 * fRadius * fRadius</code> line represents the projected area of
      the particle assuming the particle is a sphere. And finally, <code class="literal">_DRAGCOEFFICIENT</code> is a drag coefficient that we have set to 0.6. We picked this
      value from the chart of drag coefficient for a smooth sphere versus the Reynolds number shown
      in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>. We simply eyeballed a value in the Reynolds number range
      from 1e4 to 1e5. You have a choice here of tuning the drag coefficient value to achieve some
      desired effect, or you can create a curve fit or lookup table to select a drag coefficient
      corresponding to the Reynolds number of the moving particle.</p><p>Now that we have the magnitude of the drag force, we simply multiply that force by the
      unit drag vector to obtain the final drag force vector. This vector then gets aggregated in
        <code class="literal">vForces</code>.</p><p>We handle the wind force in a similar manner with a few differences in the details. First,
      since we know the unit wind force vector is in the positive x-direction (i.e., it acts from
      left to right), we can simply set the <span class="emphasis"><em>x</em></span> component of the wind force
      vector, <code class="literal">vWind</code>, to the magnitude of the wind force. We
      compute that wind force using the same formula we used for still air drag with the exception
      of using the wind speed instead of the particle’s speed. We used <code class="literal">_WINDSPEED</code>, a global <code class="literal">define</code>, to represent the
      wind speed, which we have set to 10 m/s (about 20 knots).</p><p>Finally, the wind force is aggregated in <code class="literal">vForces</code>.</p><p>At this stage the particles will fall under the influence of gravity, but not as fast as
      they would have without the drag force. And now they’ll also drift to the right due to the
      wind <a id="I_indexterm2_id323659" class="indexterm"/><a id="I_indexterm2_id323668" class="indexterm"/>force.</p></div><div class="sect1" title="Implementing Collisions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="implementing_collisions">Implementing Collisions</h2></div></div></div><p>Adding external forces <a id="pa8.4" class="indexterm"/><a id="co8.4" class="indexterm"/>made the simulation a little more interesting. However, to really make it pop,
      we’re going to add collisions. Specifically, we’ll handle particle-to-ground collisions and
      particle-to-object collisions. If you have not yet read <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>, which
      covers collisions, you should because we’ll implement principles covered in that chapter here
      in the example. We’ll implement enough collision handling in this example to allow particles
      to bounce off the ground and circular objects, and we’ll come back to collision handling in
      more detail in <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>. The material in this chapter
      should whet your appetite. We’ll start with the easier case of particle-to-ground
      collisions.</p><div class="sect2" title="Particle-to-Ground Collisions"><div class="titlepage"><div><div><h3 class="title" id="particle-to-ground_collisions">Particle-to-Ground Collisions</h3></div></div></div><p>Essentially what we’re aiming to achieve with <a id="pa8.4.1" class="indexterm"/><a id="co8.4.1" class="indexterm"/><a id="cor8.4.1" class="indexterm"/>particle-to-ground collision detection is to prevent the particles from passing
        through a ground plane specified at some <span class="emphasis"><em>y</em></span> coordinate. Imagine a
        horizontal impenetrable surface that the particles cannot pass through. There are several
        things we must do in order to detect whether a particle is indeed colliding with the
          <a id="gr8.4.1" class="indexterm"/>ground plane. If so, then we need to handle the collision, making the particles
        respond in a suitable manner.</p><p>The left side of <a class="xref" href="ch08.html#particle-to-ground_collision" title="Figure 8-5. Particle-to-ground collision">Figure 8-5</a> illustrates a collision
        scenario. It’s easy to determine whether or not a collision has taken place. Over a given
        simulation time step, a particle may have moved from some previous position (its position at
        the previous time step) to its current position. If this current position puts the centroid
        coordinate of the particle within one particle radius of the ground plane, then a collision
        might be occurring. We say <span class="emphasis"><em>might</em></span> because the other criteria we need to
        check in order to determine whether or not a collision is happening is whether or not the
        particle is moving toward the ground plane. If the particle is moving toward the ground
        plane and it’s within one radius of the ground plane, then a collision is occurring. It may
        also be the case that the particle has passed completely through the ground plane, in which
        case we assume a collision has occurred.</p><div class="figure"><a id="particle-to-ground_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id323849"/><img src="httpatomoreillycomsourceoreillyimages1598938.png" alt="Particle-to-ground collision"/></div></div><div class="figure-title">Figure 8-5. Particle-to-ground collision</div></div><p>To prevent such penetration of the ground plane, we need to do two things. First, we
        must reposition the particle so that it is just touching the ground plane, as shown on the
        right side of <a class="xref" href="ch08.html#particle-to-ground_collision" title="Figure 8-5. Particle-to-ground collision">Figure 8-5</a>. Second, we must apply some
        impact force resulting from the collision in order to force the particle to either stop
        moving down into the ground plane or to move away from the ground plane. All these steps
        make up collision detection and response.</p><p>There are several changes and additions that we must make to the example code in order
        to implement particle-to-ground collision detection and response. Let’s begin with the
          <code class="literal">Particle</code> class.</p><p>We’ve added three new properties to <code class="literal">Particle</code>, as
        follows:</p><a id="I_programlisting2_id323909"/><pre class="programlisting">class Particle {
  .
  .
  .
  Vector  vPreviousPosition;
  Vector  vImpactForces;
  bool    bCollision;
  .
  .
  .
};</pre><p><code class="literal">vPreviousPosition</code> is used to store the particle’s
        position at the previous time step—that is, at time <code class="literal">t-dt</code>.
          <code class="literal">vImpactForces</code> is used to aggregate all of the impact
        forces acting on a particle. You’ll see later that it is possible for a particle to collide
        with more than one object at the same time. <code class="literal">bCollision</code> is
        simply a flag that is used to indicate whether or not a collision has been detected with the
        particle at the current time step. This is important because when a collision occurs, at
        that instant in time, we assume that the only forces acting on the particle are the impact
        forces; all of the other forces—gravity, drag, and wind—are ignored for that time instant.
        We use <code class="literal">bCollision</code> in the updated <code class="literal">CalcLoads</code> method:</p><a id="I_programlisting2_id323960"/><pre class="programlisting">void  Particle::CalcLoads(void)
{
  // Reset forces:
  vForces.x = 0.0f;
  vForces.y = 0.0f;

  // Aggregate forces:
  if(bCollision) {
    // Add Impact forces (if any)
    vForces += vImpactForces;
  } else {
    // Gravity
    vForces += vGravity;

    // Still air drag
    Vector  vDrag;
    float  fDrag;

    vDrag -= vVelocity;
    vDrag.Normalize();
    fDrag = 0.5 * _AIRDENSITY * fSpeed * fSpeed *
           (3.14159 * fRadius * fRadius) * _DRAGCOEFFICIENT;
    vDrag *= fDrag;
    vForces += vDrag;

    // Wind
    Vector  vWind;
    vWind.x = 0.5 * _AIRDENSITY * _WINDSPEED * _WINDSPEED *
             (3.14159 * fRadius * fRadius) * _DRAGCOEFFICIENT;
    vForces += vWind;
  }
}</pre><p>The only difference between this version of <code class="literal">CalcLoads</code>
        and the previous one is that we added the conditional <code class="literal">if(bCollision) { ... } else { ... }</code>. If <code class="literal">bCollision</code> is true, then we have a collision to deal with and the only forces
        that get aggregated are the impact forces. If there is no collision, if <code class="literal">bCollision</code> is false, then the non-impact forces are aggregated
        in the usual manner.</p><p>You may have caught that we are aggregating impact forces in this example. This is an
        alternate approach to the one shown in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>. There we showed you how
        to calculate an impulse and change an object’s velocity in response to a collision, using
        conservation of momentum. Well, we’re still calculating impulses just like in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>; however, in this example, we’re going to compute the impact force
        based on that impulse and apply that force to the colliding objects. We’ll let the numerical
        integrator integrate that force to derive the colliding particle’s new velocities. Either
        method works, and we’ll show you an example of the former method later. We’re showing the
        latter method here just to illustrate some alternatives. The advantage of this latter method
        is that it is easy to compute impact forces due to multiple impacts and let the integrator
        take care of them all at once.</p><p>Now, with these changes made to <code class="literal">Particle</code>, we need to
        add a line of code to <code class="literal">Update</code><code class="literal">Simulation</code>, as shown
        here:</p><a id="I_programlisting2_id324041"/><pre class="programlisting">void  UpdateSimulation(void)
{
  .
  .
  .

  // update computer controlled units:
  for(i=0; i&lt;_MAX_NUM_UNITS; i++)
  {
    Units[i].bCollision = CheckForCollisions(&amp;(Units[i]));
    Units[i].CalcLoads();
    Units[i].UpdateBodyEuler(dt);
    .
    .
    .
  } // end i-loop

  .
  .
  .
}</pre><p>The new line is <code class="literal">Units[i].bCollision =
          CheckForCollisions(&amp;(Units[i]));</code>. <code class="literal">CheckForCollisions</code> is a new function that takes the given unit, whose pointer
        is passed as an argument, and checks to see if it’s colliding with anything—in this case,
        the ground. If a collision is detected, <code class="literal">CheckForCollisions</code> also computes the impact force and returns <code class="literal">true</code> to let us know a collision has occurred. <code class="literal">CheckForCollisions</code> is as follows:</p><a id="I_programlisting2_id324086"/><pre class="programlisting">bool  CheckForCollisions(Particle* p)
{
  Vector  n;
  Vector  vr;
  float   vrn;
  float   J;
  Vector  Fi;
  bool    hasCollision = false;


    // Reset aggregate impact force
    p-&gt;vImpactForces.x = 0;
    p-&gt;vImpactForces.y = 0;

    // check for collisions with ground plane
    if(p-&gt;vPosition.y &lt;= (_GROUND_PLANE+p-&gt;fRadius)) {
      n.x = 0;
      n.y = 1;
      vr = p-&gt;vVelocity;
      vrn = vr * n;
      // check to see if the particle is moving toward the ground
      if(vrn &lt; 0.0) {
        J = -(vr*n) * (_RESTITUTION + 1) * p-&gt;fMass;
        Fi = n;
        Fi *= J/_TIMESTEP;
        p-&gt;vImpactForces += Fi;

        p-&gt;vPosition.y = _GROUND_PLANE + p-&gt;fRadius;
        p-&gt;vPosition.x = ((_GROUND_PLANE + p-&gt;fRadius −
                         p-&gt;vPreviousPosition.y) /
                        (p-&gt;vPosition.y - p-&gt;vPreviousPosition.y) *
                        (p-&gt;vPosition.x - p-&gt;vPreviousPosition.x)) +
                        p-&gt;vPreviousPosition.x;

        hasCollision = true;
      }
    }

  return hasCollision;
}</pre><p><code class="literal">CheckForCollisions</code> makes two checks: 1) it checks to
        see whether or not the particle is making contact or passing through the ground plane; and
        2) it checks to make sure the particle is actually moving toward the ground plane. Keep in
        mind a particle could be in contact with the ground plane right after a collision has been
        handled with the particle moving away from the ground. In this case, we don’t want to
        register another collision.</p><p>Let’s consider the details of this function, starting with the local variables. <code class="literal">n</code> is a vector that represents the unit normal vector pointing
        from the ground plane to the particle colliding with it. For ground collisions, in this
        example, the unit normal vector is always straight up since the ground plane is flat. This
        means the unit normal vector will always have an <span class="emphasis"><em>x</em></span> component of 0 and
        its <span class="emphasis"><em>y</em></span> component will be 1.</p><p>The <code class="literal">Vector vr</code> is the relative velocity vector between
        the particle and the ground. Since the ground isn’t moving, the relative velocity<a id="I_indexterm2_id324145" class="indexterm"/><a id="I_indexterm2_id324155" class="indexterm"/> is simply the velocity of the particle. <code class="literal">vrn</code>
        is a scalar that’s used to store the component of the relative velocity in the direction of
        the collision unit normal vector. We compute <code class="literal">vrn</code> by
        taking the dot product of the relative velocity with the unit normal vector. <code class="literal">J</code> is a scalar that stores the impulse resulting from the
        collision. <code class="literal">Fi</code> is a vector that stores the impact force as
        derived from the impulse <code class="literal">J</code>. Finally, <code class="literal">hasCollision</code> is a flag that’s set based on whether or not a
        collision has been detected.</p><p>Now we’ll look at the details within <code class="literal">CheckForCollisions</code>. The first task is to initialize the impact force vector,
          <code class="literal">vImpactForces</code>, to 0. Next, we make the first collision
        check by determining if the y-position of the particle is less than the ground plane height
        plus the particles radius. If it is, then we know a collision may have occurred. <code class="literal">(_GROUND_PLANE</code> represents the <span class="emphasis"><em>y</em></span> coordinate
        of the ground plane, which we have set to 100.) If a collision may have occurred, then we
        make the next check—to determine if the particle is moving toward the ground plane.</p><p>To perform this second check, we compute the unit normal vector, relative velocity, and
        relative velocity component in the collision normal direct as described earlier. If the
        relative velocity in the normal direction is negative (i.e., if <code class="literal">vrn</code> &lt; 0), then a collision has occurred. If either of these checks is
          <code class="literal">false</code>, then a collision has not occurred and the
        function exits, returning <code class="literal">false</code>.</p><p>The interesting stuff happens if the second check passes. This is where we have to
        determine the impact force that will cause the particle to bounce off the ground plane.
        Here’s the specific code that computes the impact force:</p><a id="I_programlisting2_id324265"/><pre class="programlisting">        J = -(vr*n) * (_RESTITUTION + 1) * p-&gt;fMass;
        Fi = n;
        Fi *= J/_TIMESTEP;
        p-&gt;vImpactForces += Fi;

        p-&gt;vPosition.y = _GROUND_PLANE + p-&gt;fRadius;
        p-&gt;vPosition.x = (_GROUND_PLANE + p-&gt;fRadius −
                         p-&gt;vPreviousPosition.y) /
                        (p-&gt;vPosition.y - p-&gt;vPreviousPosition.y) *
                        (p-&gt;vPosition.x - p-&gt;vPreviousPosition.x) +
                         p-&gt;vPreviousPosition.x;

        hasCollision = true;</pre><p>We compute the impulse using the formulas presented in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>.
          <code class="literal">J</code> is a scalar equal to the negative of the relative
        velocity in the normal direction times the coefficient of restitution plus 1 times the
        particle mass. Recall that the coefficient of restitution, <code class="literal">_RESTITUTION</code>, governs how elastic or inelastic the collision is, or in other
        words, how much energy is transferred back to the particle during the impact. We have this
        value set to 0.6, but it is tunable depending on what effect you’re trying to achieve. A
        value of 1 makes the particles very bouncy, while a value of, say, 0.1 makes them sort of
        stick to the ground upon impact.</p><p>Now, to compute the impact force, <code class="literal">Fi</code>, that will act
        on the particle during the next time step, making it bounce off the ground, we set <code class="literal">Fi</code> equal to the collision normal vector. The magnitude of the
        impact force is equal to the impulse, <code class="literal">J</code>, divided by the
        time step in seconds. The line <code class="literal">Fi *= J/_TIMESTEP;</code> takes
        care of calculating the final impact force.</p><p>To keep the particle from penetrating the ground, we reposition it so that it’s just
        resting on the ground. The y-position is easy to compute as the ground plane elevation plus
        the radius of the particle. We compute the x-position by linearly interpolating between the
        particle’s previous position and its current position using the newly computed y-position.
        This effectively backs up the particle along the line of action of its velocity to the point
        where it is just touching the ground plane.</p><p>When you run the simulation now, you’ll see the particles fall, drifting a bit from left
        to right until they hit the ground plane. Once they hit, they’ll bounce on the ground,
        eventually coming to rest. Their specific behavior in this regard depends on what drag
        coefficient you use and what coefficient of restitution you use. If you have wind applied,
        when the particles do come to rest, vertically, they should still drift to the right as
        though they are sliding on the ground <a id="I_indexterm2_id324348" class="indexterm"/><a id="I_indexterm2_id324357" class="indexterm"/><a id="I_indexterm2_id324367" class="indexterm"/><a id="I_indexterm2_id324376" class="indexterm"/>plane.</p></div><div class="sect2" title="Particle-to-Obstacle Collisions"><div class="titlepage"><div><div><h3 class="title" id="particle-to-obstacle_collisions">Particle-to-Obstacle Collisions</h3></div></div></div><p>To make things <a id="pa8.4.2" class="indexterm"/><a id="co8.4.2" class="indexterm"/><a id="cor8.4.2" class="indexterm"/>really interesting, we’ll now add those circular obstacles you saw in <a class="xref" href="ch08.html#particles_falling_under_the_influence_of" title="Figure 8-1. Particles falling under the influence of gravity">Figure 8-1</a> through <a class="xref" href="ch08.html#particles_coming_to_rest_on_the_ground" title="Figure 8-4. Particles coming to rest on the ground plane">Figure 8-4</a>. The particles will be able to hit them
        and bounce off or even settle down into crevasses made by overlapping obstacles. The
        obstacles are simply static particles. We’ll define them as particles and initialize them
        but then skip them when integrating the equations of motion of the dynamic particles. Here’s
        the declaration for the <code class="literal">Obstacles</code> array:</p><a id="I_programlisting2_id324462"/><pre class="programlisting">Particle      Obstacles[_NUM_OBSTACLES];</pre><p>Initializing the obstacles is a matter of assigning them positions and a common radius
        and a mass. The few lines of code shown next were added to the main program’s <code class="literal">Initialize</code> function to randomly position obstacles in the lower,
        middle portion of the window above the ground plane. <a class="xref" href="ch08.html#particles_falling_under_the_influence_of" title="Figure 8-1. Particles falling under the influence of gravity">Figure 8-1</a> through <a class="xref" href="ch08.html#particles_coming_to_rest_on_the_ground" title="Figure 8-4. Particles coming to rest on the ground plane">Figure 8-4</a> illustrate how they are
        distributed.</p><a id="I_programlisting2_id324490"/><pre class="programlisting">bool  Initialize(void)
{
  .
  .
  .

  for(i=0; i&lt;_NUM_OBSTACLES; i++)
  {
    Obstacles[i].vPosition.x = GetRandomNumber(_WINWIDTH/2 −
                               _OBSTACLE_RADIUS*10,
                               _WINWIDTH/2 +
                               _OBSTACLE_RADIUS*10, false);
    Obstacles[i].vPosition.y = GetRandomNumber(_GROUND_PLANE +
                               _OBSTACLE_RADIUS, _WINHEIGHT/2 −
                               _OBSTACLE_RADIUS*4, false);
    Obstacles[i].fRadius = _OBSTACLE_RADIUS;
    Obstacles[i].fMass = 100;
  }
  .
  .
  .
}</pre><p>Drawing the obstacles is easy since they are <code class="literal">Particle</code>
        types with a <code class="literal">Draw</code> method that already draws circular
        shapes. We created <code class="literal">DrawObstacles</code> to iterate through the
          <code class="literal">Obstacles</code> array, calling the <code class="literal">Draw</code> method of each obstacle.</p><a id="I_programlisting2_id324535"/><pre class="programlisting">void DrawObstacles(void)
{
  int    i;

  for(i=0; i&lt;_NUM_OBSTACLES; i++)
  {
    Obstacles[i].Draw();
  }

}</pre><p><code class="literal">DrawObstacles</code> is then called from <code class="literal">UpdateSimulation</code>:</p><a id="I_programlisting2_id324556"/><pre class="programlisting">void  UpdateSimulation(void)
{
  .
  .
  .

  // initialize the back buffer
  if(FrameCounter &gt;= _RENDER_FRAME_COUNT)
  {
    ClearBackBuffer();
    // Draw ground plane
    DrawLine(0, _WINHEIGHT - _GROUND_PLANE,
             _WINWIDTH, _WINHEIGHT - _GROUND_PLANE,
             3, RGB(0,0,0));

    DrawObstacles();
  }
  .
  .
  .
}</pre><p>The last bit of code we need to add to have fully functioning collisions with obstacles
        involves adding more collision detection and handling code to the <code class="literal">CheckForCollisions</code> function. Before we look at <code class="literal">CheckForCollisions</code>, let’s consider colliding circles in general to gain a
        better understanding of what the new code will do.</p><p><a class="xref" href="ch08.html#collision_states" title="Figure 8-6. Collision states">Figure 8-6</a> illustrates two circles colliding. We aim to detect
        whether or not these circles are colliding by checking the distance between their centers.
        If the distance between the two centers is greater than the sum of the radii of the circles,
        then the particles are not colliding. The topmost illustration in <a class="xref" href="ch08.html#collision_states" title="Figure 8-6. Collision states">Figure 8-6</a> shows the distance, <span class="emphasis"><em>d</em></span>, between centers
        and the distance, <span class="emphasis"><em>s</em></span>, between the edges of the circles;
          <span class="emphasis"><em>s</em></span> is the gap between the two. Another way to think about this is that
        if <span class="emphasis"><em>s</em></span> is positive, then there’s no collision. Referring to the middle
        illustration in <a class="xref" href="ch08.html#collision_states" title="Figure 8-6. Collision states">Figure 8-6</a>, if <span class="emphasis"><em>s</em></span> is equal to 0,
        then the circles are in contact. If <span class="emphasis"><em>s</em></span> is a negative number, as shown in
        the bottommost illustration, then the circles are penetrating.</p><div class="figure"><a id="collision_states"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id324641"/><img src="httpatomoreillycomsourceoreillyimages1598939.png" alt="Collision states"/></div></div><div class="figure-title">Figure 8-6. Collision states</div></div><p>We’ll apply these principles for detecting colliding circles to detecting collisions
        between our particles and obstacles since they are both circles. <a class="xref" href="ch08.html#particle-to-obstacle_collision" title="Figure 8-7. Particle-to-obstacle collision">Figure 8-7</a> illustrates how our particle-to-obstacle
        collisions might look.</p><div class="figure"><a id="particle-to-obstacle_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id324680"/><img src="httpatomoreillycomsourceoreillyimages1598940.png" alt="Particle-to-obstacle collision"/></div></div><div class="figure-title">Figure 8-7. Particle-to-obstacle collision</div></div><p>We’ll calculate <span class="emphasis"><em>s</em></span> for each particle against each obstacle to
        determine contact or penetration. If we find either, then we’ll perform the relative
        velocity check in the same manner we did for particle-to-ground collisions to see if the
        particle is moving toward the obstacle. If it is, then we have a collision and we’ll back up
        the particle along the collision normal vector line of action, which is simply the line
        connecting the centers of the particle and the obstacle. We’ll also compute the impact force
        like we did earlier and let the integrator take care of the rest.</p><p>OK, now let’s look at the new code in <code class="literal">CheckForCollisions</code>:</p><a id="I_programlisting2_id324729"/><pre class="programlisting">bool  CheckForCollisions(Particle* p)
{
  .
  .
  .

    // Check for collisions with obstacles
    float r;
    Vector d;
    float s;

    for(i=0; i&lt;_NUM_OBSTACLES; i++)
    {
      r = p-&gt;fRadius + Obstacles[i].fRadius;
      d = p-&gt;vPosition - Obstacles[i].vPosition;
      s = d.Magnitude() - r;

      if(s &lt;= 0.0)
      {
        d.Normalize();
        n = d;
        vr = p-&gt;vVelocity - Obstacles[i].vVelocity;
        vrn = vr*n;


        if(vrn &lt; 0.0)
        {
          J = -(vr*n) * (_RESTITUTION + 1) /
             (1/p-&gt;fMass + 1/Obstacles[i].fMass);
          Fi = n;
          Fi *= J/_TIMESTEP;
          p-&gt;vImpactForces += Fi;

          p-&gt;vPosition -= n*s;
          hasCollision = true;
        }
      }
    }
  .
  .
  .
}</pre><p>The new code is nearly the same as the code that checks for and handles
        particle-to-ground collisions. The only major differences are in how we compute the distance
        between the particle and the obstacle and how we adjust the colliding particle’s position to
        prevent it from penetrating an obstacle, since the unit normal vector may not be straight up
        as it was before. The rest of the code is the same, so let’s focus on the
        differences.</p><p>As explained earlier and illustrated in <a class="xref" href="ch08.html#collision_states" title="Figure 8-6. Collision states">Figure 8-6</a>, we need to
        compute the separation, <code class="literal">s</code>, between the particle and the
        obstacle. So to get <code class="literal">s</code>, we declare a variable <code class="literal">r</code> and equate it to the sum of radii of the particle and the
        obstacle against which we’re checking for a collision. We define <code class="literal">d</code>, a <code class="literal">Vector</code>, as the difference between the
        positions of the particle and obstacle. The magnitude of <code class="literal">d</code> minus <code class="literal">r</code> yields <code class="literal">s</code>.</p><p>If <code class="literal">s</code> is less than 0, then we make the relative
        velocity check. Now, in this case the collision normal vector is along the line connecting
        the centers of the two circles representing the particle and the obstacle. Well, that’s just
        the vector <code class="literal">d</code> we already calculated. To get the unit
        normal vector, we simply normalize <code class="literal">d</code>. The relative
        velocity vector is simply the difference in velocities of the particle and the obstacle.
        Since the obstacles are static, the relative velocity is just the particle’s velocity. But
        we calculated the relative velocity by taking the vector difference <code class="literal">vr = p-&gt;vVelocity – Obstacles[i].vVelocity</code>, because in a more advanced
        scenario, you might have moving obstacles.</p><p>Taking the dot product of the relative velocity vector, <code class="literal">vr</code>, with the unit normal vector yields the relative velocity in the collision
        normal direction. If that relative velocity is less than 0, then the particle and the object
        are colliding and the code goes on to calculate the impact force in a manner similar to that
        described earlier for the particle-to-ground collisions. The only difference here is that
        both the particle’s and object’s masses appear in the impulse formula. Earlier we assumed
        the ground was infinitely massive relative to the particle’s mass, so the <code class="literal">1/m</code> term for the ground went to 0, essentially dropping out of
        the equation. Refer back to <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a> to recall the impulse
        formulas.</p><p>Once the impact force is calculated, the code backs up the particle by a distance equal
        to <code class="literal">s</code>, the penetration, along the line of action of the
        collision normal vector, giving us what we desire (as shown in <a class="xref" href="ch08.html#particle-to-obstacle_collision" title="Figure 8-7. Particle-to-obstacle collision">Figure 8-7</a>).</p><p>Now, when you run this simulation you’ll see the particles falling down, bouncing off
        the obstacles or flowing around them depending on the value you’re using for coefficient of
        restitution, ultimately bouncing and coming to rest on the ground plane. If you have a wind
        speed greater than 0, then the particles will still drift along the ground plane from left
        to <a id="I_indexterm2_id324889" class="indexterm"/><a id="I_indexterm2_id324899" class="indexterm"/><a id="I_indexterm2_id324908" class="indexterm"/><a id="I_indexterm2_id324917" class="indexterm"/><a id="I_indexterm2_id324927" class="indexterm"/>right.</p></div></div><div class="sect1" title="Tuning"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="tuning">Tuning</h2></div></div></div><p>Tuning is an <a id="I_indexterm2_id324947" class="indexterm"/><a id="I_indexterm2_id324957" class="indexterm"/>important part of developing any simulator. Tuning means different things to
      different people. For some, tuning is adjusting formulas and coefficients to make your
      simulation match some specific “right answer,” while to others tuning is adjusting parameters
      to make the simulation look and behave how you want it to, whether or not it’s technically the
      right answer. After all, the right answer for a game is that it’s fun and robust. Speaking of
      robustness, other folks view tuning in the sense of adjusting parameters to make the
      simulation stable. In reality, this is all tuning and you should think of it as a necessary
      part of developing your simulation. It’s the process by which you tweak, nudge, and adjust
      things to make the simulation do what you want it to do.</p><p>For example, you can use this same example simulation to model very springy rubber balls.
      To achieve this, you’ll probably adjust the coefficient of restitution toward a value
      approaching 1 and perhaps lower the drag coefficient. The particles will bounce all over the
      place with a lot of energy. If, on the other hand, you want to model something along the lines
      of mud, then you’ll lower the coefficient of restitution and increase the drag coefficient.
      There is no right or wrong combination of coefficient of restitution or drag coefficient to
      use, so long as you are pleased with the results.</p><p>Another aspect you might tune is the number of simulation frames per rendering frame. You
      may find the simulation calculations take so long that your resulting animations are too jerky
      because you aren’t updating the display enough. The converse may be true in other cases. An
      important parameter that plays into this is the time step size you take at each simulation
      iteration. If the step size is too small, you’ll perform a lot of simulation steps, slowing
      the animation down. On the other hand, a small time step can keep the simulation numerically
      stable. Your chosen integrator plays a huge role here.</p><p>If you make your time step too large, the simulation may just blow up and not work. It
      will be numerically unstable. Even if it doesn’t blow up, you might see weird results. For
      example, if the time step in the example simulation discussed in this chapter is too large,
      then particles may completely step over obstacles in a single time step, missing the collision
      that would otherwise have happened. (We’ll show you in <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a> how to deal with that situation.)</p><p>In general, tuning is a necessary part of developing physics-based simulations, and we
      encourage you to experiment—trying different combinations of parameters to see what results
      you can achieve. You should even try combinations that may break the example in this chapter
      to see what happens and what you should try to avoid in a deployed <a id="I_indexterm2_id325012" class="indexterm"/>game.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 9. 2D Rigid-Body Simulator</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch08.html" title="Chapter 8. Particles"/><link rel="next" href="ch10.html" title="Chapter 10. Implementing Collision Response"/></head><body><section class="chapter" title="Chapter 9. 2D Rigid-Body Simulator" epub:type="chapter" id="d_rigid-body_simulator"><div class="titlepage"><div><div><h2 class="title">Chapter 9. 2D Rigid-Body Simulator</h2></div></div></div><p>After reading <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>, <a id="si9.0" class="indexterm"/><a id="ri9.0" class="indexterm"/><a id="I_indexterm3_id325070" class="indexterm"/>you’ve learned the main ingredients that go into a simulator,
  specifically a particle simulator. In this chapter we’ll look beyond
  particles at 2D rigid bodies. The main difference here is that rigid bodies
  rotate, and you must deal with an additional equation of motion—namely, the
  angular equation of motion relating a rigid body’s angular acceleration and
  inertia to the sum of all moments (torques) acting on the rigid body. The
  fundamental elements of the simulator—the model, integrator, renderer,
  etc.—are the same as before; you just have to deal with rotation. In two
  dimensions, handling rotation is simple. Things get a bit more involved when
  handling rotation in three dimensions, and we’ll treat that problem in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p><p>The example we’ll take a close look at in this chapter is simple by
  design. We want to focus on the differences between the particle simulator
  and a 2D rigid-body simulator. In <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10</a>, we’ll extend this simple
  example to deal with multiple rigid bodies and collisions. That’s where
  things really get interesting. For now, we’ll consider a single rigid body,
  a virtual hovercraft, that moves around the screen under the influences of
  thrust forces that you can control with the keyboard. While simple, this
  example covers the most fundamental aspects of simulating 2D rigid
  bodies.</p><p><a class="xref" href="ch09.html#d_rigid-body_example" title="Figure 9-1. 2D rigid-body example">Figure 9-1</a> shows our virtual <a id="ho9.0" class="indexterm"/>hovercraft. The pointy end is the front, and the hovercraft
  will start off moving from the left side of the screen to the right. Using
  the arrow keys, you can increase or decrease its speed and make it turn left
  or right (port or starboard).</p><div class="figure"><a id="d_rigid-body_example"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id325146"/><img src="httpatomoreillycomsourceoreillyimages1598941.png" alt="2D rigid-body example"/></div></div><div class="figure-title">Figure 9-1. 2D rigid-body example</div></div><p>In this simulation, the world coordinate system has its x-axis
  pointing to the right, its y-axis pointing down toward the bottom of the
  screen, and the z-axis pointing into the screen. Even though this is a 2D
  example where all motion is confined to the x-y plane, you still need a
  z-axis about which the hovercraft will rotate. Also, the local, or
  body-fixed, coordinate system has its x-axis pointing toward the front of
  the hovercraft, its y-axis pointing to the starboard side, and its z-axis
  into the screen. The local coordinate system is fixed to the rigid body at
  its center of gravity location.</p><div class="sect1" title="Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="model">Model</h2></div></div></div><p>The hovercraft <a id="tw9.1" class="indexterm"/><a id="mo9.1" class="indexterm"/>modeled in this simulation is a simplified version of the
    hovercraft we’ll model in <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a>. You can
    refer to <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a> for more details on that
    model. For convenience we repeat some of the basic properties of the model
    here. <a class="xref" href="ch09.html#simple_hovercraft_model" title="Figure 9-2. Simple hovercraft model">Figure 9-2</a> illustrates the main
    features of the model.</p><div class="figure"><a id="simple_hovercraft_model"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id325253"/><img src="httpatomoreillycomsourceoreillyimages1598942.png" alt="Simple hovercraft model"/></div></div><div class="figure-title">Figure 9-2. Simple hovercraft model</div></div><p>We’re assuming this hovercraft operates over smooth land and is
    fitted with a single airscrew propeller, located toward the aft end of the
    craft, that provides forward thrust. For controllability, the craft is
    fitted with two bow thrusters, one to port and the other to starboard.
    These bow thrusters are used to steer the hovercraft.</p><p>We use a simplified drag model where the only drag component is due
    to aerodynamic drag on the entire craft with a constant projected area.
    This model is similar to the one used in <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> for
    particle drag. A more rigorous model would consider the actual projected
    area of the craft as a function of the direction of relative velocity, as
    in the flight simulator example discussed in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>,
    as well as the frictional drag between the bottom of the craft’s skirt and
    the ground. We also assume that the center of drag—the point through which
    we can assume the drag force vector is applied—is located some distance
    aft of the center of gravity so as to give a little directional stability
    (that is, to counteract rotation). This serves the same function as the
    vertical tail fins on aircraft. Again, a more rigorous model would include
    the effects of rotation on aerodynamic drag, but we ignore that
    here.</p><p>In code, the first thing you need to do to represent this vehicle is
    define a rigid-body class that contains all of the information you’ll need
    to track it and calculate the forces and moments acting on it. This
    <code class="literal">RigidBody2D</code> class is very similar to
    the <code class="literal">Particle</code> class from <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>, but with some additions mostly dealing with
    rotation. Here’s how we did it:</p><a id="I_programlisting3_id325329"/><pre class="programlisting">class RigidBody2D {
public:
    float    fMass;       // total mass (constant)
    float    fInertia;    // mass moment of inertia
    float    fInertiaInverse;   // inverse of mass moment of inertia
    Vector    vPosition;        // position in earth coordinates
    Vector    vVelocity;        // velocity in earth coordinates
    Vector    vVelocityBody;    // velocity in body coordinates
    Vector    vAngularVelocity; // angular velocity in body coordinates

    float    fSpeed;            // speed
    float    fOrientation;      // orientation

    Vector    vForces;          // total force on body
    Vector    vMoment;          // total moment on body

    float    ThrustForce;       // Magnitude of the thrust force
    Vector    PThrust, SThrust; // bow thruster forces

    float    fWidth;            // bounding dimensions
    float    fLength;
    float    fHeight;

    Vector    CD; // location of center of drag in body coordinates
    Vector    CT; // location of center of propeller thrust in body coords.
    Vector    CPT; // location of port bow thruster thrust in body coords.
    Vector    CST; // location of starboard bow thruster thrust in body
                   // coords.

    float    ProjectedArea;     // projected area of the body

    RigidBody2D(void);
    void    CalcLoads(void);
    void    UpdateBodyEuler(double dt);
    void    SetThrusters(bool p, bool s);
    void    ModulateThrust(bool up);
};</pre><p>The code comments briefly explain each property, and so far you’ve
    seen all these properties somewhere in this book, so we won’t explain them
    again here. That said, notice that several of these properties are the
    same as those shown in the <code class="literal">Particle</code>
    class from <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>. These properties include <code class="literal">fMass</code>, <code class="literal">vPosition</code>, <code class="literal">vVelocity</code>, <code class="literal">fSpeed</code>, <code class="literal">vForces</code>, and <code class="literal">fRadius</code>. All of the other properties are new and
    required to handle the rotational motion aspects of rigid bodies.</p><p>The <code class="literal">RigidBody2D</code> constructor is
    straightforward, as shown next, and simply initializes all the properties
    to some arbitrarily tuned values we decided worked well. In <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a>, you’ll see how we model a more realistic
    hovercraft.</p><a id="I_programlisting3_id325416"/><pre class="programlisting">RigidBody2D::RigidBody2D(void)
{
    fMass = 100;
    fInertia = 500;
    fInertiaInverse = 1/fInertia;
    vPosition.x = 0;
    vPosition.y = 0;
    fWidth = 10;
    fLength = 20;
    fHeight = 5;
    fOrientation = 0;

    CD.x = −0.25*fLength;
    CD.y = 0.0f;
    CD.z = 0.0f;

    CT.x = −0.5*fLength;
    CT.y = 0.0f;
    CT.z = 0.0f;

    CPT.x = 0.5*fLength;
    CPT.y = −0.5*fWidth;
    CPT.z = 0.0f;

    CST.x = 0.5*fLength;
    CST.y = 0.5*fWidth;
    CST.z = 0.0f;

    ProjectedArea = (fLength + fWidth)/2 * fHeight; // an approximation
    ThrustForce = _THRUSTFORCE;
}</pre><p>As in the particle simulator of <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>, you’ll
    notice here that the <code class="literal">Vector</code> class is
    actually a <span class="emphasis"><em>triple</em></span> (that is, it has three
    components—x, y, and z). Since this is a 2D example, the
    <span class="emphasis"><em>z</em></span> components will always be 0, except in the case of
    the angular velocity vector where only the <span class="emphasis"><em>z</em></span>
    component will be used (since rotation occurs only about the z-axis). The
    class that we use in this example is discussed in <a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a>. The reason we didn’t write a separate 2D
    vector class, one with only <span class="emphasis"><em>x</em></span> and
    <span class="emphasis"><em>y</em></span> components, is because we’ll extend this code to 3D
    later and wanted to get you accustomed to using the 3D vector class.
    Besides, it’s pretty easy to create a 2D vector class from the 3D class by
    simply stripping out the <span class="emphasis"><em>z</em></span> component.</p><p>As with the particle example of <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>, we
    need a <code class="literal">CalcLoads</code> method for the rigid
    body. As before, this method will compute all the loads acting on the
    rigid body, but now these loads include both forces and moments that will
    cause rotation. <code class="literal">CalcLoads</code> looks like
    this:</p><a id="I_programlisting3_id325495"/><pre class="programlisting">void    RigidBody2D::CalcLoads(void)
{
    Vector    Fb;        // stores the sum of forces
    Vector    Mb;        // stores the sum of moments
    Vector    Thrust;    // thrust vector

    // reset forces and moments:
    vForces.x = 0.0f;
    vForces.y = 0.0f;
    vForces.z = 0.0f;    // always zero in 2D

    vMoment.x = 0.0f;    // always zero in 2D
    vMoment.y = 0.0f;    // always zero in 2D
    vMoment.z = 0.0f;

    Fb.x = 0.0f;
    Fb.y = 0.0f;
    Fb.z = 0.0f;

    Mb.x = 0.0f;
    Mb.y = 0.0f;
    Mb.z = 0.0f;

    // Define the thrust vector, which acts through the craft's CG
    Thrust.x = 1.0f;
    Thrust.y = 0.0f;
    Thrust.z = 0.0f;     // zero in 2D
    Thrust *= ThrustForce;

    // Calculate forces and moments in body space:
    Vector   vLocalVelocity;
    float    fLocalSpeed;
    Vector   vDragVector;
    float    tmp;
    Vector   vResultant;
    Vector   vtmp;

    // Calculate the aerodynamic drag force:
        // Calculate local velocity:
        // The local velocity includes the velocity due to
        // linear motion of the craft,
        // plus the velocity at each element
        // due to the rotation of the craft.

        vtmp = vAngularVelocity^CD; // rotational part
        vLocalVelocity = vVelocityBody + vtmp;

        // Calculate local air speed
        fLocalSpeed = vLocalVelocity.Magnitude();

        // Find the direction in which drag will act.
        // Drag always acts in line with the relative
        // velocity but in the opposing direction
        if(fLocalSpeed &gt; tol)
        {
            vLocalVelocity.Normalize();
            vDragVector = -vLocalVelocity;

            // Determine the resultant force on the element.
            tmp = 0.5f * rho * fLocalSpeed*fLocalSpeed
                         * ProjectedArea;
            vResultant = vDragVector * _LINEARDRAGCOEFFICIENT * tmp;

            // Keep a running total of these resultant forces
            Fb += vResultant;

            // Calculate the moment about the CG
            // and keep a running total of these moments

            vtmp = CD^vResultant;
            Mb += vtmp;
        }

        // Calculate the Port &amp; Starboard bow thruster forces:
        // Keep a running total of these resultant forces

        Fb += PThrust;


        // Calculate the moment about the CG of this element's force
        // and keep a running total of these moments (total moment)
        vtmp = CPT^PThrust;
        Mb += vtmp;

        // Keep a running total of these resultant forces (total force)
        Fb += SThrust;

        // Calculate the moment about the CG of this element's force
        // and keep a running total of these moments (total moment)
        vtmp = CST^SThrust;
        Mb += vtmp;

    // Now add the propulsion thrust
    Fb += Thrust; // no moment since line of action is through CG

    // Convert forces from model space to earth space
    vForces = VRotate2D(fOrientation, Fb);

    vMoment += Mb;
}</pre><p>The first thing that <code class="literal">CalcLoads</code>
    does is initialize the force and moment variables that will contain the
    total of all forces and moments acting on the craft at any instant in
    time. Just as we must aggregate forces, we must also aggregate moments.
    The forces will be used along with the linear equation of motion to
    compute the linear displacement of the rigid body, while the moments will
    be used with the angular equation of motion to compute <a id="I_indexterm3_id325538" class="indexterm"/>the orientation of the body.</p><p>The function then goes on to define a vector representing the
    propeller thrust, <code class="literal">Thrust</code>. The propeller
    thrust vector acts in the positive (local) x-direction and has a magnitude
    defined by <code class="literal">ThrustForce</code>, which the user
    sets via the keyboard interface (we’ll get to that later). Note that if
    <code class="literal">ThrustForce</code> is negative, then the
    thrust will actually be a reversing thrust instead of a forward
    thrust.</p><p>After defining the thrust vector, this function goes on to calculate
    the aerodynamic drag acting on the hovercraft. These calculations are very
    similar to those discussed in <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a>. The
    first thing to do is determine the relative velocity at the center of
    drag, considering both linear and angular motion. You’ll need the
    magnitude of the relative velocity vector when calculating the magnitude
    of the drag force, and you’ll need the direction of the relative velocity
    vector to determine the direction of the drag force since it always
    opposes the velocity vector. The line <code class="literal">vtmp =
    vAngularVelocity^CD</code> computes the linear velocity at the drag
    center by taking the vector cross product of the angular velocity vector
    with the position vector of the drag center, <code class="literal">CD</code>. The result is stored in a temporary vector,
    <code class="literal">vtmp</code>, and then added vectorially to the
    body velocity vector, <code class="literal">vVelocityBody</code>.
    The result of this vector addition is a velocity vector representing the
    velocity of the point defined by <code class="literal">CD</code>,
    including contributions from the body’s linear and angular motion. We
    compute the actual drag force, which acts in line with but in a direction
    opposing the velocity vector, in a manner similar to that for particles,
    using a simple formula relating the drag force to the speed squared,
    density of air, projected area, and a drag coefficient. The following code
    performs this calculation:</p><a id="I_programlisting3_id325624"/><pre class="programlisting">            vLocalVelocity.Normalize();
            vDragVector = -vLocalVelocity;

            // Determine the resultant force on the element.
            tmp = 0.5f * rho * fLocalSpeed*fLocalSpeed
                         * ProjectedArea;
            vResultant = vDragVector * _LINEARDRAGCOEFFICIENT * tmp;</pre><p>Note that the drag coefficient, <code class="literal">LINEARDRAGCOEFFICIENT</code>, is defined as
    follows:</p><a id="I_programlisting3_id325642"/><pre class="programlisting">#define LINEARDRAGCOEFFICIENT     1.25f</pre><p>Once the drag force is determined, it gets aggregated in the total
    force vector as follows:</p><a id="I_programlisting3_id325653"/><pre class="programlisting">              Fb += vResultant;</pre><p>In addition to aggregating this force, we must aggregate the moment
    due to that force in the total moment vector as follows:</p><a id="I_programlisting3_id325664"/><pre class="programlisting">              vtmp = CD^vResultant;
              Mb += vtmp;</pre><p>The first line computes the moment due to the drag force by taking
    the vector cross product of the position vector, to the center of drag,
    with the drag force vector. The second line adds this force to the
    variable, accumulating these moments.</p><p>With the drag calculation complete, <code class="literal">CalcLoads</code> proceeds to calculate the forces and
    moments due to the bow thrusters, which may be active or inactive at any
    given time.</p><a id="I_programlisting3_id325687"/><pre class="programlisting">        Fb += PThrust;

        vtmp = CPT^PThrust;
        Mb += vtmp;</pre><p>The first line aggregates the port bow thruster force into <code class="literal">Fb</code>. <code class="literal">PThrust</code>
    is a force vector computed in the <code class="literal">SetThrusters</code> method in response to your keyboard
    input. The next two lines compute and aggregate the moment due to the
    thruster force. A similar set of code lines follows, computing the force
    and moment due to the starboard bow thruster.</p><p>Next, the propeller thrust force is added to the running total of
    forces. Remember, since the propeller thrust force acts through the center
    of gravity, there is no moment to worry about. Thus, all we need
    is:</p><a id="I_programlisting3_id325723"/><pre class="programlisting">    Fb += Thrust; // no moment since line of action is through CG</pre><p>Finally, the total force is transformed from local coordinates to
    world coordinates via a vector rotation given the orientation of the
    hovercraft, and the total forces and moments are stored so they are
    available when it comes time to integrate the equations of motion at each
    time step.</p><p>As you can see, computing loads on a rigid body is a bit more
    complex than what you saw earlier when dealing with particles. This, of
    course, is due to the nature of rigid bodies being able to rotate. What’s
    nice, though, is that all this new complexity is encapsulated in <code class="literal">CalcLoads</code>, and the rest of the simulator is
    pretty much the same as when we’re dealing with <a id="I_indexterm3_id325747" class="indexterm"/><a id="I_indexterm3_id325756" class="indexterm"/>particles.</p><div class="sect2" title="Transforming Coordinates"><div class="titlepage"><div><div><h3 class="title" id="transforming_coordinates">Transforming Coordinates</h3></div></div></div><p>Let’s talk about <a id="I_indexterm3_id325781" class="indexterm"/><a id="I_indexterm3_id325788" class="indexterm"/>transformation from local to world coordinates a bit more
      since you’ll see this sort of transform again in a few places. When
      computing forces acting on the rigid body, we want those forces in a
      vector form relative to the coordinates that are fixed with respect to
      the hovercraft (e.g., relative to the body’s center of gravity with the
      x-axis pointing toward the front of the body and the y-axis pointing
      toward the starboard side). This simplifies our calculations of forces
      and moments. However, when integrating the equation of motion to see how
      the body translates in world coordinates, we use the <a id="I_indexterm3_id325801" class="indexterm"/>equations of motion in world coordinates, requiring us to
      represent the aggregate force in world coordinates. That’s why we
      rotated the aggregate force at the end of the <code class="literal">CalcLoads</code> method.</p><p>In two dimensions, the coordinate transformation involves a little
      trigonometry as shown in the following <code class="literal">VRotate2D</code> function:</p><a id="I_programlisting3_id325835"/><pre class="programlisting">Vector    VRotate2D( float angle, Vector u)
{
    float    x,y;

    x = u.x * cos(DegreesToRadians(-angle)) +
        u.y * sin(DegreesToRadians(-angle));
    y = -u.x * sin(DegreesToRadians(-angle)) +
        u.y * cos(DegreesToRadians(-angle));

    return Vector( x, y, 0);
}</pre><p>The angle here represents the orientation of the local, body fixed
      coordinate system with respect to the world coordinate system. When
      converting from local coordinates to world coordinates, use a positive
      angle; use a negative angle when going the other way. This is just the
      convention we’ve adopted so transformations from local coordinates to
      world coordinates are positive. You can see we actually take the
      negative of the <code class="literal">angle</code> parameter, so
      in reality you could do away with that negative, and then
      transformations from local coordinates to world coordinates would
      actually be negative. It’s your preference. You’ll see this function
      used a few more times in different situations before the end of this
      chapter.</p></div><div class="sect2" title="Integrator"><div class="titlepage"><div><div><h3 class="title" id="integrator-id1">Integrator</h3></div></div></div><p>The <code class="literal">UpdateBodyEuler</code> method
      <a id="tw9.1.2" class="indexterm"/><a id="in9.1.2" class="indexterm"/>actually integrates the equations of motion for the rigid
      body. Since we’re dealing with a rigid body, unlike a particle, we have
      two equations of motion: one for translation, and the other for
      rotation. The following code sample shows <code class="literal">UpdateBodyEuler</code>.</p><a id="I_programlisting3_id325922"/><pre class="programlisting">void    RigidBody2D::UpdateBodyEuler(double dt)
{
        Vector a;
        Vector dv;
        Vector ds;
        float  aa;
        float  dav;
        float  dr;

        // Calculate forces and moments:
        CalcLoads();

        // Integrate linear equation of motion:
        a = vForces / fMass;

        dv = a * dt;
        vVelocity += dv;

        ds = vVelocity * dt;
        vPosition += ds;

        // Integrate angular equation of motion:
        aa = vMoment.z / fInertia;

        dav = aa * dt;

        vAngularVelocity.z += dav;

        dr = RadiansToDegrees(vAngularVelocity.z * dt);
        fOrientation += dr;

        // Misc. calculations:
        fSpeed = vVelocity.Magnitude();
        vVelocityBody = VRotate2D(-fOrientation, vVelocity);
}</pre><p>As the name of this method implies, we’ve implemented Euler’s
      <a id="I_indexterm3_id325937" class="indexterm"/>method of integration as described in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>. Integrating the linear equation of
      motion for a rigid body follows exactly the same steps we used for
      integrating the linear equation of motion for particles. All that’s
      required is to divide the aggregate forces acting on a body by the mass
      of the body to get the body’s acceleration. The line of code <code class="literal">a = vForces / fMass</code> does just this. Notice
      here that <code class="literal">a</code> is a <code class="literal">Vector</code>, as is <code class="literal">vForces</code>. <code class="literal">fMass</code> is a scalar, and the <code class="literal">/</code> operator defined in the <code class="literal">Vector</code> class takes care of dividing each
      component of the <code class="literal">vForces</code> vector by
      <code class="literal">fMass</code> and setting the corresponding
      components in <code class="literal">a</code>. The change in
      velocity, <code class="literal">dv</code>, is equal to
      acceleration times the change in time, <code class="literal">dt</code>. The body’s new velocity is then computed
      by the line <code class="literal">vVelocity += dv</code>. Here
      again, <code class="literal">vVelocity</code> and <code class="literal">dv</code> are <code class="literal">Vector</code>s and the <code class="literal">+=</code> operator takes care of the vector
      arithmetic. This is the first actual integration for translation.</p><p>The second integration takes place in the next few lines, where we
      determine the body’s displacement and new position by integrating its
      velocity. The line <code class="literal">ds = vVelocity *
      dt</code> determines the displacement, or change in the body’s
      position, and the line <code class="literal">vPosition +=
      ds</code> computes the new position by adding the displacement to the
      body’s old position. That’s it for translation.</p><p>The next order of business is to integrate the angular equation of
      motion to find the body’s <a id="I_indexterm3_id326087" class="indexterm"/>new orientation. The line <code class="literal">aa =
      vMoment.z / fInertia;</code> computes the body’s angular acceleration
      by dividing the aggregate moment acting on the body by its mass moment
      of inertia. <code class="literal">aa</code> is a scalar, as is
      <code class="literal">fInertia</code> since this is a 2D problem.
      In 3D, things are a bit more complicated, and we’ll get to that in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>.</p><p>We compute the change in angular velocity, <code class="literal">dav</code>, a scalar, by multiplying <code class="literal">aa</code> by the time step size, <code class="literal">dt</code>. The new angular velocity is simply the old
      velocity plus the change: <code class="literal">vAngularVelocity.z +=
      dav</code>. The change in orientation is equal to the new angular
      velocity multiplied by the time step: <code class="literal">vAngularVelocity.z * dt</code>. Notice that we
      convert the change in orientation from radians to degrees here since
      we’re keeping track of orientation in degrees. You don’t really have to,
      so long as you’re consistent.</p><p>The last line in <code class="literal">UpdateBodyEuler</code> computes the body’s linear
      speed by transforming the magnitude of its velocity vector to local,
      body coordinates. Recall in <code class="literal">CalcLoads</code>
      that we require the body’s velocity in body-fixed coordinates in order
      to compute the <a id="I_indexterm3_id326176" class="indexterm"/><a id="I_indexterm3_id326186" class="indexterm"/>drag force on the body.</p></div><div class="sect2" title="Rendering"><div class="titlepage"><div><div><h3 class="title" id="rendering-id1">Rendering</h3></div></div></div><p>In this simple example, rendering the <a id="I_indexterm3_id326210" class="indexterm"/><a id="I_indexterm3_id326223" class="indexterm"/>virtual hovercraft is just a little more involved than
      rendering the particles in the example from <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>. All we do is draw a few connected lines using
      Windows API calls wrapped in our own functions to hide some of the
      Windows-specific code. The following code snippet is all we need to
      render the hovercraft:</p><a id="I_programlisting3_id326245"/><pre class="programlisting">void    DrawCraft(RigidBody2D    craft, COLORREF clr)
{
    Vector    vList[5];
    double    wd, lg;
    int       i;
    Vector    v1;

    wd = craft.fWidth;
    lg = craft.fLength;
    vList[0].x = lg/2;     vList[0].y = wd/2;
    vList[1].x = -lg/2;    vList[1].y = wd/2;
    vList[2].x = -lg/2;    vList[2].y = -wd/2;
    vList[3].x = lg/2;     vList[3].y = -wd/2;
    vList[4].x = lg/2*1.5; vList[4].y = 0;
    for(i=0; i&lt;5; i++)
    {
        v1 = VRotate2D(craft.fOrientation, vList[i]);
        vList[i] = v1 + craft.vPosition;
    }

    DrawLine(vList[0].x, vList[0].y, vList[1].x, vList[1].y, 2, clr);
    DrawLine(vList[1].x, vList[1].y, vList[2].x, vList[2].y, 2, clr);
    DrawLine(vList[2].x, vList[2].y, vList[3].x, vList[3].y, 2, clr);
    DrawLine(vList[3].x, vList[3].y, vList[4].x, vList[4].y, 2, clr);
    DrawLine(vList[4].x, vList[4].y, vList[0].x, vList[0].y, 2, clr);
}</pre><p>You can use your own rendering code here, of course, and all you
      really need to pay close attention to is transforming the coordinates
      for the outline of the hovercraft from body to world coordinates. This
      involves rotating the vertex coordinates from body-fixed space using the
      <code class="literal">VRotate2D</code> function and then adding
      the position of the center of gravity of the hovercraft to each
      transformed vertex. These lines take care of this coordinate
      transformation:</p><a id="I_programlisting3_id326272"/><pre class="programlisting">    for(i=0; i&lt;5; i++)
    {
        v1 = VRotate2D(craft.fOrientation, vList[i]);
        vList[i] = v1 + craft.vPosition;
    }</pre></div></div><div class="sect1" title="The Basic Simulator"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="the_basic_simulator-id1">The Basic Simulator</h2></div></div></div><p>The heart of this<a id="tw9.2" class="indexterm"/> simulation is handled by the <code class="literal">RigidBody2D</code> class described earlier. However, we
    need to show you how that class is used in the context of the main
    program. This simulator is very similar to that shown in <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> for particles, so if you’ve read that chapter
    already you can breeze through this section.</p><p>First, we define a few global variables as follows:</p><a id="I_programlisting3_id326327"/><pre class="programlisting">// Global Variables:
int            FrameCounter = 0;
RigidBody2D    Craft;</pre><p><code class="literal">FrameCounter</code> counts the number of
    time steps integrated before the graphics display is updated. How many
    time steps you allow the simulation to integrate before updating the
    display is a matter of tuning. You’ll see how this is used momentarily
    when we discuss the <code class="literal">UpdateSimulation</code>
    function. <code class="literal">Craft</code> is a <code class="literal">RigidBody2D</code> type that will represent our virtual
    hovercraft.</p><p>For the most part, <code class="literal">Craft</code> is
    initialized in accordance with the <code class="literal">RigidBody2D</code> constructor shown earlier. However,
    its position is at the origin, so we make a call to the following <code class="literal">Initialize</code> function to locate the <code class="literal">Craft</code> in the middle of the screen vertically and
    on the left side. We set its orientation to 0 degrees so it points toward
    the right side of the screen:</p><a id="I_programlisting3_id326391"/><pre class="programlisting">bool    Initialize(void)
{
    Craft.vPosition.x = _WINWIDTH/10;
    Craft.vPosition.y = _WINHEIGHT/2;
    Craft.fOrientation = 0;

    return true;
}</pre><p>OK, now let’s consider <code class="literal">UpdateSimulation</code> as shown in the code snippet
    below. This function gets called every cycle through the program’s main
    message loop and is responsible for making appropriate function calls to
    update the hovercraft’s position and orientation, as well as rendering the
    scene. It also checks the states of the keyboard arrow keys and makes
    appropriate function calls:</p><a id="I_programlisting3_id326411"/><pre class="programlisting">void    UpdateSimulation(void)
{
    double  dt = _TIMESTEP;
    RECT    r;

    Craft.SetThrusters(false, false);

    if (IsKeyDown(VK_UP))
        Craft.ModulateThrust(true);

    if (IsKeyDown(VK_DOWN))
        Craft.ModulateThrust(false);

    if (IsKeyDown(VK_RIGHT))
        Craft.SetThrusters(true, false);

    if (IsKeyDown(VK_LEFT))
        Craft.SetThrusters(false, true);

    // update the simulation
    Craft.UpdateBodyEuler(dt);

    if(FrameCounter &gt;= _RENDER_FRAME_COUNT)
    {
        // update the display
        ClearBackBuffer();

        DrawCraft(Craft, RGB(0,0,255));

        CopyBackBufferToWindow();
        FrameCounter = 0;
    } else
        FrameCounter++;

    if(Craft.vPosition.x &gt; _WINWIDTH) Craft.vPosition.x = 0;
    if(Craft.vPosition.x &lt; 0) Craft.vPosition.x = _WINWIDTH;
    if(Craft.vPosition.y &gt; _WINHEIGHT) Craft.vPosition.y = 0;
    if(Craft.vPosition.y &lt; 0) Craft.vPosition.y = _WINHEIGHT;
}</pre><p>The local variable <code class="literal">dt</code> represents
    the small yet finite amount of time, in seconds, over which each
    integration step is taken. The global <code class="literal">define
    _TIMESTEP</code> stores the time step, which we have set to 0.001
    seconds. This value is subject to tuning.</p><p>The first action <code class="literal">UpdateSimulation</code>
    takes is to reset the states of the bow thrusters to inactive by calling
    the <code class="literal">SetThrusters</code> method as
    follows:</p><a id="I_programlisting3_id326458"/><pre class="programlisting">Craft.SetThrusters(false, false);</pre><p>Next, the keyboard is polled using the function <code class="literal">IsKeyDown</code>. This is a wrapper function we created
    to encapsulate the necessary Windows API calls used to check key states.
    If the up arrow key is pressed, then the <code class="literal">RigidBody2D</code> method <code class="literal">ModulateThrust</code> is called, as shown here:</p><a id="I_programlisting3_id326488"/><pre class="programlisting">Craft.ModulateThrust(true);</pre><p>If the down arrow key is pressed, then <code class="literal">ModulateThrust</code> is called, passing <code class="literal">false</code> instead of <code class="literal">true</code>.</p><p><code class="literal">ModulateThrust</code> looks like
    this:</p><a id="I_programlisting3_id326524"/><pre class="programlisting">void    RigidBody2D::ModulateThrust(bool up)
{
    double    dT = up ? _DTHRUST:-_DTHRUST;

    ThrustForce += dT;

    if(ThrustForce &gt; _MAXTHRUST) ThrustForce = _MAXTHRUST;
    if(ThrustForce &lt; _MINTHRUST) ThrustForce = _MINTHRUST;
}</pre><p>All it does is increment the propeller thrust force by a small
    amount, either increasing it or decreasing it, depending on the value of
    the <code class="literal">up</code> parameter.</p><p>Getting back to <code class="literal">UpdateSimulation</code>,
    we make a couple more calls to <code class="literal">IsKeyDown</code>, checking the states of the left and
    right arrow keys. If the left arrow key is down, then the <code class="literal">RigidBody2D</code> method <code class="literal">SetThrusters</code> is called, passing <code class="literal">false</code> as the first parameter and <code class="literal">true</code> as the second parameter. If the right arrow
    key is down, these parameter values are reversed. <code class="literal">SetThrusters</code> looks like this:</p><a id="I_programlisting3_id326591"/><pre class="programlisting">void    RigidBody2D::SetThrusters(bool p, bool s)
{
    PThrust.x = 0;
    PThrust.y = 0;
    SThrust.x = 0;
    SThrust.y = 0;

    if(p)
        PThrust.y = _STEERINGFORCE;
    if(s)
        SThrust.y = -_STEERINGFORCE;
}</pre><p>It resets the port and starboard bow thruster thrust vectors and
    then sets them according to the parameters passed in <code class="literal">SetThrusters</code>. If <code class="literal">p</code> is <code class="literal">true</code>,
    then a right turn is desired and a port thrust force, <code class="literal">PThrust</code>, is created, pointing toward the
    starboard side. This seems opposite of what you’d expect, but it is the
    port bow thruster that is fired, pushing the bow of the hovercraft toward
    the right (starboard) side. Similarly, if <code class="literal">s</code> is <code class="literal">true</code>, a
    thrust force is created that will push the bow of the hovercraft to the
    left (port) side.</p><p>Now with the thrust forces managed, <code class="literal">UpdateSimulation</code> makes the call:</p><a id="I_programlisting3_id326652"/><pre class="programlisting">Craft.UpdateBodyEuler(dt)</pre><p><code class="literal">UpdateBodyEuler</code> integrates the
    equations of motion as discussed earlier.</p><p>The next segment of code checks the value of the frame counter. If
    the frame counter has reached the defined number of frames (stored in
    <code class="literal">_RENDER_FRAME_COUNT</code>), then the back
    buffer is cleared to prepare it for drawing upon and ultimately copying to
    the screen.</p><p>Finally, the last four lines of code wrap the hovercraft’s position
    around the edges of the <a id="I_indexterm3_id326682" class="indexterm"/>screen.</p></div><div class="sect1" title="Tuning"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="tuning-id1">Tuning</h2></div></div></div><p>You’ll probably<a id="I_indexterm3_id326702" class="indexterm"/><a id="I_indexterm3_id326715" class="indexterm"/> want to tune this example to run well on your computer
    since we didn’t implement any profiling for processor speed. Moreover, you
    should tune the various parameters governing the behavior of the
    hovercraft to see how it responds. The way we have it set up now makes the
    hovercraft exhibit a soft sort of response to turning—that is, upon
    application of turning forces, the craft will tend to keep tracking in its
    original heading for a bit even while yawed. It will not respond like a
    car would turn. You can change this behavior, of course.</p><p>Some things we suggest you play with include the time step size and
    the various constants we’ve defined as follows:</p><a id="I_programlisting3_id326739"/><pre class="programlisting">#define  _THRUSTFORCE      5.0f
#define  _MAXTHRUST        10.0f
#define  _MINTHRUST        0.0f
#define  _DTHRUST          0.001f
#define  _STEERINGFORCE    3.0f
#define  _LINEARDRAGCOEFFICIENT    1.25f</pre><p><code class="literal">_THRUSTFORCE</code> is the initial
    magnitude of the propeller thrust force. <code class="literal">_MAXTHRUST</code> and <code class="literal">_MINTHRUST</code> set upper and lower bounds to this
    force, which is modulated by the user pressing the up and down arrow keys.
    <code class="literal">_DTHRUST</code> is the incremental change in
    thrust in response to the user pressing the up and down arrow keys.
    <code class="literal">_STEERINGFORCE</code> is the magnitude of the
    bow thruster forces. You should definitely play with this value to see how
    the behavior of the hovercraft changes. Finally, <code class="literal">_LINEARDRAGCOEFFICIENT</code> is the drag coefficient
    used to compute aerodynamic drag. This is another good value to play with
    to see how behavior is affected. Speaking of drag, the location of the
    center of drag that’s initialized in the <code class="literal">RigidBody2D</code> constructor is a good parameter to
    change in order to understand how it affects the behavior of the
    hovercraft. It influences the craft’s directional stability, which affects
    its turning radius—particularly at higher <a id="I_indexterm3_id326799" class="indexterm"/><a id="I_indexterm3_id326808" class="indexterm"/><a id="I_indexterm3_id326818" class="indexterm"/>speeds.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 10. Implementing Collision Response</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator"/><link rel="next" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators"/></head><body><section class="chapter" title="Chapter 10. Implementing Collision Response" epub:type="chapter" id="implementing_collision_response"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Implementing Collision Response</h2></div></div></div><p>In this chapter, we’ll show you how to add a <a id="ho10.0" class="indexterm"/><a id="co10.0" class="indexterm"/><a id="si10.0" class="indexterm"/><a id="tw10.0" class="indexterm"/>little excitement to the hovercraft example discussed in the preceding chapter.
    Specifically, we’ll add another hovercraft and show you how to add collision response so that
    the hovercraft can crash into each other and bounce off like a couple of bumper cars. This is an
    important element for many types of games, so it’s crucial that you understand the code that
    we’ll present here. Now would be a good time to go back and review <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>
    to refresh your memory on the fundamentals of rigid-body collision response since we’ll use the
    principles and formulas discussed there to develop the collision response algorithms for the
    hovercraft simulation. In <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> you saw how to implement linear collision
    response for particles, and now we’ll show you how to handle angular effects.</p><p>To start simply, we’ll first show you how to implement collision response as if the
    hovercraft were a couple of particles just like those in <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>. This
    approach uses only linear impulse and does not include angular effects, so the results will be
    somewhat unrealistic for these hovercraft; however, this approach is applicable to other types
    of problems that you may be interested in (for example, billiard ball collisions). Plus, taking
    this approach allows us to show you very clearly the distinction between linear and angular
    effects. Including angular effects will make the simulation much more realistic; when the
    hovercraft crash into each other, not only will they bounce off each other, but they will also
    spin.</p><p>Before diving into collisions, let’s add another hovercraft to the example we started in
      <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>. Recall in that example, we had a single craft that
    you could control using the keyboard. Now, we’ll add another hovercraft that simply moves under
    constant forward thrust. Later, when we add collision detection and response you’ll be able to
    run into this new hovercraft to alter its course.</p><p>Referring back to the example from <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>, we need to add
    another craft as follows:</p><a id="I_programlisting4_id326953"/><pre class="programlisting">RigidBody2D    Craft2;</pre><p>We’re calling the new hovercraft, very creatively, <code class="literal">Craft2</code>. In the <code class="literal">Initialize</code> function, we must now
    add the following code:</p><a id="I_programlisting4_id326976"/><pre class="programlisting">bool    Initialize(void)
{
.
.
.
    Craft2.vPosition.x = _WINWIDTH/2;
    Craft2.vPosition.y = _WINHEIGHT/2;
    Craft2.fOrientation = 90;
.
.
.
}</pre><p>This new code sample positions the second hovercraft in the middle of the screen and
    pointing toward the bottom.</p><p>There are a few required changes to <code class="literal">UpdateSimulation</code> as
    well. First, add <code class="literal">Craft2.UpdateBodyEuler(dt);</code> right after the
    line <code class="literal">Craft.UpdateBodyEuler(dt);</code>. Then, add <code class="literal">DrawCraft(Craft2, RGB(200, 200, 0));</code> after the similar line that
    draws the first <code class="literal">Craft</code>. <code class="literal">Craft2</code> will be drawn yellow to distinguish it from the first <code class="literal">Craft</code>. Finally, add the following lies at the end of <code class="literal">UpdateSimulation</code>:</p><a id="I_programlisting4_id327041"/><pre class="programlisting">    if(Craft2.vPosition.x &gt; _WINWIDTH) Craft2.vPosition.x = 0;
    if(Craft2.vPosition.x &lt; 0) Craft2.vPosition.x = _WINWIDTH;
    if(Craft2.vPosition.y &gt; _WINHEIGHT) Craft2.vPosition.y = 0;
    if(Craft2.vPosition.y &lt; 0) Craft2.vPosition.y = _WINHEIGHT;</pre><p>Now, we can add the code to handle collision detection and response, allowing you to ram
    your hovercraft into the new one we just added.</p><div class="sect1" title="Linear Collision Response"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="linear_collision_response">Linear Collision Response</h2></div></div></div><p>In this section, <a id="li10.1" class="indexterm"/><a id="co10.1" class="indexterm"/>we’ll show you how to implement simple collision response, assuming that the two
      hovercraft are particles. We’re going to implement only bare-minimum collision detection in
      this simulation; however, regardless of the level of sophistication of your collision
      detection routines, there are very specific pieces of information that you must collect from
      your collision detection routine(s) in order for your physics-based collision response
      routines to work.</p><p>To revise the hovercraft example of the previous chapter to include simple collision
      response, you’ll have to modify the <code class="literal">UpdateSimulation</code>
      function and add a couple more functions: <code class="literal">CheckForCollision</code>
      and <code class="literal">ApplyImpulse</code>.</p><p>Before showing you <code class="literal">CheckForCollision</code>, we want to
      explain what your <a id="I_indexterm4_id327140" class="indexterm"/>collision detection function must do. First, it must let you know whether or not
      there is a collision occurring between the hovercraft. Secondly, it must let you know if the
      hovercraft are penetrating each other. Thirdly, if the hovercraft are colliding, it must tell
      you what the collision normal vector is and what the relative velocity<a id="I_indexterm4_id327154" class="indexterm"/><a id="I_indexterm4_id327164" class="indexterm"/> is between the colliding hovercraft.</p><p>To determine whether or not there is a collision, you need to consider two factors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Whether or not the objects are close enough, within numerical tolerances, to be
          considered in colliding contact</p></li><li class="listitem"><p>What the relative normal velocity is between the objects</p></li></ul></div><p>If the objects aren’t close to each other, they obviously have not collided. If they are
      within your tolerance for contact, then they may be colliding; and if they are touching and
      overlapping such that they are moving inside each other, they are penetrating, as illustrated
      in <a class="xref" href="ch10.html#collision_nomenclature" title="Figure 10-1. Collision nomenclature">Figure 10-1</a>. If your collision detection routine finds that
      the two objects are indeed close enough to be in colliding contact, then you have to do
      another check on the relative normal velocity to see if they are moving away from each other
      or toward each other. A collision occurs when the objects are in contact and the contact
      points are moving toward each other.</p><div class="figure"><a id="collision_nomenclature"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id327225"/><img src="httpatomoreillycomsourceoreillyimages1598943.png" alt="Collision nomenclature"/></div></div><div class="figure-title">Figure 10-1. Collision nomenclature</div></div><p>Penetration is <a id="I_indexterm4_id327246" class="indexterm"/><a id="I_indexterm4_id327252" class="indexterm"/>important because if your objects overlap during the simulation, the results won’t
      look realistic—you’ll have one hovercraft moving inside the other. What you have to do is
      detect this penetration condition and then back up your simulation, reduce the time step, and
      try again. You keep doing this until they are no longer penetrating or they are within
      tolerance to be considered colliding.</p><p>You need to determine the normal velocity vector of the collision in order to calculate
      the <a id="I_indexterm4_id327273" class="indexterm"/><a id="I_indexterm4_id327285" class="indexterm"/><a id="I_indexterm4_id327295" class="indexterm"/>collision impulse that will be used to simulate their response to the collision.
      For simple cases, determining this normal vector is fairly straightforward. In the case of
      particles or spheres, the collision normal is simply along the line that connects the centers
      of gravity of each colliding object; this <a id="I_indexterm4_id327309" class="indexterm"/><a id="I_indexterm4_id327315" class="indexterm"/>is <span class="emphasis"><em>central impact</em></span>, as discussed in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>, and is the same as that used for the particle example in <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a>.</p><p>Now take a look at the function we’ve prepared for this simulation to check for
      collisions:</p><a id="I_programlisting4_id327344"/><pre class="programlisting">int     CheckForCollision (pRigidBody2D body1, pRigidBody2D body2)
{
     Vector    d;
     float     r;
     int       retval = 0;
     float     s;
     Vector    v1, v2;
     float     Vrn;

     r = body1-&gt;ColRadius + body2-&gt;ColRadius;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     d.Normalize();
     vCollisionNormal = d;

     v1 = body1-&gt;vVelocity;
     v2 = body2-&gt;vVelocity;
     vRelativeVelocity = v1 - v2;

     Vrn = vRelativeVelocity * vCollisionNormal;
     if((fabs(s) &lt;= ctol) &amp;&amp; (Vrn &lt; 0.0))
     {
          retval = 1; // collision;
          CollisionBody1 = body1;
          CollisionBody2 = body2;
     } else      if(s &lt; -ctol)
     {
          retval = −1; // interpenetrating
     } else
          retval = 0; // no collision

     return retval;
}</pre><p>This function uses a simple bounding circle check <a id="I_indexterm4_id327359" class="indexterm"/><a id="I_indexterm4_id327366" class="indexterm"/>to determine whether or not the hovercraft are colliding. The first thing it does
      is calculate the distance, <code class="literal">r</code>, that represents the absolute
      minimum separation between these hovercraft when they are in contact. <code class="literal">ColRadius</code> is the radius of the bounding circle of the hovercraft. We must compute
      it for each hovercraft upon initialization as follows:</p><a id="I_programlisting4_id327392"/><pre class="programlisting">-&gt;ColRadius = SQRT(fLength*fLength + fWidth*fWidth);</pre><p>Next, the distance separating the hovercraft at the time this function is called is
      determined and stored in the variable <code class="literal">d</code>. Since we’re
      assuming that these hovercraft are particles, determining <code class="literal">d</code>
      is simply a matter of calculating the distance between the coordinates of each craft’s center
      of gravity. In terms of vectors, this is simply the position vector of one craft minus the
      position vector of the other.</p><p>Once the function has <code class="literal">d</code> and <code class="literal">r</code>, it needs to determine the actual amount of space, <code class="literal">s</code>, separating the hovercraft’s bounding circles. After this separation is
      determined, the function normalizes the vector <code class="literal">d</code>. Since the
      vector <code class="literal">d</code> is along the line that separates the hovercraft’s
      centers of gravity, normalizing it yields the collision normal vector that we need for our
      collision response calculations. The collision normal vector is saved in the global variable
        <code class="literal">vCollisionNormal</code>.</p><p>After calculating the collision normal, this function goes on to determine the <a id="I_indexterm4_id327462" class="indexterm"/><a id="I_indexterm4_id327474" class="indexterm"/>relative velocity between the hovercraft. In vector form, this is simply the
      difference between the velocity vectors of each craft. Note that the velocity vectors used
      here must be in global coordinates, not body-fixed (local) coordinates. Since what’s really
      needed to determine if a collision is made is the<a id="I_indexterm4_id327488" class="indexterm"/> relative <span class="emphasis"><em>normal</em></span> velocity, the function proceeds to take the
      vector dot product of the relative velocity and the collision normal vectors, saving the
      result in the variable <code class="literal">Vrn</code>.</p><p>At this point, all of the calculations are complete, and the only thing left to do is make
      the appropriate checks to determine if there is a collision, penetration, or no collision at
      all.</p><p>The first check is to see if the hovercraft are colliding. We determine this by comparing
      the absolute value of the separation between the hovercraft, <code class="literal">s</code>, with a <a id="I_indexterm4_id327524" class="indexterm"/>distance tolerance, <code class="literal">ctol</code>. If the absolute value
      of <code class="literal">s</code> is less than <code class="literal">ctol</code>,
      a collision might be occurring. The second requirement is that the relative normal velocity be
      negative, which implies that the points of impact on the hovercraft are moving toward each
      other. If there is a collision, the function returns a <code class="literal">1</code> to
      indicate that collision response is necessary.</p><p>If the hovercraft are found not to be colliding, then we perform a second check to see if
      they’ve moved so close together that they are penetrating each other. In this case, if
        <code class="literal">s</code> is less than <code class="literal">–ctol</code>,
      the hovercraft are penetrating and the function returns a <code class="literal">−1</code>. If the hovercraft are not colliding and not penetrating, then the function
      simply returns a <code class="literal">0</code>, indicating that no further action is
      required.</p><p>Before moving on, let’s say a word or two about <code class="literal">ctol</code>—the collision tolerance distance. This value is subject to tuning. There’s no
      single value that works well in all cases. You must consider the overall sizes of the objects
      potentially colliding, the step size you’re using, and how far the colliding objects are from
      the viewer while being rendered (i.e., their scale). Basically, you should choose a value that
      makes collisions look correct, so that on the one hand objects do not appear to be penetrating
      each other, and on the other hand you do not report a collision when objects do not appear to
      be touching at all.</p><p>Take a look now at the other new function, <code class="literal">ApplyImpulse</code>:</p><a id="I_programlisting4_id327616"/><pre class="programlisting">void     ApplyImpulse(pRigidBody2D body1, pRigidBody2D body2)
{
     float j;


     j =  (-(1+fCr) * (vRelativeVelocity*vCollisionNormal)) /
          ( (vCollisionNormal*vCollisionNormal) *
            (1/body1-&gt;fMass + 1/body2-&gt;fMass) );

     body1-&gt;vVelocity += (j * vCollisionNormal) / body1-&gt;fMass;
     body2-&gt;vVelocity -= (j * vCollisionNormal) / body2-&gt;fMass;
}</pre><p>This is a simple but crucial function for collision response. What it does is calculate
      the linear collision impulse as a function of the colliding hovercraft’s relative normal
      velocity, masses, and coefficient of restitution, using the formula that we showed you in
        <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>. Further, it applies this impulse to each hovercraft,
      effectively changing their velocities in response to the collision. Note that the impulse is
      applied to one hovercraft and then the negative impulse applied to the other.</p><p>With those two new functions complete, it’s now time to revise <code class="literal">UpdateSimulation</code> to handle collision detection and response as the simulation
      steps through time. Here’s what the new <code class="literal">UpdateSimulation</code>
      function looks like:</p><a id="I_programlisting4_id327654"/><pre class="programlisting">void     UpdateSimulation(float dt)
{
     float     dtime = dt;
     bool      tryAgain = true;
     int       check=0;
     RigidBody2D     craft1Copy, craft2Copy;
     bool      didPen = false;
     int       count = 0;


    Craft.SetThrusters(false, false);

    if (IsKeyDown(VK_UP))
        Craft.ModulateThrust(true);

    if (IsKeyDown(VK_DOWN))
        Craft.ModulateThrust(false);

    if (IsKeyDown(VK_RIGHT))
        Craft.SetThrusters(true, false);

    if (IsKeyDown(VK_LEFT))
        Craft.SetThrusters(false, true);


     while(tryAgain &amp;&amp; dtime &gt; tol)
     {
          tryAgain = false;
          memcpy(&amp;craft1Copy, &amp;Craft, sizeof(RigidBody2D));
          memcpy(&amp;craft2Copy, &amp;Craft2, sizeof(RigidBody2D));

          Craft.UpdateBodyEuler(dtime);
          Craft2.UpdateBodyEuler(dtime);

          CollisionBody1 = 0;
          CollisionBody2 = 0;
          check = CheckForCollision(&amp;craft1Copy, &amp;craft2Copy);

          if(check == PENETRATING)
          {
               dtime = dtime/2;
               tryAgain = true;
               didPen = true;
          } else if(check == COLLISION)
          {
               if(CollisionBody1 != 0 &amp;&amp; CollisionBody2 != 0)
                    ApplyImpulse(CollisionBody1,  CollisionBody2);
          }
     }

     if(!didPen)
     {
          memcpy(&amp;Craft, &amp;craft1Copy, sizeof(RigidBody2D));
          memcpy(&amp;Craft2, &amp;craft2Copy, sizeof(RigidBody2D));
     }
}</pre><p>Obviously, this version is more complicated than the original version. There’s one main
      reason for this:<a id="I_indexterm4_id327675" class="indexterm"/><a id="I_indexterm4_id327681" class="indexterm"/> penetration could occur because the hovercraft can move far enough within a
      single time step to become overlapped. Visually, this situation is unappealing and
      unrealistic, so you should to try to prevent it.</p><p>The first thing this function does is enter a <code class="literal">while</code>
      loop:</p><a id="I_programlisting4_id327705"/><pre class="programlisting">     while(tryAgain &amp;&amp; dtime &gt; tol)
     {
         .
         .
         .
     }</pre><p>This loop is used to back up the simulation if penetration has occurred on the initial
      time step. What happens is this: the function first tries to update the hovercraft and then
      checks to see if there is a collision. If there is a collision, then it gets handled by
      applying the impulse. If there is penetration, however, then you know the time step was too
      big and you have to try again. When this occurs, <code class="literal">tryAgain</code>
      is set to <code class="literal">true</code>, the time step is cut in half, and another
      attempt is made. The function stays in this loop as long as there is penetration or until the
      time step has been reduced to a size small enough to force an exit to the loop. The purpose of
      this looping is to find the largest step size, less than or equal to <code class="literal">dt</code>, that can be taken and still avoid penetration. You either want a collision or
      no collision.</p><p>You might ask yourself when does small become too small in terms of time step? Too small
      is obviously when the time step approaches 0 and your entire simulation grinds to a halt.
      Therefore, you may want to put in some criteria to exit this loop before things slow down too
      much. This is all subject to tuning, by the way, and it also depends on the value you set for
        <code class="literal">ctol</code>. We can’t stress enough the importance of tuning
      these parameters. Basically, you must strive for visual realism while keeping your frame rates
      up to required levels.</p><p>Looking inside this <code class="literal">while</code> loop reveals what’s going on.
      First, <code class="literal">tryAgain</code> is set to <code class="literal">false</code>, optimistically assuming that there will be no penetration, and we make
      copies of the hovercraft’s states, reflecting the last successful call to <code class="literal">UpdateSimulation</code>.</p><p>Next, we make the usual call to <code class="literal">UpdateBody</code> for each
      copy of the hovercraft. Then a call to the collision detection function, <code class="literal">CheckForCollision</code>, is made to see if <code class="literal">Craft</code> is colliding with or penetrating <code class="literal">Craft2</code>.
      If there is penetration, then <code class="literal">tryAgain</code> is set to <code class="literal">true</code>, <code class="literal">dtime</code> is cut in half,
        <code class="literal">didPen</code> is set to <code class="literal">true</code>,
      and the function takes another lap through the <code class="literal">while</code> loop.
        <code class="literal">didPen</code> is a flag that lets us know that a penetration
      condition did occur.</p><p>If there was a collision, the function handles it by applying the appropriate
      impulse:</p><a id="I_programlisting4_id327858"/><pre class="programlisting">     if(CollisionBody1 != 0 &amp;&amp; CollisionBody2 != 0)
          ApplyImpulse(CollisionBody1,  CollisionBody2);</pre><p>After getting through the <code class="literal">while</code> loop, the updated
      hovercraft states are saved and <code class="literal">UpdateSimulation</code> is
      complete.</p><p>The last bit of code you need to add includes a few new global variables and <code class="literal">define</code>s:</p><a id="I_programlisting4_id327892"/><pre class="programlisting">#define     LINEARDRAGCOEFFICIENT        0.25f
#define     COEFFICIENTOFRESTITUTION     0.5f
#define     COLLISIONTOLERANCE           2.0f

Vector      vCollisionNormal;
Vector      vRelativeVelocity;
float       fCr = COEFFICIENTOFRESTITUTION;
float const ctol = COLLISIONTOLERANCE;</pre><p>The only one we haven’t mentioned so far, although you’ve seen it in <code class="literal">ApplyImpulse</code>, is <code class="literal">fCr</code>, the
      coefficient of restitution. Here we have it set to 0.5, which means that the collisions are
      halfway between perfectly elastic and perfectly inelastic (refer back to our earlier
      discussions on coefficients of restitution in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a> if you’ve forgotten
      these terms). This is one of those parameters that you’ll have to tune to get the desired
      behavior.</p><p>While we’re on the subject of tuning, we should mention that you’ll also have to play with
      the linear drag coefficient used to calculate the drag force on the hovercraft. While this
      coefficient is used to simulate fluid dynamic drag, it also plays an important role in terms
      of numerical stability. You need some damping in your simulation so that your integrator does
      not blow up—that is, damping helps keep your simulation stable.</p><p>That’s pretty much it as far as implementing basic collision response. If you run this
      example, you’ll be able to drive the hovercraft into each other and bounce off accordingly.
      You can play around with the mass of each hovercraft and the coefficient of restitution to see
      how the craft behave when one is more massive than the other, or when the collision is
      somewhere between perfectly elastic and perfectly inelastic.</p><p>You may notice that the collision response in this example sometimes looks a little
      strange. Keep in mind that’s because this collision response algorithm, so far, assumes that
      the hovercraft are round when in fact they are rectangular. This approach will work just fine
      for round objects like billiard balls, but to get the level of realism required for non-round
      rigid bodies you need to include angular effects. We’ll show you how to do that in the
        <a id="I_indexterm4_id327946" class="indexterm"/><a id="I_indexterm4_id327955" class="indexterm"/>next section.</p></div><div class="sect1" title="Angular Effects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="angular_effects">Angular Effects</h2></div></div></div><p>Including angular <a id="an10.2" class="indexterm"/><a id="co10.2" class="indexterm"/>effects will yield more realistic collision responses for these rigid bodies, the
      hovercraft. To get this to work, you’ll have to make several changes to <code class="literal">ApplyImpulse</code> and <code class="literal">CheckForCollision;</code>. <code class="literal">UpdateSimulation</code> will
      remain unchanged. The more extensive changes are in <code class="literal">CheckForCollision</code>, so we’ll discuss it first.</p><p>The new version of <code class="literal">CheckForCollision</code> will do more than
      a simple bounding circle check. Here, each hovercraft will be represented by a polygon with
      four edges and four vertices, and the types of contact that will be checked for are
      vertex-vertex and vertex-edge contact (see <a class="xref" href="ch10.html#types_of_collision" title="Figure 10-2. Types of collision">Figure 10-2</a>).<sup>[<a id="CHP-10-FN-1" href="#ftn.CHP-10-FN-1" epub:type="noteref" class="footnote">19</a>]</sup></p><div class="figure"><a id="types_of_collision"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id328069"/><img src="httpatomoreillycomsourceoreillyimages1598944.png" alt="Types of collision"/></div></div><div class="figure-title">Figure 10-2. Types of collision</div></div><p>In addition to the tasks discussed in the last section, this new version of <code class="literal">CheckForCollision</code> must also determine the exact point of contact
      between the hovercraft. This is a very important distinction between this new version and the
      last. You need to know the point of contact because in order to affect the angular velocity,
      you must apply the impulse at the point of contact. In the last section, the normal to the
      contact point always passed through the center of gravity of the hovercraft because we assumed
      they were spheres; that’s not the case here.</p><p>This now brings up the challenge of finding the collision normal. There are two cases to
      consider here. In edge-vertex collisions, the normal is always perpendicular to the edge
      that’s involved in the collision. In vertex-vertex collisions, however, the normal is
      ambiguous, so we’ve resorted to taking the normal parallel to the line connecting the
      hovercraft’s centers of gravity.</p><p>All of these considerations make <code class="literal">CheckForCollisions</code> a
      little more involved than in the previous section. The following code listing shows what we
      mean:</p><a id="I_programlisting4_id328122"/><pre class="programlisting">int     CheckForCollision(pRigidBody2D body1, pRigidBody2D body2)
{
     Vector    d;
     float     r;
     int       retval = 0;
     float     s;
     Vector    vList1[4], vList2[4];
     float     wd, lg;
     int       i,j;
     bool      haveNodeNode = false;
     bool      interpenetrating = false;
     bool      haveNodeEdge = false;
     Vector    v1, v2, u;
     Vector    edge, p, proj;
     float     dist, dot;
     float     Vrn;

     // First check to see if the bounding circles are colliding
     r = body1-&gt;fLength/2 + body2-&gt;fLength/2;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     if(s &lt;= ctol)
     {   // We have a possible collision, check further
          // build vertex lists for each hovercraft
          wd = body1-&gt;fWidth;
          lg = body1-&gt;fLength;
          vList1[0].y = wd/2;          vList1[0].x = lg/2;
          vList1[1].y = -wd/2;         vList1[1].x = lg/2;
          vList1[2].y = -wd/2;         vList1[2].x = -lg/2;
          vList1[3].y = wd/2;          vList1[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body1-&gt;fOrientation, vList1[i]);
               vList1[i] = vList1[i] + body1-&gt;vPosition;
          }

          wd = body2-&gt;fWidth;
          lg = body2-&gt;fLength;
          vList2[0].y = wd/2;          vList2[0].x = lg/2;
          vList2[1].y = -wd/2;         vList2[1].x = lg/2;
          vList2[2].y = -wd/2;         vList2[2].x = -lg/2;
          vList2[3].y = wd/2;          vList2[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body2-&gt;fOrientation, vList2[i]);
               vList2[i] = vList2[i] + body2-&gt;vPosition;
          }

          // Check for vertex-vertex collision
          for(i=0; i&lt;4 &amp;&amp; !haveNodeNode; i++)
          {
               for(j=0; j&lt;4 &amp;&amp; !haveNodeNode; j++)
               {

                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint −
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint −
                                             body2-&gt;vPosition;

                    vCollisionNormal = body1-&gt;vPosition −
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();

                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;

                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                        (Vrn &lt; 0.0) )
                         haveNodeNode = true;

               }
          }

          // Check for vertex-edge collision
          if(!haveNodeNode)
          {
               for(i=0; i&lt;4 &amp;&amp; !haveNodeEdge; i++)
               {
                    for(j=0; j&lt;3 &amp;&amp; !haveNodeEdge; j++)
                    {
                         if(j==2)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();

                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();

                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint −
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint −
                                                  body2-&gt;vPosition;

                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();

                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;

                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;
                    }
               }
          }

          // Check for penetration
          if(!haveNodeNode &amp;&amp; !haveNodeEdge)
          {
               for(i=0; i&lt;4 &amp;&amp; !interpenetrating; i++)
               {
                    for(j=0; j&lt;4 &amp;&amp; !interpenetrating; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];

                         p = vList1[i] - vList2[j];
                         dot = p * edge;
                         if(dot &lt; 0)
                         {
                              interpenetrating = true;
                         }
                    }
               }
       }

       if(interpenetrating)
       {
               retval = −1;
       } else if(haveNodeNode || haveNodeEdge)
       {
               retval = 1;
       } else
               retval = 0;

     } else
     {
          retval = 0;
     }

     return retval;
}</pre><p>The first thing that <code class="literal">CheckForCollision</code> does is perform
      a quick bounding-circle check to see if there is a possible collision. If no collision is
      detected, the function simply exits, returning <code class="literal">0</code>. This is
      the same bounding-circle check<a id="I_indexterm4_id328196" class="indexterm"/><a id="I_indexterm4_id328202" class="indexterm"/> performed in the earlier version:</p><a id="I_programlisting4_id328214"/><pre class="programlisting">     r = body1-&gt;fLength/2 + body2-&gt;fLength/2;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     if(s &lt;= ctol)
     {
          .
          .
          .
     } else
          retval = 0;
     }</pre><p>If the bounding-circle check indicates the possibility of a collision, then <code class="literal">CheckForCollision</code> proceeds by setting up a couple of polygons,
      represented by vertex lists, for each hovercraft:</p><a id="I_programlisting4_id328232"/><pre class="programlisting">          wd = body1-&gt;fWidth;
          lg = body1-&gt;fLength;
          vList1[0].y = wd/2;          vList1[0].x = lg/2;
          vList1[1].y = -wd/2;         vList1[1].x = lg/2;
          vList1[2].y = -wd/2;         vList1[2].x = -lg/2;
          vList1[3].y = wd/2;          vList1[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body1-&gt;fOrientation, vList1[i]);
               vList1[i] = vList1[i] + body1-&gt;vPosition;
          }

          wd = body2-&gt;fWidth;
          lg = body2-&gt;fLength;
          vList2[0].y = wd/2;          vList2[0].x = lg/2;
          vList2[1].y = -wd/2;         vList2[1].x = lg/2;
          vList2[2].y = -wd/2;         vList2[2].x = -lg/2;
          vList2[3].y = wd/2;          vList2[3].x = -lg/2;
          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body2-&gt;fOrientation, vList2[i]);
               vList2[i] = vList2[i] + body2-&gt;vPosition;
          }</pre><p>The vertex lists are initialized in unrotated body-fixed (local) coordinates based on the
      length and width of the hovercraft. The vertices are then rotated to reflect the orientation
      of each hovercraft. After that, the position of each hovercraft is added to each vertex to
      convert from local coordinates to global coordinates</p><p>Checking first for vertex-vertex collisions, the <a id="vv10.2" class="indexterm"/><a id="covv10.2" class="indexterm"/>function iterates through each vertex in one list, comparing it with each vertex
      in the other list to see if the points are coincident.</p><a id="I_programlisting4_id328285"/><pre class="programlisting">          // Check for vertex-vertex collision
          for(i=0; i&lt;4 &amp;&amp; !haveNodeNode; i++)
          {
               for(j=0; j&lt;4 &amp;&amp; !haveNodeNode; j++)
               {

                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint −
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint −
                                             body2-&gt;vPosition;

                    vCollisionNormal = body1-&gt;vPosition −
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();

                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;

                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                                       (Vrn &lt; 0.0) )
                         haveNodeNode = true;

               }
          }</pre><p>This comparison makes a call to another new function, <code class="literal">ArePointsEqual</code>:</p><a id="I_programlisting4_id328311"/><pre class="programlisting">                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                                       (Vrn &lt; 0.0) )
                         haveNodeNode = true;</pre><p><code class="literal">ArePointsEqual</code> simply checks to see if the points are
      within a specified distance from each other, as shown here:</p><a id="I_programlisting4_id328329"/><pre class="programlisting">bool     ArePointsEqual(Vector p1, Vector p2)
{
     // Points are equal if each component is within ctol of each other
     if(  (fabs(p1.x - p2.x) &lt;= ctol) &amp;&amp;
          (fabs(p1.y - p2.y) &lt;= ctol) &amp;&amp;
          (fabs(p1.z - p2.z) &lt;= ctol) )
          return true;
     else
          return false;
}</pre><p>Within the nested <code class="literal">for</code> loops of the vertex-vertex check,
      we perform a number of important calculations to determine the collision normal vector and
      relative velocity that are required for collision response.</p><p>First, we calculate the collision point, which is simply the coordinates of a vertex that
      is involved in the collision. Note that this point will be in global coordinates, so it will
      have to be converted to local coordinates for each hovercraft in order to be useful for
      collision response. Here’s how that’s done:</p><a id="I_programlisting4_id328355"/><pre class="programlisting">                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint −
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint −
                                             body2-&gt;vPosition;</pre><p>The second calculation is aimed at determining the collision normal vector, which for
      vertex-vertex collisions we’ve assumed is along the line connecting the centers of gravity of
      each hovercraft. The calculation is the same as that shown in the earlier version of <code class="literal">CheckForCollision</code>:</p><a id="I_programlisting4_id328375"/><pre class="programlisting">                    vCollisionNormal = body1-&gt;vPosition −
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();</pre><p>The third and final calculation is aimed at determining the relative velocity between the
      points of impact. This is an important distinction from the earlier version, since the
      velocities of the points of impact on each body are functions of the linear and angular
      velocities of the hovercraft:</p><a id="I_programlisting4_id328389"/><pre class="programlisting">                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;</pre><p>Here, <code class="literal">v1</code> and <code class="literal">v2</code>
      represent the velocities of the points of collision relative to each hovercraft in local
      coordinates, which are then converted to global coordinates. Once we’ve obtained the relative
      velocity, <code class="literal">vRelativeVelocity</code>, we obtain the relative normal
      velocity, <code class="literal">Vrn</code>, by taking the dot product of the relative
      velocity with the collision normal <a id="I_indexterm4_id328429" class="indexterm"/><a id="I_indexterm4_id328438" class="indexterm"/>vector.</p><p>If there is no vertex-vertex collision, <code class="literal">CheckForCollision</code> proceeds to check for <a id="ve10.2" class="indexterm"/><a id="cove10.2" class="indexterm"/>vertex-edge collisions:</p><a id="I_programlisting4_id328486"/><pre class="programlisting">          // Check for vertex-edge collision
          if(!haveNodeNode)
          {
               for(i=0; i&lt;4 &amp;&amp; !haveNodeEdge; i++)
               {
                    for(j=0; j&lt;3 &amp;&amp; !haveNodeEdge; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();

                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();

                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint −
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint −
                                                  body2-&gt;vPosition;

                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();

                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;

                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;
                    }
               }
          }</pre><p>Here, the nested <code class="literal">for</code> loops check each vertex in one
      list to see if it is in contact with each edge built from the vertices in the other list.
      After building the edge under consideration, we save and normalize a copy of it to represent a
      unit vector pointing along the edge:</p><a id="I_programlisting4_id328519"/><pre class="programlisting">                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();</pre><p>Variable <code class="literal">u</code> represents that unit vector, and it will be
      used in subsequent calculations. The next set of calculations determines the location of the
      projection of the vertex under consideration onto the edge under consideration, as well as the
      minimum distance from the vertex to edge:</p><a id="I_programlisting4_id328539"/><pre class="programlisting">                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();</pre><p>Variable <code class="literal">p</code> is a vector from the first vertex on the
      edge to the vertex under consideration, and <code class="literal">proj</code> is the
      distance from the first edge vertex, along the edge, to the point upon which the vertex
      projects. <code class="literal">dist</code> is the minimum distance from the vertex to
      the edge. <a class="xref" href="ch10.html#vertex-edge_check" title="Figure 10-3. Vertex-edge check">Figure 10-3</a> illustrates this geometry.</p><div class="figure"><a id="vertex-edge_check"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id328585"/><img src="httpatomoreillycomsourceoreillyimages1598945.png" alt="Vertex-edge check"/></div></div><div class="figure-title">Figure 10-3. Vertex-edge check</div></div><p>If there is a collision, the global location of the point of impact is equal to the vertex
      under consideration, which we must convert to local coordinates for each hovercraft, as shown
      here:</p><a id="I_programlisting4_id328610"/><pre class="programlisting">                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint −
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint −
                                                  body2-&gt;vPosition;</pre><p>Since, in this type of collision, the collision normal vector is perpendicular to the
      edge, you can determine it by taking the result of the cross product of <code class="literal">u</code> and <code class="literal">p</code> and crossing it with
        <code class="literal">u</code> as follows:</p><a id="I_programlisting4_id328641"/><pre class="programlisting">                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();</pre><p>These calculations give you a unit length vector in the plane of vectors <code class="literal">u</code> and <code class="literal">p</code> and perpendicular to
      the edge.</p><p>Next, the relative velocity between the points of impact on each hovercraft is determined,
      just as in the vertex-vertex collision check:</p><a id="I_programlisting4_id328668"/><pre class="programlisting">                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;</pre><p>In determining whether or not the vertex under consideration is in fact colliding with an
      edge, you have to check to see if the distance from the vertex is within your collision
      tolerance, and you also have to make sure the vertex actually projects onto the edge (that is,
      it does not project beyond the endpoints of the edge). Additionally, you need to make sure the
      relative normal velocity indicates that the points of contact are moving toward each other.
      Here’s how this check looks:</p><a id="I_programlisting4_id328687"/><pre class="programlisting">                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;</pre><p>After <code class="literal">CheckForCollision</code> checks for vertex-vertex and
      vertex-edge collisions, it goes on to check for penetration:</p><a id="I_programlisting4_id328706"/><pre class="programlisting">          if(!haveNodeNode &amp;&amp; !haveNodeEdge)
          {
               for(i=0; i&lt;4 &amp;&amp; !interpenetrating; i++)
               {
                    for(j=0; j&lt;4 &amp;&amp; !interpenetrating; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];

                         p = vList1[i] - vList2[j];
                         dot = p * edge;
                         if(dot &lt; 0)
                         {
                              interpenetrating = true;
                         }
                    }
               }
       }</pre><p>This check is a standard point-in-polygon check using the vector dot product to determine
      if any vertex of one polygon lies within the bounds of the other polygon. After this check,
      the function simply returns the appropriate result. Here again, <code class="literal">0</code> indicates no collision or penetration, <code class="literal">1</code>
      indicates a collision, and <code class="literal">−1</code> indicates penetration.</p><p>With <code class="literal">CheckForCollision</code> out of the way, turn your
      attention to <code class="literal">ApplyImpulse</code>, which also has to be revised to
      include angular effects. Specifically, you need to use the impulse formula that includes
      angular as well as linear effects (see <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>), and you also have to
      apply the impulse to the hovercraft’s angular velocities in addition to their linear
      velocities. Here’s how the new <code class="literal">ApplyImpulse</code> function
      looks:</p><a id="I_programlisting4_id328770"/><pre class="programlisting">void     ApplyImpulse(pRigidBody2D body1, pRigidBody2D body2)
{
     float j;

     j = (-(1+fCr) * (vRelativeVelocity*vCollisionNormal)) /
          ( (1/body1-&gt;fMass + 1/body2-&gt;fMass) +
          (vCollisionNormal * (((body1-&gt;vCollisionPoint ^
           vCollisionNormal)/body1-&gt;fInertia)^body1-&gt;vCollisionPoint)) +
          (vCollisionNormal * (((body2-&gt;vCollisionPoint ^
           vCollisionNormal)/body2-&gt;fInertia)^body2-&gt;vCollisionPoint))
          );

     body1-&gt;vVelocity += (j * vCollisionNormal) / body1-&gt;fMass;
     body1-&gt;vAngularVelocity += (body1-&gt;vCollisionPoint ^
                                 (j * vCollisionNormal)) /
                                 body1-&gt;fInertia;

     body2-&gt;vVelocity -= (j * vCollisionNormal) / body2-&gt;fMass;
     body2-&gt;vAngularVelocity -= (body2-&gt;vCollisionPoint ^
                                 (j * vCollisionNormal)) /
                                 body2-&gt;fInertia;
}</pre><p>Remember, the impulse is applied to one hovercraft while its negative is applied to the
      other.</p><p>That does it for this new version of the hovercraft simulation. If you run the program
      now, you’ll see that you can crash the hovercraft into each other and they bounce and rotate
      accordingly. This makes for a much more realistic simulation than the simple, linear collision
      response approach of the last section. Here again, you can play with the mass of each
      hovercraft and the coefficient of restitution to see how these parameters affect the collision
      response between the <a id="I_indexterm4_id328796" class="indexterm"/><a id="I_indexterm4_id328805" class="indexterm"/><a id="I_indexterm4_id328814" class="indexterm"/><a id="I_indexterm4_id328824" class="indexterm"/><a id="I_indexterm4_id328833" class="indexterm"/><a id="I_indexterm4_id328842" class="indexterm"/><a id="I_indexterm4_id328852" class="indexterm"/><a id="I_indexterm4_id328861" class="indexterm"/>hovercraft.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-10-FN-1"><p><sup>[<a href="#CHP-10-FN-1" class="para">19</a>] </sup>Note that this function does not handle multiple contact points.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 11. Rotation in 3D Rigid-Body Simulators</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch10.html" title="Chapter 10. Implementing Collision Response"/><link rel="next" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator"/></head><body><section class="chapter" title="Chapter 11. Rotation in 3D Rigid-Body Simulators" epub:type="chapter" id="rotation_in_3d_rigid-body_simulators"><div class="titlepage"><div><div><h2 class="title">Chapter 11. Rotation in 3D Rigid-Body Simulators</h2></div></div></div><p>A fundamental difference between <a id="th11.0" class="indexterm"/><a id="I_indexterm5_id328892" class="indexterm"/><a id="si11.0" class="indexterm"/><a id="ri11.0" class="indexterm"/>particles and rigid bodies is that we cannot ignore rotation of rigid bodies. This
    applies to both 2D and 3D rigid bodies. In two dimensions, it’s quite easy to express the <a id="I_indexterm5_id328936" class="indexterm"/>orientation of a rigid body; you need only a single scalar to represent the body’s
    rotation about a single axis. In three dimensions, however, there are three primary coordinate
    axes about each of which a rigid body may rotate. Moreover, a rigid body in three dimensions may
    rotate about any arbitrary axis, not necessarily one of the coordinate axes.</p><p>In two dimensions, we say that a rigid body has only one rotational degree of freedom,
    whereas in three dimensions we say that a rigid body has three rotational <a id="I_indexterm5_id328955" class="indexterm"/>degrees of freedom. This may lead you to infer that in three dimensions, you must
    have three scalar quantities to represent a body’s rotation. Indeed, this is a minimum
    requirement, and you’re probably already familiar with a set of angles that represent the
    orientation of a rigid body in 3D—namely, the three <a id="I_indexterm5_id328969" class="indexterm"/>Euler angles (roll, pitch, and yaw) that we’ll talk about in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>.</p><p>These three angles—roll, pitch, and yaw—are very intuitive and easy for us to visualize. For
    example, in an airplane the nose <a id="I_indexterm5_id328992" class="indexterm"/><a id="I_indexterm5_id328999" class="indexterm"/>pitches up or down, the plane <a id="I_indexterm5_id329010" class="indexterm"/>rolls (or banks) left or right, and the <a id="I_indexterm5_id329022" class="indexterm"/><a id="I_indexterm5_id329032" class="indexterm"/>yaw (or heading) changes to the left or right. Unfortunately, there’s a problem with
    using these three Euler angles in rigid-body simulations. The problem is a numerical one that
    occurs when the pitch angle reaches plus or minus 90 degrees (π/2). When this happens, roll and
    yaw become ambiguous. Worse yet, the angular equations of motion written in terms of Euler
    angles contain terms involving the cosine of the pitch angle in the denominator, which means
    that when the pitch angle is plus or minus 90 degrees the equations become singular (i.e.,
    there’s division by 0). If this happens in your simulation, the results would be unpredictable
    to say the least. Given this problem with Euler angles, you must use some other means of keeping
    track of orientation in your simulation. We’ll discuss two such means in this
    chapter—specifically, rotation matrices and quaternions.</p><p>Virtually every computer graphics book that we’ve read contains a chapter or section on
    using rotation matrices. Far fewer discuss quaternions, but if you’re familiar with quaternions,
    it’s probably in the same context as rotation matrices—that is, how they are used to rotate 3D
    points, objects, scenes, and points of view. In a simulation, however, you need to get a little
    more out of rotation matrices or quaternions and will use them in a different context than what
    you might be accustomed to. Specifically, you need to keep track of a body’s orientation in
    space and, moreover, the change in orientation over time. So it’s in this light that we’ll
    discuss rotation matrices and quaternions. We’ll try to be as concise as possible so as not to
    cloud the water with the proofs and derivations that you can find in the texts referred to in
    the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a>.</p><div class="sect1" title="Rotation Matrices"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="rotation_matrices">Rotation Matrices</h2></div></div></div><p>A rotation matrix is a 3×3 matrix that, <a id="ro11.1" class="indexterm"/><a id="rom11.1" class="indexterm"/>when multiplied with a point or vector, results in the rotation of that point
      about some axis, yielding a new set of coordinates. You can rotate points about axes in one
      coordinate system or you can use rotation matrices to convert points from one coordinate
      system to another, where one is rotated relative to the other.</p><p>Rotating a vector by a rotation matrix is typically written as follows: if <span class="strong"><strong>v</strong></span> is a vector, and <span class="strong"><strong>R</strong></span> is a
      rotation matrix, then <span class="strong"><strong>v</strong></span>’ is <span class="strong"><strong>v</strong></span> rotated by <span class="strong"><strong>R</strong></span> according to the
      formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span>’ = <span class="strong"><strong>R
        v</strong></span></td></tr></table><p>You can combine multiple rotation matrices reflecting multiple sequential rotations into a
      single rotation matrix using usual matrix multiplication. If the rotation matrices are
      expressed in terms of fixed, global coordinates, then they are combined as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>R</strong></span><sub>c</sub> = <span class="strong"><strong>R</strong></span><sub>1</sub>
        <span class="strong"><strong>R</strong></span><sub>2</sub></td></tr></table><p>Here <span class="strong"><strong>R</strong></span><sub>c</sub> is the combined rotation
      matrix reflecting a rotation first by <span class="strong"><strong>R</strong></span><sub>1</sub> and then by <span class="strong"><strong>R</strong></span><sub>2</sub>. If the rotation matrices are expressed in terms of
      rotating, body-fixed coordinates, then they are combined in the reverse order as
      follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>R</strong></span><sub>c</sub> = <span class="strong"><strong>R</strong></span><sub>2</sub>
        <span class="strong"><strong>R</strong></span><sub>1</sub></td></tr></table><p>We won’t go into the proof of this relation, but the reason it’s different depending on
      how you’ve defined your rotation matrices is that rotation matrices defined in fixed
      coordinates are unaffected by the rotation itself since the coordinate axes stay fixed. On the
      other hand, if the rotation matrices are defined relative to a coordinate system that is
      rotating due to sequential application of rotation matrices, then all rotation matrices after
      the first will be affected since they were first defined relative to the original state of the
      coordinate system—that is, before the first rotation matrix was applied. This means that the
      subsequent rotation matrices must be corrected to reflect the new system as affected by the
      previous rotation before they can be correctly applied. In other words, you have to rotate
        <span class="strong"><strong>R</strong></span><sub>2</sub> by <span class="strong"><strong>R</strong></span><sub>1</sub> to get a new <span class="strong"><strong>R</strong></span><sub>2</sub> before applying it. All this happens to work out in
      such a way that you reverse the order of multiplication of rotation matrices when they are
      defined in a r<a id="I_indexterm5_id329310" class="indexterm"/>otating coordinate system.</p><p><a class="xref" href="ch11.html#right-handed_coordinate_system-id1" title="Figure 11-1. Right-handed coordinate system">Figure 11-1</a> shows a right-handed coordinate
      system that illustrates the directions of positive rotation about each coordinate axis.</p><div class="figure"><a id="right-handed_coordinate_system-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id329340"/><img src="httpatomoreillycomsourceoreillyimages1598946.png" alt="Right-handed coordinate system"/></div></div><div class="figure-title">Figure 11-1. Right-handed coordinate system</div></div><p>Let’s consider rotation around the<a id="I_indexterm5_id329360" class="indexterm"/> z-axis where the point shown in <a class="xref" href="ch11.html#rotation_around_the_z-axis" title="Figure 11-2. Rotation around the z-axis">Figure 11-2</a> is
      rotated through an angle θ.</p><div class="figure"><a id="rotation_around_the_z-axis"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id329385"/><img src="httpatomoreillycomsourceoreillyimages1598947.png" alt="Rotation around the z-axis"/></div></div><div class="figure-title">Figure 11-2. Rotation around the z-axis</div></div><p>The coordinates of the point before the rotation are
        (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>,<span class="emphasis"><em>z</em></span>) and after the
      rotation the coordinates are (<span class="emphasis"><em>x</em></span><sub>r</sub>,
        <span class="emphasis"><em>y</em></span><sub>r</sub>,
        <span class="emphasis"><em>z</em></span><sub>r</sub>). The rotated coordinates are related to the
      original coordinates and the rotation angle by the following:</p><table style="border: 0; " class="simplelist"><tr><td>x<sub>r</sub> = x cos θ − y sin θ</td></tr><tr><td>y<sub>r</sub> = x sin θ + y cos θ</td></tr><tr><td>z<sub>r</sub> = z</td></tr></table><p>Notice that since the point is rotating about the z-axis, its <span class="emphasis"><em>z</em></span>
      coordinate remains unchanged. To write this in the vector-matrix notation, <span class="strong"><strong>v</strong></span>’ = <span class="strong"><strong>R v</strong></span>, let <span class="strong"><strong>v</strong></span>
      <span class="emphasis"><em>= [x y z]</em></span> and let <span class="strong"><strong>R</strong></span> be the
      matrix:</p><div class="informalfigure"><a id="chapter11matrix1"/><div class="mediaobject"><a id="I_mediaobject5_id329509"/><img src="httpatomoreillycomsourceoreillyimages1598948.png" alt="image with no caption"/></div></div><p>Here <span class="strong"><strong>v’</strong></span> will be the new, rotated vector, <span class="strong"><strong>v</strong></span><span class="emphasis"><em>’ = [x</em></span><sub>r</sub>
      <span class="emphasis"><em>y</em></span><sub>r</sub>
      <span class="emphasis"><em>z</em></span><sub>r</sub><span class="emphasis"><em>]</em></span>.</p><p>Rotation about <a id="I_indexterm5_id329565" class="indexterm"/><a id="I_indexterm5_id329572" class="indexterm"/>the x- and y-axes is similar to the z-axis; however, in those cases the
        <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates remain constant during
      rotations about each axis, respectively. Looking at rotation about each axis separately will
      yield three rotation matrices similar to the one we just showed you for rotation about the
      z-axis.</p><p>For rotation about the x-axis, the matrix is:</p><div class="informalfigure"><a id="chapter11matrix2"/><div class="mediaobject"><a id="I_mediaobject5_id329600"/><img src="httpatomoreillycomsourceoreillyimages1598949.png" alt="image with no caption"/></div></div><p>And for rotation about the y-axis, the matrix is:</p><div class="informalfigure"><a id="chapter11matrix3"/><div class="mediaobject"><a id="I_mediaobject5_id329630"/><img src="httpatomoreillycomsourceoreillyimages1598950.png" alt="image with no caption"/></div></div><p>These are the rotation matrices you typically see in computer graphics texts in the
      context of matrix transforms, such as translation, scaling, and rotation. You can combine all
      three of these matrices into a single rotation matrix to represent combinations of rotations
      about each coordinate axis, using matrix multiplication as mentioned earlier.</p><p>In rigid-body simulations, you can use a rotation matrix to represent the <a id="I_indexterm5_id329657" class="indexterm"/>orientation of a rigid body. Another way to think of it is the rotation matrix,
      when applied to the unrotated rigid body aligned with the fixed global coordinate system, will
      rotate the rigid body’s coordinates so as to resemble the body’s current orientation at any
      given time. This leads to another important consideration when using rotation matrices to keep
      track of orientation in rigid-body simulations: the fact that the rotation matrix will be a
      function of time.</p><p>Once you set up your initial rotation matrix for the rigid body, you’ll never directly
      calculate it again from orientation angles; instead, the forces and moments applied to the
      rigid body will change the body’s angular velocity, <a id="I_indexterm5_id329679" class="indexterm"/><a id="I_indexterm5_id329689" class="indexterm"/>likewise causing small changes in orientation at each time step throughout the
      simulation. Thus, you can see that you must have a means of relating the rotation matrix to
      angular velocity so that you can update the orientation accordingly. The formula you need is
      as follows:</p><table style="border: 0; " class="simplelist"><tr><td>d <span class="strong"><strong>R</strong></span> / dt = <span class="strong"><strong>Ω
        R</strong></span></td></tr></table><p>Here, <span class="strong"><strong>Ω</strong></span> is a skew symmetric matrix built from the
      angular velocity vector components as follows:</p><div class="informalfigure"><a id="chapter11matrix4"/><div class="mediaobject"><a id="I_mediaobject5_id329741"/><img src="httpatomoreillycomsourceoreillyimages1598951.png" alt="image with no caption"/></div></div><p>Notwithstanding a rigorous proof of this relation, it’s easy to see its beauty, which is
      that you can differentiate the rotation matrix by simply matrix multiplying by the angular
      velocity (in the form of <span class="strong"><strong>Ω</strong></span>). In a simulation you’ll know
      your initial rotation matrix, and you’ll calculate the angular velocity at each time step;
      thus, you can easily progress, or integrate, the rotation matrix.</p><p>You should be able to see here that since you’ll only explicitly calculate the rotation
      matrix once and will update it with a matrix multiply, you won’t have to use computationally
      expensive trigonometric functions during each time step. Further, you avoid the singularity
      problem mentioned in the introduction to this chapter.</p><p>It should also be obvious that you gain these benefits at some price. First, you have to
      deal with nine parameters in the rotation matrix (each element in the 3×3 rotation matrix) to
      represent three angular degrees of freedom. Secondly, in order to do that, you need to impose
      constraints on the rotation matrix; specifically, you need to enforce the constraint that the
      matrix be orthogonal with a determinant of 1 so that it satisfies the following (each column
      in the matrix <a id="I_indexterm5_id329786" class="indexterm"/>represents a unit vector, and they are all at right angles to each
        other):<sup>[<a id="CHP-11-FN-1" href="#ftn.CHP-11-FN-1" epub:type="noteref" class="footnote">20</a>]</sup></p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>R</strong></span><sup>T</sup>
        <span class="strong"><strong>R</strong></span> = <span class="strong"><strong>I</strong></span></td></tr></table><p>Here <span class="strong"><strong>R</strong></span><sup>T</sup>is the transpose of
        <span class="strong"><strong>R</strong></span>, and <span class="strong"><strong>I</strong></span> is the
      identity matrix. Due to numerical errors such as roundoff and truncation, you’ll have to
      enforce this constraint very often in your simulation. Otherwise, your rotation matrix will do
      more than rotate your objects, it may scale or translate them too.</p><p>Instead of dealing with nine parameters and trying to constrain six degrees of freedom so
      that only the three you want can be represented, you could take an alternative approach that
      lets you keep the advantages rotation matrices have to offer, but at a cheaper price. That
      alternative, quaternions, is the subject of the next <a id="I_indexterm5_id329866" class="indexterm"/><a id="I_indexterm5_id329876" class="indexterm"/>section.</p></div><div class="sect1" title="Quaternions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="quaternions">Quaternions</h2></div></div></div><p>Quaternions are somewhat of a <a id="ro11.2" class="indexterm"/><a id="qu11.2" class="indexterm"/>mathematical oddity. They were developed over 100 years ago by <a id="I_indexterm5_id329931" class="indexterm"/>William Hamilton through his work in complex (imaginary) math but have found very
      little practical use. A quaternion is a quantity, kind of like a vector, but made up of four
      components. It is typically written in the form:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = q<sub>0</sub> +
          q<sub>x</sub>
        <span class="strong"><strong>i</strong></span> + q<sub>y</sub>
        <span class="strong"><strong>j</strong></span> + q<sub>z</sub>
        <span class="strong"><strong>k</strong></span></td></tr></table><p>A quaternion is really a four-dimensional <a id="I_indexterm5_id329992" class="indexterm"/>quantity in complex space and, unfortunately, does not lend itself to
      visualization. Don’t worry, though: our use of quaternions to <a id="I_indexterm5_id330001" class="indexterm"/>represent orientation in three dimensions does allow us to attach a physical
      meaning to them, as you’ll see in a moment.</p><p>Of particular interest to us is what’s known as a <span class="emphasis"><em>unit quaternion</em></span>
      that satisfies the following:</p><table style="border: 0; " class="simplelist"><tr><td>q<sub>0</sub><sup>2</sup> +
          q<sub>x</sub><sup>2</sup> +
          q<sub>y</sub><sup>2</sup> +
          q<sub>z</sub><sup>2</sup> = 1</td></tr></table><p>This is analogous to a normalized, or unit, vector.</p><p>You can also write a quaternion in the form <span class="strong"><strong>q</strong></span> =
        [<span class="emphasis"><em>q</em></span><sub>0</sub>, <span class="strong"><strong>v</strong></span>],
      where <span class="strong"><strong>v</strong></span> is the vector,
        <span class="emphasis"><em>q</em></span><sub>x</sub>
      <span class="strong"><strong>i</strong></span> + <span class="emphasis"><em>q</em></span><sub>y</sub>
      <span class="strong"><strong>j</strong></span> + <span class="emphasis"><em>q</em></span><sub>z</sub>
      <span class="strong"><strong>k</strong></span>, and <span class="emphasis"><em>q</em></span><sub>0</sub> is a
      scalar. In the context of rotation, <span class="strong"><strong>v</strong></span> represents the
      direction in which the axis of rotation points. For a given rotation, θ, about an arbitrary
      axis represented by the unit vector <span class="strong"><strong>u</strong></span>, the representative
      quaternion can be written as follows:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = [cos(θ/2) , sin(θ/2) <span class="strong"><strong>u</strong></span>]</td></tr></table><p>This is illustrated in <a class="xref" href="ch11.html#quaternion_rotation" title="Figure 11-3. Quaternion rotation">Figure 11-3</a> for an arbitrary rigid body
      rotating about an axis passing through its <a id="I_indexterm5_id330172" class="indexterm"/>center of gravity. The rigid body rotates through an angle θ from the position
      shown in light gray to the position shown in dark gray. Here, the unit vector <span class="strong"><strong>u</strong></span> is the vector <span class="strong"><strong>v</strong></span> normalized to
      unit length.</p><div class="figure"><a id="quaternion_rotation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id330209"/><img src="httpatomoreillycomsourceoreillyimages1598952.png" alt="Quaternion rotation"/></div></div><div class="figure-title">Figure 11-3. Quaternion rotation</div></div><p>You can readily see that quaternions, when used to represent rotation or orientation,
      require you to deal with only four parameters instead of nine, subject to the easily satisfied
      constraint that the quaternion be a unit quaternion.</p><p>The use of quaternions to represent orientation is similar to how you would use rotation
      matrices. First, you set up a quaternion that represents the initial orientation of the rigid
      body at time 0 (this is the only time you’ll calculate the quaternion explicitly). Then you
      update the orientation to reflect the new orientation at a given instant in time using the
      angular velocities that are calculated for that instant. As you can see here, the differential
      equation relating an orientation quaternion to <a id="I_indexterm5_id330240" class="indexterm"/><a id="I_indexterm5_id330250" class="indexterm"/>angular velocity is very similar to that for rotation matrices:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>q</strong></span>/dt = (1/2) <span class="strong"><strong>ω
          q</strong></span></td></tr></table><p>Here, the angular velocity is written in quaternion form as [0, <span class="strong"><strong>ω</strong></span>] and is expressed in fixed, global coordinates. (<span class="strong"><strong>ω</strong></span> is still angular velocity, but you have to put it in quaternion form instead
      of vector form when multiplying it by a quaternion <span class="emphasis"><em>q</em></span>.) If <span class="strong"><strong>ω</strong></span> is expressed in rotating, body-fixed coordinates, then you need
      to use this equation:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>q</strong></span>/dt = (1/2) <span class="strong"><strong>q
          ω</strong></span></td></tr></table><p>As with rotation matrices, you can use quaternions to rotate points or vectors. If
        <span class="strong"><strong>v</strong></span> is a vector, then <span class="strong"><strong>v</strong></span>’
      is the rotated vector subject to the quaternion <span class="strong"><strong>q</strong></span>:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>v</strong></span>’ = <span class="strong"><strong>qvq</strong></span><sup>*</sup></td></tr></table><p>Here <span class="strong"><strong>q</strong></span><span class="emphasis"><em>*</em></span> is the conjugate of the
      quaternion <span class="strong"><strong>q</strong></span> defined as:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span>* = q<sub>0</sub> –
          q<sub>x</sub>
        <span class="strong"><strong>i</strong></span> – q<sub>y</sub>
        <span class="strong"><strong>j</strong></span> – q<sub>z</sub>
        <span class="strong"><strong>k</strong></span></td></tr></table><p>You can also use the preceding formula to convert vectors from one coordinate system to
      another, where one is rotated relative to the other. You have to do this, for example, in your
      simulations where you are converting forces defined in fixed, global coordinates to rotating,
      body-fixed coordinates so that you can apply the forces to the body; or you might have to
      convert a body’s velocity defined in global coordinates to body coordinates so that you can
      use the velocity in force calculations.</p><div class="sect2" title="Quaternion Operations"><div class="titlepage"><div><div><h3 class="title" id="quaternion_operations">Quaternion Operations</h3></div></div></div><p>As with vectors and matrices, quaternions have their own rules for the various
        operations that you’ll need, such as multiplication, addition, subtraction, and so on. To
        make it easy on you, we’ve included sample code in <a class="xref" href="apc.html" title="Appendix C. Quaternion Operations">Appendix C</a> that implements all of the quaternion operations you’ll need; however, we want to
        highlight a few of the more important ones here.</p><p>The <code class="literal">Quaternion</code> class is <a id="I_indexterm5_id330482" class="indexterm"/><a id="I_indexterm5_id330493" class="indexterm"/>defined with a scalar component, <span class="emphasis"><em>n</em></span>, and vector component,
          <span class="strong"><strong>v</strong></span>, where <span class="strong"><strong>v</strong></span> is the
        vector, <span class="emphasis"><em>x</em></span>
        <span class="strong"><strong>i</strong></span> + <span class="emphasis"><em>y</em></span>
        <span class="strong"><strong>j</strong></span> + <span class="emphasis"><em>z</em></span>
        <span class="strong"><strong>k</strong></span>. The class has two constructors, one of which
        initializes the quaternion to 0, and the other of which initializes the elements to those
        passed to the constructor:</p><a id="I_programlisting5_id330476"/><pre class="programlisting">class Quaternion {
public:
     float      n;     // number (scalar) part
     Vector     v;     // vector part: v.x, v.y, v.z

     Quaternion(void);
     Quaternion(float e0, float e1, float e2, float e3);

.
.
.

};</pre><div class="sect3" title="Magnitude"><div class="titlepage"><div><div><h4 class="title" id="magnitude">Magnitude</h4></div></div></div><p>The <code class="literal">Magnitude</code> method <a id="I_indexterm5_id330574" class="indexterm"/><a id="I_indexterm5_id330587" class="indexterm"/>returns the magnitude of the quaternion according to the following
          formula:</p><table style="border: 0; " class="simplelist"><tr><td>|<span class="strong"><strong>q</strong></span>| = 
          
            <span class="inlinemediaobject"><img src="inleq_1101.png" alt=""/></span>   
          
          </td></tr></table><p>This is similar to calculating the magnitude of a vector, except that for quaternions
          you have to take the fourth term, the scalar <span class="emphasis"><em>n</em></span>, into account.</p><p>Here’s the code that calculates the magnitude for our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting5_id330645"/><pre class="programlisting">inline     float     Quaternion::Magnitude(void)
{
     return (float) sqrt(n*n + v.x*v.x + v.y*v.y + v.z*v.z);
}</pre></div><div class="sect3" title="Conjugate: The ~ operator"><div class="titlepage"><div><div><h4 class="title" id="conjugate_colon_the_tilde_operator">Conjugate: The ~ operator</h4></div></div></div><p>The conjugate of the product of <a id="I_indexterm5_id330665" class="indexterm"/><a id="I_indexterm5_id330672" class="indexterm"/><a id="I_indexterm5_id330682" class="indexterm"/><a id="I_indexterm5_id330691" class="indexterm"/>quaternions is equal to the product of the quaternion conjugates, but in
          reverse order:</p><table style="border: 0; " class="simplelist"><tr><td>~(<span class="strong"><strong>qp</strong></span>) = (~<span class="strong"><strong>p</strong></span>)(~<span class="strong"><strong>q</strong></span>)</td></tr></table><p>Here’s the code that computes the conjugate for our <code class="literal">Quaternion</code> class:</p><a id="I_programlisting5_id330742"/><pre class="programlisting">     Quaternion operator~(void) const { return Quaternion( n,
                                                           -v.x,
                                                           -v.y,
                                                           -v.z);}</pre></div><div class="sect3" title="QVRotate"><div class="titlepage"><div><div><h4 class="title" id="qvrotate">QVRotate</h4></div></div></div><p>This function rotates <a id="I_indexterm5_id330762" class="indexterm"/><a id="I_indexterm5_id330772" class="indexterm"/>the vector <span class="strong"><strong>v</strong></span> by the unit quaternion
            <span class="strong"><strong>q</strong></span> according to this formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>p</strong></span>’ = (<span class="strong"><strong>q</strong></span>)(<span class="strong"><strong>v</strong></span>)(~<span class="strong"><strong>q</strong></span>)</td></tr></table><p>Here, ~<span class="strong"><strong>q</strong></span> is the conjugate of the unit quaternion,
            <span class="strong"><strong>q</strong></span>:</p><a id="I_programlisting5_id330841"/><pre class="programlisting">inline     Vector     QVRotate(Quaternion q, Vector v)
{
     Quaternion t;

     t = q*v*(~q);

     return     t.GetVector();
}</pre><p>This operator takes the conjugate of the quaternion, ~<span class="strong"><strong>q</strong></span>, which is simply the negative of the vector part. If <span class="strong"><strong>q</strong></span> = [<span class="emphasis"><em>n</em></span>, <span class="emphasis"><em>x</em></span>
          <span class="strong"><strong>i</strong></span> + <span class="emphasis"><em>y</em></span>
          <span class="strong"><strong>j</strong></span> + <span class="emphasis"><em>z</em></span>
          <span class="strong"><strong>k</strong></span>], then ~<span class="strong"><strong>q</strong></span> =
            [<span class="emphasis"><em>n</em></span>, (−<span class="emphasis"><em>x</em></span>) <span class="strong"><strong>i</strong></span>
          + (−<span class="emphasis"><em>y</em></span>) <span class="strong"><strong>j</strong></span> +
            (−<span class="emphasis"><em>z</em></span>) <span class="strong"><strong>k</strong></span>].</p></div><div class="sect3" title="Quaternion multiplication: The * operator"><div class="titlepage"><div><div><h4 class="title" id="quaternion_multiplication_colon_the_aste">Quaternion multiplication: The * operator</h4></div></div></div><p>This operator performs <a id="I_indexterm5_id330950" class="indexterm"/><a id="I_indexterm5_id330960" class="indexterm"/><a id="I_indexterm5_id330970" class="indexterm"/><a id="I_indexterm5_id330977" class="indexterm"/>quaternion multiplication according to the following formula:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q p</strong></span> = n<sub>q</sub>
              n<sub>p</sub> − <span class="strong"><strong>v</strong></span><sub>q</sub> • <span class="strong"><strong>v</strong></span><sub>p</sub> + n<sub>q</sub>
            <span class="strong"><strong>v</strong></span><sub>p</sub> + n<sub>p</sub>
            <span class="strong"><strong>v</strong></span><sub>q</sub> + (<span class="strong"><strong>v</strong></span><sub>q</sub> × <span class="strong"><strong>v</strong></span><sub>p</sub>)</td></tr></table><p>Here,
            <span class="emphasis"><em>n</em></span><sub>q</sub><span class="emphasis"><em>n</em></span><sub>p</sub>
          − <span class="strong"><strong>v</strong></span><sub>q</sub> • <span class="strong"><strong>v</strong></span><sub>p</sub> is the scalar part of the result while
            <span class="emphasis"><em>n</em></span><sub>q</sub>
          <span class="strong"><strong>v</strong></span><sub>p</sub> +
            <span class="emphasis"><em>n</em></span><sub>p</sub>
          <span class="strong"><strong>v</strong></span><sub>q</sub> + (<span class="strong"><strong>v</strong></span><sub>q</sub> × <span class="strong"><strong>v</strong></span><sub>p</sub>) is the vector part. Also note that <span class="strong"><strong>v</strong></span><sub>q</sub> and <span class="strong"><strong>v</strong></span><sub>p</sub> are the vector parts of <span class="strong"><strong>q</strong></span> and <span class="strong"><strong>p</strong></span>, respectively, • is the vector
          dot product operator, and × is the vector cross product operator.</p><p>Quaternion multiplication is associative but not commutative, thus:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span>(<span class="strong"><strong>ph</strong></span>) =
              (<span class="strong"><strong>qp</strong></span>)<span class="strong"><strong>h</strong></span></td></tr><tr><td><span class="strong"><strong>qp</strong></span> ≠ <span class="strong"><strong>pq</strong></span></td></tr></table><p>Here’s the code that multiplies two <code class="literal">Quaternion</code>s,
            <code class="literal">q1</code> and <code class="literal">q2</code>:</p><a id="I_programlisting5_id331246"/><pre class="programlisting">inline     Quaternion operator*(Quaternion q1, Quaternion q2)
{
     return     Quaternion(q1.n*q2.n - q1.v.x*q2.v.x
                               - q1.v.y*q2.v.y - q1.v.z*q2.v.z,
                           q1.n*q2.v.x + q1.v.x*q2.n
                               + q1.v.y*q2.v.z - q1.v.z*q2.v.y,
                           q1.n*q2.v.y + q1.v.y*q2.n
                               + q1.v.z*q2.v.x - q1.v.x*q2.v.z,
                           q1.n*q2.v.z + q1.v.z*q2.n
                               + q1.v.x*q2.v.y - q1.v.y*q2.v.x);
}</pre></div><div class="sect3" title="Vector multiplication: The * operator"><div class="titlepage"><div><div><h4 class="title" id="vector_multiplication_colon_the_aste">Vector multiplication: The * operator</h4></div></div></div><p>This operator <a id="I_indexterm5_id331270" class="indexterm"/><a id="I_indexterm5_id331280" class="indexterm"/><a id="I_indexterm5_id331290" class="indexterm"/><a id="I_indexterm5_id331300" class="indexterm"/>multiplies the quaternion, <code class="literal">q</code>, by the vector
            <code class="literal">v</code> as though the vector <code class="literal">v</code> were a quaternion with its scalar component equal to 0. There are two forms
          of this operator depending on the order in which the quaternion and vector are
          encountered. Since <code class="literal">v</code> is assumed to be a quaternion with
          its scalar part equal to 0, the rules of multiplication follow those outlined earlier for
          quaternion multiplication:</p><a id="I_programlisting5_id331338"/><pre class="programlisting">inline     Quaternion operator*(Quaternion q, Vector v)
{
     return     Quaternion(     -(q.v.x*v.x + q.v.y*v.y + q.v.z*v.z),
                                   q.n*v.x + q.v.y*v.z - q.v.z*v.y,
                                   q.n*v.y + q.v.z*v.x - q.v.x*v.z,
                                   q.n*v.z + q.v.x*v.y - q.v.y*v.x);
}
inline     Quaternion operator*(Vector v, Quaternion q)
{
     return     Quaternion(     -(q.v.x*v.x + q.v.y*v.y + q.v.z*v.z),
                                   q.n*v.x + q.v.z*v.y - q.v.y*v.z,
                                   q.n*v.y + q.v.x*v.z - q.v.z*v.x,
                                   q.n*v.z + q.v.y*v.x - q.v.x*v.y);
}</pre></div><div class="sect3" title="MakeQFromEulerAngles"><div class="titlepage"><div><div><h4 class="title" id="makeqfromeulerangles">MakeQFromEulerAngles</h4></div></div></div><p>This function <a id="I_indexterm5_id331365" class="indexterm"/><a id="I_indexterm5_id331375" class="indexterm"/><a id="I_indexterm5_id331381" class="indexterm"/>constructs a quaternion from a set of Euler angles.</p><p>For a given set of Euler angles, yaw (ψ), pitch (τ), and roll (φ), defining rotation
          about the z-axis, then the y-axis, and then the x-axis, you can construct the
          representative rotation quaternion. You do this by first constructing a quaternion for
          each Euler angle and then multiplying the three quaternions following the rules of
          quaternion multiplication. Here are the three quaternions representing each Euler rotation
          angle:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span><sub>roll</sub> = [cos(φ/2),
            (sin(φ/2)) <span class="strong"><strong>i</strong></span> + 0 <span class="strong"><strong>j</strong></span>
            + 0 <span class="strong"><strong>k</strong></span>]</td></tr><tr><td><span class="strong"><strong>q</strong></span><sub>pitch</sub> = [cos(τ /2), 0
              <span class="strong"><strong>i</strong></span> + (sin(τ /2)) <span class="strong"><strong>j</strong></span> + 0 <span class="strong"><strong>k</strong></span>]</td></tr><tr><td><span class="strong"><strong>q</strong></span><sub>yaw</sub> = [cos(ψ /2), 0
              <span class="strong"><strong>i</strong></span> + 0 <span class="strong"><strong>j</strong></span> + (sin(ψ
            /2)) <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Each one of these quaternions is of unit length.<sup>[<a id="CHP-11-FN-2" href="#ftn.CHP-11-FN-2" epub:type="noteref" class="footnote">21</a>]</sup></p><p>Now you can multiply these quaternions to obtain a single one that represents the
          rotation, or orientation, defined by the three Euler angles:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = <span class="strong"><strong>q</strong></span><sub>yaw</sub>
            <span class="strong"><strong>q</strong></span><sub>pitch</sub>
            <span class="strong"><strong>q</strong></span><sub>roll</sub></td></tr></table><p>Performing this multiplication yields:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = [{cos(φ/2) cos(τ /2) cos(ψ /2) + sin(φ/2)
            sin(τ /2) sin(ψ /2)},</td></tr><tr><td>{sin(φ/2) cos(τ /2) cos(ψ /2) − cos(φ/2) sin(τ /2) sin(ψ /2)} <span class="strong"><strong>i</strong></span> +</td></tr><tr><td>{cos(φ/2) sin(τ /2) cos(ψ /2) + sin(φ/2) cos(τ /2) sin(ψ /2)} <span class="strong"><strong>j</strong></span> +</td></tr><tr><td>{cos(φ/2) cos(τ /2) sin(ψ /2) − sin(φ/2) sin(τ /2) cos(ψ /2)} <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Here’s the code that takes three Euler angles and returns a quaternion:</p><a id="I_programlisting5_id331610"/><pre class="programlisting">inline     Quaternion     MakeQFromEulerAngles(float x, float y, float z)
{
     Quaternion     q;
     double     roll = DegreesToRadians(x);
     double     pitch = DegreesToRadians(y);
     double     yaw = DegreesToRadians(z);

     double     cyaw, cpitch, croll, syaw, spitch, sroll;
     double     cyawcpitch, syawspitch, cyawspitch, syawcpitch;

     cyaw = cos(0.5f * yaw);
     cpitch = cos(0.5f * pitch);
     croll = cos(0.5f * roll);
     syaw = sin(0.5f * yaw);
     spitch = sin(0.5f * pitch);
     sroll = sin(0.5f * roll);

     cyawcpitch = cyaw*cpitch;
     syawspitch = syaw*spitch;
     cyawspitch = cyaw*spitch;
     syawcpitch = syaw*cpitch;

     q.n = (float) (cyawcpitch * croll + syawspitch * sroll);
     q.v.x = (float) (cyawcpitch * sroll - syawspitch * croll);
     q.v.y = (float) (cyawspitch * croll + syawcpitch * sroll);
     q.v.z = (float) (syawcpitch * croll - cyawspitch * sroll);

     return q;
}</pre></div><div class="sect3" title="MakeEulerAnglesFromQ"><div class="titlepage"><div><div><h4 class="title" id="makeeuleranglesfromq">MakeEulerAnglesFromQ</h4></div></div></div><p>This function <a id="I_indexterm5_id331636" class="indexterm"/><a id="I_indexterm5_id331647" class="indexterm"/><a id="I_indexterm5_id331653" class="indexterm"/>extracts the three Euler angles from a given quaternion.</p><p>You can extract the three Euler angles from a quaternion by first converting the
          quaternion to a rotation matrix and then extracting the Euler angles from the rotation
          matrix. Let <span class="strong"><strong>R</strong></span> be a nine-element rotation matrix:</p><div class="informalfigure"><a id="chapter11matrix5"/><div class="mediaobject"><a id="I_mediaobject5_id331684"/><img src="httpatomoreillycomsourceoreillyimages1598953.png" alt="image with no caption"/></div></div><p>and let <span class="strong"><strong>q</strong></span> be a quaternion:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>q</strong></span> = [n, x <span class="strong"><strong>i</strong></span>
            + y <span class="strong"><strong>j</strong></span> + z <span class="strong"><strong>k</strong></span>]</td></tr></table><p>Then each element in <span class="strong"><strong>R</strong></span> is calculated from <span class="strong"><strong>q</strong></span> as follows:</p><table style="border: 0; " class="simplelist"><tr><td>r<sub>11</sub> = n<sup>2</sup> +
              x<sup>2</sup> − y<sup>2</sup> −
              z<sup>2</sup></td></tr><tr><td>r<sub>21</sub> = 2xy+2zn</td></tr><tr><td>r<sub>31</sub> = 2zx − 2yn</td></tr><tr><td>r<sub>12</sub> = 2xy − 2zn</td></tr><tr><td>r<sub>22</sub> = n<sup>2</sup> −
              x<sup>2</sup> + y<sup>2</sup> −
              z<sup>2</sup></td></tr><tr><td>r<sub>32</sub> = 2zy + 2xn</td></tr><tr><td>r<sub>13</sub> = 2xz + 2yn</td></tr><tr><td>r<sub>23</sub> = 2yz − 2xn</td></tr><tr><td>r<sub>33</sub> = n<sup>2</sup> −
              x<sup>2</sup> − y<sup>2</sup> +
              z<sup>2</sup></td></tr></table><p>To extract the Euler angles, yaw (ψ), pitch (τ), and roll (φ), from <span class="strong"><strong>R</strong></span>, you can use these relations:</p><table style="border: 0; " class="simplelist"><tr><td>tan ψ = r<sub>21</sub> / r<sub>11</sub></td></tr><tr><td>sin τ = –r<sub>31</sub></td></tr><tr><td>tan φ = r<sub>32</sub> / r<sub>33</sub></td></tr></table><p>Here’s the code that extracts the three Euler angles, returned in the form of a
            <code class="literal">Vector</code>, from a given <a id="I_indexterm5_id331925" class="indexterm"/>quaternion:</p><a id="I_programlisting5_id331937"/><pre class="programlisting">inline     Vector     MakeEulerAnglesFromQ(Quaternion q)
{
     double     r11, r21, r31, r32, r33, r12, r13;
     double     q00, q11, q22, q33;
     double     tmp;
     Vector     u;

     q00 = q.n * q.n;
     q11 = q.v.x * q.v.x;
     q22 = q.v.y * q.v.y;
     q33 = q.v.z * q.v.z;

     r11 = q00 + q11 - q22 - q33;
     r21 = 2 * (q.v.x*q.v.y + q.n*q.v.z);
     r31 = 2 * (q.v.x*q.v.z - q.n*q.v.y);
     r32 = 2 * (q.v.y*q.v.z + q.n*q.v.x);
     r33 = q00 - q11 - q22 + q33;

     tmp = fabs(r31);
     if(tmp &gt; 0.999999)
     {
          r12 = 2 * (q.v.x*q.v.y - q.n*q.v.z);
          r13 = 2 * (q.v.x*q.v.z + q.n*q.v.y);

          u.x = RadiansToDegrees(0.0f); //roll
          u.y = RadiansToDegrees((float) (-(pi/2) * r31/tmp));   // pitch
          u.z = RadiansToDegrees((float) atan2(-r12, -r31*r13)); // yaw
          return u;
     }

     u.x = RadiansToDegrees((float) atan2(r32, r33)); // roll
     u.y = RadiansToDegrees((float) asin(-r31));      // pitch
     u.z = RadiansToDegrees((float) atan2(r21, r11)); // yaw
     return u;


}</pre></div></div></div><div class="sect1" title="Quaternions in 3D Simulators"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="quaternions_in_3d_simulators">Quaternions in 3D Simulators</h2></div></div></div><p>The quaternion operations just <a id="th11.3" class="indexterm"/><a id="qu11.3" class="indexterm"/>presented are required when you are using <a id="or11.3" class="indexterm"/>quaternions to represent orientation in 3D simulations. All the 3D simulations
      discussed in this book use these quaternion operations, and in this section we’ll highlight
      where they are used in the context of the airplane example presented in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>.</p><p>When initializing the <a id="ai11.3" class="indexterm"/>orientation of the airplane, you have to set its orientation quaternion to
      something corresponding to the Euler angles you desire. You do so as follows:</p><a id="I_programlisting5_id332038"/><pre class="programlisting">Airplane.qOrientation = MakeQFromEulerAngles(iRoll, iPitch, iYaw);</pre><p>In this code sample, <code class="literal">Airplane</code> is a rigid-body class
      with the property <code class="literal">qOrientation</code>, which represents the
      orientation quaternion, which is a <code class="literal">Quaternion</code> class.
        <code class="literal">iRoll</code>, <code class="literal">iPitch</code>, and
        <code class="literal">iYaw</code> are the three Euler angles describing the
      orientation of the airplane.</p><p>If at any time you want to report the Euler angles—for example, in a heads-up display-like
      interface for the game player—you can use <code class="literal">MakeEulerAnglesFromQ</code>, as follows:</p><a id="I_programlisting5_id332096"/><pre class="programlisting">// get the Euler angles for our information
          Vector u;

          u = MakeEulerAnglesFromQ(Airplane.qOrientation);
          Airplane.vEulerAngles.x = u.x;     // roll
          Airplane.vEulerAngles.y = u.y;     // pitch
          Airplane.vEulerAngles.z = u.z;     // yaw</pre><p>Very often, it’s more convenient to calculate loads on an object like the airplane using
      body-fixed coordinates. For example, when computing aerodynamic drag on the airplane, you’ll
      want to know the relative air velocity over the aircraft in body-fixed coordinates. The
      resulting drag force will also be in body-fixed coordinates. However, when resolving all the
      loads on the aircraft to determine its motion in earth-fixed coordinates, you’ll want to
      convert those forces from body-fixed coordinates to earth-fixed coordinates. You can use
        <code class="literal">QVRotate</code> to rotate any vector, such as a force vector,
      from one coordinate system to another. The following code sample <a id="I_indexterm5_id332119" class="indexterm"/><a id="I_indexterm5_id332129" class="indexterm"/>shows how <code class="literal">QVRotate</code> is used to convert a force
      vector in body-fixed coordinates to the equivalent force in earth-fixed coordinates.</p><a id="I_programlisting5_id332144"/><pre class="programlisting">void     CalcAirplaneLoads(void)
{
     .
     .
     .

     // Convert forces from model space to earth space
     Airplane.vForces = QVRotate(Airplane.qOrientation, Fb);
     .
     .
     .
}</pre><p>Throughout the simulation, you’ll have to update the airplane’s orientation by integrating
      the angular equations of motion. The first step in handling angular motion is to calculate the
      new angular velocity at a given time step based on the previously calculated moments acting on
      the airplane and its mass properties. We do this in body coordinates using the angular
      equation of motion:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>M</strong></span><sub>cg</sub> = d<span class="strong"><strong>H</strong></span><sub>cg</sub>/dt <span class="strong"><strong>=
          I</strong></span> (d<span class="strong"><strong>ω</strong></span>/dt) + (<span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>I ω</strong></span>))</td></tr></table><p>The next step is to integrate again to update the airplane’s orientation, which is
      expressed as a quaternion. Here, you need to use the differential equation relating an
      orientation quaternion to angular velocity that we discussed earlier:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>q</strong></span>/dt = (1/2) <span class="strong"><strong>ω
          q</strong></span></td></tr></table><p>Next, to enforce the constraint that this orientation quaternion <a id="I_indexterm5_id332239" class="indexterm"/>be a <span class="emphasis"><em>unit</em></span> quaternion, you must normalize the orientation
      quaternion. The following code sample illustrates these steps:</p><a id="I_programlisting5_id332252"/><pre class="programlisting">.
.
.
          // calculate the angular velocity of the airplane in body space:
          Airplane.vAngularVelocity += Airplane.mInertiaInverse *
                                       (Airplane.vMoments -
                                       (Airplane.vAngularVelocity^
                                       (Airplane.mInertia *
                                         Airplane.vAngularVelocity)))
                                        * dt;

          // calculate the new rotation quaternion:
          Airplane.qOrientation += (Airplane.qOrientation *
                                    Airplane.vAngularVelocity) *
                                   (0.5f * dt);

          // now normalize the orientation quaternion:
          mag = Airplane.qOrientation.Magnitude();
          if (mag != 0)
               Airplane.qOrientation /= mag;

          // calculate the velocity in body space:
          // (we'll need this to calculate lift and drag forces)
          Airplane.vVelocityBody = QVRotate(~Airplane.qOrientation,
                                            Airplane.vVelocity);
.
.
.</pre><p>Notice the last line of code in the preceding sample. That line converts the airplane’s
      velocity vector from earth-fixed coordinates to body-fixed coordinates using <code class="literal">QVRotate</code>. Recall that it’s more convenient to compute body forces
      in body-fixed coordinates. <code class="literal">QVRotate</code> allows you to work with
      vectors back and forth from body-fixed to earth-fixed <a id="I_indexterm5_id332284" class="indexterm"/><a id="I_indexterm5_id332295" class="indexterm"/><a id="I_indexterm5_id332304" class="indexterm"/><a id="I_indexterm5_id332313" class="indexterm"/><a id="I_indexterm5_id332323" class="indexterm"/><a id="I_indexterm5_id332332" class="indexterm"/><a id="I_indexterm5_id332341" class="indexterm"/><a id="I_indexterm5_id332351" class="indexterm"/>coordinates.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-11-FN-1"><p><sup>[<a href="#CHP-11-FN-1" class="para">20</a>] </sup>Two vectors are orthogonal if their dot product is 0.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-11-FN-2"><p><sup>[<a href="#CHP-11-FN-2" class="para">21</a>] </sup>You can verify this by recalling the trigonometric relation
                cos<sup>2</sup>θ + sin<sup>2</sup> θ = 1.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 12. 3D Rigid-Body Simulator</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators"/><link rel="next" href="ch13.html" title="Chapter 13. Connecting Objects"/></head><body><section class="chapter" title="Chapter 12. 3D Rigid-Body Simulator" epub:type="chapter" id="d_rigid-body_simulator-id1"><div class="titlepage"><div><div><h2 class="title">Chapter 12. 3D Rigid-Body Simulator</h2></div></div></div><p>In this chapter <a id="I_indexterm6_id332372" class="indexterm"/><a id="si12.0" class="indexterm"/><a id="ri12.0" class="indexterm"/>we’ll show you how to make the leap from 2D to 3D by implementing a rigid-body
    simulation of an airplane. Specifically, this is a simulation of the hypothetical airplane model
    that we’ll discuss extensively in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>. This airplane is of typical
    configuration with its large wings forward, its elevators aft, a single vertical tail, and plain
    flaps fitted on the wings.</p><p>As with the 2D simulator in previous chapters, we’ll concentrate on the code that implements
    the physics part of the simulator and not the platform-specific GUI aspects of the
    simulations.</p><p>As in 2D, there are four main elements to this 3D simulation—the model, integrator, user
    input, and rendering. Remember, the model refers to your idealization of the thing—an airplane,
    in this case—that you are trying to simulate, while the integrator refers to the method by which
    you integrate the differential equations of motion. These two elements take care of most of the
    physics of the simulation. The user input and rendering elements refer to how you’ll allow the
    user to interact with and view your simulation.</p><p>In this simulation, the world <a id="I_indexterm6_id332446" class="indexterm"/>coordinate system has its positive x-axis pointing into the screen, its positive
    y-axis pointing to the left of your screen, and the positive z-axis pointing up. Also, the
    local, or body-fixed, coordinate system has its positive x-axis pointing toward the front of the
    airplane, its positive y-axis pointing to the port side (left side), and its positive z-axis
    pointing up. Since this is a 3D simulation of an airplane, once you get it running, you’ll be
    able to fly in any direction, looping, banking, diving, and climbing, or performing any other
    aerobatic maneuver you desire.</p><div class="sect1" title="Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="model-id1">Model</h2></div></div></div><p>One of the most <a id="th12.1" class="indexterm"/><a id="mo12.1" class="indexterm"/>important aspects of this simulation is the flight model. We’ll spend all of <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a> discussing the physics behind this flight model, so we won’t include
      that discussion here except to introduce a few key bits of code.</p><p>To implement the flight model, you first need to prepare a rigid-body structure to
      encapsulate all of the data required to completely define the state of the rigid body at any
      instant during the simulation. We’ve defined a structure called <code class="literal">RigidBody</code> for this purpose:</p><a id="I_programlisting6_id332530"/><pre class="programlisting">typedef struct _RigidBody {

     float         fMass;           // total mass
     Matrix3x3     mInertia;        // mass moment of inertia
                                    // in body coordinates

     Matrix3x3     mInertiaInverse; // inverse of mass moment of inertia
     Vector        vPosition;       // position in earth coordinates
     Vector        vVelocity;       // velocity in earth coordinates
     Vector        vVelocityBody;   // velocity in body coordinates
     Vector        vAngularVelocity;// angular velocity in body coordinates
     Vector        vEulerAngles;    // Euler angles in body coordinates
     float         fSpeed;          // speed (magnitude of the velocity)
     Quaternion    qOrientation;    // orientation in earth coordinates
     Vector        vForces;         // total force on body
     Vector        vMoments;        // total moment (torque) on body
} RigidBody, *pRigidBody;</pre><p>You’ll notice that it is very similar to the <code class="literal">RigidBody2D</code> structure that we used in the 2D hovercraft simulation. One
      significant difference, however, is that in the 2D case, <a id="I_indexterm6_id332556" class="indexterm"/>orientation was a single <code class="literal">float</code> value, and now
      in 3D it’s a quaternion of type <code class="literal">Quaternion</code>. We discussed
      the use of quaternions for tracking rigid-body orientation in the previous chapter, and <a class="xref" href="apc.html" title="Appendix C. Quaternion Operations">Appendix C</a> contains a complete definition of the <code class="literal">Quaternion</code> class.</p><p>The next step in defining the flight model is to prepare an initialization function to
      initialize the airplane at the start of the simulation. For this purpose, we’ve prepared a
      function called <code class="literal">InitializeAirplane</code>:</p><a id="I_programlisting6_id332603"/><pre class="programlisting">RigidBody    Airplane;    // global variable representing the airplane
.
.
.

void     InitializeAirplane(void)
{
     float iRoll, iPitch, iYaw;

     // Set initial position
     Airplane.vPosition.x = −5000.0f;
     Airplane.vPosition.y = 0.0f;
     Airplane.vPosition.z = 2000.0f;

     // Set initial velocity
     Airplane.vVelocity.x = 60.0f;
     Airplane.vVelocity.y = 0.0f;
     Airplane.vVelocity.z = 0.0f;
     Airplane.fSpeed = 60.0f;

     // Set initial angular velocity
     Airplane.vAngularVelocity.x = 0.0f;
     Airplane.vAngularVelocity.y = 0.0f;
     Airplane.vAngularVelocity.z = 0.0f;

     // Set the initial thrust, forces, and moments
     Airplane.vForces.x = 500.0f;
     Airplane.vForces.y = 0.0f;
     Airplane.vForces.z = 0.0f;
     ThrustForce = 500.0;

     Airplane.vMoments.x = 0.0f;
     Airplane.vMoments.y = 0.0f;
     Airplane.vMoments.z = 0.0f;

     // Zero the velocity in body space coordinates
     Airplane.vVelocityBody.x = 0.0f;
     Airplane.vVelocityBody.y = 0.0f;
     Airplane.vVelocityBody.z = 0.0f;

     // Set these to false at first,
     // you can control later using the keyboard
     Stalling = false;
     Flaps = false;

     // Set the initial orientation
     iRoll = 0.0f;
     iPitch = 0.0f;
     iYaw = 0.0f;
     Airplane.qOrientation = MakeQFromEulerAngles(iRoll, iPitch, iYaw);

     // Now go ahead and calculate the plane's mass properties
     CalcAirplaneMassProperties();
}</pre><p>This function sets the initial location, speed, attitude, and thrust for the airplane and
      goes on to calculate its mass properties by making a call to <code class="literal">CalcAirplaneMassProperties</code>. You’ll see much more of this function in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>, so we won’t show the whole thing here. We do want to point out a
      portion of the code that is distinctly different from what you do in a 2D simulation, and
      that’s the calculation of the moment of <a id="I_indexterm6_id332637" class="indexterm"/><a id="I_indexterm6_id332647" class="indexterm"/><a id="I_indexterm6_id332657" class="indexterm"/>inertia tensor:</p><a id="I_programlisting6_id332669"/><pre class="programlisting">void     CalcAirplaneMassProperties(void)
{
     .
     .
     .

     // Now calculate the moments and products of inertia for the
     // combined elements.
     // (This inertia matrix (tensor) is in body coordinates)
     Ixx = 0;     Iyy = 0;     Izz = 0;
     Ixy = 0;     Ixz = 0;     Iyz = 0;
     for (i = 0; i&lt; 8; i++)
     {
          Ixx += Element[i].vLocalInertia.x + Element[i].fMass *
                 (Element[i].vCGCoords.y*Element[i].vCGCoords.y +
                  Element[i].vCGCoords.z*Element[i].vCGCoords.z);
          Iyy += Element[i].vLocalInertia.y + Element[i].fMass *
                 (Element[i].vCGCoords.z*Element[i].vCGCoords.z +
                  Element[i].vCGCoords.x*Element[i].vCGCoords.x);
          Izz += Element[i].vLocalInertia.z + Element[i].fMass *
                 (Element[i].vCGCoords.x*Element[i].vCGCoords.x +
                  Element[i].vCGCoords.y*Element[i].vCGCoords.y);
          Ixy += Element[i].fMass * (Element[i].vCGCoords.x *
                 Element[i].vCGCoords.y);
          Ixz += Element[i].fMass * (Element[i].vCGCoords.x *
                 Element[i].vCGCoords.z);
          Iyz += Element[i].fMass * (Element[i].vCGCoords.y *
                 Element[i].vCGCoords.z);
     }

     // Finally set up the airplane's mass and its inertia matrix and take the
     // inverse of the inertia matrix
     Airplane.fMass = mass;
     Airplane.mInertia.e11 = Ixx;
     Airplane.mInertia.e12 = -Ixy;
     Airplane.mInertia.e13 = -Ixz;
     Airplane.mInertia.e21 = -Ixy;
     Airplane.mInertia.e22 = Iyy;
     Airplane.mInertia.e23 = -Iyz;
     Airplane.mInertia.e31 = -Ixz;
     Airplane.mInertia.e32 = -Iyz;
     Airplane.mInertia.e33 = Izz;

     Airplane.mInertiaInverse = Airplane.mInertia.Inverse();
}</pre><p>The airplane is modeled by a number of elements, each representing a different part of the
      airplane’s structure—for example, the tail rudder, elevators, wings, and fuselage (see <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a> for more details). The code specified here takes the mass properties of
      each element and combines them, using the techniques discussed in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> to come up with the combined inertia tensor for the entire
      aircraft. The important distinction between these calculations in a 3D simulation and the 2D
      simulation is that here the inertia is a tensor and in 2D it is a single scalar.</p><p><code class="literal">InitializeAirplane</code> is called at the very start of the
      program. We found it convenient to make the call right after the application’s main window is
      created.</p><p>The final part of the flight model has to do with calculating the forces and moments that
      act on the airplane at any given instant in time during the simulation. As in the 2D
      hovercraft simulation, without this sort of function, the airplane will do nothing. For this
      purpose we’ve defined a function called <code class="literal">CalcAirplaneLoads</code>,
      which is called at every step through the simulation. This function relies on a couple of
      other functions—namely, <code class="literal">LiftCoefficient</code>, <code class="literal">DragCoefficient</code>, <code class="literal">RudderLiftCoefficient</code>, and <code class="literal">RudderDragCoefficient</code>. All of these functions are shown and discussed in detail
      in the section <a class="xref" href="ch15.html#modeling" title="Modeling">Modeling</a> in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>.</p><p>For the most part, the code contained in <code class="literal">CalcAirplaneLoads</code> is similar to the code you’ve seen in the <code class="literal">CalcLoads</code> function of the hovercraft simulation. <code class="literal">CalcAirplanLoads</code> is a little more involved since the airplane is
      modeled by a number of elements that contribute to the total lift and drag on the airplane.
      There’s also another difference that we’ve noted here:</p><a id="I_programlisting6_id332789"/><pre class="programlisting">void     CalcAirplaneLoads(void)
{
     .
     .
     .

     // Convert forces from model space to earth space
     Airplane.vForces = QVRotate(Airplane.qOrientation, Fb);

     // Apply gravity (g is defined as −32.174 ft/s^2)
     Airplane.vForces.z += g * Airplane.fMass;

     .
     .
     .
}</pre><p>Just about all of the forces acting on the airplane are first calculated in body-fixed
      coordinates and then converted to earth-fixed coordinates before the gravity force is applied.
      The coordinate conversion is effected through the use of the function <code class="literal">QVRotate</code>, which <a id="I_indexterm6_id332808" class="indexterm"/><a id="I_indexterm6_id332815" class="indexterm"/>rotates the force vector based on the airplane’s current orientation, represented
      by a <a id="I_indexterm6_id332826" class="indexterm"/><a id="I_indexterm6_id332836" class="indexterm"/>quaternion.<sup>[<a id="CHP-12-FN-1" href="#ftn.CHP-12-FN-1" epub:type="noteref" class="footnote">22</a>]</sup></p></div><div class="sect1" title="Integration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="integration">Integration</h2></div></div></div><p>Now that the code to <a id="th12.2" class="indexterm"/><a id="in12.2" class="indexterm"/>define, initialize, and calculate loads on the airplane is complete, you need to
      develop the code to actually integrate the equations of motion so that the simulation can
      progress through time. The first thing you need to do is decide on the integration scheme that
      you want to use. In this example, we decided to go with the basic <a id="I_indexterm6_id332915" class="indexterm"/>Euler’s method. We’ve already discussed some better methods in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>. We’re going with Euler’s method here because it’s simple
      and we didn’t want to make the code here overly complex, burying some key code that we need to
      point out to you. In practice, you’re better off using one of the other methods we discuss in
        <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> instead of Euler’s method. With that said, we’ve
      prepared a function called <code class="literal">StepSimulation</code> that handles all
      of the integration necessary to actually propagate the simulation:</p><a id="I_programlisting6_id332947"/><pre class="programlisting">void     StepSimulation(float dt)
{
     // Take care of translation first:
     // (If this body were a particle, this is all you would need to do.)

          Vector Ae;

          // calculate all of the forces and moments on the airplane:
          CalcAirplaneLoads();

          // calculate the acceleration of the airplane in earth space:
          Ae = Airplane.vForces / Airplane.fMass;

          // calculate the velocity of the airplane in earth space:
          Airplane.vVelocity += Ae * dt;

          // calculate the position of the airplane in earth space:
          Airplane.vPosition += Airplane.vVelocity * dt;


     // Now handle the rotations:
          float  mag;

          // calculate the angular velocity of the airplane in body space:
          Airplane.vAngularVelocity += Airplane.mInertiaInverse *
                                       (Airplane.vMoments -
                                       (Airplane.vAngularVelocity^
                                       (Airplane.mInertia *
                                         Airplane.vAngularVelocity)))
                                        * dt;

          // calculate the new rotation quaternion:
          Airplane.qOrientation += (Airplane.qOrientation *
                                    Airplane.vAngularVelocity) *
                                   (0.5f * dt);

          // now normalize the orientation quaternion:
          mag = Airplane.qOrientation.Magnitude();
          if (mag != 0)
               Airplane.qOrientation /= mag;

          // calculate the velocity in body space:
          // (we'll need this to calculate lift and drag forces)
          Airplane.vVelocityBody = QVRotate(~Airplane.qOrientation,
                                            Airplane.vVelocity);

          // calculate the air speed:
          Airplane.fSpeed = Airplane.vVelocity.Magnitude();

          // get the Euler angles for our information
          Vector u;

          u = MakeEulerAnglesFromQ(Airplane.qOrientation);
          Airplane.vEulerAngles.x = u.x;     // roll
          Airplane.vEulerAngles.y = u.y;     // pitch
          Airplane.vEulerAngles.z = u.z;     // yaw

}</pre><p>The very first thing that <code class="literal">StepSimulation</code> does is call
        <code class="literal">CalcAirplaneLoads</code> to calculate the loads acting on the
      airplane at the current instant in time. <code class="literal">StepSimulation</code>
      then goes on to calculate the linear acceleration of the airplane based on current loads.
      Next, the function goes on to integrate, using Euler’s method, once to calculate the
      airplane’s linear velocity and then a second time to calculate the airplane’s position. As
      we’ve commented in the code, if you were simulating a particle this is all you would have to
      do; however, since this is not a particle, you need to handle angular motion.</p><p>The first step in handling angular motion is to calculate the new <a id="I_indexterm6_id332998" class="indexterm"/><a id="I_indexterm6_id333010" class="indexterm"/>angular velocity at this time step, using Euler integration, based on the
      previously calculated moments acting on the airplane and its mass properties. We do this in
      body coordinates using the following equation of angular motion but rewritten to solve for
        <span class="emphasis"><em>d</em></span>ω:</p><table style="border: 0; " class="simplelist"><tr><td>∑ <span class="strong"><strong>M</strong></span><sub>cg</sub> = d<span class="strong"><strong>H</strong></span><sub>cg</sub>/dt = <span class="strong"><strong>I</strong></span> (d<span class="strong"><strong>ω</strong></span>/dt) + (<span class="strong"><strong>ω</strong></span> × (<span class="strong"><strong>I ω</strong></span>))</td></tr></table><p>The next step is to integrate again to update the <a id="I_indexterm6_id333082" class="indexterm"/>airplane’s orientation, which is expressed as a quaternion. Here, you need to use
      the differential equation relating an orientation quaternion to angular velocity that we
      showed you in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a>:</p><table style="border: 0; " class="simplelist"><tr><td>d<span class="strong"><strong>q</strong></span>/dt = (1/2) <span class="strong"><strong>ω
          q</strong></span></td></tr></table><p>Next, to enforce the constraint that this orientation quaternion be<a id="I_indexterm6_id333124" class="indexterm"/> a <span class="emphasis"><em>unit</em></span> quaternion, the function goes ahead and normalizes
      the orientation quaternion.</p><p>Since the linear velocity was previously calculated in global coordinates (the fixed
      coordinate system), and since <code class="literal">CalcAirplaneLoads</code> needs the
      velocity in the body-fixed (rotating) coordinates system, the function goes ahead and rotates
      the velocity vector, storing the body-fixed vector in the <code class="literal">vVelocityBody</code> member of the <code class="literal">RigidBody</code>
      structure. This is done here as a matter of convenience and uses the quaternion rotation
      function <code class="literal">QVRotate</code> to rotate the vector based on the
      airplane’s current orientation. Notice here that we use the conjugate of the orientation
      quaternion since we’re now rotating from global coordinates to body coordinates.</p><p>As another convenience, we calculate the air speed, which is simply the magnitude of the
      linear velocity vector. This is used to report the air speed in the main window title
      bar.</p><p>Lastly, the three Euler angles—roll, pitch, and yaw—are extracted from the orientation
      quaternion so that they can also be reported in the main window title bar. The function to use
      here <a id="I_indexterm6_id333178" class="indexterm"/><a id="I_indexterm6_id333189" class="indexterm"/><a id="I_indexterm6_id333195" class="indexterm"/>is <code class="literal">MakeEulerAnglesFromQ</code>, which is defined in
        <a class="xref" href="apc.html" title="Appendix C. Quaternion Operations">Appendix C</a>.</p><p>Don’t forget, <code class="literal">StepSimulation</code> must be called once per
        <a id="I_indexterm6_id333227" class="indexterm"/><a id="I_indexterm6_id333236" class="indexterm"/>simulation cycle.</p></div><div class="sect1" title="Flight Controls"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="flight_controls">Flight Controls</h2></div></div></div><p>At this point, the <a id="th12.3" class="indexterm"/><a id="fl12.3" class="indexterm"/><a id="ai12.3" class="indexterm"/>simulation still won’t work very well because you have not implemented the flight
      controls. The flight controls allow you to interact with the airplane’s various controls
      surfaces in order to actually fly the plane. We’ll use the keyboard as the main input device
      for the flight controls. Remember, in a physics-based simulation such as this one, you don’t
      directly control the motion of the airplane; you control only how various forces are applied
      to the airplane, which then, by integration over time, affect the airplane’s motion.</p><p>For this simulation, the flight stick is simulated by the arrow keys. The down arrow pulls
      back on the stick, raising the nose; the up arrow pushes the stick forward, causing the nose
      to dive; the left arrow rolls the plane to the left (port side); and the right arrow <a id="I_indexterm6_id333318" class="indexterm"/>rolls the plane to the right (starboard side). The X key applies left rudder
      action to cause the nose of the plane to yaw toward the left, while the C key applies right
      rudder action to cause the nose to <a id="I_indexterm6_id333330" class="indexterm"/>yaw toward the right. Thrust is <a id="I_indexterm6_id333342" class="indexterm"/>controlled by the A and Z keys. The A key increments the propeller thrust by 100
      pounds, and the Z key decrements the thrust by 100 pounds. The minimum thrust is 0, while the
      maximum available thrust is 3,000 pounds. The F key activates the landing flaps to increase
      lift at low speed, while the D key deactivates the landing flaps.</p><p>We control pitch <a id="I_indexterm6_id333359" class="indexterm"/>by deflecting the flaps on the aft elevators; for example, to pitch the nose up,
      we deflect the aft elevator flaps upward (that is, the trailing edge of the elevator is raised
      with respect to the leading edge). We control roll in this simulation by applying the flaps
      differentially; for example, to roll right, we deflect the right flap upward and the left flap
      downward. Finally, we control yaw by deflecting the vertical tail rudder; for example, to yaw
      left, we deflect the trailing edge of the tail rudder toward the left.</p><p>We’ve prepared several functions to handle the flight controls that should be called
      whenever the user is pressing one of the flight control keys. There are two functions for the
      propeller thrust:</p><a id="I_programlisting6_id333382"/><pre class="programlisting">void     IncThrust(void)
{
     ThrustForce += _DTHRUST;
     if(ThrustForce &gt; _MAXTHRUST)
          ThrustForce = _MAXTHRUST;
}

void     DecThrust(void)
{
     ThrustForce -= _DTHRUST;
     if(ThrustForce &lt; 0)
          ThrustForce = 0;
}</pre><p><code class="literal">IncThrust</code> simply increases the thrust by <code class="literal">_DTHRUST</code> checking to make sure it does not exceed <code class="literal">_MAXTHRUST</code>. We’ve defined <code class="literal">_DTHRUST</code> and <code class="literal">_MAXTHRUST</code> as follows:</p><a id="I_programlisting6_id333422"/><pre class="programlisting">#define    _DTHRUST      100.0f
#define    _MAXTHRUST    3000.0f</pre><p><code class="literal">DecThrust</code>, on the other hand, decreases the thrust by
        <code class="literal">_DTHRUST</code> checking to make sure it does not fall below
      0.</p><p>To control yaw, we’ve prepared three functions that manipulate the rudder:</p><a id="I_programlisting6_id333447"/><pre class="programlisting">void     LeftRudder(void)
{
     Element[6].fIncidence = 16;
}

void     RightRudder(void)
{
     Element[6].fIncidence = −16;
}

void     ZeroRudder(void)
{
     Element[6].fIncidence = 0;
}</pre><p><code class="literal">LeftRudder</code> changes the incidence angle of <code class="literal">Element[6]</code>, the vertical tail rudder, to 16 degrees, while
        <code class="literal">RightRudder</code> changes the incidence angle to −16 degrees.
        <code class="literal">ZeroRudder</code> centers the rudder at 0 degrees.</p><p>The ailerons, or flaps, are <a id="I_indexterm6_id333485" class="indexterm"/><a id="I_indexterm6_id333492" class="indexterm"/>manipulated by these functions to control roll:</p><a id="I_programlisting6_id333500"/><pre class="programlisting">void     RollLeft(void)
{
     Element[0].iFlap = 1;
     Element[3].iFlap = −1;
}

void     RollRight(void)
{
     Element[0].iFlap = −1;
     Element[3].iFlap = 1;
}

void     ZeroAilerons(void)
{
     Element[0].iFlap = 0;
     Element[3].iFlap = 0;
}</pre><p><code class="literal">RollLeft</code> deflects the port aileron, located on the port
      wing section (<code class="literal">Element[0]</code>), upward, and the starboard
      aileron, located on the starboard wing section (<code class="literal">Element[3]</code>), downward. <code class="literal">RollRight</code> does just the
      opposite, and <code class="literal">ZeroAilerons</code> resets the flaps back to their
      undeflected positions.</p><p>We’ve defined yet another set of functions to control the aft <a id="I_indexterm6_id333544" class="indexterm"/>elevators so as to control <a id="I_indexterm6_id333553" class="indexterm"/>pitch:</p><a id="I_programlisting6_id333565"/><pre class="programlisting">void     PitchUp(void)
{
     Element[4].iFlap = 1;
     Element[5].iFlap = 1;
}

void     PitchDown(void)
{
     Element[4].iFlap = −1;
     Element[5].iFlap = −1;
}


void     ZeroElevators(void)
{
     Element[4].iFlap = 0;
     Element[5].iFlap = 0;
}</pre><p><code class="literal">Element[4]</code> and <code class="literal">Element[5]</code> are the elevators. <code class="literal">PitchUp</code> deflects
      their flaps upward, and <code class="literal">PitchDown</code> deflects their flaps
      downward. <code class="literal">ZeroElevators</code> resets their flaps back to their
      undeflected positions.</p><p>Finally, there are two more functions to control the landing flaps:</p><a id="I_programlisting6_id333610"/><pre class="programlisting">void     FlapsDown(void)
{
     Element[1].iFlap = −1;
     Element[2].iFlap = −1;
     Flaps = true;
}

void     ZeroFlaps(void)
{
     Element[1].iFlap = 0;
     Element[2].iFlap = 0;
     Flaps = false;
}</pre><p>The landing flaps are fitted on the inboard wings sections, port and starboard, which are
        <code class="literal">Element[1]</code> and <code class="literal">Element[2]</code>. <code class="literal">FlapsDown</code> deflects the flaps
      downward, while <code class="literal">ZeroFlaps</code> resets them back to their
      undeflected position.</p><p>As we said, these functions should be called when the user is pressing the flight control
      keys. Further, they need to be called before <code class="literal">StepSimulation</code>
      is called so that they can be included in the current time step’s force and moment
      calculations. The sequence of calls should look something like this:</p><a id="I_programlisting6_id333659"/><pre class="programlisting">.
.
.

     ZeroRudder();
     ZeroAilerons();
     ZeroElevators();

     // pitch down
     if (IsKeyDown(VK_UP))
          PitchDown();

     // pitch up
     if (IsKeyDown(VK_DOWN))
          PitchUp();

     // roll left
     if (IsKeyDown(VK_LEFT))
          RollLeft();

     // roll right
     if (IsKeyDown(VK_RIGHT))
          RollRight();

     //  Increase thrust
     if (IsKeyDown(0x41)) // A
          IncThrust();

     //  Decrease thrust
     if (IsKeyDown(0x5A)) // Z
          DecThrust();

     // yaw left
     if (IsKeyDown(0x58)) // x
          LeftRudder();

     // yaw right
     if (IsKeyDown(0x43)) // c
          RightRudder();

     // landing flaps down
     if (IsKeyDown(0x46)) //f
          FlapsDown();

     // landing flaps up
     if (IsKeyDown(0x44)) // d
          ZeroFlaps();

     StepSimulation(dt);
.
.
.</pre><p>Before <code class="literal">StepSimulation</code> is called, we check each of the
      flight control keys to see if it is being pressed. If so, then the appropriate function is
      called.</p><p>The function <code class="literal">IsKeyDown</code>, which checks whether a certain
      key is pressed, looks like this in a Windows implementation:</p><a id="I_programlisting6_id333693"/><pre class="programlisting">BOOL IsKeyDown(short KeyCode)
{

    SHORT    retval;

    retval = GetAsyncKeyState(KeyCode);

    if (HIBYTE(retval))
        return TRUE;

    return FALSE;
}</pre><p>The important thing to note here is that the keys are being checked asynchronously because
      it is possible that more than one key will be pressed at any given time, and they must be
      handled simultaneously instead of one at a time (as would be the case in the standard Windows
      message processing function).</p><p>The addition of flight control code pretty much completes the physics part of the
      simulation. So far, you have the model, the integrator, and the user input or flight control
      elements completed. All that remains is setting up the application’s main window and actually
      drawing something that represents what you’re simulating. We’ll leave that part up to you, or
      you can look at the example we’ve included on the book’s website to see what we did on a
      Windows <a id="I_indexterm6_id333714" class="indexterm"/><a id="I_indexterm6_id333723" class="indexterm"/><a id="I_indexterm6_id333733" class="indexterm"/><a id="I_indexterm6_id333742" class="indexterm"/><a id="I_indexterm6_id333751" class="indexterm"/>machine.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-12-FN-1"><p><sup>[<a href="#CHP-12-FN-1" class="para">22</a>] </sup><code class="literal">QVRotate</code> is defined in <a class="xref" href="apc.html" title="Appendix C. Quaternion Operations">Appendix C</a>.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 13. Connecting Objects</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator"/><link rel="next" href="ch14.html" title="Chapter 14. Physics Engines"/></head><body><section class="chapter" title="Chapter 13. Connecting Objects" epub:type="chapter" id="connecting_objects"><div class="titlepage"><div><div><h2 class="title">Chapter 13. Connecting Objects</h2></div></div></div><p>Simulating particles and rigid bodies is <a id="ob13.0" class="indexterm"/><a id="I_indexterm7_id333789" class="indexterm"/><a id="mo13.0" class="indexterm"/>great fun, and with these simple entities you can achieve a
  wide variety of effects or simulate a wide variety of objects. In this
  chapter we’ll take things a step further, showing you how to simulate
  connected particles and rigid bodies. Doing so opens a whole new realm of
  possibilities. In this book’s first edition, David showed you how to use
  <a id="I_indexterm7_id333818" class="indexterm"/><a id="I_indexterm7_id333827" class="indexterm"/>springs and particles to simulate cloth. <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17</a> in the first edition covers that, and the
  <a id="I_indexterm7_id333844" class="indexterm"/><a id="I_indexterm7_id333850" class="indexterm"/>corresponding “Cloth Simulation” example on the book’s website
  implements the model. As shown in <a class="xref" href="ch13.html#network_of_particles_and_springs" title="Figure 13-1. Network of particles and springs">Figure 13-1</a>, the <a id="I_indexterm7_id333867" class="indexterm"/>flag model is simply a collection of particles initially laid
  out in a grid pattern connected by linear springs that are then rendered to
  look like cloth. The springs give structure to the particles, keeping them
  organized in a mesh that can be rendered while allowing them to move,
  emulating the movement of a flowing fabric.</p><div class="figure"><a id="network_of_particles_and_springs"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id333887"/><img src="httpatomoreillycomsourceoreillyimages1598954.png.jpg" alt="Network of particles and springs"/></div></div><div class="figure-title">Figure 13-1. Network of particles and springs</div></div><p>Each line in the wireframe flag shown in <a class="xref" href="ch13.html#network_of_particles_and_springs" title="Figure 13-1. Network of particles and springs">Figure 13-1</a> represents a spring-damper
  element, while the nodes where these springs intersect represent the
  particles. We modeled the springs using the <a id="I_indexterm7_id333914" class="indexterm"/>spring-damper formulas that we showed you back in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>. The (initially) horizontal and vertical springs provide
  the basic structure for the flag, while the diagonal springs are there to
  resist shear forces and lend further strength to the cloth. Without these
  shear springs, the cloth would be quite stretchy. Note that there are no
  particles located at the intersection of the diagonal springs.</p><p>In this chapter, we’ll show you how to use those same techniques to
  simulate something like a hanging rope or vine. You can use these techniques
  to simulate all sorts of things besides cloth and rope or vines. For
  example, you can model the swing of a golf club if you can imagine one rigid
  body representing the arm and another representing the golf club. We’ll get
  to that example in <a class="xref" href="ch19.html" title="Chapter 19. Sports">Chapter 19</a>, but for now let’s see how to
  model a hanging rope or vine and some other springy objects.</p><p>Application of linear springs is not the only method available to connect objects, but it
    has the advantages of being conceptually simple, easy to implement, and effective. One of the
    potential disadvantages is that you can run into numerical stability problems if the springs are
    too stiff. We’ll talk more about these issues throughout this chapter. Also, the examples we’ll
    cover are in 2D for simplicity, but the techniques apply in 3D, too.</p><div class="sect1" title="Springs and Dampers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="springs_and_dampers-id1">Springs and Dampers</h2></div></div></div><p>You learned in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> that <a id="I_indexterm7_id333971" class="indexterm"/><a id="I_indexterm7_id333981" class="indexterm"/>springs are structural elements that, when connected between
    two objects, apply equal and opposite forces to each object. This spring
    force follows <a id="I_indexterm7_id333993" class="indexterm"/>Hooke’s law and is a function of the stretched or compressed
    length of the spring relative to the rest length of the spring and the
    spring constant. The spring constant<a id="I_indexterm7_id334002" class="indexterm"/> is a quantity that relates the force exerted by the spring
    to its deflection:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>s</sub> = –k<sub>s</sub> (L –
      r)</td></tr></table><p>Here, <span class="emphasis"><em>F</em></span><sub>s</sub> is the spring
    force, <span class="emphasis"><em>k</em></span><sub>s</sub> is the spring
    constant, <span class="emphasis"><em>L</em></span> is the stretched or compressed length of
    the spring, and <span class="emphasis"><em>r</em></span> is the rest length of the spring.
    The negative sign in the preceding equation just means that the force is
    in the opposite direction of the displacement.</p><p>Dampers are usually used in conjunction with springs in numerical
    simulations. They act like viscous drag in that dampers act against
    velocity. The force developed by a damper is proportional to the relative
    velocity of the connected objects and a<a id="I_indexterm7_id334062" class="indexterm"/> damping constant,
    <span class="emphasis"><em>k</em></span><sub>d</sub>, that relates relative
    velocity to damping force.</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>d</sub> = –k<sub>d</sub>
      (v<sub>1</sub> – v<sub>2</sub>)</td></tr></table><p>This equation shows the damping force,
    <span class="emphasis"><em>F</em></span><sub>d</sub>, as a function of the
    damping constant and the relative velocity of the connected points on the
    two connected bodies.</p><p>Typically, springs and dampers are combined into a single <a id="I_indexterm7_id334119" class="indexterm"/>spring-damper element where a single formula is used to
    represent the combined force. In vector notation, the formula for a
    spring-damper element connecting two bodies is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>1</sub> =
      –{k<sub>s</sub> (L – r) + k<sub>d</sub>
      ((<span class="strong"><strong>v</strong></span><sub>1</sub> –
      <span class="strong"><strong>v</strong></span><sub>2</sub>) •
      <span class="strong"><strong>L</strong></span>)/L} <span class="strong"><strong>L</strong></span>/L</td></tr></table><p>Here, <span class="strong"><strong>F</strong></span><sub>1</sub>
    is the force exerted on body 1, while the force, <span class="strong"><strong>F</strong></span><sub>2</sub>, exerted on body 2
    is:</p><table style="border: 0; " class="simplelist"><tr><td><span class="strong"><strong>F</strong></span><sub>2</sub> =
      –<span class="strong"><strong>F</strong></span><sub>1</sub></td></tr></table><p><span class="strong"><strong>L</strong></span> is the length of the
    spring-damper (<span class="emphasis"><em>L</em></span>, not in bold print, is the magnitude
    of the vector <span class="strong"><strong>L</strong></span>), which is equal to the
    vector difference in position between the connected points on bodies 1 and
    2. If the connected objects are particles, then <span class="strong"><strong>L</strong></span> is equal to the position of body 1 minus the
    position of body 2. Similarly, <span class="strong"><strong>v</strong></span><sub>1</sub> and <span class="strong"><strong>v</strong></span><sub>2</sub> are the velocities of
    the connected points on bodies 1 and 2. The quantity (<span class="strong"><strong>v</strong></span><sub>1</sub> – <span class="strong"><strong>v</strong></span><sub>2</sub>) represents the
    <a id="I_indexterm7_id334288" class="indexterm"/><a id="I_indexterm7_id334299" class="indexterm"/>relative velocity between the connected bodies.</p><p>It’s fairly straightforward to connect particles with springs (and
    dampers); you need only specify the particles to which the spring is
    connected and compute the stretched or compressed length of the spring as
    the particles move relative to each other. The force generated by the
    spring is then applied equally (but in opposite directions) to the
    connected particles. This is a linear force.</p><p>For rigid bodies, things are a bit more complicated. First, not only
    do you have to specify to which body the spring is attached, but you must
    also specify the precise points on each object where the spring attaches.
    Then, in addition to the linear force applied by the spring to each body,
    you must also compute the resulting moment on each body causing each to
    rotate.</p></div><div class="sect1" title="Connecting Particles"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="connecting_particles">Connecting Particles</h2></div></div></div><p>From <a id="co13.2" class="indexterm"/><a id="pa13.2" class="indexterm"/><a id="cop13.2" class="indexterm"/><a id="pc13.2" class="indexterm"/><a id="ro13.2" class="indexterm"/><a id="vi13.2" class="indexterm"/>swinging vines in Activision’s <span class="emphasis"><em>Pitfall</em></span>
    to barnacle tongues in Valve Corporation’s <span class="emphasis"><em>Half-Life</em></span>,
    dangling rope-like objects have appeared in video games in various
    incarnations since the very early days of video gaming. Some
    implementations, such as those in the 1982 versions of
    <span class="emphasis"><em>Pitfall</em></span>, are implemented rather simply and
    unrealistically, while others, such as barnacle tongues, are implemented
    more realistically in how they dangle and swing. Whether it’s a vine,
    rope, chain, or tongue, you can use particles and springs to simulate
    realistic rope-like behavior. We’ll show you how in the following simple
    example.</p><div class="sect2" title="Rope"><div class="titlepage"><div><div><h3 class="title" id="rope">Rope</h3></div></div></div><p>You know from your real-life experience that ropes are flexible, although some are more
        flexible than others. Ropes are elastic and stretch to varying extents. They drape when
        suspended by their two ends. They bend when swinging or when collapsing on the ground. We
        can capture all these behaviors using simple particles connected with springs. <a class="xref" href="ch13.html#swinging_rope" title="Figure 13-2. Swinging rope">Figure 13-2</a> illustrates the rope example we’ll cover here.</p><div class="figure"><a id="swinging_rope"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id334464"/><img src="httpatomoreillycomsourceoreillyimages1598955.png" alt="Swinging rope"/></div></div><div class="figure-title">Figure 13-2. Swinging rope</div></div><p>The example consists of a rope comprising 10 particles and 9
      springs. At the start of the simulation, the rope, originally extended
      straight out to the right, falls under the influence of gravity,
      swinging left and right until it comes to rest (hanging straight down).
      The dots represent particles and the lines represent <a id="sp13.2.1" class="indexterm"/>springs. The topmost particle is fixed, and the
      illustration on the left in <a class="xref" href="ch13.html#swinging_rope" title="Figure 13-2. Swinging rope">Figure 13-2</a> shows the
      rope swinging down from right to left while the illustration on the
      right shows the rope swinging back from left to right.</p><p>This example uses all the same code and techniques presented in
      <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> through <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a> for simulating particles and rigid
      bodies. Really, the only difference is that we have to compute a new
      force—the spring force on each object. But before we do that, we have to
      define and initialize the springs.</p><div class="sect3" title="Spring structure and variables"><div class="titlepage"><div><div><h4 class="title" id="spring_structure_and_variables">Spring structure and variables</h4></div></div></div><p>The following code sample shows the spring data structure we set
        up to store each spring’s information:</p><a id="I_programlisting7_id334542"/><pre class="programlisting">typedef struct _Spring {
    int        End1;
    int        End2;
    float      k;
    float      d;
    float      InitialLength;
} Spring, *pSpring;</pre><p>Specifically, this information includes:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">End1</code></span></dt><dd><p>A reference to the first particle to which the spring is
              connected</p></dd><dt><span class="term"><code class="literal">End2</code></span></dt><dd><p>A reference to the second particle to which the spring is
              connected</p></dd><dt><span class="term"><code class="literal">k</code></span></dt><dd><p>The spring constant</p></dd><dt><span class="term"><code class="literal">d</code></span></dt><dd><p>The damping constant</p></dd><dt><span class="term"><code class="literal">InitialLength</code></span></dt><dd><p>The unstretched length of the spring</p></dd></dl></div><p>This structure is appropriate for connecting particles. We’ll
        make a slight modification to this structure later, when we get to the
        example where we’re connecting rigid bodies.</p><p>There are <code class="literal">define</code>s and
        variables unique to this example that must be set up as
        follows:</p><a id="I_programlisting7_id334665"/><pre class="programlisting">#define        _NUM_OBJECTS     10
#define        _NUM_SPRINGS     9
#define        _SPRING_K        1000
#define        _SPRING_D        100

Particle        Objects[_NUM_OBJECTS];
Spring          Springs[_NUM_SPRINGS];</pre><p>As stated earlier, there are 10 particles (objects) and 9
        springs in this simulation. The arrays <code class="literal">Objects</code> and <code class="literal">Springs</code> are used to keep track of them. We
        also set up a few <code class="literal">define</code>s
        representing the spring and damping constants. The values shown here
        are arbitrary, and you can change them to suit whatever behavior you
        desire. The higher the spring constant, the stiffer the springs;
        whereas the lower the spring constant, the stretchier the springs.
        Stretchy springs make your rope more elastic. Keep in mind while
        tuning these values that if you make the spring constant too high,
        you’ll probably have to make the simulation time step smaller and/or
        use a robust integration scheme to avoid numerical
        instabilities.</p><p>The damping constant controls how quickly the springiness of the
        springs dampens out. You’ll end up tuning this value to get the
        behavior you desire. A small value can make the rope seem jittery,
        while a large value will make the stretchiness appear smoother. Higher
        damping also helps alleviate numerical instabilities to some extent,
        although it’s no substitute for a robust integration scheme.</p></div><div class="sect3" title="Initialize the particles and springs"><div class="titlepage"><div><div><h4 class="title" id="initialize_the_particles_and_springs">Initialize the particles and springs</h4></div></div></div><p>Initially, our particle rope is set up horizontally, as shown in
        <a class="xref" href="ch13.html#particle_rope_setup" title="Figure 13-3. Particle rope setup">Figure 13-3</a>, with the leftmost particle,
        <span class="emphasis"><em>p0</em></span>, fixed—that is, the particle
        <span class="emphasis"><em>p0</em></span> will not move, and the remainder of the rope
        will pivot about <span class="emphasis"><em>p0</em></span>. For convenience, all
        remaining particles are incrementally indexed from left to
        right.</p><div class="figure"><a id="particle_rope_setup"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id334748"/><img src="httpatomoreillycomsourceoreillyimages1598956.png" alt="Particle rope setup"/></div></div><div class="figure-title">Figure 13-3. Particle rope setup</div></div><p>There are nine springs, which are indexed from left to right as illustrated in <a class="xref" href="ch13.html#particle_rope_setup" title="Figure 13-3. Particle rope setup">Figure 13-3</a>. Spring 0 connects particle 0 to particle 1, spring 1
          connects particle 1 to particle 2, and so on. The following code sample shows how all this
          is initialized:</p><a id="I_programlisting7_id334777"/><pre class="programlisting">bool    Initialize(void)
{
    Vector    r;
    int       i;

    Objects[0].bLocked = true;

    // Initialize particle locations from left to right.
    for(i=0; i&lt;_NUM_OBJECTS; i++)
    {
        Objects[i].vPosition.x = _WINWIDTH/2 + Objects[0].fLength * i;
        Objects[i].vPosition.y = _WINHEIGHT/8;
    }

    // Initialize springs connecting particles from left to right.
    for(i=0; i&lt;_NUM_SPRINGS; i++)
    {
        Springs[i].End1 = i;
        Springs[i].End2 = i+1;
        r = Objects[i+1].vPosition - Objects[i].vPosition;

        Springs[i].InitialLength = r.Magnitude();
        Springs[i].k = _SPRING_K;
        Springs[i].d = _SPRING_D;
    }
    return true;
}</pre><p>First, the local variables <code class="literal">r</code>
        and <code class="literal">i</code> are declared. <code class="literal">r</code> will be used to compute the initial,
        unstretched length of the springs, and <code class="literal">i</code> will be used to index the <code class="literal">Objects</code> and <code class="literal">Springs</code> arrays. Second, <code class="literal">Objects[0]</code>, the one that is fixed, has its
        <code class="literal">bLocked</code> property set to <code class="literal">true</code>, indicating that it does not move (that
        is, it’s locked).</p><p>Next, the particle positions are initialized starting from the first particle—the
          fixed one positioned at the middle of the screen—and proceeding to the rest of the
          particles, offsetting each to the right by an amount equal to property <code class="literal">fLength</code>. <code class="literal">fLength</code> is an
          arbitrary length that you can define, that represents the spacing of the particles and,
          subsequently, the initial length of the springs connecting the particles.</p><p>Finally, we set up the springs, connecting each particle to its
        neighbor on the right. Starting at the first spring, we set its end
        references to the index of the particle to its left and right in the
        properties <code class="literal">End1</code> and <code class="literal">End2</code>, respectively. These indices are simply
        <code class="literal">i</code> and <code class="literal">i+1</code>, as shown in the preceding code sample
        within the last <code class="literal">for</code> loop. The
        initial length vector of the spring is computed and stored in the
        vector <code class="literal">r</code>, where <code class="literal">r = Objects[i+1].vPosition -
        Objects[i].vPosition</code>. The magnitude of this vector is the
        initial spring length, which is stored in the spring’s property,
        <code class="literal">InitialLength</code>. This step isn’t
        strictly necessary in this example since you already know that the
        property <code class="literal">fLength</code> discussed earlier
        is the initial length of each spring. However, we’ve done it this
        general way since you may not necessarily initialize the particle
        positions as we have simply done.</p></div><div class="sect3" title="Update the simulation"><div class="titlepage"><div><div><h4 class="title" id="update_the_simulation">Update the simulation</h4></div></div></div><p>Updating the particle positions at <a id="si13.2.1.3" class="indexterm"/>each simulation time step, under the influence of gravity and spring forces
          proceeds just like in the earlier examples of <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> and <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>. Essentially, you must compute the forces on the
          particles, integrate the equations of motion, and redraw the scene. As usual in our
          examples, the function <code class="literal">UpdateSimulation</code> is called on to
          perform these tasks. For the current example, <code class="literal">UpdateSimulation</code> looks like this:</p><a id="I_programlisting7_id334990"/><pre class="programlisting">void    UpdateSimulation(void)
{
    double    dt = _TIMESTEP;
    int       i;
    double    f, dl;
    Vector    pt1, pt2;
    int       j;
    Vector    r;
    Vector    F;
    Vector    v1, v2, vr;

    // Initialize the spring forces on each object to zero.
    for(i=0; i&lt;_NUM_OBJECTS; i++)
    {
        Objects[i].vSprings.x = 0;
        Objects[i].vSprings.y = 0;
        Objects[i].vSprings.z = 0;
    }

    // Calculate all spring forces based on positions of connected objects.
    for(i=0; i&lt;_NUM_SPRINGS; i++)
    {
        j = Springs[i].End1;
        pt1 = Objects[j].vPosition;
        v1 = Objects[j].vVelocity;

        j = Springs[i].End2;
        pt2 = Objects[j].vPosition;
        v2 = Objects[j].vVelocity;

        vr = v2 - v1;
        r = pt2 - pt1;
        dl = r.Magnitude() - Springs[i].InitialLength;
        f = Springs[i].k * dl; // - means compression, + means tension
        r.Normalize();
        F = (r*f) + (Springs[i].d*(vr*r))*r;

        j = Springs[i].End1;
        Objects[j].vSprings += F;

        j = Springs[i].End2;
        Objects[j].vSprings -= F;
    }

    .
    .
    .
    // Integrate equations of motion as usual.
    .
    .
    .
    // Render the scene as usual.
    .
    .
    .
}</pre><p>As you can see, there are several local variables here. We’ll explain each one as we
          get to the code where it’s used. After the local variable declarations, this function’s
          first task is to reset the aggregate spring forces on each particle to 0. Each particle
          stores the aggregate spring force in the property <code class="literal">vSprings</code>, which is a vector. In this example, each particle will have up to
          two springs acting on it at any given time.</p><p>The next block of code in the <code class="literal">for</code> loop computes the springs forces acting
        on each particle. There are several steps to this, so we’ll go through
        each one. First the loop is set up to step through the list of
        springs. Recall that each spring is connected to two particles, so
        each step through the loop will compute a spring force and apply it to
        two separate particles.</p><p>Within the loop, the variable <code class="literal">j</code> is used as a convenience to temporarily
        store the index that refers to the <code class="literal">Object</code> to which the spring is attached. For
        each spring <code class="literal">j</code> is first set to the
        spring’s <code class="literal">End1</code> property. A temporary
        variable, <code class="literal">pt1</code>, is then set equal to
        the position of the <code class="literal">Object</code> to which
        <code class="literal">j</code> refers. Another temporary
        variable, <code class="literal">v1</code>, is set to the
        velocity of the <code class="literal">Object</code> to which
        <code class="literal">j</code> refers. Next, <code class="literal">j</code> is set to the index of <code class="literal">End2</code>, the other <code class="literal">Object</code> to which the current spring is
        attached, and that object’s position and velocity are stored in
        <code class="literal">pt2</code> and <code class="literal">v2</code>, respectively. This sort of temporary
        variable use isn’t necessary, of course, but it makes the following
        lines of code that compute the spring force more readable in our
        opinion.</p><p><code class="literal">vr</code> is a vector that stores
        the relative velocity between the two ends of the spring. We compute
        <code class="literal">vr</code> by subtracting <code class="literal">v1</code> from <code class="literal">v2</code>. Similarly, <code class="literal">r</code> is a vector that stores the relative
        distance between the two ends of the spring. We compute <code class="literal">r</code> by subtracting <code class="literal">pt1</code> from <code class="literal">pt2</code>. The magnitude of <code class="literal">r</code> represents the stretched or compressed
        length of the spring. The change in spring length is computed and
        stored in <code class="literal">dl</code> as follows:</p><a id="I_programlisting7_id335196"/><pre class="programlisting">        dl = r.Magnitude() - Springs[i].InitialLength;</pre><p><code class="literal">dl</code> will be negative if the
        computed length is shorter than the initial length of the spring. This
        implies that the spring is in compression and should act to push the
        particles away from each other. A positive <code class="literal">dl</code> means the spring is in tension and should
        act to pull the particles toward each other. The line:</p><a id="I_programlisting7_id335220"/><pre class="programlisting">        f = Springs[i].k * dl;</pre><p>computes the corresponding spring force as a function of
        <code class="literal">dl</code> and the spring constant. Note
        that <code class="literal">f</code> is a scalar and we have not
        yet computed its line of action, although we know it acts along the
        line connecting the particles at <code class="literal">End1</code> and <code class="literal">End2</code>. That line is represented by <code class="literal">r</code>, which we computed earlier. And the spring
        force is just <code class="literal">f</code> times the unit
        vector along <code class="literal">r</code>. Since we’re
        including damping, we have to use the spring-damper equation for the
        total force acting on each particle, which we call the vector <code class="literal">F</code>. <code class="literal">F</code> is
        computed as follows:</p><a id="I_programlisting7_id335287"/><pre class="programlisting">        F = (r*f) + (Springs[i].d*(vr*r))*r;</pre><p>The first term on the right side of the equals sign is the
        Hooke’s law–based spring force, and the second term is the damping
        force. Note here that <code class="literal">r</code> is a unit
        vector previously computed using the line:</p><a id="I_programlisting7_id335304"/><pre class="programlisting">        r.Normalize();</pre><p>Finally, the spring force is applied to each particle connected
        by the spring. Remember, the force is equal in magnitude but opposite
        in direction for each particle. The lines:</p><a id="I_programlisting7_id335316"/><pre class="programlisting">        j = Springs[i].End1;
        Objects[j].vSprings += F;</pre><p>apply the spring force to the particle at the first end of the
        spring, whereas the lines:</p><a id="I_programlisting7_id335327"/><pre class="programlisting">        j = Springs[i].End2;
        Objects[j].vSprings -= F;</pre><p>apply the opposite spring force to the particle at the second
        end of the spring.</p><p>That’s it for computing and applying the spring forces. The
        remainder of the code is business as usual, where we compute the force
        due to gravity and add it to the aggregate spring force for each
        particle and then integrate the equations of motion. Finally, we
        render the scene at each time <a id="I_indexterm7_id335343" class="indexterm"/><a id="I_indexterm7_id335352" class="indexterm"/><a id="I_indexterm7_id335362" class="indexterm"/><a id="I_indexterm7_id335371" class="indexterm"/><a id="I_indexterm7_id335380" class="indexterm"/><a id="I_indexterm7_id335390" class="indexterm"/><a id="I_indexterm7_id335399" class="indexterm"/><a id="I_indexterm7_id335408" class="indexterm"/>step.</p></div></div></div><div class="sect1" title="Connecting Rigid Bodies"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="connecting_rigid_bodies">Connecting Rigid Bodies</h2></div></div></div><p>As with particles,<a id="cl13.3" class="indexterm"/><a id="rl13.3" class="indexterm"/><a id="cc13.3" class="indexterm"/><a id="rc13.3" class="indexterm"/><a id="li13.3" class="indexterm"/> you can connect rigid bodies with springs to simulate some interesting things.
      For example, you may want to simulate something as simple as a linked chain, where each link
      is connected to the other in series. Or perhaps you want to simulate connected body parts to
      simulate rag doll physics or maybe a golfer’s swing. All these require some means of
      connecting rigid bodies. In this section we’ll show you how to use linear spring-dampers, the
      same we’ve discussed already, to connect rigid bodies. We’ll start with a simple analog to the
      rope example discussed earlier. Instead of connecting particles with springs to simulate a
      dangling rope, we’ll connect rigid links to simulate a dangling rope or chain. Later, we’ll
      show you how linear springs can be used to restrain angular motion.</p><div class="sect2" title="Links"><div class="titlepage"><div><div><h3 class="title" id="links">Links</h3></div></div></div><p>In this example, each link is rigid in that it does not deform; however, the links are
        connected by springs in a way that allows the ensemble to swing, stretch, and bend in a
        manner similar to a hanging chain. <a class="xref" href="ch13.html#swinging_links" title="Figure 13-4. Swinging links">Figure 13-4</a> illustrates our swinging
        linked chain as it swings from right to left and then back toward the right.</p><div class="figure"><a id="swinging_links"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id335538"/><img src="httpatomoreillycomsourceoreillyimages1598957.png" alt="Swinging links"/></div></div><div class="figure-title">Figure 13-4. Swinging links</div></div><p>As in the rope example, the topmost link is connected to a fixed
      point by a spring, such that the linked chain pivots around and hangs
      from the fixed point. The rectangles represent each rigid link, with the
      lines connecting the rectangles representing springs.</p><p>To model this linked chain, we need only make a few changes to the
      rope example to address the fact that we’re now dealing with rigid
      bodies that can rotate versus particles. This requires us to specify the
      point on each body to which the springs are attached, and in addition to
      computing the spring forces acting on each body, we must also compute
      the moments due to those forces. Aside from these spring force and
      moment computations, the remainder of the simulation is the same as
      those discussed in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> through
      <a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12</a>.</p><div class="sect3" title="Basic structures and variables"><div class="titlepage"><div><div><h4 class="title" id="basic_structures_and_variables">Basic structures and variables</h4></div></div></div><p>We can use the <code class="literal">Spring</code>
        structure shown earlier in the rope example again here with one small
        modification. Basically, we need to change the type of the endpoint
        references, <code class="literal">End1</code> and <code class="literal">End2</code>, from integers to a new structure we’ll
        call <code class="literal">EndPoint</code>. The new <code class="literal">Spring</code> structure looks like this:</p><a id="I_programlisting7_id335626"/><pre class="programlisting">typedef struct _Spring {
    EndPoint    End1;
    EndPoint    End2;
    float        k;
    float        d;
    float        InitialLength;
} Spring, *pSpring;</pre><p>The new <code class="literal">EndPoint</code> structure is
        as follows:</p><a id="I_programlisting7_id335642"/><pre class="programlisting">typedef struct _EndPointRef {
    int       ref;
    Vector    pt;
} EndPoint;</pre><p>Here, <code class="literal">ref</code> is the index
        referring to the <code class="literal">Object</code> to which
        the spring is attached, and <code class="literal">pt</code> is
        the point in the attached <code class="literal">Object</code>’s
        local coordinate system to which the spring is attached. Notice from
        <a class="xref" href="ch13.html#swinging_links" title="Figure 13-4. Swinging links">Figure 13-4</a> that the first spring, the topmost
        one, is connected to a single object; the other end of it is connected
        to a fixed point in space. We’ll use a <code class="literal">ref</code> of <code class="literal">−1</code>
        to indicate that a spring’s endpoint is connected to a fixed point in
        space instead of an object.</p><p>As in the rope example, we have a few important <code class="literal">define</code>s and variables to set up:</p><a id="I_programlisting7_id335706"/><pre class="programlisting">#define        _NUM_OBJECTS     10
#define        _NUM_SPRINGS     10
#define        _SPRING_K        1000
#define        _SPRING_D        100

RigidBody2D       Objects[_NUM_OBJECTS];
Spring            Springs[_NUM_SPRINGS];</pre><p>These are the same as before except now we have 10 springs
        instead of 9, and <code class="literal">Objects</code> is of
        type <code class="literal">RigidBody2D</code> instead of
        <code class="literal">Particle</code>.</p><p>The damping and spring constants play the same role here as they
        did in the rope example.</p></div><div class="sect3" title="Initialize"><div class="titlepage"><div><div><h4 class="title" id="initialize">Initialize</h4></div></div></div><p>Initially our linked chain is set up horizontally, just like the
        rope example, but with the link and spring indices shown in <a class="xref" href="ch13.html#linked-chain_setup" title="Figure 13-5. Linked-chain setup">Figure 13-5</a>. Each rectangle represents a rigid
        link, and a spring attached to the left end of each link connects the
        link to its neighbor to the left. In the case of the first link,
        <span class="emphasis"><em>L0</em></span>, the spring connects the left end of the link
        to a fixed point in space.</p><div class="figure"><a id="linked-chain_setup"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id335779"/><img src="httpatomoreillycomsourceoreillyimages1598958.png" alt="Linked-chain setup"/></div></div><div class="figure-title">Figure 13-5. Linked-chain setup</div></div><p>The code for this setup is only a little more involved than that
        for the rope example; the additional complexity is due to having to
        deal with specific points on the rigid bodies to which each spring is
        attached. The following code sample contains the modified <code class="literal">Initialize</code> function:</p><a id="I_programlisting7_id335809"/><pre class="programlisting">bool    Initialize(void)
{
    Vector    r;
    Vector    pt;
    int       i;

    // Initialize objects for linked chain.
    for(i=0; i&lt;_NUM_LINKS; i++)
    {
        Objects[i].vPosition.x = _WINWIDTH/2 + Objects[0].fLength * i;
        Objects[i].vPosition.y = _WINHEIGHT/8;
        Objects[i].fOrientation = 0;
    }

    // Connect end of the first object to a fixed point in space.
    Springs[0].End1.ref = −1;
    Springs[0].End1.pt.x = _WINWIDTH/2-Objects[0].fLength/2;
    Springs[0].End1.pt.y = _WINHEIGHT/8;

    Springs[0].End2.ref = 0;
    Springs[0].End2.pt.x = -Objects[0].fLength/2;
    Springs[0].End2.pt.y = 0;

    pt = VRotate2D(Objects[0].fOrientation, Springs[0].End2.pt)
         + Objects[0].vPosition;
    r = pt - Springs[0].End1.pt;

    Springs[0].InitialLength = r.Magnitude();
    Springs[0].k = _SPRING_K;
    Springs[0].d = _SPRING_D;

    // Connect end of all remaining springs.
    for(i=1; i&lt;_NUM_LINKS; i++)
    {
        Springs[i].End1.ref = i-1;
        Springs[i].End1.pt.x = Objects[i-1].fLength/2;
        Springs[i].End1.pt.y = 0;

        Springs[i].End2.ref = i;
        Springs[i].End2.pt.x = -Objects[i].fLength/2;
        Springs[i].End2.pt.y = 0;

        pt = VRotate2D(Objects[i].fOrientation, Springs[i].End2.pt)
              + Objects[i].vPosition;
        r = pt - (VRotate2D(Objects[i-1].fOrientation, Springs[i].End1.pt)
                  + Objects[i-1].vPosition);

        Springs[i].InitialLength = r.Magnitude();
        Springs[i].k = _SPRING_K;
        Springs[i].d = _SPRING_D;
    }

    return true;
}</pre><p>The local variables <code class="literal">r</code> and
        <code class="literal">i</code> are the same as before; however,
        there’s a new variable, <code class="literal">pt</code>, that we
        use to temporarily store the coordinates of specific points when
        converting from one coordinate system to another. We’ll see how this
        is done shortly.</p><p>After the local variables are declared, the <code class="literal">Object</code> positions are initialized, starting
        from the first <code class="literal">Object</code> positioned at
        the middle of the screen and proceeding to the rest of the <code class="literal">Object</code>s, offsetting each to the right by an
        amount equal to property <code class="literal">fLength</code>.
        Here, <code class="literal">fLength</code> is an arbitrary
        length representing the length of each rigid body, not the length of
        the springs connecting each rigid body. As you’ll see momentarily, the
        initial length of all the springs in this example is 0.</p><p>You should be aware that the coordinates for each object
        computed here are the coordinates of the object’s center of gravity,
        which in this example we defined as the middle of the rectangle
        representing each object. Since these are rigid bodies, not only must
        you specify their initial positions, but you must also specify their
        initial orientations as shown in the preceding code sample. The way we
        have this example set up, each object is initialized with an
        orientation of 0 degrees.</p><p>The next task is to set up the spring connecting the first link,
        the one on the left, to a fixed point in space. The following code
        handles this task:</p><a id="I_programlisting7_id335902"/><pre class="programlisting">    // Connect end of the first object to a fixed point in space.
    Springs[0].End1.ref = −1;
    Springs[0].End1.pt.x = _WINWIDTH/2-Objects[0].fLength/2;
    Springs[0].End1.pt.y = _WINHEIGHT/8;

    Springs[0].End2.ref = 0;
    Springs[0].End2.pt.x = -Objects[0].fLength/2;
    Springs[0].End2.pt.y = 0;

    pt = VRotate2D(Objects[0].fOrientation, Springs[0].End2.pt)
         + Objects[0].vPosition;
    r = pt - Springs[0].End1.pt;

    Springs[0].InitialLength = r.Magnitude();
    Springs[0].k = _SPRING_K;
    Springs[0].d = _SPRING_D;</pre><p>The first spring, <code class="literal">Spring[0]</code>,
        has its first endpoint, <code class="literal">End1</code>, set
        to refer to <code class="literal">−1</code>, which, as explained
        earlier, means that this end of the spring is connected to some fixed
        point in space. The location of the point, stored in the <code class="literal">End1.pt</code> property, must be specified in
        global coordinates as shown previously.</p><p>Now the second end of the first spring is connected to the left
        end of the first link; therefore, <code class="literal">End2.ref</code> of the first spring is set to
        <code class="literal">0</code>, which is the index to the first
        <code class="literal">Object</code>. The point on <code class="literal">Object[0]</code> to which the spring is attached is
        the leftmost end on the centerline of the object; thus, its
        coordinates—relative to the object’s center of gravity location and
        specified in local, body-fixed coordinates—are:</p><a id="I_programlisting7_id335972"/><pre class="programlisting">    Springs[0].End2.pt.x = -Objects[0].fLength/2;
    Springs[0].End2.pt.y = 0;</pre><p>Now remember, the points on <code class="literal">Objects</code> to which springs are attached are
        specified in body-fixed, local coordinates of each referenced object,
        whereas any point fixed in space to which a spring is attached and not
        on an <code class="literal">Object</code> must be specified in
        global, earth-fixed coordinates. You have to keep these coordinates
        straight and make the appropriate rotations when computing spring
        lengths throughout the simulation. The code;</p><a id="I_programlisting7_id335998"/><pre class="programlisting">    pt = VRotate2D(Objects[0].fOrientation, Springs[0].End2.pt)
         + Objects[0].vPosition;
    r = pt - Springs[0].End1.pt;</pre><p>illustrates how to do this. To compute the initial spring
        length, we need to compute the relative distance between the endpoints
        of the spring. In case of the first spring, <code class="literal">End1</code> was specified in global coordinates,
        but <code class="literal">End2</code> was specified in the local
        coordinate system of <code class="literal">Object[0]</code>.
        Therefore, we have to convert the coordinates of <code class="literal">End2</code> from local coordinates to global
        coordinates before calculating the relative distance between the ends.
        The preceding line, which calls the <code class="literal">VRotate2D</code> function you saw in earlier
        chapters, rotates the locally specified point, <code class="literal">End2.pt</code>, from local to global coordinates;
        it then adds the <code class="literal">Object</code>’s position
        to the result, arriving at a point, <code class="literal">pt</code>, in global coordinates coincident with
        the second endpoint of the spring. The relative distance, <code class="literal">r</code>, is the second endpoint, <code class="literal">pt</code>, minus the first endpoint, <code class="literal">End1.pt</code>.</p><p>Finally, we compute the initial length of the spring by taking
        the magnitude of <code class="literal">r</code> and storing the
        result in the spring’s <code class="literal">InitialLength</code> property.</p><p>With the first spring out of the way, the <code class="literal">Initialize</code> function enters a loop to set up
        the remaining springs. Proceeding from left to right in <a class="xref" href="ch13.html#linked-chain_setup" title="Figure 13-5. Linked-chain setup">Figure 13-5</a>, the first endpoint, <code class="literal">End1</code>, is connected to the right side of
        <code class="literal">Object[i-1]</code>, and the second
        endpoint, <code class="literal">End2</code>, is connected to the
        left side of <code class="literal">Object[i]</code>. Be aware
        that each endpoint of each spring is specified in different coordinate
        systems. The left end is in the coordinate system of <code class="literal">Object[i-1]</code>, while the right end is in the
        coordinate system of <code class="literal">Object[i]</code>. It
        may seem trivial during this setup, but when things start moving and
        rotating it is critically important to keep these coordinate systems
        straight. Doing so involves transforming each endpoint coordinate from
        the local system of the body to which it’s attached to the global
        coordinate system. This is illustrated as follows:</p><a id="I_programlisting7_id336154"/><pre class="programlisting">        pt = VRotate2D(Objects[i].fOrientation, Springs[i].End2.pt)
              + Objects[i].vPosition;
        r = pt - (VRotate2D(Objects[i-1].fOrientation, Springs[i].End1.pt)
                  + Objects[i-1].vPosition);</pre><p>The first line converts the spring attachment point <code class="literal">End2</code> from the local coordinate system of
        <code class="literal">Object[i]</code> to global coordinates by
        performing a rotation and translation using functions you’ve already
        seen numerous times now. The result is temporarily stored in the local
        variable, <code class="literal">pt</code>. The second line
        converts the spring attachment point <code class="literal">End1</code> from the local coordinate system of
        <code class="literal">Object[i-1]</code> to global coordinates
        and then subtracts the result from <code class="literal">pt</code>, yielding a vector, <code class="literal">r</code>, representing the relative distance
        between the spring’s endpoints. The magnitude of <code class="literal">r</code> is the spring’s initial length. Performing
        these same calculations during the simulation will result in the
        spring’s stretched or compressed length. That calculation is performed
        in <code class="literal">UpdateSimulation</code>.</p></div><div class="sect3" title="Update"><div class="titlepage"><div><div><h4 class="title" id="update">Update</h4></div></div></div><p>The function <code class="literal">UpdateSimulation</code>
        is substantially <a id="si13.3.1.3" class="indexterm"/>the same as that discussed in the rope example. There
        are a few differences that we’ll highlight here. Again, these
        differences are due to the fact that we’re now dealing with rigid
        bodies that rotate rather than simple particles. The following code
        sample shows the additions to <code class="literal">UpdateSimulation</code>. You can see there are a
        couple of new variables, <code class="literal">M</code> and
        <code class="literal">Fo</code>. <code class="literal">M</code> is used to temporarily store moments due
        to spring forces <code class="literal">Fo</code> in the local
        coordinates of each <code class="literal">Object</code>.</p><p>Just as the property <code class="literal">vSprings</code> was initialized to 0
          at the start of <code class="literal">UpdateSimulation</code>, so too must we
          initialize <code class="literal">vMSprings</code> to 0. Recall, <code class="literal">vSprings</code> aggregates the spring forces acting on each <code class="literal">Object</code>. For rigid bodies that rotate, we’ll use <code class="literal">vMSprings</code> to aggregate the moments on each <code class="literal">Object</code> resulting from those spring forces:</p><a id="I_programlisting7_id336348"/><pre class="programlisting">void    UpdateSimulation(void)
{
    .
    .
    .
    Vector    M;
    Vector    Fo;

    // Initialize the spring forces and moments on each object to zero.
    for(i=0; i&lt;_NUM_OBJECTS; i++)
    {
        .
        .
        .

        Objects[i].vMSprings.x = 0;
        Objects[i].vMSprings.y = 0;
        Objects[i].vMSprings.z = 0;
    }

    // Calculate all spring forces based on positions of connected objects
    for(i=0; i&lt;_NUM_SPRINGS; i++)
    {
        if(Springs[i].End1.ref == −1)
        {
            pt1 = Springs[i].End1.pt;
            v1.x = v1.y = v1.z = 0; // point is not moving
        } else {
            j = Springs[i].End1.ref;
            pt1 = Objects[j].vPosition + VRotate2D(Objects[j].fOrientation,
                                                   Springs[i].End1.pt);
            v1 = Objects[j].vVelocity + VRotate2D(Objects[j].fOrientation,
                 Objects[j].vAngularVelocity^Springs[i].End1.pt);
        }

        if(Springs[i].End2.ref == −1)
        {
            pt2 = Springs[i].End2.pt;
            v2.x = v2.y = v2.z = 0;
        } else {
            j = Springs[i].End2.ref;
            pt2 = Objects[j].vPosition + VRotate2D(Objects[j].fOrientation,
                                                   Springs[i].End2.pt);
            v2 = Objects[j].vVelocity + VRotate2D(Objects[j].fOrientation,
                 Objects[j].vAngularVelocity^Springs[i].End2.pt);
        }

        // Compute spring-damper force.
        vr = v2 - v1;
        r = pt2 - pt1;
        dl = r.Magnitude() - Springs[i].InitialLength;
        f = Springs[i].k * dl;
        r.Normalize();
        F = (r*f) + (Springs[i].d*(vr*r))*r;

        // Aggregate the spring force on each connected object
        j = Springs[i].End1.ref;
        if(j != −1)
            Objects[j].vSprings += F;

        j = Springs[i].End2.ref;
        if(j != −1)
            Objects[j].vSprings −= F;


        // convert force to first ref local coords
        // Get local lever
        // calc moment

        // Compute and aggregate moments due to spring force
        // on each connected object.
        j = Springs[i].End1.ref;
        if(j != −1)
        {
            Fo = VRotate2D(-Objects[j].fOrientation, F);
            r = Springs[i].End1.pt;
            M = r^Fo;
            Objects[j].vMSprings += M;
        }

        j = Springs[i].End2.ref;
        if(j!= −1)
        {
            Fo = VRotate2D(-Objects[j].fOrientation, F);
            r = Springs[i].End2.pt;
            M = r^Fo;
            Objects[j].vMSprings −= M;
        }
    }
    .
    .
    .
    // Integrate equations of motion as usual.
    .
    .
    .
    // Render the scene as usual.
    .
    .
    .
}</pre><p>As in the rope example, <code class="literal">UpdateSimulation</code> steps through all the
        <code class="literal">Springs</code>, computing their stretched
        or compressed length, the relative velocity of each spring’s
        endpoints, and the resulting spring forces. These calculations are a
        bit different in this current example because we have to handle
        rotation, as explained earlier.</p><p>Upon entering the <code class="literal">for</code> loop in
        the preceding code sample, <code class="literal">End1</code> of
        the current spring is checked to see if it’s connected to a fixed
        point in space. If so, the temporary variable <code class="literal">pt1</code> stores the global coordinates of the
        endpoint, and the variable <code class="literal">v1</code>
        stores the velocity of the endpoint, which is 0. If the endpoint
        reference is a valid <code class="literal">Object</code>, then
        we compute the position of the endpoint, stored in <code class="literal">pt1</code>, just like we did in the <code class="literal">Initialize</code> function, using a coordinate
        transform as follows:</p><a id="I_programlisting7_id336442"/><pre class="programlisting">pt1 = Objects[j].vPosition + VRotate2D(Objects[j].fOrientation,
                                       Springs[i].End1.pt);</pre><p>We compute the velocity of that point as shown in <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a> by first computing the velocity of
        the point due to rotation in body-fixed coordinates, converting that
        to global coordinates, and then adding the result to the <code class="literal">Object</code>’s <a id="I_indexterm7_id336465" class="indexterm"/><a id="I_indexterm7_id336476" class="indexterm"/>linear velocity. This is accomplished in the following
        code:</p><a id="I_programlisting7_id336488"/><pre class="programlisting">v1 = Objects[j].vVelocity + VRotate2D(Objects[j].fOrientation,
     Objects[j].vAngularVelocity^Springs[i].End1.pt);</pre><p>We then repeat these calculations for the second endpoint of the
        spring.</p><p>Once we’ve obtained the positions and velocities of the spring
        endpoints, we compute the spring-damper force in the same manner as in
        the rope example. The resulting spring forces are aggregated in the
        <code class="literal">vSprings</code> property of each object.
        Note that if the spring endpoint reference is a fixed point in space,
        we do not aggregate the force on that fixed point.</p><p>Since the <code class="literal">Object</code>s are rigid
        bodies here, we now have to compute the moment due to the spring force
        acting on each object. You must do this so that when we integrate the
        <a id="I_indexterm7_id336522" class="indexterm"/>equations of motion, the objects rotate properly.</p><p>For the <code class="literal">Object</code> connected to
        <code class="literal">End1</code> of the current spring, the
        following lines compute the moment:</p><a id="I_programlisting7_id336550"/><pre class="programlisting">            Fo = VRotate2D(-Objects[j].fOrientation, F);
            r = Springs[i].End1.pt;
            M = r^Fo;
            Objects[j].vMSprings += M;</pre><p><code class="literal">Fo</code> is a vector representing
        the spring force computed earlier on the current <code class="literal">Object</code> in the current <code class="literal">Object</code>’s local, body-fixed coordinate
        system. The line:</p><a id="I_programlisting7_id336578"/><pre class="programlisting">            Fo = VRotate2D(-Objects[j].fOrientation, F);</pre><p>transforms <code class="literal">F</code> from global to
        local coordinates of the current <code class="literal">Object</code>, <code class="literal">Object[j]</code>.</p><p><code class="literal">r</code> is set to the local,
        body-fixed coordinates of the spring attachment point for the current
        <code class="literal">Object</code>, and we compute the
        resulting moment by taking the vector cross product of <code class="literal">r</code> with <code class="literal">Fo</code>. The result is stored in the vector
        variable <code class="literal">M</code>, which gets aggregated
        in the <code class="literal">Object</code> property <code class="literal">vMSprings</code>. We then perform these same sorts
        of calculations for the <code class="literal">Object</code>
        connected to the other end of the spring.</p><p>After these calculations, the rest of <code class="literal">UpdateSimulation</code> is the same as that shown
        earlier; the function integrates the equations of motion and renders
        the scene.</p><p>Upon running this simulation, you’ll see the linked chain swing
        down and to the left and then back and forth until the motion dampens
        out. You’ll also notice there’s some stretch to the springs between
        the objects that appears to increase as you look from the lower link
        to the upper link. This is indeed a non-uniform stretch in the
        springs, which makes sense when you consider that the upper spring has
        more weight, thus more force, pulling down on it than does the lower
        spring.</p><p>As in this rope example, you can tune the spring and damping
        constants to minimize the spring stretch if that gap created by the
        stretched spring bothers you. You must keep in mind numerical
        stability if your springs are too stiff, and here again, you must
        implement a robust <a id="I_indexterm7_id336684" class="indexterm"/>integrator.</p></div></div><div class="sect2" title="Rotational Restraint"><div class="titlepage"><div><div><h3 class="title" id="rotational_restraint">Rotational Restraint</h3></div></div></div><p>So far we’ve used springs only to attach objects in a way that keeps the attachment
        points together but allows the objects to rotate about the attachment point. This is a
        so-called <span class="emphasis"><em>pinned joint</em></span>. <a id="I_indexterm7_id336711" class="indexterm"/><a id="ro13.3.2" class="indexterm"/><a id="rr13.3.2" class="indexterm"/>If you want a fixed joint that minimizes the amount of rotation between the
        connected objects, you can add another spring to restrain the connected objects’
        rotation.</p><p><a class="xref" href="ch13.html#rotation_restraint_setup" title="Figure 13-6. Rotation restraint setup">Figure 13-6</a> illustrates an example
      comprising two rigid objects connected at their ends, forming a
      ninety-degree angle. The uppermost end of the first object is connected
      to a fixed point in space as in our rope and linked-chain examples.
      Under gravity, the assembly would rotate and swing around this fixed
      point. However, unlike the linked-chain example, the extra spring
      prevents the lower link from pivoting around the other end of the first
      link, as illustrated in <a class="xref" href="ch13.html#rotation_restraint_in_action" title="Figure 13-7. Rotation restraint in action">Figure 13-7</a>.</p><div class="figure"><a id="rotation_restraint_setup"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id336773"/><img style="width: 212.59842519685; " src="httpatomoreillycomsourceoreillyimages1598959.png" alt="Rotation restraint setup"/></div></div><div class="figure-title">Figure 13-6. Rotation restraint setup</div></div><div class="figure"><a id="rotation_restraint_in_action"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id336804"/><img src="httpatomoreillycomsourceoreillyimages1598960.png" alt="Rotation restraint in action"/></div></div><div class="figure-title">Figure 13-7. Rotation restraint in action</div></div><p>The setup for this example is relatively straightforward and
      consists of setting the initial positions and orientations of two rigid
      bodies and connecting three springs.</p><p>This example’s <code class="literal">Initialize</code>
      function is as follows:</p><a id="I_programlisting7_id336837"/><pre class="programlisting">bool    Initialize(void)
{
    Vector    r;
    Vector    pt;
    int       i;

    // Position objects
    Objects[0].vPosition.x = _WINWIDTH/2;
    Objects[0].vPosition.y = _WINHEIGHT/8+Objects[0].fLength/2;
    Objects[0].fOrientation = 90;

    Objects[1].vPosition.x = _WINWIDTH/2+Objects[1].fLength/2;
    Objects[1].vPosition.y = _WINHEIGHT/8+Objects[0].fLength;
    Objects[1].fOrientation = 0;

    // Connect end of the first object to the earth:
    Springs[0].End1.ref = −1;
    Springs[0].End1.pt.x = _WINWIDTH/2;
    Springs[0].End1.pt.y = _WINHEIGHT/8;

    Springs[0].End2.ref = 0;
    Springs[0].End2.pt.x = -Objects[0].fLength/2;
    Springs[0].End2.pt.y = 0;

    pt = VRotate2D(Objects[0].fOrientation, Springs[0].End2.pt) +
         Objects[0].vPosition;
    r = pt - Springs[0].End1.pt;

    Springs[0].InitialLength = r.Magnitude();
    Springs[0].k = _SPRING_K;
    Springs[0].d = _SPRING_D;

    // Connect other end of first object to end of second object
    i = 1;
    Springs[i].End1.ref = i-1;
    Springs[i].End1.pt.x = Objects[i-1].fLength/2;
    Springs[i].End1.pt.y = 0;

    Springs[i].End2.ref = i;
    Springs[i].End2.pt.x = -Objects[i].fLength/2;
    Springs[i].End2.pt.y = 0;

    pt = VRotate2D(Objects[i].fOrientation, Springs[i].End2.pt) +
         Objects[i].vPosition;
    r = pt - (VRotate2D(Objects[i-1].fOrientation, Springs[i].End1.pt) +
              Objects[i-1].vPosition);

    Springs[i].InitialLength = r.Magnitude();
    Springs[i].k = _SPRING_K;
    Springs[i].d = _SPRING_D;

    // Connect CG of objects to each other
    Springs[2].End1.ref = 0;
    Springs[2].End1.pt.x = 0;
    Springs[2].End1.pt.y = 0;

    Springs[2].End2.ref = 1;
    Springs[2].End2.pt.x = 0;
    Springs[2].End2.pt.y = 0;

    r = Objects[1].vPosition - Objects[0].vPosition;

    Springs[2].InitialLength = r.Magnitude();
    Springs[2].k = _SPRING_K;
    Springs[2].d = _SPRING_D;
}</pre><p>The two <code class="literal">Objects</code> are positioned
      with the lines:</p><a id="I_programlisting7_id336868"/><pre class="programlisting">    Objects[0].vPosition.x = _WINWIDTH/2;
    Objects[0].vPosition.y = _WINHEIGHT/8+Objects[0].fLength/2;
    Objects[0].fOrientation = 90;

    Objects[1].vPosition.x = _WINWIDTH/2+Objects[1].fLength/2;
    Objects[1].vPosition.y = _WINHEIGHT/8+Objects[0].fLength;
    Objects[1].fOrientation = 0;</pre><p>Basically, the first <code class="literal">Object</code>,
      <code class="literal">Object[0]</code>, is located somewhere
      toward the top middle of the screen with an initial rotation of ninety
      degrees so that it stands vertically. The second <code class="literal">Object</code>, <code class="literal">Object[1]</code>, is positioned so that it lies
      horizontally with its left end coincident with the lower end of the
      first object. We’ll put a spring there momentarily, but first, we’ll
      connect a spring to the upper end of the first object to connect it to a
      fixed point. The following code takes care of that spring using the same
      techniques discussed earlier:</p><a id="I_programlisting7_id336909"/><pre class="programlisting">    // Connect end of the first object to the earth:
    Springs[0].End1.ref = −1;
    Springs[0].End1.pt.x = _WINWIDTH/2;
    Springs[0].End1.pt.y = _WINHEIGHT/8;

    Springs[0].End2.ref = 0;
    Springs[0].End2.pt.x = -Objects[0].fLength/2;
    Springs[0].End2.pt.y = 0;

    pt = VRotate2D(Objects[0].fOrientation, Springs[0].End2.pt) +
         Objects[0].vPosition;
    r = pt - Springs[0].End1.pt;

    Springs[0].InitialLength = r.Magnitude();
    Springs[0].k = _SPRING_K;
    Springs[0].d = _SPRING_D;</pre><p>Now, we connect a spring at the corner formed by the two objects
      using the following code:</p><a id="I_programlisting7_id336923"/><pre class="programlisting">    // Connect other end of first object to end of second object
    i = 1;
    Springs[i].End1.ref = i-1;
    Springs[i].End1.pt.x = Objects[i-1].fLength/2;
    Springs[i].End1.pt.y = 0;

    Springs[i].End2.ref = i;
    Springs[i].End2.pt.x = -Objects[i].fLength/2;
    Springs[i].End2.pt.y = 0;

    pt = VRotate2D(Objects[i].fOrientation, Springs[i].End2.pt) +
         Objects[i].vPosition;
    r = pt - (VRotate2D(Objects[i-1].fOrientation, Springs[i].End1.pt) +
              Objects[i-1].vPosition);

    Springs[i].InitialLength = r.Magnitude();
    Springs[i].k = _SPRING_K;
    Springs[i].d = _SPRING_D;</pre><p>If we stop here, the simulation will behave just like the
      linked-chain example, albeit we’ll have a very short chain. So, to
      prevent rotation at the corner, we’ll add another spring connecting the
      centers of gravity of the objects. You can use other points if you
      desire; we chose the centers of gravity for convenience. The following
      code adds this rotational restraint spring:</p><a id="I_programlisting7_id336941"/><pre class="programlisting">    // Connect CG of objects to each other
    Springs[2].End1.ref = 0;
    Springs[2].End1.pt.x = 0;
    Springs[2].End1.pt.y = 0;

    Springs[2].End2.ref = 1;
    Springs[2].End2.pt.x = 0;
    Springs[2].End2.pt.y = 0;

    r = Objects[1].vPosition - Objects[0].vPosition;

    Springs[2].InitialLength = r.Magnitude();
    Springs[2].k = _SPRING_K;
    Springs[2].d = _SPRING_D;</pre><p>The rest of this simulation is the same as in the linked-chain
      example. There are no other code modifications required. It’s all in the
      setup.</p><p>Now, if you want to allow some amount of rotation or flexibility
      in the joint, you can do so by tuning the spring constant for the
      rotation restraint spring. Using linear springs creatively, you can
      model all sorts of joints <a id="I_indexterm7_id336962" class="indexterm"/><a id="I_indexterm7_id336971" class="indexterm"/><a id="I_indexterm7_id336981" class="indexterm"/><a id="I_indexterm7_id336990" class="indexterm"/><a id="I_indexterm7_id336999" class="indexterm"/><a id="I_indexterm7_id337009" class="indexterm"/><a id="I_indexterm7_id337018" class="indexterm"/><a id="I_indexterm7_id337027" class="indexterm"/><a id="I_indexterm7_id337037" class="indexterm"/>very simply.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 14. Physics Engines</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Rigid-Body Dynamics"/><link rel="prev" href="ch13.html" title="Chapter 13. Connecting Objects"/><link rel="next" href="pt03.html" title="Part III. Physical Modeling"/></head><body><section class="chapter" title="Chapter 14. Physics Engines" epub:type="chapter" id="physics_engines"><div class="titlepage"><div><div><h2 class="title">Chapter 14. Physics Engines</h2></div></div></div><p>A <span class="emphasis"><em>physics engine</em></span> is the part of <a id="I_indexterm8_id337060" class="indexterm"/>your game that contains all the code required for whatever
  you’re trying to simulate using physics-based techniques. For many game
  programmers, a physics engine is a real-time, rigid-body simulator such as
  the sort we’ve discussed earlier in this book. The open source and
  licensable physics engines available to you are typically of the
  rigid-body-simulator variety. Some physics engines are rather generic and
  are useful for general rigid bodies and particles; others include various
  connectors and constraints, enabling ragdoll simulation. Still others focus
  on soft bodies and fluids. Fewer actually focus on the physics of some
  specific thing, like a car or a boat. A simple Internet search on the phrase
  “game physics engine” will generate many links to potential options for your
  use. That said, you could always write your own physics engine.</p><div class="sect1" title="Building Your Own Physics Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="building_your_own_physics_engine">Building Your Own Physics Engine</h2></div></div></div><p>We’re advocates of <a id="ph14.1" class="indexterm"/>using physics where you need it. Sure, you can write a
    general-purpose physics engine for a game, but if you’re creating a game
    that doesn’t require a general-purpose physics engine, then don’t write
    one. That may sound obvious, but sometimes we are compelled to do more
    than what we need just so we can say we did it. Aside from the effort
    <a id="I_indexterm8_id337113" class="indexterm"/>involved, a general-purpose physics engine will probably be
    less efficient than a purpose-built physics engine. By
    <span class="emphasis"><em>purpose-built</em></span>, we <a id="I_indexterm8_id337129" class="indexterm"/>mean designing the physics engine specifically to suit what
    you’re trying to simulate. For example, a general-purpose physics engine
    would surely include particles, rigid bodies, connectors, other force
    effectors, and who knows what else—fluids, perhaps—and be fully 3D. But if
    you’re writing a 2D side-scrolling game for a smartphone, you certainly
    won’t need 3D with the associated complexities involved in dealing with
    rotation and collisions in 3D; and if your game simply involves throwing a
    ball of fuzz at some arbitrary junk, then you may not even need to deal
    with rigid bodies at all. We’re being somewhat facetious here, but the
    point is, unless you <span class="emphasis"><em>must</em></span> write a general-purpose
    physics engine—say, if you plan to license it as a middleware product or
    use it in a variety of game types—then don’t write one. Instead, write one
    specifically optimized for the game you’re working on.</p><p>Let’s consider a few examples. Let’s say you’re writing a 3D
    first-person <a id="I_indexterm8_id337154" class="indexterm"/>shooter and you want to use physics to simulate how wooden
    barrels and crates blow apart when shot. Typically, such an effect would
    show pieces of wood flying off in different directions while falling under
    the influence of gravity. You could simulate such an effect in 3D using
    rigid bodies and you wouldn’t even need to consider collisions, unless you
    wanted the pieces to bounce off each other or other objects. Ignoring
    these aspects greatly simplifies the underlying physics engine. Consider
    another example. Let’s say you’re working on a game involving flying an
    airplane. You can use physics to simulate the flight dynamics, as we
    explain in this book, without the need for particles, connectors, or even
    collision response.</p><p>The point of all this discussion is that you should consider which aspects of your game
      will really benefit from physics and write your physics engine to deal specifically with those
      aspects.</p><p>Another thing to consider is whether or not you need real-time physics. You might expect,
      after reading the available game physics literature, that your game must include real-time
      simulations <a id="I_indexterm8_id337183" class="indexterm"/><a id="I_indexterm8_id337193" class="indexterm"/>if it is to incorporate physics. However, there are many ways to include physics
      in a game without having to solve the physics via real-time simulations. We show you an
      example in <a class="xref" href="ch19.html" title="Chapter 19. Sports">Chapter 19</a> whereby a golf swing is <a id="I_indexterm8_id337211" class="indexterm"/><a id="I_indexterm8_id337221" class="indexterm"/>simulated in order to determine club head velocity at the time of club-ball
      impact. In this case, given specific initial parameters, we can solve the swing quickly,
      almost instantaneously, to determine the club speed, which can then be used as an initial
      condition for the ball flight. The ball’s flight can be solved quickly as well and not
      necessarily in real time. It really depends on how you want to present the result to the
      player. If your game involves following the flight of the ball as it soars through the air,
      then you might want to simulate its flight in real time so you can realistically move the ball
      and camera. If, however, you simply want to show where the ball ends up, then you need not
      perform the simulation in real time. For such a simple problem, you can solve for the final
      ball location quicker than real time. Sometimes, the action you’re simulating may happen so
      fast in real life that you’ll want to slow it down for your game. Following a golf ball’s
      flight in real time might have the camera moving so fast that your player won’t be able to
      enjoy the beautifully rendered bird’s-eye view of the course. In this case, you rapidly solve
      the flight path, save the data, and then animate the scene at a more enjoyable pace of your
      choosing.</p><p>We don’t want to come across as trying to talk you out of writing a
    physics engine if you so choose. The point of our discussion so far is
    that you simply don’t have to write a generic, real-time physics engine in
    order to use physics in your games. You have other options as we’ve just
    explained.</p><p>Assuming that, after all these considerations, you need to write a
    physics engine, then we have the following to offer.</p><p>A physics engine is just one component of a <a id="I_indexterm8_id337258" class="indexterm"/>game engine. The other components include the graphics engine, audio engine, AI
      engine, and whatever other engines you may require or whatever other components of a game you
      may elevate to the status of engine. Whatever the case, the physics engine handles the
      physics. Depending on whom you talk to, you’ll get different ideas on what composes a physics
      engine. Some will say that the heart of the physics engine is the collision detection module.
      Well, what if your game doesn’t require collision detection, yet it still uses physics to
      simulate certain behaviors or features? Then collision detection certainly cannot be the heart
      of your physics engine. Some programmers will certainly take issue with these statements. To
      them, a physics engine simulates rigid-body motion using Newtonian dynamics while taking care
      of <a id="I_indexterm8_id337273" class="indexterm"/><a id="I_indexterm8_id337283" class="indexterm"/><a id="I_indexterm8_id337292" class="indexterm"/><a id="I_indexterm8_id337302" class="indexterm"/>collision detection and response. To us, a significant component of a physics
      engine is the model—that is, the idealization of the thing you’re trying to simulate in a
      realistic manner. You cannot realistically simulate the flight characteristics of a specific
      aircraft by treating it as a generic rigid body. You have to develop a representative model of
      that aircraft including very specific features; otherwise, it’s a hack (which, by the way, we
      recognize as a valid and long-established approach).</p><p>Earlier, in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> and <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>, we showed you several example <a id="I_indexterm8_id337331" class="indexterm"/>simulations. While simple, these examples include many of the required components
      of a generic physics engine. There are the particle and rigid-body classes that encapsulate
      generic object properties and behaviors, physics models that govern object behaviors,
      collision detection and response systems, and a numerical integrator. Additionally, those
      examples include interfacing the physics code with user input and visual feedback. These
      examples also show the basic flow from user input to physics solver to visual feedback.</p><p>In summary, the major components of a generic physics engine
    <a id="I_indexterm8_id337350" class="indexterm"/>include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Physics models</p></li><li class="listitem"><p>Simulated objects manager</p></li><li class="listitem"><p>Collision detection engine or interface thereto</p></li><li class="listitem"><p>Collision response module</p></li><li class="listitem"><p>Force effectors</p></li><li class="listitem"><p>Numerical integrator</p></li><li class="listitem"><p>Game engine interface</p></li></ul></div><div class="sect2" title="Physics Models"><div class="titlepage"><div><div><h3 class="title" id="physics_models">Physics Models</h3></div></div></div><p>Physics models are <a id="I_indexterm8_id337432" class="indexterm"/><a id="I_indexterm8_id337442" class="indexterm"/><a id="I_indexterm8_id337452" class="indexterm"/>the idealizations of the things you’re simulating. If your physics engine is a
        generic rigid-body simulator used to simulate an assortment of solid objects your players
        can knock around, throw, shoot, and generally interact with in a basic manner, then the
        physics model will probably be very generic. It’s probably safe to assume that each object
        will be subject to gravity’s pull, thus mass will be an important attribute. Size will also
        be important, not only because you’ll need to know how big things are when checking for
        collisions and handling other interactions, but also because size is related to the
        distribution of the object’s mass. More precisely, each object will <a id="I_indexterm8_id337466" class="indexterm"/>have <span class="emphasis"><em>mass moment of inertia</em></span> attributes. The objects will
        most likely also have some ascribed <a id="I_indexterm8_id337480" class="indexterm"/>coefficient of restitution that will be used during collision response handling.
        Additionally, you might ascribe some friction coefficients <a id="I_indexterm8_id337493" class="indexterm"/>that may be used during collision response or in situations where the objects
        may slide along a floor. As the objects will likely find themselves airborne at some point,
        you’ll probably also include a drag coefficient <a id="I_indexterm8_id337503" class="indexterm"/>for each object. All of these parameters will help you differentiate massive
        objects from lighter ones or compact objects from voluminous ones.</p><p>If your simulation involves more than generic rigid bodies, then
      your physics will be more specific and perhaps far more elaborate. A
      great example of a more complicated model is flight simulation. No
      matter how good your generic rigid-body model, it won’t fly like any
      specific aircraft if it flies at all. You must develop a model that
      captures flight aerodynamics specific to the aircraft you’re simulating.
      <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a> shows how to put together a model for an
      aircraft that can be used in a real-time flight simulation.</p><p>The other chapters in Part IV of this book are meant to give you a
      taste of modeling aspects for a variety of things you might simulate in
      a game. Just as you cannot simulate an aircraft with a generic
      rigid-body model, you cannot simulate a ship with an aircraft model, nor
      can you simulate a golf ball with a ship model. The point is that you
      must spend some time designing your physics model specific to what
      you’re going to simulate in your game. Time spent here is just as
      important to creating a realistic physics engine as time spent on
      designing a robust integration scheme or collision detection system. We
      can’t overstate the importance of the physical model. The model is what
      defines the behavior of the thing you’re simulating.</p></div><div class="sect2" title="Simulated Objects Manager"><div class="titlepage"><div><div><h3 class="title" id="simulated_objects_manager">Simulated Objects Manager</h3></div></div></div><p>Your simulated objects manager will be <a id="I_indexterm8_id337552" class="indexterm"/><a id="I_indexterm8_id337562" class="indexterm"/><a id="I_indexterm8_id337568" class="indexterm"/>responsible for instantiating, initializing, and disposing
      of objects. It will also be responsible for maintaining links between
      object physics and other attributes such as geometry, for example, if in
      a 3D simulation you use the same polyhedron to render an object and for
      collision detection and response.</p><p>You must have some means of managing the objects in your simulation. One can imagine
        many different approaches to managing these objects, and unless your simulation uses just a
        handful of objects or fewer, essentially what you need is a list of objects of whatever
        class you’ve defined. You’ve seen in previous chapters’ examples where we use simple arrays
        of <code class="literal">RigidBody</code> type objects or <code class="literal">Particle</code> type objects. If all the objects in your simulation are the same, then
        you need only a single class capturing all their behavior. However, for more diversity, you
        should use a list of various classes with each class encapsulating the code required to
        implement its own physical model. This is particularly important with respect to the forces
        acting on the model. For example, you could have some objects representing projectiles with
        others representing aircraft. These different classes will share some common code (for
        example, collision detection); however, the way forces are computed on each will vary due to
        the differences in how they are modeled. With such an approach, each class must have code
        that implements its particular model. During integration, the entire list will be traversed,
        calling the force aggregation method for each object, and the particular class will handle
        the details suitable for the type of object.</p><p>In some simple cases, you need not use different object classes if
      the types of objects you plan to use are not too different. For example,
      it would be fairly straightforward to implement a single class capable
      of handling both particles and rigid bodies. The object class could
      include an object type property used to denote whether the object is a
      particle or a rigid body, and then the class methods would call the
      appropriate code. Again, this will work satisfactorily for simple
      objects with few differences. If you want to simulate more than two
      types of objects or if they are very different, you’re probably better
      off using different classes specific to each object being
      simulated.</p><p>However you structure your classes or lists, the flow of
      processing your objects will generally be the same. Every physics
      <span class="emphasis"><em>tick</em></span>—that is, every time step in the physics
      simulation—you must check for object collisions, resolve those
      collisions, aggregate the usual forces on each object, integrate the
      equations of motion for each object, and then update each object’s
      state.</p><p>As we said, this is the general flow at every physics tick, or
      time step, which may not be the same as your <a id="I_indexterm8_id337634" class="indexterm"/>rendering steps. For example, for accuracy in your
      simulation you may have to take small steps around a millisecond or so.
      You wouldn’t want to update the graphics every millisecond when you need
      only about a third as many graphics updates per second. Thus, your
      objects manager will have to be integrated with your overall game
      engine, and your game engine must be responsible for making sure the
      physics and graphics are updated appropriately.</p></div><div class="sect2" title="Collision Detection"><div class="titlepage"><div><div><h3 class="title" id="collision_detection">Collision Detection</h3></div></div></div><p>If collisions are an <a id="I_indexterm8_id337663" class="indexterm"/><a id="I_indexterm8_id337673" class="indexterm"/>important part of your game, then a robust collision
      detection system is required.</p><p>Your collision detection system is distinct from the collision
      response system or module, though the two go hand in hand. Collision
      detection <a id="I_indexterm8_id337690" class="indexterm"/>is the computational geometry problem of determining if
      objects collide and, if so, what points are making contact. These points
      are sometimes called <a id="I_indexterm8_id337702" class="indexterm"/>the <span class="emphasis"><em>contact manifold</em></span>. They’re just
      the points that are touching, which could be a line or surface, though
      for simplicity usually the point, end points, or points defining the
      contact surface boundary are all that are included in the contact
      manifold.</p><p>The collision detection system’s role is very specific: determine
      which objects are colliding, what points on each object are involved in
      the collision, and the velocities of those points. It sounds
      straightforward, but actual implementation can get quite complex. There
      are situations where fast-moving objects may go right though other
      objects, especially thin ones, over a single time step, making the
      <a id="I_indexterm8_id337724" class="indexterm"/><a id="I_indexterm8_id337734" class="indexterm"/>collision detection system miss the collision if it relies
      solely on checking the separation distance between objects and their
      relative velocity (i.e., it detects a collision if the objects are
      within some collision tolerance and are also moving toward each other).
      A robust collision detection system will capture this situation and
      respond accordingly. In <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> we simply check if
      particles moved past the ground over the course of a single time step,
      for example, and then reset their position to that of the ground plane
      level. We can handle many situations using such simple techniques,
      especially when dealing with objects passing through floors or walls;
      however, other situations may require more complex algorithms to predict
      if a collision will occur sometime in the near future depending on how
      fast objects are moving relative to each other. This latter case is
      <a id="I_indexterm8_id337758" class="indexterm"/><a id="I_indexterm8_id337764" class="indexterm"/>called <span class="emphasis"><em>continuous</em></span> collision
      detection, and it is covered in many Internet, book, and technical paper
      sources. Many commercial and open source physics engines advertise their
      capability to handle continuous collision detection.</p><p>Another challenge associated with collision detection is the fact
      that it can be very time-consuming if you have a large or even moderate
      number of objects in your simulation. There are various techniques to
      deal with this. First, the <a id="I_indexterm8_id337785" class="indexterm"/>game space is partitioned in some coarse grid-like manner,
      and this grid is used to organize objects depending on which cell they
      occupy. Then, in the second phase of collision detection, only those
      <a id="I_indexterm8_id337794" class="indexterm"/>objects occupying adjacent cells are checked against each
      other to see if they are colliding. Without this grid partitioning,
      pairwise checks of every object against every other object would be very
      computationally expensive. The second phase of collision detection is
      often a broad approach using <a id="I_indexterm8_id337808" class="indexterm"/><a id="I_indexterm8_id337814" class="indexterm"/><a id="I_indexterm8_id337824" class="indexterm"/>bounding spheres or bounding boxes, which may be axis- or
      body-aligned. If the bounding spheres or boxes of each object are found
      to collide, then the objects likewise may be colliding and further
      checks will be required; otherwise, we can infer that the objects are
      not colliding. In the case of a potential collision, these further
      checks become more complex depending on the geometry of the objects.
      This phase generally involves polygon- and vertex-level checks; there
      are well-established techniques for performing such checks that we won’t
      get into here. Again, there’s a wealth of literature on collision
      detection available online.</p></div><div class="sect2" title="Collision Response"><div class="titlepage"><div><div><h3 class="title" id="collision_response">Collision Response</h3></div></div></div><p>Once the collision <a id="I_indexterm8_id337849" class="indexterm"/><a id="I_indexterm8_id337860" class="indexterm"/>detection system does its job, it’s time for the collision
      response system to deal with the colliding objects. Earlier in this
      book, we showed you how to implement an <a id="I_indexterm8_id337872" class="indexterm"/><a id="I_indexterm8_id337879" class="indexterm"/><a id="I_indexterm8_id337889" class="indexterm"/>impulse-moment collision response method. Recall that this
      method assumes that at the instant of collision, the most significant
      forces acting on the objects are the collision forces, so all other
      forces can be ignored for that instant. The method then computes the
      resulting velocities of the objects after colliding and instantly
      changes their velocities accordingly. To perform the required
      calculations, the collision response system requires the objects
      colliding, of course, the collision points, and the velocities of those
      points. Also, each object must have some associated mass and <a id="I_indexterm8_id337905" class="indexterm"/>coefficient of restitution, which are likewise used to
      compute the resulting velocities of the objects after the
      collision.</p><p>In practice, the collision response system works <a id="I_indexterm8_id337921" class="indexterm"/><a id="I_indexterm8_id337931" class="indexterm"/>hand in hand with the collision detection system,
      particularly when dealing with objects that may be penetrating each
      other. As we mentioned earlier, in many cases an object <a id="I_indexterm8_id337944" class="indexterm"/><a id="I_indexterm8_id337950" class="indexterm"/>penetrating another, such as an object penetrating a wall
      or floor, can simply be moved so that it is just touching the wall or
      floor. Other cases may be more complicated, and iterative algorithms are
      used to resolve the penetration. For example, if penetration is
      detected, then the simulation may back up to the previous time step and
      take a short time step to see if penetration still occurs. If it does
      not, the simulation proceeds; otherwise, the simulation takes an even
      smaller time step. This process repeats until penetration does not
      occur. This works fine in many cases; however, sometimes the penetration
      is never resolved and the simulation could get stuck taking smaller and
      smaller time steps. This failure to resolve could be attributed to
      objects that are just outside the collision distance tolerance at one
      instant, and due to numerical errors, exceedingly small time steps are
      required to stay outside of the <a id="I_indexterm8_id337969" class="indexterm"/>distance tolerance. Some programmers simply put an
      iteration limit in the code to prevent the simulation from getting
      stuck, but the consequences in every situation may be unpredictable. The
      continuous collision detection approach we mentioned earlier avoids this
      sort of problem by predicting the future collision or penetration and
      dealing with it ahead of time. Whatever the approach, there will be some
      back and forth and data exchange between your collision detection and
      response systems to avoid excessive penetration situations.</p><p>Additionally, there are situations when an object may come to rest
      in contact with another—for example, a box resting on the floor. There
      are many ways to deal with such <a id="I_indexterm8_id337988" class="indexterm"/>contact situations, one of which is to just allow the
      impulse-momentum approach to deal with it. This works just fine in many
      cases; however, sometimes the objects in resting contact will jitter
      with the impulse-momentum approach. One resolution to this jittering
      problem is to put those <a id="I_indexterm8_id338002" class="indexterm"/><a id="I_indexterm8_id338012" class="indexterm"/>objects to sleep—that is, if they are found to be
      colliding, but their relative velocities are smaller than some
      tolerance, they are put to sleep. A related but somewhat more
      complicated approach is to compute the contact normal between the object
      and the floor and set that velocity to 0. This serves as a constraint,
      preventing the object from penetrating the floor while still allowing it
      to slide along the floor.</p></div><div class="sect2" title="Force Effectors"><div class="titlepage"><div><div><h3 class="title" id="force_effectors">Force Effectors</h3></div></div></div><p>Force effectors <a id="I_indexterm8_id338037" class="indexterm"/><a id="I_indexterm8_id338047" class="indexterm"/><a id="I_indexterm8_id338053" class="indexterm"/>apply direct or indirect force on the objects in your
      simulations. Your physics engine may include several. For example, if
      your engine allows users to move objects around with the mouse, then
      you’ll need some virtualization of the force applied by the user via the
      mouse or a finger on a touch screen. This is an example of a direct
      force. Another <a id="I_indexterm8_id338068" class="indexterm"/>direct force effector could be a virtual jet engine. If
      you associate that virtual engine, which produces some thrust force,
      with some object, then the associated object will behave as though it
      were pushed around by the jet.</p><p>Some examples of indirect force effectors<a id="I_indexterm8_id338081" class="indexterm"/> include gravity and wind. <a id="I_indexterm8_id338089" class="indexterm"/><a id="I_indexterm8_id338101" class="indexterm"/>Gravity applies force on objects by virtue of their mass,
      but it is typically modeled as body acceleration and not an explicit
      force. Wind can be viewed as exerting a pressure force on an object, and
      that force will be a function of the object’s size and drag
      coefficients.</p><p>You can imagine all sorts of force effectors, from ones similar to
      those just described to perhaps some otherworldly ones. Whatever you
      imagine, you must remember that a force has magnitude, direction, and
      some central point of application. If you put a jet engine on the side
      of a box, the box will not only translate but will spin as well. Wind
      creates a force that has a<a id="I_indexterm8_id338124" class="indexterm"/><a id="I_indexterm8_id338130" class="indexterm"/> center of pressure, which is the point through which you
      can assume the total wind force acts. The direction of the force and
      point of application are important for capturing both translation and
      rotation. As an example, consider the <a id="I_indexterm8_id338143" class="indexterm"/>hovercraft we modeled in <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a> that included two bow thrusters for
      steering and a propeller for forward motion. Each of these direct force
      effectors—the bow thrusters and the propeller—is applied at specific
      locations on the hovercraft. The bow thrusters are located toward the
      bow and point sideways in order to create spin, thus allowing some
      steering. The propeller is located on the center line of the hovercraft,
      which passes through the hovercraft’s center of gravity so that it does
      not create spin and instead simply pushes the craft forward. There’s
      another force effector in <a id="I_indexterm8_id338164" class="indexterm"/>that model—aerodynamic drag, which is an indirect force
      effector. The drag force is applied at a point aft of the center of
      gravity so that it creates some torque, or moment, which in this model
      helps keep the hovercraft pointed straight; it provides some directional
      stability.</p><p>Whatever force effectors you contrive, they all must be aggregated
      for each object and dealt with in your numerical integrator. Thus, your
      integrator must have some means of accessing all the force effector
      information required to accurately simulate their effect on each
      associated object.</p></div><div class="sect2" title="Numerical Integrator"><div class="titlepage"><div><div><h3 class="title" id="numerical_integrator">Numerical Integrator</h3></div></div></div><p>The integrator is responsible <a id="I_indexterm8_id338197" class="indexterm"/><a id="I_indexterm8_id338208" class="indexterm"/><a id="I_indexterm8_id338214" class="indexterm"/><a id="I_indexterm8_id338225" class="indexterm"/>for solving the equations of motion for each object. We
      showed you how to do this earlier, in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a> through <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>. In your generic physics engine you’ll
      iterate through all the objects in the simulation to compute their new
      velocities, positions, and orientations at every time step. To make
      these calculations, your integrator must have access to the force
      effectors associated with each object. The forces will be used to
      compute accelerations, which will then be integrated to compute
      velocities, and those in turn will be used to compute positions and
      orientations.</p><p>You can handle aggregating the <a id="I_indexterm8_id338253" class="indexterm"/>forces in a few ways. You could aggregate all the forces on all objects prior to
        looping through the objects integrating the equations of motion, but this would require
        looping through all the objects twice. Alternatively, since you’re looping through the
        object list in order to integrate each object’s equations of motion, you can simply
        aggregate each <a id="I_indexterm8_id338268" class="indexterm"/>object’s forces during the integration step. A complication arises when object
        pairs apply forces to each other. A linear spring and damper, for example, connected between
        two objects, apply equal and opposite forces to each object. The force is a function of the
        relative distance between the objects (the spring component) and their relative velocity
        (the damping component). So, if during a given time step you aggregate the forces on one of
        the objects in the pair, the resulting force will be a function of the current relative
        position and velocities of the objects. Integrating that object will give it a new position
        and velocity. Then, when you get to the other object in the pair, if you recomputed the
        spring force, it will be a function of the new relative position and velocity between the
        objects that includes the new displacement and velocity of the previously updated object but
        the old displacement and velocity of the current object. This is inconsistent with Newton’s
        law of <a id="I_indexterm8_id338288" class="indexterm"/><a id="I_indexterm8_id338298" class="indexterm"/><a id="I_indexterm8_id338308" class="indexterm"/>equal and opposite forces. You can resolve this problem by storing the force
        computed for the first object and applying it to the second one without recomputing the
        spring force for the second object.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 15. Aircraft</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Physical Modeling"/><link rel="prev" href="pt03.html" title="Part III. Physical Modeling"/><link rel="next" href="ch16.html" title="Chapter 16. Ships and Boats"/></head><body><section class="chapter" title="Chapter 15. Aircraft" epub:type="chapter" id="aircraft"><div class="titlepage"><div><div><h2 class="title">Chapter 15. Aircraft</h2></div></div></div><p>If you are going to write a <a id="I_indexterm1_id338361" class="indexterm"/>flight simulation game, one of the most important aspects of
  your <a id="I_indexterm1_id338372" class="indexterm"/>game engine will be your flight model. Yes, your 3D graphics,
  user interface, story, avionics system simulation, and coding are all
  important, but what really defines the behavior of the aircraft that you are
  simulating is your flight model. Basically, this is your simplified version
  of the physics of aircraft flight—that is, your assumptions, approximations,
  and all the formulas you’ll use to calculate mass, inertia, and lift and
  drag forces and moments.</p><p>There are four major <a id="I_indexterm1_id338389" class="indexterm"/><a id="I_indexterm1_id338402" class="indexterm"/>forces that act on an airplane in flight: gravity, lift,
  thrust, and drag. <a id="I_indexterm1_id338413" class="indexterm"/>Gravity, of course, is the force that tends to pull the
  aircraft to the ground, while <a id="I_indexterm1_id338425" class="indexterm"/>lift is the force generated by the wings (or lifting surfaces)
  of the aircraft to counteract gravity and enable the plane to stay aloft.
  The <a id="I_indexterm1_id338437" class="indexterm"/>thrust force generated by the aircraft’s propulsor (jet engine
  or propeller) increases the aircraft’s velocity and enables the lifting
  surfaces to generate lift. Finally, drag <a id="I_indexterm1_id338450" class="indexterm"/>counteracts the thrust force, tending to impede the aircraft’s
  motion. <a class="xref" href="ch15.html#forces_on_aircraft_in_flight" title="Figure 15-1. Forces on aircraft in flight">Figure 15-1</a> illustrates these
  forces.</p><div class="figure"><a id="forces_on_aircraft_in_flight"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id338476"/><img src="httpatomoreillycomsourceoreillyimages1598961.png" alt="Forces on aircraft in flight"/></div></div><div class="figure-title">Figure 15-1. Forces on aircraft in flight</div></div><p>We’ve already discussed the force due to gravity in earlier chapters,
  so we won’t address it again in this chapter except to say that the total of
  all lift forces must be greater than or equal to the gravitational force if
  an aircraft is to maintain flight.</p><p>To address the other three forces acting on an aircraft, we’ll refer
  to a simplified, generic model of an airplane and use it as an illustrative
  example. There are far too many aircraft types and configurations to treat
  them all in this short chapter. Moreover, the subject of aerodynamics is too
  broad and complex. Therefore, the model that we’ll look at will be of a
  typical subsonic configuration, as shown in <a class="xref" href="ch15.html#model_configuration" title="Figure 15-2. Model configuration">Figure 15-2</a>.</p><div class="figure"><a id="model_configuration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id338522"/><img src="httpatomoreillycomsourceoreillyimages1598962.png" alt="Model configuration"/></div></div><div class="figure-title">Figure 15-2. Model configuration</div></div><p>In this configuration the main lifting surfaces (the large wings) are
  located forward on the aircraft, with relatively smaller lifting surfaces
  located toward the tail. This is the basic arrangement of most aircraft in
  existence today.</p><p>We’ll have to make some assumptions in order to make even this
  simplified model manageable. Further, we’ll rely on empirical data and
  formulas for the calculation of lift and drag forces.</p><div class="sect1" title="Geometry"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="geometry">Geometry</h2></div></div></div><p>Before getting into lift, drag, and thrust, <a id="I_indexterm1_id338565" class="indexterm"/>we need to go over some basic geometry and terms to make
    sure we are speaking the same language. Familiarity with these terms will
    also help you quickly find what you are looking for when searching through
    the references that we’ll provide later.</p><p>First, take another look at the arrangement of our model aircraft in
    <a class="xref" href="ch15.html#model_configuration" title="Figure 15-2. Model configuration">Figure 15-2</a>. The main body of the aircraft, the
    part usually occupied by cargo and people, is <a id="I_indexterm1_id338589" class="indexterm"/>called <a id="I_indexterm1_id338600" class="indexterm"/>the <span class="emphasis"><em>fuselage</em></span>. The
    <span class="emphasis"><em>wings</em></span> <a id="I_indexterm1_id338615" class="indexterm"/>are the large rectangular lifting surfaces protruding from
    the fuselage near the forward end. The longer dimension of the wing is
    called its <span class="emphasis"><em>span</em></span>, while <a id="I_indexterm1_id338627" class="indexterm"/>its shorter dimension is called its <span class="emphasis"><em>chord
    length</em></span>, or <a id="I_indexterm1_id338638" class="indexterm"/><a id="I_indexterm1_id338645" class="indexterm"/>simply <span class="emphasis"><em>chord</em></span>. The ratio of span squared
    to wing area is called the <span class="emphasis"><em>aspect ratio</em></span>, and
    <a id="I_indexterm1_id338666" class="indexterm"/>for rectangular wings this reduces to the ratio of
    span-to-chord.</p><p>In our model, the <span class="emphasis"><em>ailerons</em></span> are <a id="I_indexterm1_id338680" class="indexterm"/>located on the outboard ends of the wings. The
    <span class="emphasis"><em>flaps</em></span> are <a id="I_indexterm1_id338692" class="indexterm"/>also located on the wings inboard of the ailerons. The small
    wing-like surfaces located near the tail are called
    <span class="emphasis"><em>elevators</em></span>. And the vertical flap located on the aft
    end of the tail is <a id="I_indexterm1_id338704" class="indexterm"/>the <span class="emphasis"><em>rudder</em></span>. We’ll talk more about what
    <a id="I_indexterm1_id338722" class="indexterm"/>these <span class="emphasis"><em>control surfaces</em></span> do later.</p><p>Taking a close look at a cross section of the wing helps to define a
    few more terms, as shown in <a class="xref" href="ch15.html#airfoil_section" title="Figure 15-3. Airfoil section">Figure 15-3</a>.</p><div class="figure"><a id="airfoil_section"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id338756"/><img src="httpatomoreillycomsourceoreillyimages1598963.png" alt="Airfoil section"/></div></div><div class="figure-title">Figure 15-3. Airfoil section</div></div><p>The airfoil <a id="I_indexterm1_id338779" class="indexterm"/>shown in <a class="xref" href="ch15.html#airfoil_section" title="Figure 15-3. Airfoil section">Figure 15-3</a> is a typical
    <span class="emphasis"><em>cambered</em></span> airfoil. Camber represents the curvature of
    the airfoil. If you draw a straight line from the trailing edge to the
    leading edge, you end up with what’s called the<a id="I_indexterm1_id338801" class="indexterm"/> <span class="emphasis"><em>chord line</em></span>. Now if you divide the
    airfoil into a number of cross sections, like slices in a loaf of bread,
    going from the trailing edge to the leading edge, and then draw a curved
    line passing through the midpoint of each section’s thickness, you end up
    with the<a id="I_indexterm1_id338814" class="indexterm"/> <span class="emphasis"><em>mean camber line</em></span>. The maximum
    difference between the mean camber line and the chord line is a measure of
    the camber of the airfoil. The angle measured between the direction of
    travel of the airfoil (the relative velocity vector of the airfoil as it
    passes through the air) and the chord line is called the <a id="I_indexterm1_id338828" class="indexterm"/>absolute <span class="emphasis"><em>angle of attack</em></span>.</p><p>When an aircraft is in flight, it may rotate about any axis. It is
    standard practice to always refer to an aircraft’s rotations about three
    axes relative to the pilot. Thus, these axes<a id="I_indexterm1_id338851" class="indexterm"/><a id="I_indexterm1_id338857" class="indexterm"/><a id="I_indexterm1_id338867" class="indexterm"/><a id="I_indexterm1_id338876" class="indexterm"/>— the <span class="emphasis"><em>pitch</em></span> axis, the
    <span class="emphasis"><em>roll</em></span> axis, and the <span class="emphasis"><em>yaw</em></span> axis—are
    fixed to the aircraft, so to speak, irrespective of its actual orientation
    in three-dimensional space.</p><p>The pitch axis runs transversely across the aircraft—that is, in the
    port-starboard direction.<sup>[<a id="CHP-15-FN-1" href="#ftn.CHP-15-FN-1" epub:type="noteref" class="footnote">23</a>]</sup> Pitch rotation is when the nose of the aircraft is raised or
    lowered from the pilot’s perspective. The roll axis runs longitudinally
    through the center of the aircraft. Roll motions (rotations) about this
    axis result in the wing tips being raised or lowered on either side of the
    pilot. Finally, the yaw axis is a vertical axis about which the nose of
    the aircraft rotates in the left-to-right (or right-to-left) direction
    with respect to the pilot. These rotations are illustrated in <a class="xref" href="ch15.html#aircraft_rotations" title="Figure 15-4. Aircraft rotations">Figure 15-4</a>.</p><div class="figure"><a id="aircraft_rotations"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id338934"/><img src="httpatomoreillycomsourceoreillyimages1598964.png" alt="Aircraft rotations"/></div></div><div class="figure-title">Figure 15-4. Aircraft rotations</div></div></div><div class="sect1" title="Lift and Drag"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="lift_and_drag">Lift and Drag</h2></div></div></div><p>When an airfoil <a id="ai15.2" class="indexterm"/><a id="fo15.2" class="indexterm"/><a id="li15.2" class="indexterm"/><a id="dr15.2" class="indexterm"/>moves through a fluid such as air, lift is produced. The
    mechanisms by which this occurs are similar to those in the case of the
    Magnus lift force, discussed earlier in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>, in
    that Bernoulli’s law is still in effect. However, this time, instead of
    rotation it’s the airfoil’s shape and <a id="aif15.2" class="indexterm"/><a id="I_indexterm1_id339051" class="indexterm"/>angle of attack that affect the flow of air so as to create
    lift.</p><p><a class="xref" href="ch15.html#airfoil_moving_through_air" title="Figure 15-5. Airfoil moving through air">Figure 15-5</a> shows an airfoil
    section moving through air at a speed <span class="emphasis"><em>V</em></span>.
    <span class="emphasis"><em>V</em></span> is the relative velocity between the foil and the
    undisturbed air ahead of the foil. As the air hits and moves around the
    foil, it splits at the forward stagnation point located near the foil
    leading edge such that air flows both over and under the foil. The air
    that flows under the foil gets deflected downward, while the air that
    flows over the foil speeds up as it goes around the leading edge and over
    the surface of the foil. The air then flows smoothly off the trailing
    edge; this is the so-called <a id="I_indexterm1_id339080" class="indexterm"/>Kutta condition. Ideally, the boundary layer remains
    “attached” to the foil without separating as in the case of the sphere
    discussed in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>.</p><div class="figure"><a id="airfoil_moving_through_air"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id339105"/><img src="httpatomoreillycomsourceoreillyimages1598965.png" alt="Airfoil moving through air"/></div></div><div class="figure-title">Figure 15-5. Airfoil moving through air</div></div><p>The relatively fast-moving air above the foil results in a region of
    low pressure above the foil (remember <a id="I_indexterm1_id339126" class="indexterm"/><a id="I_indexterm1_id339133" class="indexterm"/>Bernoulli’s equation that shows pressure is inversely
    proportional to velocity in fluid flow). The air hitting and moving along
    the underside of the foil creates a region of relatively high pressure.
    The combined effect of this flow pattern is to create regions of
    relatively low and high pressure above and below the airfoil. It’s this
    pressure differential that gives rise to the lift force. By definition,
    the lift force is perpendicular to the line of flight—that is, the
    velocity vector.</p><p>Note that the airfoil does not have to be cambered in order to
    generate lift; a flat plate oriented at an angle of attack relative to the
    airflow will also generate lift. Likewise, an airfoil does not have to
    have an angle of attack either. Cambered airfoils can generate lift at 0,
    or even negative, angles of attack. Thus, in general, the total lift force
    on an airfoil is composed of two components: the lift due to camber and
    the lift due to attack angle.</p><p>Theoretically, the thickness of an airfoil does not contribute to
    lift. You can, after all, have a thin curved wing as in the case of wings
    made from fabric (such as those used for hang gliders). In practice,
    thickness is utilized for structural reasons. Further, thickness at the
    leading edge can help delay stall (more on this in a moment).</p><p>The pressure differential between the upper and lower surfaces of
    the airfoil also gives rise to a drag force that acts in line with, but
    opposing, the velocity vector. The lift and drag forces are perpendicular
    to each other and lie in the plane defined by the velocity vector and the
    vector normal (perpendicular) to the airfoil chord line. When combined,
    these two force components, lift and drag, yield the resultant force
    acting on the airfoil in flight. This is illustrated in <a class="xref" href="ch15.html#airfoil_moving_through_air" title="Figure 15-5. Airfoil moving through air">Figure 15-5</a>.</p><p>Both lift and drag are functions of air density, speed, viscosity,
    surface area, aspect ratio, and angle of attack. Traditionally, the lift
    and drag properties of a given foil design are expressed in terms of
    nondimensional coefficients C<sub>L</sub> and
    C<sub>D</sub>, respectively:</p><table style="border: 0; " class="simplelist"><tr><td>C<sub>L</sub> = L / [(1/2) ρ
      V<sup>2</sup> S]</td></tr><tr><td>C<sub>D</sub> = D / [(1/2) ρ
      V<sup>2</sup> S]</td></tr></table><p>where <span class="emphasis"><em>S</em></span> is the wing planform area (span times
    chord for rectangular wings), <span class="emphasis"><em>L</em></span> is the lift force,
    <span class="emphasis"><em>D</em></span> is the drag force, <span class="emphasis"><em>V</em></span> is the
    speed through the air, and ρ (rho) is air density. These coefficients are
    experimentally determined from wind tunnel tests of model airfoil designs
    at various angles of attack. The results of these tests are usually
    presented as graphs of lift and drag coefficient versus attack angle.
    <a class="xref" href="ch15.html#typical_cl_versus_angle_of_attack" title="Figure 15-6. Typical CL versus angle of attack">Figure 15-6</a> through <a class="xref" href="ch15.html#typical_cm_versus_attack_angle" title="Figure 15-8. Typical CM versus attack angle">Figure 15-8</a> illustrate some typical lift
    and drag charts for a wing <a id="I_indexterm1_id339252" class="indexterm"/><a id="I_indexterm1_id339262" class="indexterm"/>section.</p><div class="figure"><a id="typical_cl_versus_angle_of_attack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id339290"/><img style="width: 230.314960629921; " src="httpatomoreillycomsourceoreillyimages1598966.png" alt="Typical CL versus angle of attack"/></div></div><div class="figure-title">Figure 15-6. Typical C<sub>L</sub> versus angle of attack</div></div><div class="figure"><a id="typical_cd_versus_angle_of_attack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id339325"/><img style="width: 230.314960629921; " src="httpatomoreillycomsourceoreillyimages1598967.png" alt="Typical CD versus angle of attack"/></div></div><div class="figure-title">Figure 15-7. Typical C<sub>D</sub> versus angle of attack</div></div><div class="figure"><a id="typical_cm_versus_attack_angle"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id339360"/><img src="httpatomoreillycomsourceoreillyimages1598968.png" alt="Typical CM versus attack angle"/></div></div><div class="figure-title">Figure 15-8. Typical C<sub>M</sub> versus attack angle</div></div><p>The most widely known family of foil section designs and test data is the <a id="I_indexterm1_id339383" class="indexterm"/>NACA foil sections. <span class="emphasis"><em>Theory of Wing Sections</em></span> by Ira H. Abbott <a id="I_indexterm1_id339394" class="indexterm"/>and Albert E. Von Doenhoff <a id="I_indexterm1_id339401" class="indexterm"/>(Dover) contains a wealth of lift and drag data for practical airfoil designs (see
      the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a> for a complete reference to this
        work).<sup>[<a id="CHP-15-FN-2" href="#ftn.CHP-15-FN-2" epub:type="noteref" class="footnote">24</a>]</sup></p><p>In practice, the flow of air around a wing is not strictly
    two-dimensional—that is, flowing uniformly over each parallel cross
    section of the wing—and there exists a span-wise flow of air along the
    wing. The flow is said to be three-dimensional. The more three-dimensional
    the flow, the <a id="I_indexterm1_id339437" class="indexterm"/>less efficient the wing.<sup>[<a id="CHP-15-FN-3" href="#ftn.CHP-15-FN-3" epub:type="noteref" class="footnote">25</a>]</sup> This effect is reduced on longer, high-aspect-ratio wings
    (and wings with end plates where the effective aspect ratio is increased);
    thus, high-aspect-ratio wings are comparatively more efficient.</p><p>To account for the effect of aspect ratio, wing sections of various
    aspect ratios for a given foil design are usually tested so as to produce
    a family of lift and drag curves versus attack angle. There are other
    geometrical factors that affect the flow around wings; for a rigorous
    treatment of these, we refer you to <a id="I_indexterm1_id339464" class="indexterm"/><a id="I_indexterm1_id339470" class="indexterm"/>the <span class="emphasis"><em>Theory of Wing Sections</em></span> and
    <span class="emphasis"><em>Fluid-Dynamic Lift</em></span>.<sup>[<a id="CHP-15-FN-4" href="#ftn.CHP-15-FN-4" epub:type="noteref" class="footnote">26</a>]</sup></p><p>Turning back to <a class="xref" href="ch15.html#typical_cl_versus_angle_of_attack" title="Figure 15-6. Typical CL versus angle of attack">Figure 15-6</a>, you’ll notice that the
    drag coefficient increases sharply with attack angle. This is reasonable,
    as you would expect the wing to produce the most drag when oriented flat
    against or perpendicular to the flow of air.</p><p>A look at the lift coefficient curve, which initially increases
    linearly<a id="I_indexterm1_id339518" class="indexterm"/> with attack angle, shows that at some attack angle the lift
    coefficient reaches a maximum value. This angle is <a id="I_indexterm1_id339530" class="indexterm"/>called the <span class="emphasis"><em>critical attack angle</em></span>. For
    angles beyond the critical, the lift coefficient drops off rapidly and the
    airfoil (or wing) <a id="I_indexterm1_id339542" class="indexterm"/><a id="I_indexterm1_id339552" class="indexterm"/>will <span class="emphasis"><em>stall</em></span> and cease to produce lift.
    This is bad. When an aircraft stalls in the air, it will begin to drop
    rapidly until the pilot corrects the stall situation by, for example,
    reducing pitch and increasing thrust. When stall occurs, the air no longer
    flows smoothly over the trailing edge, and the corresponding high angle of
    attack results in flow separation (as illustrated in <a class="xref" href="ch15.html#stalled_airfoil" title="Figure 15-9. Stalled airfoil">Figure 15-9</a>). This loss in lift is also accompanied by an
    increase in drag.</p><div class="figure"><a id="stalled_airfoil"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id339586"/><img src="httpatomoreillycomsourceoreillyimages1598969.png" alt="Stalled airfoil"/></div></div><div class="figure-title">Figure 15-9. Stalled airfoil</div></div><p>Theoretically, the resultant force acting on an airfoil acts through
    a point located at one-quarter the chord length aft of the leading edge.
    This is called the<a id="I_indexterm1_id339608" class="indexterm"/> <span class="emphasis"><em>quarter-chord</em></span> point. <a id="I_indexterm1_id339618" class="indexterm"/>In reality, the resultant force line of action will vary
    depending on attack angle, pressure distribution, and speed, among other
    factors. However, in practice it is reasonable to assume that the line of
    action passes through the quarter-chord point for typical operational
    conditions. To account for the difference between the actual line of
    action of the resultant and the quarter-chord point, we must consider the
    pitching moment about the quarter-chord point. This pitching moment tends
    to tilt the leading edge of the foil down. In some cases this moment is
    relatively small compared to the other moments acting on the aircraft, and
    it may be neglected.<sup>[<a id="CHP-15-FN-5" href="#ftn.CHP-15-FN-5" epub:type="noteref" class="footnote">27</a>]</sup> An exception may be when the foil has deflected
    flaps.</p><p>Flaps are control <a id="I_indexterm1_id339652" class="indexterm"/>devices used to alter the shape of the foil so as to change
    its lift characteristics. <a class="xref" href="ch15.html#typical_cl_versus_angle_of_attack" title="Figure 15-6. Typical CL versus angle of attack">Figure 15-6</a> also shows typical lift,
    drag, and moment coefficients for an airfoil fitted with a plain flap
    deflected <a id="I_indexterm1_id339666" class="indexterm"/>downward at 15°.<sup>[<a id="CHP-15-FN-6" href="#ftn.CHP-15-FN-6" epub:type="noteref" class="footnote">28</a>]</sup> Notice the significant increase in lift, drag, and pitch
    moment when the flap is deflected. <span class="emphasis"><em>Theory of Wing
    Sections</em></span> also provides data for flapped airfoils for flap
    angles <a id="I_indexterm1_id339693" class="indexterm"/><a id="I_indexterm1_id339703" class="indexterm"/>between −15° and 60°.</p></div><div class="sect1" title="Other Forces"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="other_forces">Other Forces</h2></div></div></div><p>The most notable force that we’ve yet to discuss is thrust—the
    <a id="I_indexterm1_id339722" class="indexterm"/>propulsion force. Thrust provides forward motion; without
    it, the aircraft’s wings can’t generate lift and the aircraft won’t fly.
    Thrust, whether generated by a propeller or a jet engine, is usually
    expressed in pounds, and a common ratio used to compare the relative
    merits of aircraft powering is <a id="I_indexterm1_id339736" class="indexterm"/>the <span class="emphasis"><em>thrust-to-weight ratio</em></span>. This ratio
    is the maximum thrust deliverable by the propulsion plant divided by the
    aircraft’s total weight. When the thrust-to-weight ratio is greater than
    one, the aircraft is capable of overcoming gravity in a vertical climb.
    This is more like a rocket than a traditional airplane. Most normal planes
    are not capable of this, but many military planes do have thrust-to-weight
    ratios of greater than one. However, airplane engines rely on oxygen in
    the atmosphere to combust their fuel with and to produce the force that
    propels them forward. As the plane climbs higher, the engines will have
    less oxygen and produce less thrust. The thrust-to-weight ratio will fall,
    and eventually the plane will again need lift from the wings to maintain
    its altitude. Even when the plane is climbing vertically like a rocket,
    the wings still generate lift, and in this case try to pull the airplane
    away from a vertical trajectory.</p><p>Besides gravity, thrust, wing lift, and wing drag, there are other
    forces that act on an aircraft in flight. These are <a id="I_indexterm1_id339760" class="indexterm"/>drag forces (and lift in some cases) on the various
    components of the aircraft besides the wings. For example, the fuselage
    contributes to the overall drag acting on the aircraft. Additionally,
    anything sticking out of the fuselage will contribute to the overall drag.
    If it’s not a wing, anything sticking out of the fuselage is typically
    called an <span class="emphasis"><em>appendage</em></span>. Some examples of appendages are
    the aircraft landing gear, canopy, bombs, missiles, fuel pods, and air
    intakes.</p><p>Typically, drag data for fuselages and appendages is expressed in
    terms of a <a id="I_indexterm1_id339784" class="indexterm"/>drag coefficient similar to that discussed in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>, where experimentally determined drag forces are
    nondimensionalized by projected frontal area (S), density (ρ), and
    velocity squared (V<sup>2</sup>). This means that the
    experimentally measured drag force is divided by the quantity (1/2) ρ
    V<sup>2</sup> S to get the dimensionless drag coefficient.
    Depending on the object under consideration, the drag coefficient data
    will be presented as a function of some important geometric parameter,
    such as attack angle in the case of airfoils, or length-to-height ratio in
    the case of canopies. Here again, <a id="I_indexterm1_id339812" class="indexterm"/>Hoerner’s <span class="emphasis"><em>Fluid-Dynamic Drag</em></span> is an
    excellent source of practical data for all sorts of fuselage shapes and
    appendages.</p><p>For example, when an aircraft’s landing gear is down, the wheels (as
    well as associated mechanical gear) contribute to the overall drag force
    on the aircraft. Hoerner reports drag coefficients based on the frontal
    area of some small-plane landing-gear designs to be in the range of 0.25
    to 0.55. By comparison, drag coefficients for typical external storage
    pods (such as for fuel), which are usually streamlined, can range from
    0.06 to 0.26.</p><p>Another component of the total drag force acting on aircraft in
    flight is due to <a id="I_indexterm1_id339834" class="indexterm"/><a id="I_indexterm1_id339847" class="indexterm"/>skin friction. Aircraft wings, fuselages, and appendages are
    not completely smooth. Weld seams, rivets, and even paint cause surface
    imperfections that increase frictional drag. As in the case of the sphere
    data presented in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>. This frictional drag is
    dependent on the nature of the flow around the part of the aircraft under
    consideration—that is, whether the flow is laminar or turbulent. This
    implies that frictional drag coefficients for specific surfaces will
    generally be a function of the Reynolds number.</p><p>In a rigorous analysis of a specific aircraft’s flight, you’d of
    course want to consider all these additional drag components. If you’re
    interested in seeing the nitty-gritty details of such calculations, we
    suggest you take a look at <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14</a> of
    <span class="emphasis"><em>Fluid-Dynamic Drag</em></span>, where Hoerner gives a detailed
    example calculation of the total drag force on a fighter <a id="I_indexterm1_id339882" class="indexterm"/><a id="I_indexterm1_id339892" class="indexterm"/>aircraft.</p></div><div class="sect1" title="Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="control">Control</h2></div></div></div><p>The flaps located on <a id="I_indexterm1_id339916" class="indexterm"/>the inboard trailing edge of the wing in our model are used
    to alter the chord and camber of the wing section to increase lift at a
    given speed. <a id="I_indexterm1_id339929" class="indexterm"/>Flaps are used primarily to increase lift during slow speed
    flight, such as when taking off or landing. When landing, flaps are
    typically deployed at a high downward angle (downward flap deflections are
    considered positive) on the order to 30° to 60°. This increases both the
    lift and drag of the wings. During landing, this increase in drag also
    assists in slowing the aircraft to a suitable landing speed. During
    takeoff, this increase in drag works against you in that it necessitates
    higher thrust to get up to speed; thus, flaps may not be deployed to as
    great an angle as when you are landing.</p><p>Ailerons control or <a id="I_indexterm1_id339945" class="indexterm"/>induce roll motion by producing differential lift between
    the port and starboard wing sections. The basic aileron is nothing more
    than a pair of trailing-edge flaps fitted to the tips of the wings. These
    flaps move opposite each other, one deflecting upward and the other
    downward, to create a lift differential between the port and starboard
    wings. This lift differential, separated by the distance between the
    ailerons, creates a torque that rolls the aircraft. To roll the aircraft
    to the port side (the pilot’s left), the starboard aileron would be
    deflected in a downward direction while the port aileron would be
    deflected in an upward direction relative to the pilot. Likewise, the
    opposite deflections of the ailerons would induce a roll to the starboard
    side. In a real aircraft, the pilot controls the ailerons by moving the
    flight stick to either the left or right.</p><p>Elevators, <a id="I_indexterm1_id339964" class="indexterm"/>the tail “wings,” are used to control the pitch of the
    aircraft. (Elevators can be flaps, as shown in <a class="xref" href="ch15.html#model_configuration" title="Figure 15-2. Model configuration">Figure 15-2</a>, or the entire tail wing can rotate as on
    the Lockheed Martin F-16.) When the elevators are deflected such that
    their trailing edge goes down with respect to the pilot, a nose-down pitch
    rotation will be induced; that is, the tail of the aircraft will tend to
    rise relative to its nose, and the aircraft will dive. In an actual
    aircraft, the pilot achieves this by pushing the flight stick forward.
    When elevators are deflected such that their tailing edge goes up, a
    nose-up pitch rotation will be induced.</p><p>Elevators are very important <a id="I_indexterm1_id339985" class="indexterm"/>for <span class="emphasis"><em>trimming</em></span> (adjusting the pitch of)
    the aircraft. Generally, the aircraft’s center of gravity is located above
    the mean quarter-chord line of the aircraft wings such that the center of
    gravity is in line with the main lift force. However, as we explained
    earlier, the lift force does not always pass through the <a id="I_indexterm1_id340002" class="indexterm"/><a id="I_indexterm1_id340012" class="indexterm"/>quarter-chord point. Further, the aircraft’s center of
    gravity may very well change during flight—for example, as fuel is burned
    off and when ordnance is released. By controlling the elevators, the pilot
    is able to adjust the <span class="emphasis"><em>attitude</em></span> of the aircraft such
    that all of the forces balance and the aircraft flies at the desired
    orientation (pitch angle).</p><p>Finally, the rudder is <a id="I_indexterm1_id340029" class="indexterm"/><a id="I_indexterm1_id340042" class="indexterm"/>used to control yaw. The pilot uses foot pedals to control
    the rudder; pushing the left (port) pedal yaws left and pushing the right
    pedals yaws right (starboard). The rudder is useful for fine-tuning the
    alignment of the aircraft for approach on landing or when sighting up a
    target. Typically, large rudder action tends to also induce roll motion
    that must be compensated for by proper use of the ailerons.</p><p>In some cases the rudder consists of a flap on the trailing edge of
    the vertical tail, while in other cases there is no rudder flap and the
    entire vertical tail rotates. In both cases, the vertical tail, which also
    provides directional stability, will usually have a symmetric airfoil
    shape; that is, its mean camber line will be coincident with its chord
    line. When the aircraft is flying straight and level, the tail will not
    generate lift since it is symmetric and its attack angle will be 0.
    However, if the plane sideslips (yaws relative to its flight direction),
    then the tail will be at an angle of attack and will generate lift,
    tending to push the plane back to its original orientation.</p></div><div class="sect1" title="Modeling"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="modeling">Modeling</h2></div></div></div><p>Although we’ve yet to <a id="ai15.5" class="indexterm"/><a id="mo15.5" class="indexterm"/>cover a lot of the material required to implement a
    real-time flight simulator, we’d like to go ahead and outline some of the
    steps necessary to calculate the lift and drag forces on your model
    aircraft:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Discretize the lifting surfaces into a number of smaller wing
        sections.</p></li><li class="listitem"><p>Collect geometric and foil performance data.</p></li><li class="listitem"><p>Calculate the relative air velocity over each wing
        section.</p></li><li class="listitem"><p>Calculate the attack angle for each wing section.</p></li><li class="listitem"><p>Determine the appropriate lift and drag coefficients and
        calculate lift and drag forces.</p></li></ol></div><p>The first step is relatively straightforward in that you need to
    divide the aircraft into smaller sections where each section is
    approximately uniform in characteristics. Performing this step for the
    model shown in <a class="xref" href="ch15.html#model_configuration" title="Figure 15-2. Model configuration">Figure 15-2</a>, you might divide
    the wing into four sections—one for each wing section that’s fitted with
    an aileron and one for each section that’s fitted with a flap. You could
    also use two sections to model the elevators, one port and one starboard,
    and another section to model the tail/rudder. Finally, you could lump the
    entire fuselage together as one additional section or further subdivide it
    into smaller sections depending on how detailed you want to get.</p><p>If you’re going to model your aircraft as a rigid body, you’ll have
    to account for all of the forces and moments acting on the aircraft while
    it is in flight. Since the aircraft is composed of a number of different
    components, each contributing to the total lift and drag, you’ll have to
    break up your calculations into a number of smaller chunks and then sum
    all contributions to get the resultant lift and drag forces. You can then
    use these resultant forces along with thrust and gravity in the equations
    of motion for your aircraft. You can, of course, refine your model further
    by adding more components for such items as the cockpit canopy, landing
    gear, external fuel pods, bombs, etc. The level of detail to which you go
    depends on the degree of accuracy you’re going for. If you are trying to
    mimic the flight performance of a specific aircraft, then you need to
    sharpen your pencil.</p><p>Once you’ve defined each section, you must now prepare the
    appropriate geometric and performance data. For example, for the wings and
    other lifting surfaces you’ll need to determine each section’s initial
    incidence angle (its fixed pitch or attack angle relative to the aircraft
    reference system), span, chord length, aspect ratio, planform area, and
    quarter-chord location relative to the aircraft’s center of gravity.
    You’ll also have to prepare a table of lift and drag coefficients versus
    attack angle appropriate for the section under consideration. Since this
    data is usually presented in graphical form, you’ll have to pull data from
    the charts to build your lookup table for use in your game. Finally,
    you’ll need to calculate the unit normal vector perpendicular to the plane
    of each wing section. (You’ll need this later when calculating angle of
    attack.)</p><p>These first two steps need only be performed once at the beginning
    of your game or simulation since the data will remain constant (unless
    your plane changes shape or its center of gravity shifts during your
    simulation).</p><p>The third step involves calculating the relative velocity between
    the air and each component so you can calculate lift and drag forces. At
    first glance, this might seem trivial since the aircraft will be traveling
    at an air speed that will be known to you during your simulation. However,
    you must also remember that the aircraft is a rigid body and in addition
    to the linear velocity of its center of gravity, you must account for its
    rotational velocity.</p><p>Back in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, we gave you a formula to
    calculate the relative velocity of any point on a rigid body that was
    undergoing both linear and rotational motion:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>R</sub> = v<sub>cg</sub> + (ω ×
      r)</td></tr></table><p>This is the formula you’ll need to calculate the relative velocity
    at each component in your model. In this case,
    <span class="emphasis"><em>v</em></span><sub>cg</sub> is the vector representing
    the air speed and flight direction of the aircraft, ω (omega) is the
    angular velocity vector of the aircraft, and <span class="emphasis"><em>r</em></span> is the
    distance vector from the aircraft’s center of gravity to the component
    under consideration.</p><p>When dealing with wings, once you have the relative velocity vector,
    you can proceed to calculate the attack angle for each wing section. The
    drag force vector will be parallel to the relative velocity vector, while
    the lift force vector will be perpendicular to the velocity vector. Angle
    of attack is then the angle between the lift force vector and the normal
    vector perpendicular to the plane of the wing section. This involves
    taking the dot product of these two vectors.</p><p>Once you have the attack angle, you can go to your coefficient of
    lift and drag versus attack angle tables to determine the lift and drag
    coefficients to use at this instant in your simulation. With these
    coefficients, you can use the following formulas to estimate the
    magnitudes of lift and drag forces on the wing section under
    consideration:</p><table style="border: 0; " class="simplelist"><tr><td>Lift = C<sub>L</sub> (1/2) ρ
      V<sup>2</sup> S</td></tr><tr><td>Drag = C<sub>D</sub> (1/2) ρ
      V<sup>2</sup> S</td></tr></table><p>This is a very simplified approach that only approximates the lift
    and drag characteristics. This approach does not account for span-wise
    flow effects, or the flow effects between adjacent wing sections. Nor does
    this approach account for air disturbances, such as downwash, that may
    affect the relative angle of attack for a wing section. Further, the
    airflow over each wing section is assumed to be steady and uniform.</p><p>As a simple example, consider wing panel 1, which is the starboard
    aileron wing section. Assume that the wing is set at an initial incidence
    angle of 3.5° and that the plane is traveling at a speed of 38.58 m/s in
    level flight at low altitude with a pitch angle of 4.5°. This wing section
    has a chord length of 1.585 m and the span of this section is 1.829 m.
    Using the lift and drag data presented in <a class="xref" href="ch15.html#typical_cl_versus_angle_of_attack" title="Figure 15-6. Typical CL versus angle of attack">Figure 15-6</a>, calculate the lift and
    drag on this wing section, assuming the ailerons are not deflected and
    that the density of air is 1.221 kg/m<sup>3</sup>.</p><p>The first step is to calculate the angle of attack, which is 8°,
    based on the information provided. Now, looking at <a class="xref" href="ch15.html#typical_cl_versus_angle_of_attack" title="Figure 15-6. Typical CL versus angle of attack">Figure 15-6</a>, you can find the airfoil
    lift and drag coefficients to be 0.92 and 0.013, respectively.</p><p>Next, you’ll need to calculate the planform area of this section,
    which is simply its chord times its span. This yields 2.899
    m<sup>2</sup>. Now you have enough information to
    calculate lift and drag as follows:</p><table style="border: 0; " class="simplelist"><tr><td>Lift = C<sub>L</sub> (1/2) ρ
      V<sup>2</sup> S</td></tr><tr><td>Lift = 0.92 (1/2) (1.221 kg/m<sup>3</sup>)
      (38.58 m/s)<sup>2</sup> (2.899
      m<sup>2</sup>)</td></tr><tr><td><span class="strong"><strong>Lift = 2,412.8 N</strong></span></td></tr><tr><td>Drag = C<sub>D</sub> (1/2) ρ
      V<sup>2</sup> S</td></tr><tr><td>Drag = 0.013 (1/2) (1.221 kg/m<sup>3</sup>)
      (38.58 m/s)<sup>2</sup> (2.899
      m<sup>2</sup>)</td></tr><tr><td><span class="strong"><strong>Drag = 35.6 N</strong></span></td></tr></table><p>In your simulation, you’ll have to perform a similar set of
    calculations for every component that you’ve defined. As you can see,
    using this sort of empirical data and formulas, although only approximate,
    lends itself to fairly easy calculations. The hard part is deciding what
    to model and finding the right data, and after that the lift and drag
    calculations are pretty simple.</p><p>We’ve prepared an example program to show you how to model a simple
    airplane using the method shown here. The program is named <em class="filename">FlightSim.exe</em> and is a real-time, 3D flight
    simulator. The small aircraft simulated resembles that shown in <a class="xref" href="ch15.html#model_configuration" title="Figure 15-2. Model configuration">Figure 15-2</a>.</p><p>This program includes the following source files along with a text
    file (<em class="filename">Instructions.txt</em>) that explains
    the <a id="fl15.5" class="indexterm"/><a id="th15.5" class="indexterm"/>flight controls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="filename">Physics.cpp</em> and <em class="filename">Physics.h</em></p></li><li class="listitem"><p><em class="filename">D3dstuff.cpp</em> and <em class="filename">D3dstuff.h</em></p></li><li class="listitem"><p><em class="filename">Mymath.h</em></p></li><li class="listitem"><p><em class="filename">Winmain.cpp</em></p></li></ul></div><p>As we said, this program is a real-time simulation, and it treats
    the aircraft as a rigid body. We’ve covered real-time simulations earlier
    in this book, and <a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12</a> in
    particular covered some aspects of this flight simulation; therefore, some
    of the code to follow will be familiar to you. In this present chapter,
    though, we’re going to focus on a few specific functions that implement
    the flight model. These functions are contained in the source file
    <em class="filename">Physics.cpp</em>.</p><p>The first function we want you to look at is <code class="literal">CalcAirplaneMassProperties</code>:</p><a id="I_programlisting1_id340574"/><pre class="programlisting">//------------------------------------------------------------------------//
// This model uses a set of eight discrete elements to represent the
// airplane.  The elements are described below:
//
//          Element 0:  Outboard; port (left) wing section fitted with ailerons
//          Element 1:  Inboard; port wing section fitted with landing flaps
//          Element 2:  Inboard; starboard (right) wing section fitted with
                        landing flaps
//          Element 3:  Outboard; starboard wing section fitted with ailerons
//          Element 4:  Port elevator fitted with flap
//          Element 5:  Starboard elevator fitted with flap
//          Element 6:  Vertical tail/rudder (no flap; the whole thing rotates)
//          Element 7:  The fuselage
//
//  This function first sets up each element and then goes on to calculate
//  the combined weight, center of gravity, and inertia tensor for the plane.
//  Some other properties of each element are also calculated, which you'll
//  need when calculating the lift and drag forces on the plane.
//------------------------------------------------------------------------//
void     CalcAirplaneMassProperties(void)
{
     float     mass;
     Vector    vMoment;
     Vector    CG;
     int       i;
     float     Ixx, Iyy, Izz, Ixy, Ixz, Iyz;
     float     in, di;

     // Initialize the elements here
     // Initially the coordinates of each element are referenced from
     // a design coordinates system located at the very tail end of the plane,
     // its baseline and center line.  Later, these coordinates will be adjusted
     // so that each element is referenced to the combined center of gravity of
     // the airplane.
     Element[0].fMass = 6.56f;
     Element[0].vDCoords = Vector(14.5f,12.0f,2.5f);
     Element[0].vLocalInertia = Vector(13.92f,10.50f,24.00f);
     Element[0].fIncidence = −3.5f;
     Element[0].fDihedral = 0.0f;
     Element[0].fArea = 31.2f;
     Element[0].iFlap = 0;

     Element[1].fMass = 7.31f;
     Element[1].vDCoords = Vector(14.5f,5.5f,2.5f);
     Element[1].vLocalInertia = Vector(21.95f,12.22f,33.67f);
     Element[1].fIncidence = −3.5f;
     Element[1].fDihedral = 0.0f;
     Element[1].fArea = 36.4f;
     Element[1].iFlap = 0;

     Element[2].fMass = 7.31f;
     Element[2].vDCoords = Vector(14.5f,−5.5f,2.5f);
     Element[2].vLocalInertia = Vector(21.95f,12.22f,33.67f);
     Element[2].fIncidence = −3.5f;
     Element[2].fDihedral = 0.0f;
     Element[2].fArea = 36.4f;
     Element[2].iFlap = 0;

     Element[3].fMass = 6.56f;
     Element[3].vDCoords = Vector(14.5f,−12.0f,2.5f);
     Element[3].vLocalInertia = Vector(13.92f,10.50f,24.00f);
     Element[3].fIncidence = −3.5f;
     Element[3].fDihedral = 0.0f;
     Element[3].fArea = 31.2f;
     Element[3].iFlap = 0;

     Element[4].fMass = 2.62f;
     Element[4].vDCoords = Vector(3.03f,2.5f,3.0f);
     Element[4].vLocalInertia = Vector(0.837f,0.385f,1.206f);
     Element[4].fIncidence = 0.0f;
     Element[4].fDihedral = 0.0f;
     Element[4].fArea = 10.8f;
     Element[4].iFlap = 0;

     Element[5].fMass = 2.62f;
     Element[5].vDCoords = Vector(3.03f,−2.5f,3.0f);
     Element[5].vLocalInertia = Vector(0.837f,0.385f,1.206f);
     Element[5].fIncidence = 0.0f;
     Element[5].fDihedral = 0.0f;
     Element[5].fArea = 10.8f;
     Element[5].iFlap = 0;

     Element[6].fMass = 2.93f;
     Element[6].vDCoords = Vector(2.25f,0.0f,5.0f);
     Element[6].vLocalInertia = Vector(1.262f,1.942f,0.718f);
     Element[6].fIncidence = 0.0f;
     Element[6].fDihedral = 90.0f;
     Element[6].fArea = 12.0f;
     Element[6].iFlap = 0;

     Element[7].fMass = 31.8f;
     Element[7].vDCoords = Vector(15.25f,0.0f,1.5f);
     Element[7].vLocalInertia = Vector(66.30f,861.9f,861.9f);
     Element[7].fIncidence = 0.0f;
     Element[7].fDihedral = 0.0f;
     Element[7].fArea = 84.0f;
     Element[7].iFlap = 0;

     // Calculate the vector normal (perpendicular) to each lifting surface.
     // This is required when you are calculating the relative air velocity for
     // lift and drag calculations.
     for (i = 0; i&lt; 8; i++)
     {
          in = DegreesToRadians(Element[i].fIncidence);
          di = DegreesToRadians(Element[i].fDihedral);
          Element[i].vNormal = Vector((float)sin(in), (float)(cos(in)*sin(di)),
                                      (float)(cos(in)*cos(di)));
          Element[i].vNormal.Normalize();
     }

     // Calculate total mass
     mass = 0;
     for (i = 0; i&lt; 8; i++)
          mass += Element[i].fMass;

     // Calculate combined center of gravity location
     vMoment = Vector(0.0f, 0.0f, 0.0f);
     for (i = 0; i&lt; 8; i++)
     {
          vMoment += Element[i].fMass*Element[i].vDCoords;
     }
     CG = vMoment/mass;

     // Calculate coordinates of each element with respect to the combined CG
     for (i = 0; i&lt; 8; i++)
     {
          Element[i].vCGCoords = Element[i].vDCoords − CG;
     }

     // Now calculate the moments and products of inertia for the
     // combined elements.
     // (This inertia matrix (tensor) is in body coordinates)
     Ixx = 0;     Iyy = 0;     Izz = 0;
     Ixy = 0;     Ixz = 0;     Iyz = 0;
     for (i = 0; i&lt; 8; i++)
     {
          Ixx += Element[i].vLocalInertia.x + Element[i].fMass *
                 (Element[i].vCGCoords.y*Element[i].vCGCoords.y +
                 Element[i].vCGCoords.z*Element[i].vCGCoords.z);
          Iyy += Element[i].vLocalInertia.y + Element[i].fMass *
                 (Element[i].vCGCoords.z*Element[i].vCGCoords.z +
                 Element[i].vCGCoords.x*Element[i].vCGCoords.x);
          Izz += Element[i].vLocalInertia.z + Element[i].fMass *
                 (Element[i].vCGCoords.x*Element[i].vCGCoords.x +
                 Element[i].vCGCoords.y*Element[i].vCGCoords.y);
          Ixy += Element[i].fMass * (Element[i].vCGCoords.x *
                 Element[i].vCGCoords.y);
          Ixz += Element[i].fMass * (Element[i].vCGCoords.x *
                 Element[i].vCGCoords.z);
          Iyz += Element[i].fMass * (Element[i].vCGCoords.y *
                 Element[i].vCGCoords.z);
     }

     // Finally, set up the airplane's mass and its inertia matrix and take the
     // inverse of the inertia matrix.
     Airplane.fMass = mass;
     Airplane.mInertia.e11 = Ixx;
     Airplane.mInertia.e12 = -Ixy;
     Airplane.mInertia.e13 = -Ixz;
     Airplane.mInertia.e21 = -Ixy;
     Airplane.mInertia.e22 = Iyy;
     Airplane.mInertia.e23 = -Iyz;
     Airplane.mInertia.e31 = -Ixz;
     Airplane.mInertia.e32 = -Iyz;
     Airplane.mInertia.e33 = Izz;

     Airplane.mInertiaInverse = Airplane.mInertia.Inverse();
}</pre><p>Among other things, this function essentially completes step 1 (and
    part of step 2) of our modeling method: discretize the airplane into a
    number of smaller pieces, each with its own mass and lift and drag
    properties. For this model we chose to use eight pieces, or elements, to
    describe the aircraft. Our comments at the beginning of the function
    explain what each element represents.</p><p>The very first thing this function does is initialize the elements
    with the properties that we’ve defined to approximate the aircraft. Each
    element is given a mass, a set of <span class="emphasis"><em>design coordinates</em></span>
    to its center of mass, a set of moments of inertia about each element’s
    center of mass, an initial incidence angle, a planform area, and
    <a id="I_indexterm1_id340650" class="indexterm"/>a <span class="emphasis"><em>dihedral angle</em></span>.</p><p>The design coordinates are the coordinates of the element with
    respect to an origin located at the very tip of the aircraft’s tail, on
    its centerline and at its baseline. The x-axis of this system points
    toward the nose of the aircraft, while the y-axis points toward the port
    side. The z-axis points up. You have to set up your elements in this
    design coordinate system first because you don’t yet know the location of
    the whole aircraft’s center of mass, which is the combined center of mass
    of all of the elements. Ultimately, you want each element referenced from
    the combined center of mass because it’s the center of mass that you’ll
    track during the simulation.</p><p>The dihedral angle is the angle about the x-axis at which the
    element is initially set. For our model, all of the elements have a 0
    dihedral angle; that is, they are horizontal, except for the tail rudder,
    which has a 90° dihedral since it is oriented vertically.</p><p>After we’ve set up the elements, the first calculation that this
    function performs is to find the unit normal vector to each element’s
    surface based on the element’s incidence and dihedral angles. You need
    this direction vector to help calculate the angle of attack between the
    airflow and the element.</p><p>The next calculation is the total mass calculation, which is simply
    the sum of all element masses. Immediately following that, we determine
    the combined center of gravity location using the technique we discussed
    in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>. The coordinates to the combined
    center of gravity are referenced to the design coordinate system. You need
    to subtract this coordinate from the design coordinate of each element in
    order to determine each element’s coordinates relative to the combined
    center of gravity. After that, you’re all set with the exception of the
    combined moment of inertia tensor, which we already discussed in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a> and <a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12</a>.</p><p>Step 2 of our modeling method says you need to collect the airfoil
    performance data. For the example program, we used a cambered airfoil with
    plain flaps to model the wings and elevators, and we used a symmetric
    airfoil without flaps to model the tail rudder. We didn’t use flaps for
    the tail rudder since we just made the whole thing rotate about a vertical
    axis to provide rudder action.</p><p>For the wings, we set up two functions to handle the lift and drag
    coefficients:</p><a id="I_programlisting1_id340718"/><pre class="programlisting">//------------------------------------------------------------------------//
//  Given the attack angle and the status of the flaps, this function
//  returns the appropriate lift coefficient for a cambered airfoil with
//  a plain trailing-edge flap (+/- 15 degree deflection).
//------------------------------------------------------------------------//
float     LiftCoefficient(float angle, int flaps)
{
     float clf0[9] = {−0.54f, −0.2f, 0.2f, 0.57f, 0.92f, 1.21f, 1.43f, 1.4f,
                      1.0f};
     float clfd[9] = {0.0f, 0.45f, 0.85f, 1.02f, 1.39f, 1.65f, 1.75f, 1.38f,
                      1.17f};
     float clfu[9] = {−0.74f, −0.4f, 0.0f, 0.27f, 0.63f, 0.92f, 1.03f, 1.1f,
                      0.78f};
     float a[9]      = {−8.0f, −4.0f, 0.0f, 4.0f, 8.0f, 12.0f, 16.0f, 20.0f,
                        24.0f};
     float cl;
     int   i;

     cl = 0;
     for (i=0; i&lt;8; i++)
     {
          if( (a[i] &lt;= angle) &amp;&amp; (a[i+1] &gt; angle) )
          {
               switch(flaps)
               {
                    case 0:// flaps not deflected
                         cl = clf0[i] - (a[i] - angle) * (clf0[i] - clf0[i+1]) /
                             (a[i] - a[i+1]);
                         break;
                    case −1: // flaps down
                         cl = clfd[i] - (a[i] - angle) * (clfd[i] - clfd[i+1]) /
                             (a[i] - a[i+1]);
                         break;
                    case 1: // flaps up
                         cl = clfu[i] - (a[i] - angle) * (clfu[i] - clfu[i+1]) /
                             (a[i] - a[i+1]);
                         break;
               }
               break;
          }
     }

     return cl;
}

//------------------------------------------------------------------------//
//  Given the attack angle and the status of the flaps, this function
//  returns the appropriate drag coefficient for a cambered airfoil with
//  a plain trailing-edge flap (+/- 15 degree deflection).
//------------------------------------------------------------------------//
float     DragCoefficient(float angle, int flaps)
{
     float cdf0[9] = {0.01f, 0.0074f, 0.004f, 0.009f, 0.013f, 0.023f, 0.05f,
                      0.12f, 0.21f};
     float cdfd[9] = {0.0065f, 0.0043f, 0.0055f, 0.0153f, 0.0221f, 0.0391f, 0.1f,
                      0.195f, 0.3f};
     float cdfu[9] = {0.005f, 0.0043f, 0.0055f, 0.02601f, 0.03757f, 0.06647f,
                      0.13f, 0.18f, 0.25f};
     float a[9]      = {−8.0f, −4.0f, 0.0f, 4.0f, 8.0f, 12.0f, 16.0f, 20.0f,
                        24.0f};
     float cd;
     int   i;

     cd = 0.5;
     for (i=0; i&lt;8; i++)
     {
          if( (a[i] &lt;= angle) &amp;&amp; (a[i+1] &gt; angle) )
          {
               switch(flaps)
               {
                    case 0:// flaps not deflected
                         cd = cdf0[i] - (a[i] - angle) * (cdf0[i] - cdf0[i+1]) /
                              (a[i] - a[i+1]);
                         break;
                    case −1: // flaps down
                         cd = cdfd[i] - (a[i] - angle) * (cdfd[i] - cdfd[i+1]) /
                              (a[i] - a[i+1]);
                         break;
                    case 1: // flaps up
                         cd = cdfu[i] - (a[i] - angle) * (cdfu[i] - cdfu[i+1]) /
                              (a[i] - a[i+1]);
                         break;
               }
               break;
          }
     }

     return cd;

}</pre><p>Each of these functions takes the angle of attack as a parameter
    along with a flag used to indicate the state of the flaps—that is, whether
    the flaps are in neutral position, deflected downward, or deflected
    upward. Notice that the lift and drag coefficient data is given for a set
    of discrete attack angles, thus we use linear interpolation to determine
    the coefficients for attack angles that fall between the discrete
    angles.</p><p>The functions for determining the tail rudder lift and drag
    coefficients are similar to those shown here for the wings, with the only
    differences being the coefficients themselves and the fact that the tail
    rudder does not include flaps. Here are the functions:</p><a id="I_programlisting1_id340766"/><pre class="programlisting">//------------------------------------------------------------------------//
//  Given the attack angle, this function returns the proper lift coefficient
//  for a symmetric (no camber) airfoil without flaps.
//------------------------------------------------------------------------//
float     RudderLiftCoefficient(float angle)
{
     float clf0[7] = {0.16f, 0.456f, 0.736f, 0.968f, 1.144f, 1.12f, 0.8f};
     float a[7]      = {0.0f, 4.0f, 8.0f, 12.0f, 16.0f, 20.0f, 24.0f};
     float cl;
     int       i;
     float     aa = (float) fabs(angle);

     cl = 0;
     for (i=0; i&lt;8; i++)
     {
          if( (a[i] &lt;= aa) &amp;&amp; (a[i+1] &gt; aa) )
          {
               cl = clf0[i] - (a[i] - aa) * (clf0[i] - clf0[i+1]) /
                   (a[i] - a[i+1]);
               if (angle &lt; 0) cl = -cl;
               break;
          }
     }
     return cl;
}

//------------------------------------------------------------------------//
//  Given the attack angle, this function returns the proper drag coefficient
//  for a symmetric (no camber) airfoil without flaps.
//------------------------------------------------------------------------//
float     RudderDragCoefficient(float angle)
{
     float cdf0[7] = {0.0032f, 0.0072f, 0.0104f, 0.0184f, 0.04f, 0.096f, 0.168f};
     float a[7]      = {0.0f, 4.0f, 8.0f, 12.0f, 16.0f, 20.0f, 24.0f};
     float cd;
     int       i;
     float     aa = (float) fabs(angle);

     cd = 0.5;
     for (i=0; i&lt;8; i++)
     {
          if( (a[i] &lt;= aa) &amp;&amp; (a[i+1] &gt; aa) )
          {
               cd = cdf0[i] - (a[i] - aa) * (cdf0[i] - cdf0[i+1]) /
                   (a[i] - a[i+1]);
               break;
          }
     }
     return cd;
}</pre><p>With steps 1 and 2 out of the way, steps 3, 4, and 5 are handled in
    a single function called <code class="literal">CalcAirplaneLoads</code>:</p><a id="I_programlisting1_id340796"/><pre class="programlisting">//------------------------------------------------------------------------//
// This function calculates all of the forces and moments acting on the
// plane at any given time.
//------------------------------------------------------------------------//
void     CalcAirplaneLoads(void)
{
     Vector     Fb, Mb;

     // reset forces and moments:
     Airplane.vForces.x = 0.0f;
     Airplane.vForces.y = 0.0f;
     Airplane.vForces.z = 0.0f;

     Airplane.vMoments.x = 0.0f;
     Airplane.vMoments.y = 0.0f;
     Airplane.vMoments.z = 0.0f;

     Fb.x = 0.0f;     Mb.x = 0.0f;
     Fb.y = 0.0f;     Mb.y = 0.0f;
     Fb.z = 0.0f;     Mb.z = 0.0f;

     // Define the thrust vector, which acts through the plane's CG
     Thrust.x = 1.0f;
     Thrust.y = 0.0f;
     Thrust.z = 0.0f;
     Thrust *= ThrustForce;

     // Calculate forces and moments in body space:
     Vector    vLocalVelocity;
     float     fLocalSpeed;
     Vector    vDragVector;
     Vector    vLiftVector;
     float     fAttackAngle;
     float     tmp;
     Vector    vResultant;
     int       i;
     Vector    vtmp;

     Stalling = false;

     for(i=0; i&lt;7; i++) // loop through the seven lifting elements
                        // skipping the fuselage
     {
          if (i == 6) // The tail/rudder is a special case since it can rotate;
          {           // thus, you have to recalculate the normal vector.
               float in, di;
               in = DegreesToRadians(Element[i].fIncidence); // incidence angle
               di = DegreesToRadians(Element[i].fDihedral);  // dihedral angle
               Element[i].vNormal = Vector(     (float)sin(in),
                                                (float)(cos(in)*sin(di)),
                                                (float)(cos(in)*cos(di)));
               Element[i].vNormal.Normalize();
          }

          // Calculate local velocity at element
          // The local velocity includes the velocity due to linear
          // motion of the airplane,
          // plus the velocity at each element due to the
          // rotation of the airplane.

          // Here's the rotational part
          vtmp = Airplane.vAngularVelocity^Element[i].vCGCoords;

          vLocalVelocity = Airplane.vVelocityBody + vtmp;

          // Calculate local air speed
          fLocalSpeed = vLocalVelocity.Magnitude();

          // Find the direction in which drag will act.
          // Drag always acts inline with the relative
          // velocity but in the opposing direction
          if(fLocalSpeed &gt; 1.)
               vDragVector = -vLocalVelocity/fLocalSpeed;

          // Find the direction in which lift will act.
          // Lift is always perpendicular to the drag vector
          vLiftVector = (vDragVector^Element[i].vNormal)^vDragVector;
          tmp = vLiftVector.Magnitude();
          vLiftVector.Normalize();

          // Find the angle of attack.
          // The attack angle is the angle between the lift vector and the
          // element normal vector. Note, the sine of the attack angle
          // is equal to the cosine of the angle between the drag vector and
          // the normal vector.
          tmp = vDragVector*Element[i].vNormal;
          if(tmp &gt; 1.) tmp = 1;
          if(tmp &lt; −1) tmp = −1;
          fAttackAngle = RadiansToDegrees((float) asin(tmp));

          // Determine the resultant force (lift and drag) on the element.
          tmp = 0.5f * rho * fLocalSpeed*fLocalSpeed * Element[i].fArea;
          if (i == 6) // Tail/rudder
          {
               vResultant =  (vLiftVector*RudderLiftCoefficient(fAttackAngle) +
                              vDragVector*RudderDragCoefficient(fAttackAngle))
                              * tmp;
          } else
               vResultant =  (vLiftVector*LiftCoefficient(fAttackAngle,
                              Element[i].iFlap) +
                              vDragVector*DragCoefficient(fAttackAngle,
                              Element[i].iFlap) ) * tmp;
          // Check for stall.
          // We can easily determine stall by noting when the coefficient
          // of lift is 0. In reality, stall warning devices give warnings well
          // before the lift goes to 0 to give the pilot time to correct.
          if (i&lt;=0)
          {
               if (LiftCoefficient(fAttackAngle, Element[i].iFlap) == 0)
                    Stalling = true;
          }

          // Keep a running total of these resultant forces (total force)
          Fb += vResultant;

          // Calculate the moment about the CG of this element's force
          // and keep a running total of these moments (total moment)
          vtmp = Element[i].vCGCoords^vResultant;
          Mb += vtmp;
     }

     // Now add the thrust
     Fb += Thrust;

     // Convert forces from model space to earth space
     Airplane.vForces = QVRotate(Airplane.qOrientation, Fb);

     // Apply gravity (g is defined as −32.174 ft/s^2)
     Airplane.vForces.z += g * Airplane.fMass;

     Airplane.vMoments += Mb;
}</pre><p>The first thing this function does is reset the variables that hold
    the total force and moment acting on the aircraft. Next, the thrust vector
    is set up. This is trivial in this example since we’re assuming that the
    thrust vector always points in the plus x-axis direction (toward the nose)
    and passes through the aircraft center of gravity (so it does not create a
    moment).</p><p>After calculating the thrust vector, the function loops over the
    model elements to calculate the lift and drag forces on each element.
    We’ve skipped the fuselage in this model; however, if you want to account
    for its drag in your model, this is the place to add the drag
    calculation.</p><p>Going into the loop, the first thing the function does is check to
    see if the current element is element number six, the tail rudder. If it
    is, then the rudder’s normal vector is recalculated based on the current
    incidence angle. The incidence angle for the rudder is altered when you
    press the X or C keys to apply rudder action.</p><p>The next calculation is to determine the relative velocity between
    the air and the element under consideration. As we stated earlier, this
    relative velocity consists of the linear velocity as the airplane moves
    through the air plus the velocity of each element due to the airplane’s
    rotation. Once you’ve obtained this vector, you calculate the relative air
    speed by taking the magnitude of the relative velocity vector.</p><p>The next step is to determine the direction in which drag will act. Since drag opposes
      motion, it acts inline with, but opposite to, the relative velocity vector; thus, all you need
      to do is take the negative of the relative velocity vector and normalize the result (divide it
      by its magnitude) to obtain the drag direction vector. Since this vector was normalized, its
      length is equal to 1 (unity), so you can multiply it by the drag force that will be calculated
      later to get the drag force vector.</p><p>After obtaining the drag direction vector, this function uses it to
    determine the lift direction vector. The lift force vector is always
    perpendicular to the drag force vector, so to calculate its direction you
    first take the cross product of the drag direction vector with the element
    normal vector and then cross the result with the drag direction vector
    again. Here again, the function normalizes the lift direction
    vector.</p><p>Now that the lift and drag direction vectors have been obtained, the
    function proceeds to calculate the angle of attack for the current
    element. The attack angle is the angle between the lift vector and the
    element normal. You can calculate the angle by taking the inverse cosine
    of the vector dot product of the lift direction vector with the element
    normal vector. Since the drag vector is perpendicular to the lift vector,
    you can get the same result by taking the inverse sine of the vector dot
    product of the drag direction vector with the element normal
    vector.</p><p>Now with all the lift and drag vector stuff out of the way, the
    function goes on to calculate the resultant force acting on the element.
    The resultant force vector is simply the vector sum of the lift and drag
    force vectors. Notice that this is where the lift and drag coefficient
    functions are called and where the empirical lift and drag formulas
    previously discussed are applied.</p><p>After calculating the resultant force, the function checks to see if
    the calculated lift coefficient is 0. If it is, then the stall flag is set
    to warn us that the plane is in a stalled situation.</p><p>Finally, the resultant force is accumulated in the total force
    vector variable, and we calculate the moment by taking the cross product
    of the element coordinate vector with the resultant force. The resulting
    moment is accumulated in the total moment vector variable. After exiting
    the loop, the function adds the thrust vector to the total force.</p><p>So far, all of these forces and moments have been referenced in the
    body-fixed-coordinate system. The only thing left to do now is apply the
    gravity force, but this force acts in the negative y-axis direction in the
    earth-fixed-coordinate system. To apply the gravity force, the function
    must first rotate the body force vector from body space to earth space
    coordinates. We used a quaternion rotation technique in this example,
    which we already discussed in <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a> and <a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12</a>.</p><p>That’s pretty much it for the flight model. We encourage you to play
    with the flight model in this program. Go ahead and tweak the element
    properties and watch to see what happens. Even though this is a rough
    model, the flight results look quite <a id="I_indexterm1_id340936" class="indexterm"/><a id="I_indexterm1_id340946" class="indexterm"/><a id="I_indexterm1_id340955" class="indexterm"/><a id="I_indexterm1_id340965" class="indexterm"/>realistic.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-1"><p><sup>[<a href="#CHP-15-FN-1" class="para">23</a>] </sup>Port is to the pilot’s left and starboard is to the pilot’s
        right when he or she is sitting in the cockpit facing forward.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-2"><p><sup>[<a href="#CHP-15-FN-2" class="para">24</a>] </sup><span class="emphasis"><em>Theory of Wing Sections</em></span> includes standard foil section geometry
          and performance data, including the well-known NACA family of foil sections. The
          appendixes to <span class="emphasis"><em>Theory of Wing Sections</em></span> have all the data you need to
          collect lift and drag coefficient data for various airfoil designs, including those with
          flaps.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-3"><p><sup>[<a href="#CHP-15-FN-3" class="para">25</a>] </sup>Lifting efficiency can be expressed in terms of lift-to-drag
        ratio. The higher the lift-to-drag ratio, the more efficient the wing
        or foil section.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-4"><p><sup>[<a href="#CHP-15-FN-4" class="para">26</a>] </sup><span class="emphasis"><em>Fluid-Dynamic Lift</em></span>, by Sighard F. Hoerner
        and Henry V. Borst, and <span class="emphasis"><em>Fluid-Dynamic Drag</em></span>, by
        Sighard F. Hoerner (both self-published by Hoerner), contain tons of
        practical charts, tables, and formulas for virtually every aspect of
        aircraft aerodynamics. They even include material appropriate for
        high-speed boats and automobiles.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-5"><p><sup>[<a href="#CHP-15-FN-5" class="para">27</a>] </sup>Aircraft designers must always consider this pitching moment
        when designing the aircraft’s structure, as this moment tends to want
        to twist the wings off the fuselage.</p></div><div class="footnote" epub:type="footnote" id="ftn.CHP-15-FN-6"><p><sup>[<a href="#CHP-15-FN-6" class="para">28</a>] </sup>There’s a large variety of flap designs besides the plain
        trailing-edge flap discussed here. Flaps are typically referred to in
        the literature as <span class="emphasis"><em>high lift devices</em></span>, and the
        references we’ll provide in this chapter give rough descriptions of
        the most common designs.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 16. Ships and Boats</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Physical Modeling"/><link rel="prev" href="ch15.html" title="Chapter 15. Aircraft"/><link rel="next" href="ch17.html" title="Chapter 17. Cars and Hovercraft"/></head><body><section class="chapter" title="Chapter 16. Ships and Boats" epub:type="chapter" id="ships_and_boats"><div class="titlepage"><div><div><h2 class="title">Chapter 16. Ships and Boats</h2></div></div></div><p>The physics of <a id="I_indexterm2_id340979" class="indexterm"/><a id="sh16.0" class="indexterm"/>ships is a vast subject. While the same principles govern canoes and super tankers,
    the difference between the two scales is not trivial. Our goal in this chapter will be to
    explain some of the fundamental physical principles to allow you to develop realistic
    simulations. The typical displacement-type ship lends itself well to illustrating these
    principles; however, many of these principles also apply to other objects submerged or partially
    submerged in a fluid, such as submarines and air balloons. Remember, air is considered a fluid
    when we are considering buoyancy.</p><p>While surface ships or ships that operate on the water’s surface (at
  the air water interface) are similar to fully submerged objects like
  submarines or air balloons in that they all experience buoyancy, there are
  some very distinct differences in their physical nature that we’ll highlight
  in this chapter. These differences affect their behavior, so it is important
  to be aware of them if you intend to simulate such objects.</p><p>Ships have an entire language of their own, so we’ll be spending a lot
  of time just getting the vocabulary right. This will allow you to do further
  research on any topics that are of particular interest. There are many ways
  to classify ships and boats, but in regards to the physics governing them,
  there are three basic <a id="I_indexterm2_id341026" class="indexterm"/>types. <span class="emphasis"><em>Displacement</em></span> vessels,
  <span class="emphasis"><em>semi-displacement</em></span> vessels, and
  <span class="emphasis"><em>planing</em></span> vessels are named after the forces that keep
  the boat afloat while it is at cruising speed. When not moving, all vessels
  are in <span class="emphasis"><em>displacement mode</em></span>.</p><p>The term <span class="emphasis"><em>displacement</em></span> in <a id="I_indexterm2_id341059" class="indexterm"/>this context means that the ship is supported solely by
  buoyancy—that is, without dynamic or aerostatic lift as you would see on a
  high-speed racing boat or a hovercraft. The word
  <span class="emphasis"><em>displacement</em></span> itself refers to the volume of water
  displaced or “pushed” out of the way by the ship as it sits floating in the
  water. We’ll discuss this more in the next section.</p><p>A planing vessel is <a id="I_indexterm2_id341081" class="indexterm"/>one that is not supported by buoyancy, but by <a id="I_indexterm2_id341089" class="indexterm"/>hydrodynamic lift. This includes the everyday speedboats that most boaters own. When
    the boat isn’t moving, it just floats in the water, bobbing up and down. However, when the boat
    begins traveling at high speed, the force of the water hitting the bottom of the boat causes the
    boat to rise up. This is known as planing, and it greatly reduces the resistance of the vessel.
    Semi-displacement vessels are those that straddle the two categories, with some support coming
    from buoyancy and some coming from planing forces. Before we continue discussing this, let’s go
    over some vocabulary.</p><p>The <span class="emphasis"><em>hull</em></span> of the <a id="I_indexterm2_id341112" class="indexterm"/><a id="I_indexterm2_id341118" class="indexterm"/>ship is the watertight part of the ship that actually
  displaces the water. Everything in or on the ship is contained within the
  hull, which is partially submerged in the water. The length <a id="I_indexterm2_id341131" class="indexterm"/>of the ship is the distance measured from the bow to the
  stern. In practice, there are several lengths used to denote the length of a
  ship, but here we’ll refer to the <span class="emphasis"><em>overall length</em></span> of the
  hull. The <span class="emphasis"><em>bow</em></span> is the front of the ship, while the
  <span class="emphasis"><em>stern</em></span> is the aft part. When you are on the ship facing
  the bow, the <span class="emphasis"><em>port</em></span> side is to your left and the
  <span class="emphasis"><em>starboard</em></span> side is to your right. The overall height of
  the hull is called the <span class="emphasis"><em>depth</em></span>, and its width is called
  <span class="emphasis"><em>breadth</em></span> or <span class="emphasis"><em>beam</em></span>. When a ship is
  floating in the water, the distance from the water surface to the bottom of
  the hull is called <a id="I_indexterm2_id341176" class="indexterm"/>the <span class="emphasis"><em>draft</em></span>. <a class="xref" href="ch16.html#ship_geometry" title="Figure 16-1. Ship geometry">Figure 16-1</a> illustrates these terms.</p><div class="figure"><a id="ship_geometry"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id341205"/><img src="httpatomoreillycomsourceoreillyimages1598970.png" alt="Ship geometry"/></div></div><div class="figure-title">Figure 16-1. Ship geometry</div></div><p>Given that ship design is a diverse subject, we’ll limit ourselves to
  discussing those aspects of ships that make for realistic models. These
  subjects include stability and sinking, resistance characteristics,
  propulstion, and manuverability. Most of these subjects cannot be fully
  simulated in real time, so we’ll show you some general rules that ships
  follow instead of full numerical <a id="I_indexterm2_id341229" class="indexterm"/>simulation.</p><div class="sect1" title="Stability and Sinking"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="stability_and_sinking">Stability and Sinking</h2></div></div></div><p>If you have boats in your video game, the first step to making them
    realistic physically is allowing them to sink if they become damaged. To
    understand why boats sink and how they do so, you must first understand
    <span class="emphasis"><em>stability</em></span>.</p><div class="sect2" title="Stability"><div class="titlepage"><div><div><h3 class="title" id="stability">Stability</h3></div></div></div><p>Most boats <a id="sh16.1.1" class="indexterm"/><a id="st16.1.1" class="indexterm"/>are least stable about their longitudinal axis—that is,
      they are easier to heel port and starboard than they are to flip end
      over end. If the vessel heels over so far that it is upside down, this
      is called capsizing. <a id="I_indexterm2_id341301" class="indexterm"/>This is how most boats sink due to wind, waves, or in some
      cases of side damage. One of the most famous examples of a sinking ship,
      the <span class="emphasis"><em>Titanic</em></span>, shows that when a boat is sinking from
      damage, it can sink end over end, sometimes with the ship breaking in
      two. We’ll discuss both here so that you can animate realistic sinking
      in your simulation.</p><p>In <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> we introduced the concept of buoyancy
      and stated that the force on a submerged object due to buoyancy is a
      function of the submerged <a id="I_indexterm2_id341326" class="indexterm"/><a id="I_indexterm2_id341332" class="indexterm"/>volume of the object. <a id="I_indexterm2_id341343" class="indexterm"/><a id="I_indexterm2_id341350" class="indexterm"/>Archimedes’s principle states that the <a id="I_indexterm2_id341363" class="indexterm"/><a id="I_indexterm2_id341373" class="indexterm"/>weight of an object floating in a fluid is equal to the
      weight of the volume of fluid displaced by the object. This is an
      important principle. It says that a ship of a given weight must have
      sufficient volume to displace enough water, an amount equal to the
      weight of the ship, in order for it to float. Further, this principle
      provides a clever way of determining the weight of a ship: simply
      measure or calculate the amount of water displaced by the ship and you
      can calculate the weight of the ship. In the marine field, <a id="I_indexterm2_id341389" class="indexterm"/>displacement is synonymous with the weight of the
      ship.</p><p>As discussed in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>, we can calculate the
      buoyant force on any object by using the following formula:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>B</sub> = ρ g ∇</td></tr></table><p>Here, ∇ is the submerged volume of the object, ρ is the density of
      the fluid within which the object is submerged, and
      <span class="emphasis"><em>g</em></span> is the acceleration due to gravity. Since
      buoyancy is a force, it has both magnitude and direction, and always
      acts straight up through the center of buoyancy. The center of buoyancy
      is the geometric center of the submerged part of the object.</p><p>When a ship is floating in equilibrium on the surface of the
      water, its center of buoyancy must be located directly below the ship’s
      <a id="I_indexterm2_id341437" class="indexterm"/>center of gravity. The weight of the ship, a force, acts
      straight down through the center of gravity, opposing the force due to
      buoyancy. When the ship is in equilibrium, these two forces, weight and
      buoyancy, are equal in magnitude and opposite in direction.</p><p>Now, when an external force causes the ship to <a id="I_indexterm2_id341457" class="indexterm"/><a id="I_indexterm2_id341469" class="indexterm"/>roll or pitch, the portion of the hull below the water is
      changed and the center of buoyancy moves to the new geometric centroid
      of the underwater portion of the hull. For example, if the ship rolls to
      the starboard side, then the center of buoyancy shiwfts out toward the
      starboard side. When this happens, the lines of action of the weight of
      the ship and the buoyant force are no longer in line, which results in a
      moment (torque) that acts on the ship. This torque is equal to the
      perpendicular distance between the lines of action of the forces times
      the weight of the ship.</p><p>Now here’s where we get to the floating upright part that we
      mentioned earlier. When a ship rolls, for example, you don’t want it to
      keep rolling until it capsizes. Instead, you want it to gently return
      itself to the upright position after whatever force caused it to
      roll—the wind, for example—has been removed. In short, you want the ship
      to be stable. For a ship to be stable, the line of action of the buoyant
      force must cross the vessel’s centerline at a point, called <a id="I_indexterm2_id341497" class="indexterm"/>the <span class="emphasis"><em>metacenter</em></span>, above the center of
      gravity. When this happens, the moment developed when the ship rolls
      tends to restore the ship to the upright position. If the metacenter is
      located below the center of gravity, then the moment developed would
      tend to capsize the ship. The distance between the center of gravity and
      the metacenter is called <span class="emphasis"><em>GM</em></span>. This is also known as
      <a id="I_indexterm2_id341515" class="indexterm"/><a id="I_indexterm2_id341521" class="indexterm"/>the <span class="emphasis"><em>stability index</em></span>, as a positive
      value means the floating body is stable and a negative GM means the body
      is unstable. <a class="xref" href="ch16.html#ship_stability" title="Figure 16-2. Ship stability">Figure 16-2</a> illustrates these two
      scenarios.</p><div class="figure"><a id="ship_stability"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id341548"/><img src="httpatomoreillycomsourceoreillyimages1598971.png" alt="Ship stability"/></div></div><div class="figure-title">Figure 16-2. Ship stability</div></div><p>If you’re a sailor, then you know how important it is to keep the
      center of gravity of your boat low. This helps increase the height of
      the metacenter above the center of gravity, and thus helps with
      stability.</p><p>In the case of fully submerged objects, like submarines, the
      situation is different. The buoyant force still acts through the
      geometric centroid of the object, but for stability, the center of
      buoyancy must be located above the center of gravity. This way, when the
      object rotates, the lines of action of the weight of the object and the
      buoyant force are separated and form a moment that tends to restore the
      object to its upright position. If it’s the other way around, then the
      object would be unstable, like trying to balance one bowling ball on top
      of another. In this case, the slightest disturbance would upset the
      balance and the object would flip upside-down such that the center of
      gravity is located below the center of <a id="I_indexterm2_id341580" class="indexterm"/><a id="I_indexterm2_id341591" class="indexterm"/>buoyancy.</p></div><div class="sect2" title="Sinking"><div class="titlepage"><div><div><h3 class="title" id="sinking">Sinking</h3></div></div></div><p>In general, <a id="I_indexterm2_id341615" class="indexterm"/><a id="I_indexterm2_id341625" class="indexterm"/>boats protect their stability by compartmentalizing the
      hull into several watertight sections, fittingly <a id="I_indexterm2_id341633" class="indexterm"/>called <span class="emphasis"><em>compartments</em></span>. This way, if the
      side of a vessel hits an iceberg, only the compartment damaged will
      flood with seawater. If enough compartments are damaged, the vessel will
      not have enough buoyancy to support its weight and it will sink. The end
      with the flooded compartments will sink first, causing a large angle
      about the transverse axis. This is what happened to the
      <span class="emphasis"><em>Titanic</em></span>. In fact, in that ship’s case, the angle,
      called <span class="emphasis"><em>trim</em></span>, was so large that the stern was lifted
      out of the water. The hull could not support the weight of the stern
      section that was no longer being supported by buoyancy, and the
      structure ripped in two.</p><p>It should be noted that ships can sink in the matter of minutes,
      or it can take hours. For instance, the <span class="emphasis"><em>Titanic</em></span>
      took about three hours to sink. The <span class="emphasis"><em>Lusitania</em></span> sank
      in 18 minutes. The time it takes depends heavily on the type of damage
      and the construction of the vessel. We don’t suggest trying to get
      players to wait three hours for their game to end; however, it is
      possible to continue fighting/propelling a vessel that is terminally
      damaged. In many cases where terminal damage is suspected, captains
      endeavor to ground their vessels to prevent the ship from actually going
      under.</p><p>If side damage occurs, especially in high wind and waves, then it
      could be that the vessel can still have enough buoyancy to float, but no
      longer enough stability to remain upright. As damage usually occurs only
      on one side of a vessel, the center of buoyancy will no longer be on
      centerline. This means that the restoring moment in one direction is
      diminished by whatever amount the center has moved to that side. A big
      wave comes along and pushes the vessel over to the point where the
      righting arm is no longer positive. The vessel will flip 180 degrees
      with the bottom pointed skyward but will still <a id="I_indexterm2_id341681" class="indexterm"/>float (capsizing). Once rolled over, the remaining
      compartments will tend to fill with water as vents or other openings
      fail over time. In the case of recreational boats, they are usually only
      a single compartment. If they capsize, they will sink readily; indeed,
      this is the way that most small boats sink.</p><p>As we mentioned before, accurately computing all degrees
      <a id="I_indexterm2_id341694" class="indexterm"/>of freedom for a nontrivial-shaped body in real time would
      be difficult to accomplish with today’s computer hardware. In general,
      you want to follow a few high-level rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The higher the center of gravity, the more likely it is that
          the boat will tip over.</p></li><li class="listitem"><p>Large vessels are always compartmentalized. Damage should be
          limited to the watertight compartment in which it occurred.</p></li><li class="listitem"><p>The vessel will heal or trim in the direction of damage. If
          damage occurs on the starboard side, the boat will heel to
          starboard. If the damage occurs in the bow, the boat will list
          forward.</p></li><li class="listitem"><p>A boat will remain floating as long as the undamaged
          compartments have a volume in cubic meters of at least the weight of
          the hull in metric tons divided by 1.025.</p></li><li class="listitem"><p>After being damaged, even if a vessel has enough undamaged
          volume to remain afloat, it doesn’t necessarily mean it will float
          upright.</p></li><li class="listitem"><p>Sinking almost never occurs as quickly as depicted in video
          games; however, capsizing can occur rapidly and is probably a more
          realistic way to model a stability failure.</p></li></ul></div></div></div><div class="sect1" title="Ship Motions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ship_motions">Ship Motions</h2></div></div></div><p>Closely related to <a id="sh16.2" class="indexterm"/><a id="mo16.2" class="indexterm"/>ship stability is the subject of ship motions. Knowing how
    vessels work in a random set of waves will greatly help you to increase
    realism in your games. The most important aspect of this is<a id="I_indexterm2_id341813" class="indexterm"/><a id="I_indexterm2_id341819" class="indexterm"/> coupled motions, which we will talk about shortly. First,
    some more vocabulary! As discussed before, there are six degrees of motion
    any rigid body is capable of; for boats, <a id="de16.2" class="indexterm"/>some of these have special names and are described next and
    illustrated in <a class="xref" href="ch16.html#floating-body_degrees_of_freedom" title="Figure 16-3. Floating-body degrees of freedom">Figure 16-3</a>.</p><div class="figure"><a id="floating-body_degrees_of_freedom"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id341862"/><img style="width: 194.88188976378; " src="httpatomoreillycomsourceoreillyimages1598972.png" alt="Floating-body degrees of freedom"/></div></div><div class="figure-title">Figure 16-3. Floating-body degrees of freedom</div></div><p>Roll, pitch, <a id="I_indexterm2_id341884" class="indexterm"/><a id="I_indexterm2_id341896" class="indexterm"/><a id="I_indexterm2_id341909" class="indexterm"/>and yaw are the terms also used for airplanes. The
    translation degrees of freedom are called surge, heave, and sway. Surge,
    sway, and yaw are not that apparent when vessels are moving forward, so it
    is acceptable to limit your model to heave, pitch, and roll. <a id="I_indexterm2_id341924" class="indexterm"/>Heave is the up-and-down motion of the boat caused by the
    change in elevation of the water’s surface as a wave passes. If a vessel
    is stationary, it would be referred to as bobbing. Pitch is the rotation
    about the transverse axis of the vessel due to increased buoyancy on one
    end of the ship as a wave passes. This motion is most pronounced when the
    waves are traveling in the same direction (or 180 degrees) from the
    vessel. Roll is like pitch, but about the longitudinal axis.</p><div class="sect2" title="Heave"><div class="titlepage"><div><div><h3 class="title" id="heave">Heave</h3></div></div></div><p>As stated <a id="I_indexterm2_id341948" class="indexterm"/>before, heave is displacement in the vertical direction
        from the static equilibrium draft. This degree of freedom is
        straightforward to model as a hydrostatic spring acting in the
        vertical direction. Assuming we have a barge that is 30 meters long
        and 10 meters wide, we’ll develop an equation that can govern our
        heave simulation.</p><p>Commonly, a vessel’s hydrostatics include something called <a id="I_indexterm2_id341962" class="indexterm"/><a id="I_indexterm2_id341969" class="indexterm"/>tons per centimeter immersion (TPCM)—that is, for every centimeter you press
          the boat down, a certain number of tons of buoyancy force is created. For our barge, this
          is a relatively straightforward calculation.</p><p>Given that the water plane area is a constant 300 square meters,
        1 centimeter of immersion would result in a volume of 3 cubic meters.
        As 1 cubic meter of saltwater weighs 1,027 kg, 3 cubic meters would be
        3,081 kg, and (assuming this boat is on Earth), would result in a
        buoyant force of 3,081 kg × 9.81 m/s<sup>2</sup>, or
        30.2 kN. Therefore, 30.2 kN per cm would make a good starting value
        for a spring constant to model the heave response of this vessel in
        waves.</p></div><div class="sect2" title="Roll"><div class="titlepage"><div><div><h3 class="title" id="roll">Roll</h3></div></div></div><p>For us to <a id="I_indexterm2_id342003" class="indexterm"/>simulate realistic roll motions, it is important that
        the ship take time to complete the motion. This <a id="I_indexterm2_id342018" class="indexterm"/>time is called the <span class="emphasis"><em>roll period</em></span>.
        This defines the angular velocity that a ship rolled to one side will
        experience when it recovers. We can estimate it by the following
        equation:</p><table style="border: 0; " class="simplelist"><tr><td>T = 
          
            <span class="inlinemediaobject"><img src="inleq_1601.png" alt=""/></span>   
            
          </td></tr></table><p>Where <span class="emphasis"><em>k</em></span> is the radius of gyration and
        <span class="emphasis"><em>GM</em></span> is the distance from the metacenter to the
        center of gravity. A good estimate for the radius of gyration is often
        taken as 30% of the beam of the vessel. A vessel with a shorter roll
        period will respond quicker to a wave and try to assume the wave
        slope. This is known as being “stiff” and can cause passenger
        discomfort and damage via higher angular accelerations. Conversely,
        vessels with higher roll periods are known as “tender” and lag behind
        the waves. These vessels generally heel farther over but are more
        comfortable for passengers.</p></div><div class="sect2" title="Pitch"><div class="titlepage"><div><div><h3 class="title" id="pitch">Pitch</h3></div></div></div><p>Likewise, <a id="I_indexterm2_id342080" class="indexterm"/>there is a pitch period that measures the speed at which the vessel responds
          to a wave. This is highly dependent on the length of a ship and can be estimated as
          follows:</p><table style="border: 0; " class="simplelist"><tr><td>T = (2π /
          g<sup>1/2</sup>)(k/(GM)<sup>1/2</sup>)</td></tr></table><p>Where <span class="emphasis"><em>k</em></span> is the radius of gyration and is
        commonly taken as 30% of the beam. Note that pitch period is normally
        one-third to one-half that of roll period, so that the bow of a vessel
        will rise and fall with the wave more in phase <a id="I_indexterm2_id342122" class="indexterm"/>than in a roll event.</p></div><div class="sect2" title="Coupled Motions"><div class="titlepage"><div><div><h3 class="title" id="coupled_motions">Coupled Motions</h3></div></div></div><p>The real trick to <a id="I_indexterm2_id342145" class="indexterm"/><a id="I_indexterm2_id342152" class="indexterm"/>getting motions to look right is to understand that for most boats the motions
        are coupled. For instance, heave and pitch are strongly coupled. This means that if a wave
        causes your boat to heave, it will most likely also cause it to pitch. This is because the
        distribution of buoyancy along the hull is not constant. If the waterline is raised some
        constant value, there is usually more buoyancy provided aft than there is forward for the
        same change in waterline. This will cause the vessel to pitch forward to move the center of
        buoyancy to the longitudinal location of the center of gravity. Similarly, a pitch event
        will cause the vessel to heave because if the stern is lifted from the water, there is
        usually a loss of total buoyancy, and the boat will sink farther into the <a id="I_indexterm2_id342170" class="indexterm"/><a id="I_indexterm2_id342180" class="indexterm"/>water.</p></div></div><div class="sect1" title="Resistance and Propulsion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="resistance_and_propulsion">Resistance and Propulsion</h2></div></div></div><p>Resistance is the amount of force it takes to move a body through
    the water. Propulsion is the method by which you create that force.</p><div class="sect2" title="General Resistance"><div class="titlepage"><div><div><h3 class="title" id="general_resistance">General Resistance</h3></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>, we <a id="sh16.3.1" class="indexterm"/><a id="re16.3.1" class="indexterm"/><a id="dr16.3.1" class="indexterm"/>discussed drag forces on objects moving through a fluid. Specifically, we
        discussed frictional and pressure drag. Ships moving on the water’s surface experience these
        drag forces; however, at the air-water interface, there are other drag components that you
        have to consider. If you were to write an equation breaking up the total resistance acting
        on a ship into its three main components, that equation would look something like
        this:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>total</sub> =
        R<sub>friction</sub> + R<sub>pressure</sub> +
        R<sub>waves</sub></td></tr></table><p>We’ll describe each of these components and give you some
      empirical formulas in just a moment. First, however, we want to qualify
      the material to follow by saying it is very general in nature and
      applicable only when little detail is known about the complete geometry
      of the particular ship under consideration. In the practice of ship
      design, these formulas would be used only in the very early stages of
      the design process to approximate resistance. That said, they are very
      useful for getting in the ballpark, so to speak, and (sometimes more
      importantly) in performing parametric studies to see the effects of
      changes in major parameters.</p><p>The first resistance component is the frictional drag<a id="I_indexterm2_id342314" class="indexterm"/> on the underwater surface of the hull as it moves through
      the water. This is the same as the frictional drag that we discussed in
      <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>. However, for ships there’s a convenient set of
      empirical formulas that you can use to calculate this force:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>friction</sub> = (1/2) ρ
        V<sup>2</sup> S C<sub>f</sub></td></tr></table><p>In this formula, ρ is the density of water, <span class="emphasis"><em>V</em></span>
      is the speed of the ship, <span class="emphasis"><em>S</em></span> is the surface area of
      the underwater portion of the hull, and
      <span class="emphasis"><em>C</em></span><sub>f</sub> is the coefficient of
      frictional resistance. You can use this empirical formula to calculate
      <span class="emphasis"><em>C</em></span><sub>f</sub>:</p><table style="border: 0; " class="simplelist"><tr><td>C<sub>f</sub> = 0.075 / (log10 Rn – 2)2</td></tr></table><p>Here, <span class="emphasis"><em>Rn</em></span> is the <a id="I_indexterm2_id342398" class="indexterm"/>Reynolds number, as defined in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>, based on the length of the ship’s hull. This
      formula was adopted in 1957 by the International Towing Tank Conference
      (ITTC)<a id="I_indexterm2_id342412" class="indexterm"/><a id="I_indexterm2_id342418" class="indexterm"/> and is widely used in the field of naval architecture for
      estimating frictional resistance coefficients for ships.</p><p>To apply the formula for R<sub>friction</sub>, you’ll
      also have to know the surface area, <span class="emphasis"><em>S</em></span>, of the
      underwater portion of the hull. You can directly calculate this area
      using numerical integration techniques, similar to those for calculating
      volume, or you can use yet another empirical formula:</p><table style="border: 0; " class="simplelist"><tr><td>S = C<sub>ws</sub>
          √(∇L)
        </td></tr></table><p>In this formula, ∇ is the displaced volume, <span class="emphasis"><em>L</em></span>
      the length of the ship, and
      <span class="emphasis"><em>C</em></span><sub>ws</sub> is the wetted surface
      coefficient. This coefficient is a function of the ship’s shape—its
      breadth-to-draft ratio—and <a id="I_indexterm2_id342469" class="indexterm"/>statistically it ranges from 2.6 to 2.9 for typical
      displacement hull forms.</p><p>The pressure drag <a id="I_indexterm2_id342479" class="indexterm"/>experienced by a ship is the same as that experienced by
      projectiles as discussed in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>. Remember, this
      drag is due to the viscous effects causing a region of relatively low
      pressure behind the ship. Quantifying this force is difficult for ships
      of arbitrary geometry. We can use computational fluid dynamics
      algorithms to approximate this force, but this requires detailed
      knowledge of the hull geometry and a whole lot of time-consuming
      computations. An alternative is to rely on scale-model test data where
      results from the model test are extrapolated to approximate drag on the
      full-size ship.</p><p>Just like pressure drag, wave drag is <a id="I_indexterm2_id342502" class="indexterm"/>difficult to compute, and we usually rely on model testing
      in practice. Wave drag is due to the energy transfer, or momentum
      transfer, from the ship to the fluid, or in other words, it’s a function
      of the work done by the ship on the surrounding fluid to generate the
      waves. The visible presence of wave resistance is evident in the large
      bow wave that builds up at the front of the ship as well as the wave
      system that originates at the stern of the ship as it moves through the
      water. These waves affect the pressure distribution around the ship and
      thus affect the pressure drag, which makes it difficult for us to
      separate the wave drag component from pressure drag when performing an
      analysis.</p><p>When scale model tests are performed, pressure drag and wave drag
      are usually lumped together in <a id="I_indexterm2_id342520" class="indexterm"/><a id="I_indexterm2_id342526" class="indexterm"/>what’s known as <span class="emphasis"><em>residual resistance</em></span>.
      Analogous to the coefficient of frictional drag, you can determine a
      coefficient of residual resistance, such that:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>r</sub> = R<sub>pressure</sub> +
        R<sub>wave</sub> = (1/2) ρ V<sup>2</sup> S
        C<sub>r</sub></td></tr></table><p>Here <span class="emphasis"><em>R</em></span><sub>r</sub> is the total
      residual resistance, and <span class="emphasis"><em>C</em></span><sub>r</sub>
      is the coefficient of residual resistance.</p><p>There are many resistance estimation methods available that allow
      you to estimate the coefficient of residual resistance for a ship;
      however, they are usually presented for specific ship types. For
      example, one method might give empirical formulas for
      <span class="emphasis"><em>C</em></span><sub>r</sub> for destroyer-type ships,
      while another might give formulas for
      <span class="emphasis"><em>C</em></span><sub>r</sub> for large oil tankers.
      The trick, of course, is to choose a method appropriate for the type of
      ship you are analyzing.<sup>[<a id="CHP-16-FN-1" href="#ftn.CHP-16-FN-1" epub:type="noteref" class="footnote">29</a>]</sup> Generally, <span class="emphasis"><em>C</em></span><sub>r</sub>
      increases as the displacement and speed of the ship increase. A typical
      range for <span class="emphasis"><em>C</em></span><sub>r</sub> for large
      displacement hulls is from 1.0e–3 to 3.0e–3.</p><p>While these three resistance components—friction, pressure, and
      wave—are the most important for typical displacement-type ships, they
      aren’t the only ones. Since a ship operates at the air-water interface,
      a large part of its structure is above the water surface, exposed to the
      air. This means that the ship will also experience air resistance.
      <a id="I_indexterm2_id342642" class="indexterm"/>You can approximate this air resistance using the
      following formula:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>air</sub> = (1/2) ρ
        V<sup>2</sup> A<sub>p</sub>
        C<sub>air</sub></td></tr></table><p>Here, <span class="emphasis"><em>C</em></span><sub>air</sub> is the coefficient of air
        resistance, ρ is the density of air, <span class="emphasis"><em>V</em></span> is the speed of the ship, and
          <span class="emphasis"><em>A</em></span><sub>p</sub> is the projected transverse (profile) area
        of the ship. <span class="emphasis"><em>C</em></span><sub>air</sub> typically ranges from 0.6 to
        1.1, depending on the type of ship. Tankers and large cargo ships tend to be near the upper
        end of the range, while combatant ships tend to be near the lower end. In lieu of enough
        information to calculate the projected transverse area of the ship, you can approximate it
        by:</p><table style="border: 0; " class="simplelist"><tr><td>A<sub>p</sub> =
        B<sup>2</sup>/2</td></tr></table><p>where <span class="emphasis"><em>B</em></span> is the breadth (width) of the
      <a id="I_indexterm2_id342734" class="indexterm"/>ship.</p><div class="sect3" title="Planing craft"><div class="titlepage"><div><div><h4 class="title" id="planing_craft">Planing craft</h4></div></div></div><p>Planing craft <a id="I_indexterm2_id342759" class="indexterm"/>are different than displacement vessels in that when
        they reach their cruising speed they are not supported by buoyancy.
        Unlike a super tanker, a recreational speedboat has a much “flatter”
        hull form. It almost looks like a very fat foil, which it is! When a
        speedboat is just sitting in the water it is fully supported by its
        buoyancy, just like a tanker. However, as the boat starts moving
        forward, the hull is at an angle of attack to the water. Like a super
        tanker, the boat is also creating a wave in front of it as it moves,
        called the <span class="emphasis"><em>bow wave</em></span>. However, similar to an
        airplane breaking the sound barrier, a planing craft is fast enough to
        catch up to this wave. As it reaches its own bow wave, the vessel will
        start to tilt backward. This tilting increases the resistance by
        virtue of increasing the angle of attack of the vessel’s hull.
        However, if the vessel has additional power to overcome this increased
        resistance, the lift force generated from the hull foil will begin to
        lift the hull out of the water. At this point, the forces in <a class="xref" href="ch16.html#forces_on_a_planing_craft" title="Figure 16-4. Forces on a planing craft">Figure 16-4</a> begin to dominate.</p><div class="figure"><a id="forces_on_a_planing_craft"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id342796"/><img style="width: 290.551181102362; " src="httpatomoreillycomsourceoreillyimages1598973.png" alt="Forces on a planing craft"/></div></div><div class="figure-title">Figure 16-4. Forces on a planing craft</div></div><p>As you can see, compared to when the boat is at rest, very
        little of the hull is in the water now. This, in turn, provides
        positive feedback because it reduces the wetted surface area and
        <a id="I_indexterm2_id342820" class="indexterm"/>skin friction and allows the craft to go faster,
        generating more lift and reducing the skin friction yet again.
        Simultaneously, the drag created by the foil moving through the fluid
        increases until eventually the available power is exhausted and top
        speed is attained. If we plot the resistance versus speed, it might
        look something like <a class="xref" href="ch16.html#planing_craft_resistance_versus_speed" title="Figure 16-5. Planing craft resistance versus speed">Figure 16-5</a>.</p><div class="figure"><a id="planing_craft_resistance_versus_speed"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id342852"/><img src="httpatomoreillycomsourceoreillyimages1598974.png" alt="Planing craft resistance versus speed"/></div></div><div class="figure-title">Figure 16-5. Planing craft resistance versus speed</div></div><p>Notice the hump region. This is where the vessel trims aft in
        the transition mode and there is a rise in the resistance. There have
        been embarrassing cases where a vessel, although having enough power
        to make the design speed once over the humps, lacked the power to make
        the transition.</p></div><div class="sect3" title="Virtual mass"><div class="titlepage"><div><div><h4 class="title" id="virtual_mass">Virtual mass</h4></div></div></div><p>The <a id="I_indexterm2_id342892" class="indexterm"/><a id="I_indexterm2_id342898" class="indexterm"/>concept of <span class="emphasis"><em>virtual mass</em></span> is
        important for calculating the acceleration of a ship in a real-time
        simulator. Virtual mass is equal to the mass of the ship plus the mass
        of the water that is accelerated with the ship.</p><p>Back in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> we told you about the viscous boundary layer, <a id="I_indexterm2_id342924" class="indexterm"/><a id="I_indexterm2_id342930" class="indexterm"/>and we said that the relative velocity (relative to the moving body) of the
          fluid particles near the moving body’s surface is 0 at the body surface and increases to
          the free stream velocity as distance from the body surface increases. Essentially, some of
          the fluid sticks to the body as it moves and is accelerated with the body. Since the
          velocity of the fluid varies within the boundary layer, so does the acceleration. The
            <span class="emphasis"><em>added mass</em></span>, the mass of water that gets accelerated, is a weighted
          integration of the entire mass of fluid that is affected by the body’s
          acceleration.</p><p>For a ship, the viscous boundary layer can be quite thick, up to several feet near the
          end of the ship depending on its length, and the mass of water that gets accelerated is
          significant. Therefore, when doing any sort of analysis that involves the acceleration of
          the ship, you need to consider added mass, too. The calculation of added mass is beyond
          the scope of this book. We should also point out that, unlike mass, added mass is a
          tensor—that is, it depends on the direction of acceleration. Further, added mass applies
          to both linear and angular motion.</p><p>Added mass is typically expressed in terms of an added mass
        coefficient, which equals the added mass divided by the mass of the
        ship. Some methods actually integrate over the actual hull surface,
        while others approximate the hull as an ellipsoid with proportions
        matching the ship’s. Using this approximation, the ellipsoid’s length
        corresponds to the ship’s length while its width corresponds to the
        ship’s breadth. For longitudinal motion (that is, linear motion along
        an axis parallel to the ship’s length), the added mass coefficient
        varies nearly linearly from 0.0 at a breadth-to-length ratio
        <a id="I_indexterm2_id342968" class="indexterm"/>of 0 (the ship is infinitely thin) up to 0.5 at a
        breadth-to-length ratio of 1 (a sphere).</p><p>When the added mass coefficient is expressed as a percentage of
        the ship’s mass, virtual mass can be calculated as
        <span class="emphasis"><em>mv</em></span> = <span class="emphasis"><em>m</em></span> (1 +
        <span class="emphasis"><em>xa</em></span>), where <span class="emphasis"><em>m</em></span> is mass, and
        <span class="emphasis"><em>xa</em></span> is the added mass coefficient—for example, 0.2
        for 20%. For typical displacement ship proportions, the longitudinal
        added mass ranges from about 4% to 15% of the mass of the ship.
        Conservative estimates generally use 20%.</p></div><div class="sect3" title="Guidance speeds"><div class="titlepage"><div><div><h4 class="title" id="guidance_speeds">Guidance speeds</h4></div></div></div><p>To provide some guidance, <a class="xref" href="ch16.html#some_vessels_and_their_speeds" title="Table 16-1. Some vessels and their speeds">Table 16-1</a> provides common <a id="I_indexterm2_id343020" class="indexterm"/><a id="I_indexterm2_id343030" class="indexterm"/>ship types and appropriate speed ranges. This will help
        guide you in properly simulating the resistance of your vessel.</p><div class="table"><a id="some_vessels_and_their_speeds"/><div class="table-title">Table 16-1. Some vessels and their speeds</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Vessel
                type</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Speed
                (knots)</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Horsepower
                (hp)</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Aircraft
                carrier</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>31.5</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>260,000</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cruiser</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>80,000</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Oil
                tanker</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15–20</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>20,000–60,000</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Containership</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>21</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>100,000</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>200-foot
                yacht</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15.5</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>4,000</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35-foot recreational
                boat</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>420</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35-foot
                speedboat</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>70</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>1,200</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>40-foot
                sailboat</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>8.5</p></td><td style="text-align: left; vertical-align: top; "><p>N/A</p></td></tr></tbody></table></div></div><p>Note that at a certain speed, for non-planing hulls, there is a
        theoretical limit to how fast a boat can go. This speed is <a id="I_indexterm2_id343380" class="indexterm"/>called the <span class="emphasis"><em>hull speed</em></span>. At the hull
        speed the bow and stern waves reinforce each other, and there is a
        rise in wave-making resistance. This can be a barrier for some fuller
        hulls. Note that the speed for the 40-foot sailboat is the hull speed
        of a 40-foot full-formed (not slender) hull. We can calculate the hull
        speed with the following formula:</p><table style="border: 0; " class="simplelist"><tr><td>V<sub>hull</sub> ≈ 1.34 × 
            <span class="inlinemediaobject"><img src="inleq_1602.png" alt=""/></span>   
            
          </td></tr></table><p>Where <span class="emphasis"><em>V</em></span><sub>hull</sub> is the
        hull speed in knots and L<sub>WL</sub> is the length on
        the water line. Some modern displacement boats, especially racing
        kayaks, can exceed their hull speed if they have very fine ends, long
        hulls with narrow beams, or some other optimized hull <a id="I_indexterm2_id343433" class="indexterm"/><a id="I_indexterm2_id343442" class="indexterm"/>form.</p></div></div><div class="sect2" title="Propulsion"><div class="titlepage"><div><div><h3 class="title" id="propulsion">Propulsion</h3></div></div></div><p>There are a <a id="I_indexterm2_id343462" class="indexterm"/><a id="I_indexterm2_id343472" class="indexterm"/>variety of methods to propel a boat through the water. The
      oldest is by way of sails using the wind. The physics of sailing could
      fill several chapters on its own, so we won’t go into detail here. If
      you are interested in that topic, <span class="emphasis"><em>The Physics of Sailing
      Explained</em></span> (Sheridan House), by <a id="I_indexterm2_id343485" class="indexterm"/>Bryon Anderson, is a good starting point. You can also
      check out the airplane chapter in this book and note that a sail is just
      a vertical wing. We will say this: if you choose to put a sailing vessel
      in your simulation, make sure to remember the golden rule! You cannot
      generally sail within 45 degrees of the direction the wind is coming
      from.</p><p>There are many different kinds of propulsion: rudders, shafted
      fixed-pitch propellers, shafted CPP propellers, azimuthing thrusters,
      propellers in nozzles, water jets, pump jets, contra-rotating, and the
      very odd Voith Schneider type. We can’t get into all of them here, but
      the aforementioned list should get you started if you are interesting in
      modeling the specifics of different propulsor types.</p><p>The major propulsion relationship for your simulation would be
      <a id="I_indexterm2_id343506" class="indexterm"/>the thrust-to-propeller RPM or <a id="I_indexterm2_id343515" class="indexterm"/>thrust-to-throttle curve. The fly in the ointment here is
      that thrust is also dependent on forward speed. As the boat moves faster
      and faster through the water, the inflow velocity of the water into the
      propeller is higher and higher. This means that the difference between
      the velocity of the intake and the velocity of the output is smaller,
      reducing the amount of thrust. In general, the thrust curve versus boat
      speed will look like <a class="xref" href="ch16.html#speed_versus_required_thrust" title="Figure 16-6. Speed versus required thrust">Figure 16-6</a>.</p><div class="figure"><a id="speed_versus_required_thrust"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id343543"/><img src="httpatomoreillycomsourceoreillyimages1598975.png" alt="Speed versus required thrust"/></div></div><div class="figure-title">Figure 16-6. Speed versus required thrust</div></div><p>An important physical phenomenon concerning propulsion that you may want to incorporate<a id="I_indexterm2_id343563" class="indexterm"/> is <span class="emphasis"><em>cavitation</em></span>. Cavitation occurs when a propeller is
        moving fast enough that the low-pressure side of the blade starts spontaneously creating
        vapor bubbles. These bubbles exist for a short while, and then as the propeller turns, the
        static pressure changes. This higher static pressure causes the bubbles to collapse
        violently. This collapse is so fast and furious that it can cause metal erosion at a high
        rate. It will eat away at a propeller until it is no longer producing thrust. It is also
        very noisy. That is why submarine propellers are shaped very differently than other ships’
        propellers. They seek to limit cavitations so they’re not heard by enemy vessels. The damage
        caused by cavitation also creates a speed limit on RPMs for a propeller. Cavitation is a
        real-life phenomenon you can exploit to penalize the player for driving around at high speed
        all the time.</p></div></div><div class="sect1" title="Maneuverability"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="maneuverability">Maneuverability</h2></div></div></div><p>Another aspect of <a id="sh16.4" class="indexterm"/><a id="I_indexterm2_id343610" class="indexterm"/>ships and boats that is often oversimplified is maneuverability. Maneuverability
      is also a very complex topic whose numerical simulation is beyond the current realm of
      real-time simulation. However, with some simplifications and assumptions, it can be more
      accurately modeled than if you do not know the underlying framework. Almost all vessels
      maneuver by way of two methods: rudders or thrust vectoring. The users generally won’t care
      about the differences, so you can model both by angling the thrust vector off-center.</p><div class="sect2" title="Rudders and Thrust Vectoring"><div class="titlepage"><div><div><h3 class="title" id="rudders_and_thrust_vectoring">Rudders and Thrust Vectoring</h3></div></div></div><p>Although <a id="I_indexterm2_id343636" class="indexterm"/><a id="I_indexterm2_id343648" class="indexterm"/>rudders and thrust vectoring have the same result, there
      are some important differences. A thrust vectoring system, like a jet
      boat, can steer only when the vessel is producing thrust. A rudder, on
      the other hand, works only when the vessel has forward speed. If the
      boat isn’t moving forward with enough speed, then the rudder can’t
      produce a turning moment.</p><p>If you keep in mind those differences, you can model both systems
      the same way. The most important thing to keep in mind when modeling
      larger ships in your games is that they take significant time to respond
      to control inputs. <a class="xref" href="ch16.html#solidus_10_zig-zag_test" title="Figure 16-7. 10/10 zig-zag test">Figure 16-7</a><a id="I_indexterm2_id343668" class="indexterm"/> tracks the heading of a ship over time during what is
      called the <span class="emphasis"><em>10/10 maneuver</em></span>.</p><div class="figure"><a id="solidus_10_zig-zag_test"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id343693"/><img style="width: 279.92125984252; " src="httpatomoreillycomsourceoreillyimages1598976.png" alt="10/10 zig-zag test"/></div></div><div class="figure-title">Figure 16-7. 10/10 zig-zag test</div></div><p>A vessel is moving in a straight line, and the rudder is put over
      10 degrees in one direction. Once the vessel’s heading changes 10
      degrees, the rudder is moved to the opposite side at the same angle. The
      initial turning time is the time it took for the vessel to change its
      heading 10 degrees. As large ships have enormous momentum, they will
      continue to turn even though the rudder is in the opposite direction.
      The maximum deviation from the original heading minus the 10 degrees at
      which the rudder was flipped is called<a id="I_indexterm2_id343720" class="indexterm"/> the <span class="emphasis"><em>overshoot angle</em></span>. The size of
      this angle is one measure of how slow the vessel is to respond to the
      helm. For larger ships, this can be between 15 degrees when light and 45
      degrees when loaded with cargo.</p><p>The time to check yaw is the time in seconds it takes for the
      overshoot angle to be achieved and the vessel to start changing its
      heading again. This is repeated for the other side to detect any bias a
      vessel may have for turning in a particular direction. The moral of the
      story is that for anything other than a high-speed small craft, boats
      and ships can take a significant amount of time to respond to the helm.
      Your simulation should strive to reproduce a turning ability that
      matches <a class="xref" href="ch16.html#solidus_10_zig-zag_test" title="Figure 16-7. 10/10 zig-zag test">Figure 16-7</a> for extra
      realism.</p><p>A special kind of thrust vectoring is <a id="I_indexterm2_id343750" class="indexterm"/><a id="I_indexterm2_id343756" class="indexterm"/>called <span class="emphasis"><em>throttle steering</em></span>. Imagine that a boat has two
        engines. If one is run in forward and the other in reverse, the vessel will turn quite
        rapidly. For a twin-engine vessel operating in close quarters, the rudders are often
        centered and the vessel maneuvered solely by altering the throttle settings of the two
        props.</p><div class="sect3" title="Propeller walk"><div class="titlepage"><div><div><h4 class="title" id="propeller_walk">Propeller walk</h4></div></div></div><p>Another interesting <a id="I_indexterm2_id343786" class="indexterm"/>maneuvering phenomenon that is closely related to thrust
        vectoring is called <span class="emphasis"><em>propeller walk</em></span>, or
        <span class="emphasis"><em>prop walk</em></span>. This is especially important for
        vessels with only one propeller moving in tight spaces. The cause of
        propeller walk is related to the fact that most propellers are
        installed at an angle to the horizon. This angle causes the thrust to
        be greater when the blades are moving down than when the blades are
        moving upward. In a propeller that turns clockwise, this creates a
        push to the right.</p><p>In forward gear the rudder is very effective at countering the propeller walk, but in
          reverse the rudder is much less effective, making the propeller walk much more noticeable.
          This can add a significant amount of realism when you are simulating vessels in docking
            <a id="I_indexterm2_id343811" class="indexterm"/>maneuvers.</p></div></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.CHP-16-FN-1"><p><sup>[<a href="#CHP-16-FN-1" class="para">29</a>] </sup>These methods are quite involved and there are far too many to discuss here, so
            we’ve included some references in the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a>
            for you.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 17. Cars and Hovercraft</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Physical Modeling"/><link rel="prev" href="ch16.html" title="Chapter 16. Ships and Boats"/><link rel="next" href="ch18.html" title="Chapter 18. Guns and Explosions"/></head><body><section class="chapter" title="Chapter 17. Cars and Hovercraft" epub:type="chapter" id="cars_and_hovercraft"><div class="titlepage"><div><div><h2 class="title">Chapter 17. Cars and Hovercraft</h2></div></div></div><p>What cars and <a id="I_indexterm3_id343833" class="indexterm"/>hovercraft have in common is that they operate in an
  essentially 2D manner. Unless they have jumped a ramp, both vehicles remain
  on the ground or water plane. In this chapter we’ll discuss the forces
  behind each vehicle’s method of travel and discuss how to accurately model
  them in your simulations.</p><div class="sect1" title="Cars"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="cars">Cars</h2></div></div></div><p>In the <a id="I_indexterm3_id343862" class="indexterm"/>following sections we want to discuss certain aspects of the
    physics behind automobile motion. Like the previous four chapters, the
    purpose of this chapter is to explain, by example, certain physical
    phenomena. We also want to give you a basic understanding of the mechanics
    involved in automobile motion in case you want to simulate one in your
    games. In keeping with the theme of this book, we’ll be talking about
    mechanics in the sense of rigid-body motion, and not in the sense of how
    an internal combustion engine works, or how power is transferred through
    the transmission system to the wheels, etc. Those are all internal to the
    car as a rigid body, and we’ll focus on the external forces. We will,
    however, discuss how the torque applied to the drive wheel is translated
    to a force that pushes the car along.</p><div class="sect2" title="Resistance"><div class="titlepage"><div><div><h3 class="title" id="resistance">Resistance</h3></div></div></div><p>Before we talk <a id="I_indexterm3_id343894" class="indexterm"/><a id="I_indexterm3_id343904" class="indexterm"/><a id="I_indexterm3_id343916" class="indexterm"/>about why cars move forward, let’s talk about what slows
      them down. When a car drives down a road, it experiences two main
      components of resistance that try to slow it down. The first <a id="I_indexterm3_id343931" class="indexterm"/>component is aerodynamic drag, and the second is called
      <span class="emphasis"><em>rolling resistance</em></span>. The total resistance felt by
      the car is the sum of these two components:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>total</sub> = R<sub>air</sub> +
        R<sub>rolling</sub></td></tr></table><p>The aerodynamic drag is primarily skin friction <a id="I_indexterm3_id343973" class="indexterm"/><a id="I_indexterm3_id343985" class="indexterm"/>and pressure drag similar to that experienced by the
      projectiles discussed in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>, and the planes
      and boats discussed in earlier chapters. Here again, you can use the
      familiar drag formula:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>air</sub> = (1/2) ρ
        V<sup>2</sup> S<sub>p</sub>
        C<sub>d</sub></td></tr></table><p>Here ρ (rho) is the mass density of air, <span class="emphasis"><em>V</em></span> is
      the speed of the car, <span class="emphasis"><em>S</em></span><sub>p</sub> is
      the projected frontal area of the car normal to the direction of
      <span class="emphasis"><em>V</em></span>, and
      <span class="emphasis"><em>C</em></span><sub>d</sub> is the drag coefficient.
      <a id="I_indexterm3_id344047" class="indexterm"/>Typical ranges of drag coefficients for different types of
      vehicles are 0.29 to 0.4 for sports cars, 0.43 to 0.5 for pickup trucks,
      0.6 to 0.9 for tractor-trailers, and 0.4 to 0.5 for the average economy
      car. Drag coefficient is a function of the shape of the vehicle—that is,
      the degree of boxiness or streamline. Streamlined body styles have lower
      drag coefficients; for example, the Chevy Corvette has a low drag
      coefficient of 0.29, while the typical tractor-trailer without fairings
      has a high drag coefficient of up to 0.9. You can use these coefficients
      in your simulations to tune the behavior of different types and shapes
      of vehicles.</p><p>When a tire rolls on a road, it experiences <a id="I_indexterm3_id344066" class="indexterm"/><a id="I_indexterm3_id344074" class="indexterm"/>rolling resistance, which tends to retard its motion.
      Rolling resistance is not frictional resistance, but instead has to do
      with the deformation of the tire while rolling. It’s a difficult
      quantity to calculate theoretically since it’s a function of a number of
      complicated factors—such as tire and road deformation, the pressure over
      the contact area of the tire, the elastic properties of the tire and
      road materials, the roughness of the tire and road surfaces, and tire
      pressure, to name a few—so instead you’ll have to rely on an empirical
      formula. The formula to use is as follows:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>rolling</sub> = C<sub>r</sub>
        w</td></tr></table><p>This gives you the rolling resistance per tire, where
      <span class="emphasis"><em>w</em></span> is the weight supported by the tire, <a id="I_indexterm3_id344117" class="indexterm"/>and <span class="emphasis"><em>C</em></span><sub>r</sub> is the
      <span class="emphasis"><em>coefficient of rolling resistance</em></span>.
      <span class="emphasis"><em>C</em></span><sub>r</sub> is simply the ratio of
      the rolling resistance force to the weight supported by the tire.
      Luckily for you, tire manufacturers generally provide the coefficient of
      rolling resistance for their tires under design conditions. Typical car
      tires have a <span class="emphasis"><em>C</em></span><sub>r</sub> of about
      0.015, while truck tires fall within the range of 0.006 to 0.01. If you
      assume that a car has four identical tires, then you can estimate the
      total rolling resistance for the car by substituting the total car
      weight for <span class="emphasis"><em>w</em></span> in the preceding equation.</p></div><div class="sect2" title="Power"><div class="titlepage"><div><div><h3 class="title" id="power">Power</h3></div></div></div><p>Now that you know <a id="I_indexterm3_id344167" class="indexterm"/><a id="I_indexterm3_id344177" class="indexterm"/><a id="I_indexterm3_id344187" class="indexterm"/><a id="I_indexterm3_id344193" class="indexterm"/>how to calculate the total resistance on your car, you can
      easily calculate the power required to overcome the resistance at a
      given speed. Power is a measure of the amount of
      <span class="emphasis"><em>work</em></span> done by a force, or torque, over time.
      Mechanical work done by a force is equal to the force times the distance
      an object moves under the action of that force. It’s expressed in units
      such as foot-pounds. Since power is a measure of work done over time,
      its units are, for example, foot-pounds per second. Usually power in the
      context of car engine output is expressed in units of
      <span class="emphasis"><em>horsepower</em></span>, where 1 horsepower equals 550
      ft-lbs/s.</p><p>To calculate the horsepower required to overcome total resistance
      at a given speed, you simply use this formula:</p><table style="border: 0; " class="simplelist"><tr><td>P = (R<sub>total</sub> V) / 550</td></tr></table><p>Here <span class="emphasis"><em>P</em></span> is power in units of horsepower, and
      <span class="emphasis"><em>R</em></span><sub>total</sub> is the total
      resistance corresponding to the car’s speed, <span class="emphasis"><em>V</em></span>.
      Note, in this equation
      <span class="emphasis"><em>R</em></span><sub>total</sub> must be in pound
      units and <span class="emphasis"><em>V</em></span> must be in units of feet per
      second.</p><p>Now this is not the engine output power required to reach the
      speed <span class="emphasis"><em>V</em></span> for your car; rather, it is the required
      power delivered by the drive wheel to reach the speed
      <span class="emphasis"><em>V</em></span>. The installed engine power will be higher for
      several reasons. First, there will be mechanical losses associated with
      delivering the power from the engine through the transmission and drive
      train to the tire. The power will actually reach the tire in the form of
      torque, which given the radius of the tire will create a force
      <span class="emphasis"><em>F</em></span><sub>w</sub> that will overcome the
      total resistance. This force is calculated as follows:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>w</sub> =
        T<sub>w</sub>/r</td></tr></table><p>Here <span class="emphasis"><em>F</em></span><sub>w</sub> is the force delivered by the tire
        to the road to push the car along, <span class="emphasis"><em>T</em></span><sub>w</sub> is the
        torque on the tire, and <span class="emphasis"><em>r</em></span> is the radius of the tire. The second reason
        the installed engine power will be greater is because some engine power will be transferred
        to other systems in the car. For example, power is required to charge the battery and to run
        the air conditioner.</p></div><div class="sect2" title="Stopping Distance"><div class="titlepage"><div><div><h3 class="title" id="stopping_distance">Stopping Distance</h3></div></div></div><p>Under normal <a id="I_indexterm3_id344340" class="indexterm"/><a id="I_indexterm3_id344351" class="indexterm"/><a id="I_indexterm3_id344357" class="indexterm"/>conditions, stopping distance is a function of the braking system and how hard
        the driver applies the brakes: the harder the brakes are applied, the shorter the stopping
        distance. That’s not the case when the tires start to skid. Under skidding conditions,
        stopping distance is a function of the <a id="I_indexterm3_id344370" class="indexterm"/>frictional force that develops between the tires and the road, in addition to
        the inclination of the roadway. If the car is traveling uphill, the skidding distance will
        be shorter because gravity helps slow the car, while it will tend to accelerate the car and
        increase the skidding distance when the car is traveling downhill.</p><p>There’s a simple formula that considers these factors that you can
      use to calculate skidding distance:</p><table style="border: 0; " class="simplelist"><tr><td>d<sub>s</sub> = V<sup>2</sup> /
        [2g ( µ cos φ + sin φ)]</td></tr></table><p>Here <span class="emphasis"><em>d</em></span><sub>s</sub> is the
      <a id="I_indexterm3_id344417" class="indexterm"/><a id="I_indexterm3_id344427" class="indexterm"/>skidding distance, <span class="emphasis"><em>g</em></span> the acceleration
      due to gravity, µ the coefficient of friction between the tires and
      road, <span class="emphasis"><em>V</em></span> the initial speed of the car, and φ the
      inclination of the roadway (where a positive angle means uphill and a
      negative angle means downhill). Note that this equation does not take
      into account any aerodynamic drag that will help slow the car
      down.</p><p>The coefficient of friction will vary depending on the condition
      of the tires and surface of the road, but for rubber on pavement the
      dynamic friction coefficient is typically around 0.4, while the static
      coefficient is around 0.55.</p><p>When calculating the actual frictional force between the tire and road, say in a
        real-time simulation, you’ll use the same formula that we showed you in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>f</sub> = µ W</td></tr></table><p>Here <span class="emphasis"><em>F</em></span><sub>f</sub> is the friction force applied to
        each tire, assuming it’s not rolling, and <span class="emphasis"><em>W</em></span> is the weight supported by
        each tire. If you assume that all tires are identical, then you can use the total weight of
        the car in the preceding formula to determine the total friction force applied to all
        tires.</p></div><div class="sect2" title="Steering"><div class="titlepage"><div><div><h3 class="title" id="steering">Steering</h3></div></div></div><p>When you turn the <a id="ca17.1.4" class="indexterm"/><a id="st17.1.4" class="indexterm"/>steering wheel of a car, the front wheels exert a side
      force such that the car starts to turn. In terms of <a id="I_indexterm3_id344537" class="indexterm"/>Euler angles, this would be yaw, although Euler angles
      aren’t usually used in discussions about turning cars. Even if the car’s
      speed is constant, it experiences acceleration due to the fact that its
      velocity vector has changed direction. Remember, acceleration is the
      time rate of change in velocity, which has both magnitude and
      direction.</p><p>For a car to maintain its curved path, there must <a id="I_indexterm3_id344557" class="indexterm"/><a id="I_indexterm3_id344564" class="indexterm"/>be a <span class="emphasis"><em>centripetal</em></span> force (“center
      seeking” in Greek) that acts on the car. When riding in a turning car,
      you feel an <a id="I_indexterm3_id344579" class="indexterm"/><a id="I_indexterm3_id344585" class="indexterm"/><a id="I_indexterm3_id344595" class="indexterm"/>apparent <span class="emphasis"><em>centrifugal</em></span> acceleration, or
      force directed away from the center of the turn. This acceleration is
      really a result of <span class="emphasis"><em>inertia</em></span>, the tendency of your
      body and the car to continue on their original path, and is not a real
      force acting on the car or your body. The real force is the centripetal
      force, and without it your car would continue on its straight path and
      not along the curve.</p><p>One of the most important aspects of racing is taking turns as fast as possible but
        without losing control. The longer you can wait to decelerate for the turn, and the sooner
        you can start accelerating again, the higher your average speed will be. It is interesting
        to note that when people ride in racecars, what really surprises them isn’t the acceleration
        but the massive decelerations they can create through braking forces. A Formula One car
        regularly experiences decelerations of 4g, with 5–6g being the extreme value for certain
        race courses. Most road-legal sports cars can achieve about 1g of braking force. This allows
        the racecars to maintain speed until just entering the corner.</p><p>When you turn the steering wheel in a car, the tires produce a
      centripetal force toward the center of the curve via friction with the
      surface of the road. It follows that the maximum static frictional force
      between the tires and the road must exceed the required centripetal
      force. Mathematically, this takes on the following inequality:</p><table style="border: 0; " class="simplelist"><tr><td>µ <sub>s</sub>N &gt;
        mv<sup>2</sup>/r</td></tr></table><p>Centripetal acceleration is the square of the tangential velocity,
      <span class="emphasis"><em>v</em></span>, divided by the radius of the turn,
      <span class="emphasis"><em>r</em></span>. This multiplied by mass of the vehicle,
      <span class="emphasis"><em>m</em></span>, gives the force required to make a turn. The
      available force is the static coefficient of friction times the normal
      force, <span class="emphasis"><em>N</em></span>. Rewriting this formula, we can develop a
      simplified maximum cornering speed as follows:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>limit</sub> &lt;  <span class="inlinemediaobject"><img src="inleq_1701.png" alt=""/></span> </td></tr></table><p>If this speed is exceeded, the cornering force will exceed the
      static coefficient of friction and the tires will begin to slide. It may
      be tempting to replace the normal force, <span class="emphasis"><em>N</em></span>, with
      the weight of the vehicle (mass times gravity) and cancel out the mass
      of the car, but the normal force may not always be simplified as such,
      as we’ll discuss in a moment. Also, in real life, the weight of a
      vehicle is rarely evenly distributed among all four tires and is
      definitely not when the car is acceleration or decelerating. In general,
      acceleration causes a weight shift to the aft tires, and deceleration
      causes weight to shift to the forward tires. This is important because,
      depending on where the weight is, the front or back tires will tend to
      have less available friction. If one or the other sets of tires begins
      to slide, the car will either <a id="I_indexterm3_id344706" class="indexterm"/><a id="I_indexterm3_id344712" class="indexterm"/>understeer or oversteer (see <a class="xref" href="ch17.html#understeer_on_right_comma_oversteer_on" title="Figure 17-1. Understeer on right, oversteer on left">Figure 17-1</a>).</p><div class="figure"><a id="understeer_on_right_comma_oversteer_on"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id344735"/><img src="httpatomoreillycomsourceoreillyimages1598977.png.jpg" alt="Understeer on right, oversteer on left"/></div></div><div class="figure-title">Figure 17-1. Understeer on right, oversteer on left</div></div><p>If the front wheels slide, the car understeers and the arc is
      larger than the driver intended. This is commonly caused by traveling
      too fast through a corner and trying to take the corner too tightly.
      However, if the driver breaks hard or even just lets off the gas, there
      will be a weight shift forward. This will keep the forward wheels from
      slipping but if too aggressive will cause the rear wheels to slip as
      weight is transferred away from them. This causes the car to turn more
      than the driver intended, and can even result in a spin. These two
      conditions limit the speed at which a car can complete a turn and also
      the amount of deceleration the car can handle once the turn is
      initiated.</p><p>To increase the limit speed,
      <span class="emphasis"><em>v</em></span><sub>limit</sub>, we must increase the
      normal force. We could do so by increasing the car’s mass, but this
      would have negative effects on the car’s ability to accelerate or
      decelerate. A better solution is the use of aerodynamic features to
      create what is called <span class="emphasis"><em>downforce</em></span>. You may have seen
      racecars or even street cars with large wing-like features called
      spoilers on their trunks. Formula 1 cars also have wing-like appendages
      on the front of the car. These are like the wings of an airplane but
      inverted so that instead of pulling the vehicle up, they actually push
      the vehicle down. These wings, therefore, increase the normal force, and
      their effects are proportional to speed so that more downforce is
      available at higher speeds...just when you need it. In fact, some very
      fast cars create so much downforce that if the road were inverted, the
      car would remain glued to the pavement and be able to drive
      upside-down.</p><p>The trade-off for this increased cornering limit speed is increased drag caused by the
        airfoils. This limits the top speed of the vehicle in areas of road that have no corners. It
        is good practice to allow users to select an angle of attack for their vehicle’s airfoils.
        This forces them to choose between the option of higher top speed with slower cornering or
        faster cornering with lower top speed.</p><p>You may notice that on some raceways, the corners are not flat.
      This is called <a id="I_indexterm3_id344794" class="indexterm"/><a id="I_indexterm3_id344800" class="indexterm"/>roadway bank or <span class="emphasis"><em>superelevation</em></span>. In a
      corner where the car would normally skid, the superelevation helps keep
      the car in the turn because as the car is inclined, a force component
      develops that acts toward the center of curvature of the turn (see <a class="xref" href="ch17.html#superelevation" title="Figure 17-2. Superelevation">Figure 17-2</a>).</p><div class="figure"><a id="superelevation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id344830"/><img src="httpatomoreillycomsourceoreillyimages1598978.png" alt="Superelevation"/></div></div><div class="figure-title">Figure 17-2. Superelevation</div></div><p>The following simple formula relates the superelevation angle of a
      roadway to the speed of the car and the coefficient of friction between
      the tires and road:</p><table style="border: 0; " class="simplelist"><tr><td>tan φ =
        V<sub>t</sub><sup>2</sup>/(g r) –
        µ<sub>s</sub></td></tr></table><p>Here, φ is the superelevation angle (as shown in <a class="xref" href="ch17.html#superelevation" title="Figure 17-2. Superelevation">Figure 17-2</a>),
      <span class="emphasis"><em>V</em></span><sub>t</sub> is the tangential
      component of velocity of the car going around the turn,
      <span class="emphasis"><em>g</em></span> is the acceleration due to gravity,
      <span class="emphasis"><em>r</em></span> is the radius of the curve, and
      µ<sub>s</sub> is the static coefficient of friction between
      the tires and the road. If you know φ, <span class="emphasis"><em>r</em></span>, and µ,
      then you can calculate the speed at which the car will begin to slip out
      of the turn and off the road.</p><p>Vehicle dynamics is a complex field, and if you are interested in
      a highly realistic driving simulation game, we recommend reading up on
      the subject. A good <a id="I_indexterm3_id344907" class="indexterm"/><a id="I_indexterm3_id344917" class="indexterm"/>starting place is <span class="emphasis"><em>Fundamentals of Vehicle
      Dynamics</em></span> by <a id="I_indexterm3_id344931" class="indexterm"/>Thomas Gillespie (Society of Automobile Engineers).</p></div></div><div class="sect1" title="Hovercraft"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="hovercraft">Hovercraft</h2></div></div></div><p>Hovercraft, or air cushion vehicles (ACVs), <a id="I_indexterm3_id344951" class="indexterm"/><a id="I_indexterm3_id344962" class="indexterm"/><a id="ho17.2" class="indexterm"/>have made their way into a video game or two recently. Their
    appeal seems to stem from their futuristic aura, high speed, and
    levitating ability, which lets them go anywhere. In real life, hovercraft
    have been around since the 1950s and have been used in combat, search and
    rescue, cargo transport, ferrying, and recreational roles. They come in
    all shapes and sizes, but they all pretty much work the same, with the
    basic idea of getting the craft off the land or water to reduce its drag.
    In <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>, we touched on what forces
    you have to model when considering hovercraft, and now we’ll talk about
    them in more detail.</p><div class="sect2" title="How Hovercraft Work"><div class="titlepage"><div><div><h3 class="title" id="how_hovercraft_work">How Hovercraft Work</h3></div></div></div><p>The first hovercraft designs pumped air through an annular nozzle around the periphery
        of the craft (see <a class="xref" href="ch17.html#hovercraft_configurations" title="Figure 17-3. Hovercraft configurations">Figure 17-3</a>). Large fans are used to feed
        the air through the nozzle under the craft. This jet of air creates a region of relatively
        high pressure over the area underneath the craft, which results in a net lifting force. The
        lifting force must equal the weight of the craft if it is to attain hovering flight. This
        sort of lifting is known as <span class="emphasis"><em>aerostatic</em></span> lift. The <a id="I_indexterm3_id345024" class="indexterm"/><a id="I_indexterm3_id345031" class="indexterm"/>hover height is limited by the amount of <a id="I_indexterm3_id345042" class="indexterm"/>power available and the lifting fan’s ability to pump enough air through the
        nozzle: the higher the hover height, the greater the power demand.</p><div class="figure"><a id="hovercraft_configurations"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id345066"/><img src="httpatomoreillycomsourceoreillyimages1598979.png" alt="Hovercraft configurations"/></div></div><div class="figure-title">Figure 17-3. Hovercraft configurations</div></div><p>This approach proved impractical because hover heights were very
      limited and made the clearance between the hard structure of the craft
      and the ground (or water) too small to overcome all but the smallest
      obstacles. The solution to this problem was to fit a flexible
      <span class="emphasis"><em>skirt</em></span> around the craft to contain the air cushion
      in what’s called <a id="I_indexterm3_id345093" class="indexterm"/>the <span class="emphasis"><em>plenum chamber</em></span> (see <a class="xref" href="ch17.html#hovercraft_configurations" title="Figure 17-3. Hovercraft configurations">Figure 17-3</a>). This approach extended the
      clearance between the ground and the hard structure of the craft
      significantly even though the gap between the bottom of the skirt and
      the ground was very small. This is the basic configuration of most
      hovercraft in operation today, although there are all sorts of skirt
      designs. Some of these skirts are simple curtains, while others are
      sophisticated pressurized bag and finger arrangements. The end result is
      that hovercraft fitted with skirts can clear relatively large obstacles
      without damage to their hard structure, and the skirt simply distorts
      and conforms to the terrain over which the craft operates.</p><p>The actual calculation of the aerostatic lift force is fairly
      complicated because the pressure distribution within the air cushion is
      nonuniform and because you must also take into account the performance
      of the lift fan system. There are theories available to treat both the
      annular jet and plenum chamber configurations, but they are beyond the
      scope of this book. Besides, for a game simulation, what’s important is
      that you realize that the lift force must equal the weight of the craft
      in order for it to maintain equilibrium in hovering flight.</p><p>Ideally, the ability of a hovercraft to eliminate contact with the
      ground (or water) over which it operates means that it can travel
      relatively fast since it no longer experiences contact drag forces.
      Notice we said <span class="emphasis"><em>ideally</em></span>. In reality, hovercraft
      often pitch and roll, causing parts of the skirt to drag, and any
      obstacle that comes into contact with the skirt will cause more drag. At
      any rate, while eliminating ground contact is good for speed, it’s not
      so good for maneuverability.</p><p>Hovercraft are <a id="I_indexterm3_id345139" class="indexterm"/><a id="I_indexterm3_id345152" class="indexterm"/>notoriously difficult to control since they glide across
      the ground. They tend to continue on their original trajectory even
      after you try to turn them. Currently, there are several means employed
      in various configurations for directional control. Some hovercraft use
      vertical tail rudders much like an airplane, while others actually
      vector their propulsion thrust. Still others use bow thrusters, which
      offer very good control. All of these means are fairly easy to model in
      a simulation; they are all simply forces acting on the craft at some
      distance from its center of gravity so as to create a yawing moment. The
      2D simulation that we walked you through in <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a> shows how to handle bow thrusters.
      You can handle vertical tail rudders as we showed you <a id="I_indexterm3_id345174" class="indexterm"/>in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>.</p></div><div class="sect2" title="Resistance"><div class="titlepage"><div><div><h3 class="title" id="resistance-id1">Resistance</h3></div></div></div><p>Let’s take a <a id="ho17.2.2" class="indexterm"/><a id="re17.2.2" class="indexterm"/>look now at some of the <a id="dr17.2.2" class="indexterm"/>drag forces acting on a hovercraft during flight. To do
      this, we’ll handle operation over land separately from operation over
      water since there are some specific differences in the drag forces
      experienced by the hovercraft.</p><p>When a hovercraft is operating over smooth land, the total drag
      acting against the hovercraft is <a id="ae17.2.2" class="indexterm"/><a id="hoa17.2.2" class="indexterm"/>aerodynamic in nature. This assumes that drag induced by
      dragging the skirt or hitting obstacles is ignored. The three components
      of aerodynamic drag are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Skin friction and <a id="I_indexterm3_id345306" class="indexterm"/>viscous pressure drag on the body of the craft</p></li><li class="listitem"><p>Induced drag<a id="I_indexterm3_id345328" class="indexterm"/> when the craft is pitched</p></li><li class="listitem"><p>Momentum drag</p></li></ul></div><p>In equation form, the total drag is as follows:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>total</sub> =
        R<sub>viscous</sub> + R<sub>induced</sub> +
        R<sub>momentum</sub></td></tr></table><p>The first of these components, the viscous drag<a id="I_indexterm3_id345376" class="indexterm"/> on the body of the craft, is the same sort of drag
      experienced by projectiles flying through the air, as explained in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>. This drag is estimated using the
      by-now-familiar formula:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>viscous</sub> = (1/2) ρ
        V<sup>2</sup> S<sub>p</sub>
        C<sub>d</sub></td></tr></table><p>Here ρ is the mass density of air, <span class="emphasis"><em>V</em></span> the
      speed of the hovercraft, <span class="emphasis"><em>S</em></span><sub>p</sub>
      the projected frontal area of the craft normal to the direction of
      <span class="emphasis"><em>V</em></span>, and
      <span class="emphasis"><em>C</em></span><sub>d</sub> the drag coefficient.
      <a id="I_indexterm3_id345438" class="indexterm"/>Typical values of
      <span class="emphasis"><em>C</em></span><sub>d</sub> for craft in operation
      today range from 0.25 to 0.4.</p><p>The next drag component, the induced drag, is a result of the
      craft assuming a pitched attitude when moving. When the bow of the craft
      pitches up by an angle τ, there will be a component of the aerostatic
      lift vector that acts in a direction opposing <span class="emphasis"><em>V</em></span>.
      This component is approximately equal to the weight of the craft times
      the tangent of the pitch angle:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>induced</sub> ≈ W (tan τ)</td></tr></table><p>Finally, momentum drag<a id="I_indexterm3_id345482" class="indexterm"/> results from the destruction of horizontal momentum of air, relative to the
        craft entering the lift fan intake. This component is difficult to compute unless you know
        the properties of the entire lifting system such that the <a id="I_indexterm3_id345492" class="indexterm"/>mass flow rate of air into the fan is known. Given the mass flow rate,
          <span class="emphasis"><em>R</em></span><sub>momentum</sub> is equal to the mass flow rate times
        the velocity of the craft:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>momentum</sub> =
        (dm<sub>fan</sub>/dt) V</td></tr></table><p>Mass flow rate is expressed in units such as kg/s, which when
      multiplied by velocity in m/s yields <span class="emphasis"><em>N</em></span>.</p><p>In <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a> we mentioned that it
      is beneficial to have the center of this drag be behind the center of
      gravity. This gives directional stability, as the vessel will tend to
      try to point into the apparent wind. Consider if the vessel yaws some
      angle, the forward velocity is creating a wind that is now hitting the
      side of the hovercraft. If the center of effort of this force is forward
      of the center of gravity, it will want to yaw the vessel more,
      increasing the side force and causing even greater drag until the vessel
      spins 180 degrees! If the center of effort of the wind is aft of the
      center of gravity, the vessel will spin back into the wind. You don’t
      want the center of effort so far aft that it is too difficult to turn
      the vessel, but it is generally better to have the vessel naturally
      straighten out than to require constant steering input to maintain a
      steady course. This is also true of sailboats and is called
      <span class="emphasis"><em>weather helm</em></span>. <a id="I_indexterm3_id345551" class="indexterm"/><a id="I_indexterm3_id345558" class="indexterm"/>This also occurs in airplanes. The solution in airplanes
      is similar to that of hovercraft: to fit tail fins that move the center
      of the area aft, increasing its directional stability. If you choose to
      model damage in your simulation, the loss of a tail fin will cause the
      vessel to be very difficult to control.</p><p>In addition to these three drag components, hovercraft will
      experience other forms of resistance when operating over water. These
      additional components <a id="I_indexterm3_id345577" class="indexterm"/><a id="we17.2.2" class="indexterm"/>are <span class="emphasis"><em>wave</em></span> drag and
      <span class="emphasis"><em>wetted</em></span> drag. The equation for total drag can thus
      be revised for operation over water as follows:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>total</sub> =
        R<sub>viscous</sub> + R<sub>induced</sub> +
        R<sub>momentum</sub> + R<sub>wave</sub> +
        R<sub>wetted</sub></td></tr></table><p>When a hovercraft operates over water, its air cushion creates a
      depression in the water surface due to cushion pressure (see <a class="xref" href="ch17.html#hovercraft_over_water" title="Figure 17-4. Hovercraft over water">Figure 17-4</a>). At zero to low speeds, the weight
      of this displaced volume of water is equal to the weight of the craft,
      just as if the craft were floating in the water supported by buoyancy.
      As the craft starts to move forward, it tends to pitch up by the bow.
      When that happens, the surface of the water in the depressed region is
      approximately parallel to the bottom of the craft. As speed increases,
      the depression is reduced and the pitch angle tends to decrease.</p><div class="figure"><a id="hovercraft_over_water"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id345660"/><img src="httpatomoreillycomsourceoreillyimages1598980.png" alt="Hovercraft over water"/></div></div><div class="figure-title">Figure 17-4. Hovercraft over water</div></div><p>Wave drag is a result of this depression and is equal to the
      horizontal components of pressure forces acting on the water surface in
      the depressed region. As it turns out, for small pitch angles and at low
      speeds, wave drag is on the same order of magnitude as the induced
      drag:</p><table style="border: 0; " class="simplelist"><tr><td>R<sub>wave</sub> ≈ W (tan τ)</td></tr></table><p>Since wave drag is proportional to the size of the depression, it
      tends to be highest at low speeds and decreases at higher operational
      speeds. If you were to plot the wave drag curve as a function of speed
      for a typical hovercraft, you’d find that it is not a straight or even
      parabolic curve, but rather it has a hump in the curve at the lower
      speed range, as illustrated in <a class="xref" href="ch17.html#wave_drag" title="Figure 17-5. Wave drag">Figure 17-5</a>.</p><div class="figure"><a id="wave_drag"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id345720"/><img src="httpatomoreillycomsourceoreillyimages1598981.png" alt="Wave drag"/></div></div><div class="figure-title">Figure 17-5. Wave drag</div></div><p>There are several theoretical treatments of wave drag in the
      literature that aim to predict the speed at which this hump occurs along
      with its magnitude. These theories indicate that the hump depends on the
      planform geometry of the hovercraft, and it tends to occur at speeds in
      the range of <span class="inlinemediaobject"><img src="inleq_1702.png" alt=""/></span> to <span class="inlinemediaobject"><img src="inleq_1703.png" alt=""/></span>, where <span class="emphasis"><em>g</em></span> is the acceleration due to
      gravity and <span class="emphasis"><em>L</em></span> is the length of the air cushion. In
      practice, the characteristics of a particular hovercraft’s wave drag are
      usually best determined through scale model testing.</p><p>The so-called wetted drag is a function of several things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The fact that parts of the hull and skirt tend to hit the
          water surface during flight</p></li><li class="listitem"><p>The impact of spray on the hull and skirt</p></li><li class="listitem"><p>The increase in weight as the hovercraft gets wet and
          sometimes takes on water</p></li></ul></div><p>Wetted drag is difficult to predict, and in practice model tests
      are relied on to determine its magnitude for a particular design. It’s
      important to note, however, that this tends to be a significant drag
      component, sometimes accounting for as much as 30% of the total
      <a id="I_indexterm3_id345810" class="indexterm"/><a id="I_indexterm3_id345819" class="indexterm"/><a id="I_indexterm3_id345829" class="indexterm"/><a id="I_indexterm3_id345838" class="indexterm"/><a id="I_indexterm3_id345847" class="indexterm"/><a id="I_indexterm3_id345857" class="indexterm"/>drag force.</p></div><div class="sect2" title="Steering"><div class="titlepage"><div><div><h3 class="title" id="steering-id1">Steering</h3></div></div></div><p>In <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9</a>, the <a id="I_indexterm3_id345880" class="indexterm"/><a id="I_indexterm3_id345890" class="indexterm"/>hovercraft was steered using a bow thruster that pushed
      transversely forward of the center of gravity. In reality, most
      hovercraft are steered by vectoring the thrust of the propulsion fan via
      rudders attached directly aft of the fans. This can be modeled by
      angling the propulsive thrust.</p><p>The most important characteristic to remember about steering
      hovercraft is that they will not turn like a car or boat. The
      hovercraft, because it has lower friction with its environment, will
      take longer to turn and tends to continue in the direction it was
      heading while rotating. Once rotated, the thrust acts along a new
      vector. One possible maneuver in a hovercraft is to quickly rotate the
      vessel and then shut down the propulsive thrust. This would allow you to
      travel in one direction and point in another for as long as your
      momentum carries you. This could be very useful in strafing enemies or
      just racking up style points.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 18. Guns and Explosions</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Physical Modeling"/><link rel="prev" href="ch17.html" title="Chapter 17. Cars and Hovercraft"/><link rel="next" href="ch19.html" title="Chapter 19. Sports"/></head><body><section class="chapter" title="Chapter 18. Guns and Explosions" epub:type="chapter" id="guns_and_explosions"><div class="titlepage"><div><div><h2 class="title">Chapter 18. Guns and Explosions</h2></div></div></div><p>One of the most widely successful video <a id="I_indexterm4_id345932" class="indexterm"/>game genres is the venerable first-person shooter. Ever since the breakthrough games
    of <span class="emphasis"><em>Wolfenstein 3D</em></span> and <span class="emphasis"><em>Doom</em></span>, the first-person shooter
    has received the lion’s share of research and development budgets. It is amazing that the
    physics of aiming a gun and of a bullet traveling through the air are rarely modeled accurately.
    In general, game designers treat guns like laser beams so that wherever you point them, the
    bullet goes in an infinitely straight line. In this chapter we’ll discuss how to more accurately
    model both aiming and the trajectory of bullets, which is known as ballistics.</p><div class="sect1" title="Projectile Motion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="projectile_motion">Projectile Motion</h2></div></div></div><p>There are actually <a id="gu18.1" class="indexterm"/><a id="I_indexterm4_id345987" class="indexterm"/><a id="I_indexterm4_id345997" class="indexterm"/><a id="pr18.1" class="indexterm"/><a id="mo18.1" class="indexterm"/>four subtopics of ballistics. <span class="emphasis"><em>Internal ballistics</em></span> is <a id="I_indexterm4_id346040" class="indexterm"/>the study of what happens to the bullet inside the barrel of the <a id="I_indexterm4_id346047" class="indexterm"/>gun; <span class="emphasis"><em>transitional ballistics</em></span> is the study of what happens as
      the bullet exits the barrel. Once the bullet has fully exited the barrel, it is in the realm <a id="I_indexterm4_id346060" class="indexterm"/>of <span class="emphasis"><em>external ballistics</em></span>. At this point the only acceleration
      is that of gravity, and the same forces discussed in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> take over.
      The last topic <a id="I_indexterm4_id346077" class="indexterm"/>is <span class="emphasis"><em>terminal ballistics</em></span>, which is the study of what happens
      when the bullet hits its target. The last two topics are the ones we’ll discuss here. The
      other phases are more important to firearm manufacturers and not so much to the shooter. If
      you don’t recall the material in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>, we highly recommend that you
      review it before continuing.</p><p>While we aren’t very concerned about what happens in the barrel of the gun, there are a
      few tidbits we do need to know about the system. The first is where the barrel is pointed.
      This is referred to as the gun’s <span class="emphasis"><em>aim</em></span>, <a id="I_indexterm4_id346099" class="indexterm"/>and is almost universally controlled by where the mouse is on the screen.</p><p>The next is the initial velocity of the bullet. The bullet here refers to the actual metal
      projectile that leaves the barrel; the thing that you load into the gun is called a
        <span class="emphasis"><em>round</em></span> and contains a casing, gunpowder, a primer, and, of course, the
      bullet. The initial velocity is usually measured just after the bullet leaves the muzzle (the
      end of the barrel) and is appropriately called <a id="I_indexterm4_id346125" class="indexterm"/><a id="I_indexterm4_id346131" class="indexterm"/>the <span class="emphasis"><em>muzzle velocity</em></span>. Every kind of ammunition is tested at
      the factory and given a muzzle velocity. You can add realism to your game by giving different
      ammunition different muzzle velocities. This way, a handgun round won’t have the same range as
      a rifle round. Ammunition also comes with a <a id="I_indexterm4_id346149" class="indexterm"/><a id="I_indexterm4_id346158" class="indexterm"/>bullet weight measured in either grams or grains. One grain is equal to 0.0648
      grams and is an old unit based on the weight of a single seed of wheat!</p><p>Last, but not least, we need some approximation for the way air resistance will affect the
      flight of a bullet. This is where things start to get interesting for people studying
      ballistics, but we’ll stay away from exotic aerodynamics and use our existing drag model.
      First, we should review the current state of first-person-shooter physics.</p><p>Firearms in games present a <a id="I_indexterm4_id346180" class="indexterm"/>unique problem to the game developer. If you have ever been to the firing range,
      you know that in reality it takes a good deal of practice and concentration to hit a target
      reliably. Considering that target shooting is hard enough to be an Olympic sport under very
      controlled circumstances, the ability for in-game characters to spring from cover and shoot
      five enemies with five bullets is somewhat superhuman. We have all played games where you find
      yourself shooting a target very far away, and the procedure is as simple as pointing the
      crosshair where you want the bullet to go and clicking the mouse button. In reality, the skill
      needed to get a bullet weighing a few grams to hit something a few hundred meters away is so
      complicated it is amazing that anyone does it with regularity. For those developers wishing to
      actually model firearm performance in their game, there is a double-edged sword to
      consider.</p><p>The physics of what happens to the bullet in its flight are not simple to boil down.
      However, the behavior of the bullet as it flies downrange is important in the practical art of
      marksmanship. There has been considerable work done to find a way to compare ammunition so
      that a hunter or marksman can predict the performance of a particular ammunition. The result
      is a pseudophysical factor <a id="I_indexterm4_id346209" class="indexterm"/><a id="I_indexterm4_id346215" class="indexterm"/>called the <span class="emphasis"><em>ballistic coefficient</em></span> (BC). The BC is a ratio that
      determines the ability of a particular bullet to retain its downrange velocity compared to
      some standard bullet. The most common form is that of the G1 reference projectile. However,
      this number has limited use, as it does not take into account modern bullet shapes that
      provide very low drag. There are updated models whose designations are G2, G3, and ECT. If you
      are interested in the details of highly accurate ballistic modeling, there are a few free
      programs that can provide you in-depth models such as Remington’s Shoot! and the GNU
      Ballistics program. Given that most first-person shooters don’t yet include wind effects or
      bullet drop, we’ll limit ourselves to a simplified method of turning the existing parameters
      in the <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> projectile <a id="I_indexterm4_id346237" class="indexterm"/><a id="I_indexterm4_id346247" class="indexterm"/><a id="I_indexterm4_id346256" class="indexterm"/>algorithm.</p></div><div class="sect1" title="Taking Aim"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="taking_aim">Taking Aim</h2></div></div></div><p>When discussing aim, <a id="gu18.2" class="indexterm"/><a id="pr18.2" class="indexterm"/><a id="I_indexterm4_id346311" class="indexterm"/>we’ll primarily be talking about rifles or carbines here, as handguns are not
      usually used for long-distance shooting. Similarly, shotguns, given that they fire many small
      projectiles, are generally not carefully aimed but instead pointed. Both of these weapons are
      what are <a id="I_indexterm4_id346325" class="indexterm"/>known as <span class="emphasis"><em>point-blank weapons</em></span>. Rifles have a point-blank
      range, which we will discuss, but for handguns and shotguns this really refers to the fact
      that at the ranges where these weapons are effective, you can reasonably expect to hit where
      you the point the gun. That is not to say that these weapons don’t need to be aimed to be
      effective, but in the fast-paced combat central to most first-person shooters it would be
      tedious to have the player use the sights on a handgun to effectively hit anything. Instead,
      most games use a “shoot from the hip” or free aim model, where the gun is not even in line
      with the camera. The careful programmer might still check to see if the target is within the
      effective range of the bullet before counting it as a hit even when auto-aiming in this
      manner. The effective range is the distance the bullet can travel before hitting the ground.
      Determining this is a straightforward application of the equations in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> and <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>.</p><p>To discuss <a id="I_indexterm4_id346357" class="indexterm"/>firearms, we’ve adapted the code from the <a id="I_indexterm4_id346369" class="indexterm"/>Cannon2 example in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> to run in a Java program called
      Marksman. In our example, the player is looking through a scope at a target of 1 meter by 1
      meter. We’ve provided him an adjustable level of zoom so that as the range increases, he can
      still see the target. The aiming point is shown as an empty circle, and the bullet hole as a
      black filled circle. The method we’ve used to determine where the user is aiming in the model
      world converts the pixel-based location of the mouse to a coordinate in the model world. This
      distance and the range are then used to find the angles required to aim the gun. The code to
      do this is shown next, where <code class="literal">alp</code> and <code class="literal">gmm</code> are the angles of inclination and bearing. These are measured
      from horizontal and the line of view:</p><a id="I_programlisting4_id346403"/><pre class="programlisting">alp = 90-Math.toDegrees(Math.atan(((200-aimY)*(targetH/(drawH)))/range));
gmm = Math.toDegrees(Math.atan(((200-aimX)*(targetH/(drawH)))/range));</pre><p>where <code class="literal">targetH/drawH</code> is just the ratio of the target
      height to the height of the target in pixels on the screen. This allows the mouse coordinate
      given in pixels to be converted to meters. The arctangent then converts the ratio of these
      distances to an angle for the gun. The constant <code class="literal">200</code> refers
      to the pixel coordinate system, which is 200 pixels away from the center of the target. If you
      were to adapt this for a full 3D rendering system, you could remove a lot of these conversions
      we have to do.</p><p>At the 10-meter range shown in <a class="xref" href="ch18.html#point-blank_range" title="Figure 18-1. Point-blank range">Figure 18-1</a>, we are within
      point-blank range and the bullet hole lines up with the sights.</p><div class="figure"><a id="point-blank_range"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id346451"/><img src="httpatomoreillycomsourceoreillyimages1598982.png.jpg" alt="Point-blank range"/></div></div><div class="figure-title">Figure 18-1. Point-blank range</div></div><p>In <a class="xref" href="ch18.html#hitting_lower_than_expected" title="Figure 18-2. Hitting lower than expected">Figure 18-2</a>, with the target at 100 meters, we see
      that for some reason the bullet is not hitting the target where we have pointed the weapon. At
      300 meters, the bullet hole isn’t even on the target. You can see that by simply accounting
      for projective motion and idealized drag, we are already having trouble hitting the bull’s
      eye. The process by which these differences are accounted for is called <span class="emphasis"><em>zeroing the
        sights</em></span>.</p><div class="figure"><a id="hitting_lower_than_expected"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id346495"/><img src="httpatomoreillycomsourceoreillyimages1598983.png.jpg" alt="Hitting lower than expected"/></div></div><div class="figure-title">Figure 18-2. Hitting lower than expected</div></div><div class="sect2" title="Zeroing the Sights"><div class="titlepage"><div><div><h3 class="title" id="zeroing_the_sights">Zeroing the Sights</h3></div></div></div><p>The idea of zeroing the <a id="ai18.2.1" class="indexterm"/><a id="I_indexterm4_id346540" class="indexterm"/><a id="tr18.2.1" class="indexterm"/>sights is probably the most important thing to model if you want to have
        realistic gunplay in your game. As we mentioned before, when players are running from room
        to room, they probably don’t want to be thinking about the wind and the range. However, for
        a hunting simulation or a sniper game, it may be appropriate to introduce this.</p><p>When a person is looking through a scope, her body and the rifle become a rigid body so
        that to change the aim of the weapon, she must rotate her entire body. This is convenient
        for us, because the player generally controls the shooter’s position with his left hand via
        the keyboard and the direction of aim with the right hand. Other methods of aiming, briefly
        described previously as free aim, don’t really have a counterpart in the real world, so
        we’ll be limiting ourselves to this solid-body aiming.</p><div class="sect3" title="Bullet drop: Gravity and air resistance"><div class="titlepage"><div><div><h4 class="title" id="bullet_drop_colon_gravity_and_air_resist">Bullet drop: Gravity and air resistance</h4></div></div></div><p>If you are aiming a rifle horizontally, <a id="ze18.2.1.1" class="indexterm"/><a id="gr18.2.1.1" class="indexterm"/><a id="re18.2.1.1" class="indexterm"/>you might expect that the bullet leaves the muzzle horizontally, and that
          gravity and air resistance cause it to drop from there. <a class="xref" href="ch18.html#zero-elevation_scope" title="Figure 18-3. Zero-elevation scope">Figure 18-3</a> shows a rifle and scope combination that is mounted
          perfectly parallel. Ignoring all other factors for a minute, we see that the bullet will
          never hit where the scope is pointed. It will always be a few centimeters low.</p><div class="figure"><a id="zero-elevation_scope"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id346656"/><img src="httpatomoreillycomsourceoreillyimages1598984.png" alt="Zero-elevation scope"/></div></div><div class="figure-title">Figure 18-3. Zero-elevation scope</div></div><p>By adjusting the elevation control of the scope, we can make the rifle hit where the
          scope is pointed. (See <a class="xref" href="ch18.html#scope_with_elevation" title="Figure 18-4. Scope with elevation">Figure 18-4</a>.) The range at which the
          bullet will cross the line defined by the scope is called <a id="I_indexterm4_id346683" class="indexterm"/>the <span class="emphasis"><em>zero range</em></span>. If a target is at the zero range, you
          simply point the crosshairs and pull the trigger.</p><div class="figure"><a id="scope_with_elevation"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id346706"/><img src="httpatomoreillycomsourceoreillyimages1598985.png" alt="Scope with elevation"/></div></div><div class="figure-title">Figure 18-4. Scope with elevation</div></div><p>If we remove the target and graph the trajectory, it would look something like <a class="xref" href="ch18.html#ballistic_trajectory" title="Figure 18-5. Ballistic trajectory">Figure 18-5</a>.</p><div class="figure"><a id="ballistic_trajectory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id346743"/><img src="httpatomoreillycomsourceoreillyimages1598986.png" alt="Ballistic trajectory"/></div></div><div class="figure-title">Figure 18-5. Ballistic trajectory</div></div><p>Here we can see there is a second point in which the bullet will cross the line made
          by the scope’s crosshairs. This is called <a id="I_indexterm4_id346770" class="indexterm"/><a id="I_indexterm4_id346776" class="indexterm"/>the <span class="emphasis"><em>far zero</em></span>, or <span class="emphasis"><em>second zero</em></span>. This
          is generally where the thing you will be shooting at will be. This diagram is often
          available from ammunition suppliers. More often, they provide ballistic tables of
          downrange heights. It is important when using these charts that you remember they assume
          the scope to be horizontal and that the bullet starts with a negative height below the
          scope line. <a class="xref" href="ch18.html#long-range_trajectory_remington_express" title="Table 18-1. Long-range trajectory Remington Express .45–70 Govt">Table 18-1</a> shows data from
          Remington’s website and assumes the rifle was zeroed at 100 yards; it tells you how far
          the bullet is below the horizontal at every 50 yards past that 0. You can tune the drag
          coefficient in the projectile simulation to match these elevations.</p><div class="table"><a id="long-range_trajectory_remington_express"/><div class="table-title">Table 18-1. Long-range trajectory Remington Express .45–70 Govt</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/><col class="col5"/><col class="col6"/><col class="col7"/><col class="col8"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>Range in yards</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>100</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>150</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>200</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>250</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>300</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  <p>400</p>
                </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                  <p>500</p>
                </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>Drop in inches</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>0</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>−4.6</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>−13.8</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>−28.6</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>−50.1</p>
                </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                  <p>−115.47</p>
                </td><td style="text-align: left; vertical-align: top; ">
                  <p>−219.1</p>
                </td></tr></tbody></table></div></div><p>From this table you can see that the bullet drop is over two feet at 250 yards. This
          means that if the target is at 250 yards and your scope is zeroed at 100 yards, then you
          would have to aim two feet above your target to hit it. That might be high enough that you
          can’t even see the target in the scope anymore!</p><p>To counteract this problem, most rifles come with scopes that have <a id="I_indexterm4_id347089" class="indexterm"/>elevation adjustments. This is a knob on the side of the scope that can be
          rotated to discrete settings called clicks. Most scopes use a 1/4 minute of angle
          adjustment per click although some use 1/8, 1/2, or even full minutes. A minute of angle
          is simply 1/60 of a degree. Therefore, when adjusting for elevation, the shooter can turn
          a knob on the scope, and as she hears the clicks, she knows that she has adjusted her
          scope however many minutes of angle. Now when she re-aims the crosshairs on the target,
          the barrel will have a slightly different angle than it did before, essentially aiming
          higher to accommodate the longer distance.</p><p>To achieve high accuracy in the field, the shooter would know that she zeroed her
          rifle to a certain range. Then, when attempting a shot, she would estimate the range to
          her target and adjust the scope however many clicks up or down. The biggest cause of error
          is an inaccurate estimate of range. Modern shooters often use laser range finders to
          determine exactly what elevation offset is required. In long-distance shooting situations,
          you can provide the range to the users and let them adjust the rifle’s scope from the
          current zero range to a new zero range.</p><p>Most games today don’t model even the effect of gravity on a bullet, so adding
          elevation adjustment to a sniper or hunting portion of your game will add much-needed
            <a id="I_indexterm4_id347120" class="indexterm"/><a id="I_indexterm4_id347130" class="indexterm"/><a id="I_indexterm4_id347139" class="indexterm"/>accuracy.</p></div><div class="sect3" title="Wind"><div class="titlepage"><div><div><h4 class="title" id="wind">Wind</h4></div></div></div><p>Just like in the <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> projectile <a id="I_indexterm4_id347165" class="indexterm"/><a id="I_indexterm4_id347175" class="indexterm"/>example, our target shooting game’s bullets are affected by wind. Just as
          before, a bullet’s susceptibility to wind largely depends on its lateral drag coefficient.
          In our simulation, you can tune the bullet’s susceptibility to the wind by adjusting the
          factor <code class="literal">Cw</code>. This, again, will apply only to rifles
          shooting at long ranges. At 20 meters, the wind will have little to do in determining
          where a bullet will hit. At 600 meters, it can cause the bullet to be off by a meter! The
          adjustment for wind is similar to the adjustment for elevation. By turning a knob, you can
          adjust your scope or sights to be slightly to the right or left of the barrel’s
          centerline. This angle, called gamma in our simulation, enables you to cancel out the
          effect of wind.</p><p>To deal with wind in the field, we require simple calculations that depend on the
          particular performance of the shooter’s ammunition. It may work something like this: if
          the wind is blowing directly across your shot, the adjustment in inches is going to be
          half the wind speed in miles per hour. Of course, there are many other rules of thumb that
          differ for each caliber of ammunition, but for our simulation you can tune the wind drag
          coefficient to whatever value you want your shooter to encounter. He will have to spend
          some time at the range, just like a real shooter, figuring out how much the wind affects
          his shots. As the wind changes, he will have to adjust in real time and either aim to the
          left or right of the target or readjust the windage settings for the <a id="I_indexterm4_id347210" class="indexterm"/><a id="I_indexterm4_id347218" class="indexterm"/>scope.</p></div></div><div class="sect2" title="Breathing and Body Position"><div class="titlepage"><div><div><h3 class="title" id="breathing_and_body_position">Breathing and Body Position</h3></div></div></div><p>Although most games <a id="ai18.2.2" class="indexterm"/>don’t model gravity and wind when calculating bullet trajectories, many do
        attempt to regulate the accuracy with which you initially fire the bullet. Most commonly,
        game developers accomplish this by approximating the crosshairs with four lines that do not
        intersect. When fired, the bullet will land anywhere within the circle described by the
        inner endpoints of these four lines. Different weapons have different accuracies, and the
        lines can move in or out to reflect that. Usually the first shot is the most accurate, and
        once the weapon is fired you must “resight” the target, and this takes time. Therefore,
        shots fired in quick succession usually become less and less accurate.</p><p>In our simulation, we modeled a few things that affect accuracy in the real world and
        will give you some suggestions for other factors you could easily include. As our game was
        most interested in long-distance shooting via rifles, the most common source of error is
        breathing. As discussed before, when a shooter is looking through a scope on a rifle, she
        essentially becomes a fixed body. As she breathes, the rifle is essentially breathing too.
        When making difficult shots, it is very common for the shooter to take a breath and hold it
        while firing. In our simulation, we’ve modeled this with a <code class="literal">breathing</code> class that adjusts the point of aim up and down with time to mimic
        how a scope moves when the shooter is breathing deeply. This works via a timer started in
        our <code class="literal">initComponents()</code> function that fires every 100 ms. In
        the code that follows, you’ll see that this leads to a breath every two seconds.</p><a id="I_programlisting4_id347290"/><pre class="programlisting">        timer = new Timer(100, TargetPanel);
        timer.start();</pre><p>That function causes the aim point <code class="literal">(aimX, aimY)</code> to be
        moved independently of the cursor via the following algorithm:</p><a id="I_programlisting4_id347306"/><pre class="programlisting">        if (direction == true) {
            breathHeight = breathHeight + 1;
            if (breathHeight == 5) {
                direction = false;
                breathHeight = breathHeight + 1;
            }
        }

        if (direction == false) {
            breathHeight = breathHeight − 1;
            if (breathHeight == −5) {
                direction = true;
            }
        }

        if (breathing) {
            aimY = aimY + breathHeight;
        }</pre><p>Here we are simply moving it up to some limit—in our case, 5 pixels—and then moving it
        back down. A better implementation would increase the unsteadiness as the user zooms in, as
        shakes are magnified also. There is no limit to the innovative functions you can use to move
        the aiming circle away from the cursor to simulate the reality of having to aim a gun. Yet
        this is certainly an area of first-person shooters that is lacking in variety.</p><p>When he is ready to fire, the user can left-click to hold his breath, the variable
          <code class="literal">breathing</code> becomes <code class="literal">false</code>, and the crosshairs will stop moving. This simple addition makes the game
        much more challenging and engaging. It should be noted that if the shooter holds his breath
        too long in real life, the aim will again become unsteady as his body reacts to not having
        fresh oxygen. Another improvement to this algorithm would be for the aim to become unstable
        after the left mouse button is pressed for some amount of time.</p><p>Many games also change the accuracy of a weapon depending on body position. There are
        three basic types of <a id="I_indexterm4_id347347" class="indexterm"/>shooting positions: standing, kneeling, and prone. <a id="I_indexterm4_id347359" class="indexterm"/><a id="I_indexterm4_id347365" class="indexterm"/>Standing is—you guessed it—standing up. <a id="I_indexterm4_id347373" class="indexterm"/>Kneeling is some form of squatting rather than just kneeling on your knees. <a id="I_indexterm4_id347380" class="indexterm"/>Prone is laid flat on the ground. Because the rifle is locked to your body, the
        less unstable your body is, the less unstable the aim. When standing, your body’s muscles
        have to do a lot of work to remain upright. When kneeling, they do less so, and when prone,
        your muscles don’t have to worry about keeping you standing at all.</p><p>You can add these parameters as random twitches in the aim and tune them to change the
        relative advantage of each position. However, prone should always be more stable than
        kneeling, and kneeling more stable than <a id="I_indexterm4_id347397" class="indexterm"/><a id="I_indexterm4_id347406" class="indexterm"/><a id="I_indexterm4_id347416" class="indexterm"/>standing.</p></div></div><div class="sect1" title="Recoil and Impact"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="recoil_and_impact">Recoil and Impact</h2></div></div></div><p>Now that <a id="I_indexterm4_id347437" class="indexterm"/><a id="I_indexterm4_id347447" class="indexterm"/><a id="I_indexterm4_id347457" class="indexterm"/>we’ve aimed, fired, and figured out where the bullet is at any given moment, let’s
      talk about the last phase, terminal ballistics. To really understand what happens at the end
      of a bullet’s flight, let’s revisit the beginning. Earlier we talked about recoil as the
      result of Newton’s <span class="emphasis"><em>conservation of momentum</em></span>. <a id="I_indexterm4_id347470" class="indexterm"/><a id="I_indexterm4_id347477" class="indexterm"/><a id="I_indexterm4_id347487" class="indexterm"/><a id="I_indexterm4_id347497" class="indexterm"/><a id="I_indexterm4_id347507" class="indexterm"/><a id="I_indexterm4_id347517" class="indexterm"/>Everyone has seen a cheesy movie where the hero shoots the bad guy and the bullets
      cause the bad guy to be blown off his feet. There is a big problem with this! If the bullets
      were powerful enough to knock the person they hit off his feet, then the person shooting the
      gun would also be blown off his feet! In reality, the force felt by the person being shot is
      nearly the same as the force felt when the weapon recoils. For a 9 mm bullet weighing 7.45 g
      and leaving the barrel at 390 m/s, the gun will experience recoil such that its momentum is
      equal to the moment of the bullet.</p><p>One interesting way to incorporate recoil into a video game is in space. On Earth, a gun’s
      recoil is pretty quickly transferred to the ground by <a id="I_indexterm4_id347537" class="indexterm"/>friction between the player and the big bad earth. In space, the shooter has no
      planetary body to push against, so the recoil of the gun becomes the recoil of the gun/person
      system. Next time your character needs to move from one ship to another in a micro-gravity
      environment, you can make her spend some ammo to get herself moving.</p><p>Now, if you get shot you will probably fall down pretty quickly, but this has more to do
      with biology than physics. However, ignoring living targets, if you want to simulate the
      damage done by a bullet hitting something, it is more important to look at the bullet’s <a id="I_indexterm4_id347558" class="indexterm"/>kinetic energy. In fact, bullets and artillery shells are <a id="I_indexterm4_id347571" class="indexterm"/>called <span class="emphasis"><em>kinetic weapons</em></span>, as their primary means of destroying
      a target is by transferring their kinetic energy to the target. This is different than, say, a
      bomb that transfers its chemical energy into heat and kinetic energy after impact.</p></div><div class="sect1" title="Explosions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="explosions">Explosions</h2></div></div></div><p>Accurately <a id="I_indexterm4_id347599" class="indexterm"/>modeling explosions involves multiphysics fluid simulations like the kind
      discussed in <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14</a> through <a class="xref" href="ch16.html" title="Chapter 16. Ships and Boats">Chapter 16</a>. One
      of our pet peeves is that video games usually have a collection of barrels lying around that,
      if shot once, explode violently enough to blow up nearby vehicles. While this makes for an
      easy out against multiple enemies, it is actually pretty hard to get everyday objects to blow
      up. Shooting a gas can with a handgun will almost never result in a fire, much less an
      explosion. Indeed, even shooting a propane tank with a rifle won’t give you fireworks. It
      would take something like a tank of 1/4 propane mixed with 3/4 oxygen to explode, and those
      aren’t usually lying around. Regardless, when we play video games we’re often thankful that we
      have an occasional red barrel to shoot, so we’ll review how to make the resulting explosion
      more accurate even if the ignition is improbable.</p><div class="sect2" title="Particle Explosions"><div class="titlepage"><div><div><h3 class="title" id="particle_explosions">Particle Explosions</h3></div></div></div><p>For most in-game explosions, <a id="pk18.4.1" class="indexterm"/><a id="bf18.4.1" class="indexterm"/><a id="ex18.4.1" class="indexterm"/>it will be sufficient to implement a particle-type explosion that we covered way
        back in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. Now, in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> the particles
        were simply dots, <a id="exk18.4.1" class="indexterm"/><a id="ki18.4.1" class="indexterm"/><a id="pe18.4.1" class="indexterm"/><a id="pr18.4.1" class="indexterm"/>but they don’t have to be limited to such simple sprites. In some cases, such as
        sparks from a bullet hitting a metal container, it would be very accurate to model
        explosions as particles; however, by making our particles look like bits of cars, we can
        also make it appear that the car itself exploded. The reason this is easier is because the
        particle explosions don’t have any <a id="I_indexterm4_id347760" class="indexterm"/><a id="I_indexterm4_id347770" class="indexterm"/>angular motion. Although you can assign different parts of the cars to different
        particles, when they fly off due to the explosion, they won’t be rotating. The good news is
        that a particle explosion will still give you a realistic distribution of fragments of
        something on the ground.</p><p>To talk about how to link bullets and particle explosions in detail, we’ll consider
        something more physically accurate than a bullet blowing up a car. Let’s consider a bullet
        hitting some loose gravel. This will generally cause the gravel to be thrown up into the air
        from the bullet collision. Instead of trying to calculate the complex collisions during
        impact, we’ll generate a particle explosion based on the code in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>:</p><a id="I_programlisting4_id347796"/><pre class="programlisting">void CreateParticleExplosion(int x, int y, int Vinit, int life,
                             float gravity, float angle)
{
     int   i;
     int   m;
     float f;

     Explosion.Active = TRUE;
     Explosion.x = x;
     Explosion.y = y;
     Explosion.V0 = Vinit;

     for(i=0; i&lt;_MAXPARTICLES; i++)
     {
          Explosion.p[i].x = 0;
          Explosion.p[i].y = 0;
          Explosion.p[i].vi = tb_Rnd(Vinit/2, Vinit);

          if(angle &lt; 999)
          {
               if(tb_Rnd(0,1) == 0)
                    m = −1;
               else
                    m = 1;
               Explosion.p[i].angle = -angle + m * tb_Rnd(0,10);
          } else
               Explosion.p[i].angle = tb_Rnd(0,360);

          f = (float) tb_Rnd(80, 100) / 100.0f;
          Explosion.p[i].life = tb_Round(life * f);
          Explosion.p[i].r = 255;//tb_Rnd(225, 255);
          Explosion.p[i].g = 255;//tb_Rnd(85, 115);
          Explosion.p[i].b = 255;//tb_Rnd(15, 45);
          Explosion.p[i].time = 0;
          Explosion.p[i].Active = TRUE;
          Explosion.p[i].gravity = gravity;
     }

}</pre><p>As you can see, the initial velocity <code class="literal">V0</code> controls the
        strength of the explosion. In <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, we chose this value randomly.
        Now that we have a bullet flying through the air, we can make a better estimate of how
        strong of an explosion to create. As you recall from earlier in the chapter, a bullet has an
        energy associated with it at any time, <code class="literal">t</code>, in its flight.
        This energy is its kinetic energy and is equal to half the bullet mass times its velocity
        squared.</p><p>In our projectile simulation, it is simple to calculate this energy as the bullet flies
        through the air. It should be noted that a big bullet moving slowly is just as powerful as a
        smaller bullet moving quickly. Our upcoming code is going to assume that 100% of the kinetic
        energy is delivered to the target. This would not be true if a bullet shot straight through
        something. A way to visualize this is to imagine two targets, both hanging from the ceiling.
        One is made from paper and one is made from steel. When shot at, the steel target swings
        from its support, while the paper target stays still. This is because the bullet is passing
        straight though the paper and not transferring its kinetic energy to the target. To make
        things simple, we’ll transfer all of the bullet’s kinetic energy <a id="kib18.4.1" class="indexterm"/>to the gravel. In equation form, this would look like:</p><table style="border: 0; " class="simplelist"><tr><td>1/2 m<sub>b</sub>
            v<sup>2</sup><sub>bullet</sub> = Σ1/2
            m<sub>g</sub>
          v<sup>2</sup><sub>gravel</sub></td></tr></table><p>Note that this is the sum of the individual bits of gravel’s velocities. In, <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, each particle was just given a random velocity anywhere from
          <code class="literal">Vinit/2</code> to <code class="literal">Vinit</code>.
        This could lead to creating a set of particles whose energies exceed the input energy. To
        prevent this, we’ll add a variable to our explosion class like so:</p><a id="I_programlisting4_id347913"/><pre class="programlisting">typedef     struct _TParticle
{
     float          x;              // x-coordinate of the particle
     float          y;              // y-coordinate of the particle
     float          vi;             // initial velocity
     float          angle;          // initial trajectory (direction)
     int            life;           // duration in milliseconds
     int            r;              // red component of particle's color
     int            g;              // green component of particle's color
     int            b;              // blue component of particle's color
     int            time;           // keeps track of the effect's time
     float          gravity;        // gravity factor
     BOOL           Active;         // indicates whether this particle
                                    // is active or dead
     <span class="strong"><strong>float          mass;           //for calculating the particle's energy</strong></span>
} TParticle;

#define     _MAXPARTICLES 50
<span class="strong"><strong>#define    _MASSOFPARTICLE .25</strong></span>

typedef struct _TParticleExplosion
{
     TParticle          p[_MAXPARTICLES];  // list of particles
                                           // making up this effect
     int           x;  // initial x location
     int           y;  // initial y location
     float         KE;  //Available kinect energy
     float
     BOOL          Active;      // indicates whether this effect is
                                //active or dead
} TParticleExplosion;</pre><p>Notice that <code class="literal">V0</code> is no longer required, as the
        available kinetic energy will govern the strength of the explosion. Assuming that the
        bullet’s kinetic energy is given as a variable <code class="literal">KEb</code>, our
        new <code class="literal">CreateParticleExplosion</code> function would look like the
        following:</p><a id="I_programlisting4_id347965"/><pre class="programlisting">void CreateParticleExplosion(int x, int y, int KEb, int life,
                             float gravity, float angle)
{
     int     i;
     int     m;
     float   f;

     Explosion.Active = TRUE;
     Explosion.x = x;
     Explosion.y = y;
     <span class="strong"><strong>Explosion.KE = KEb;</strong></span>

     for(i=0; i&lt;_MAXPARTICLES; i++)
     {
          Explosion.p[i].x = 0;
          Explosion.p[i].y = 0;
          Explosion.p[i].m = _MASSOFPARTICLE; //Mass of a single gravel
          <span class="strong"><strong>Explosion.p[i].vi = tb_Rnd(0, sqrt(Explosion.KE/(_MASSOFPARTICLE*               _MAXPARTICLES));</strong></span>
          <span class="strong"><strong>Explosion.KE = Explosion.KE - ((1/2)*(Explosion.p[i].m)*                        (Explosion.p[i].vi));</strong></span>

          if(angle &lt; 999)
          {
               if(tb_Rnd(0,1) == 0)
                    m = −1;
               else
                    m = 1;
               Explosion.p[i].angle = -angle + m * tb_Rnd(0,10);
          } else
               Explosion.p[i].angle = tb_Rnd(0,360);

          f = (float) tb_Rnd(80, 100) / 100.0f;
          Explosion.p[i].life = tb_Round(life * f);
          Explosion.p[i].r = 255;//tb_Rnd(225, 255);
          Explosion.p[i].g = 255;//tb_Rnd(85, 115);
          Explosion.p[i].b = 255;//tb_Rnd(15, 45);
          Explosion.p[i].time = 0;
          Explosion.p[i].Active = TRUE;
          Explosion.p[i].gravity = gravity;
     }

}</pre><p>As you can see, we’ve altered the statements that set the initial velocity of the
        particles to be a random-number generator in a range anywhere from 0 to a velocity that
        would consume the entire explosion’s kinetic energy. The next line reduces the available
        kinetic energy in the explosion by the amount just assigned to the particle. This way, you
        can be sure that the outgoing explosion is never more powerful then the input. A more
        interesting way to handle this would be to first initialize the particles with some given
        mass distribution and to assign the velocities not randomly, but with a normal distribution.
        Numerical recipes in C can help you accomplish this.</p><p>Even though the preceding code does not take into account some of the more subtle
        aspects of the transfer of kinetic energy, it will ensure that a small, slow-moving bullet
        produces a smaller explosion than a big, fast-moving one. This is something that is lacking
        in today’s video <a id="I_indexterm4_id348014" class="indexterm"/><a id="I_indexterm4_id348024" class="indexterm"/><a id="I_indexterm4_id348033" class="indexterm"/><a id="I_indexterm4_id348042" class="indexterm"/><a id="I_indexterm4_id348052" class="indexterm"/><a id="I_indexterm4_id348061" class="indexterm"/><a id="I_indexterm4_id348070" class="indexterm"/><a id="I_indexterm4_id348080" class="indexterm"/>games.</p></div><div class="sect2" title="Polygon Explosions"><div class="titlepage"><div><div><h3 class="title" id="polygon_explosions">Polygon Explosions</h3></div></div></div><p>While particle <a id="ex18.4.2" class="indexterm"/><a id="po18.4.2" class="indexterm"/>explosions are appropriate for small, uniform objects, they fail to give
        appropriate realism when something is blown into identifiable chunks. This is why in video
        games you rarely see a car explode and the door fly away to land next to you. Instead, games
        usually handle objects like this with a particle explosion that obscures the object while it
        is re-rendered in its now-exploded state with the missing pieces having been apparently
        blown to smithereens.</p><p>If you do want to model a full explosion of solid bodies, you can reuse the particle
        code for the translation aspects. Essentially the particles will now describe the center of
        gravity of each solid body. You will have to add in an initial angular velocity and let the
        simulation, as described in <a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12</a>, handle their
        motion after that initial angle.</p><p>While we don’t have room to go over another example here, we’ll talk a little about the
        input energy to such an explosion to help you bridge the gap. While we are on that subject,
        let’s recall that a bullet just doesn’t have the energy required to blow something apart.
        Even when you hit something with a tank-mounted gun, it really isn’t the kinetic energy of
        the bullet that blows apart the thing you hit, but some secondary explosion. In the case of
        a tank hitting another tank, the molten slag from the impact is usually peppered all over
        the inside of the tank, causing the fuel or ammunition to explode. That is where you get the
        big booms—it’s the conversion of chemical energy to heat, light, and pressure!</p><p>The most common method of quantifying the chemical energy in weapons is <a id="I_indexterm4_id348160" class="indexterm"/>called <span class="emphasis"><em>TNT equivalency</em></span>. This is how much TNT it would take
        to cause the same explosion regardless of what you are actually exploding. Now, explosion
        modeling of, say, gasoline and air is pretty complex, so let’s stick with TNT. A kilogram of
        TNT contains 4.184 Mega joules of energy; a 9 mm round has 400 J. You can see from that
        comparison why it is hard to blow something up by shooting at it, but easy to do with a
        block of TNT.</p><p>For the purposes of this discussion, let’s say you have an open box (five polygon sides)
        into which your player just tossed a 1 kg block of TNT. When the TNT is detonated, you can
        give each polygon side an initial velocity (translational and angular) and let the kinematic
        equations take over. Those velocities can be based on two simple rules.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The velocity vector can be defined by two points: the center of the block of TNT and
            the center of area of the polygon.</p></li><li class="listitem"><p>The sum of all the kinetic energy must be less than the available chemical energy in
            the TNT. This can be prorated by the square of the distance from the polygon to the
            block of TNT.</p></li></ul></div><p>The use of the center of area in our first rule will impart some rotation into our
        polygon, as it will cause a moment about the center of gravity unless the two coincide. If
        this is the case, as it would be for our box, aerodynamic drag and unevenness of the
        explosion will still cause rotation, so you should either model these explicitly or impart
        some rotational velocity manually.</p><p>Now that we have a velocity direction, we need to define its <a id="I_indexterm4_id348214" class="indexterm"/>magnitude. The force on objects near an explosion is caused by the rapid
        expansion of gasses due to the heat generated by the detonation of the explosive. However,
        not all the chemical energy is transferred to the objects—a lot of it is converted into
        heat, light, and sound. Typically, only one-third of the available chemical energy is
        converted in the initial detonation. Let’s call this the efficiency of the explosion, which
        we’ll denote by ζ. Therefore, we can write the relationship between velocities of the
        polygons as follows:</p><div class="informalequation"><div class="mediaobject"><img src="eq_1801.png" alt="Polygon Explosions"/></div></div><p>Here, we can tune ζ to give the polygons realistic velocities in the event of an
        explosion (i.e., not sending them off at the speed of light). If the energy from the
        explosion is divided up equally, you can see that lighter objects will have higher
        velocities, as you might expect. You can also adjust the amount of explosion energy
        available to each object by weighting the object’s imparted energy by its distance from the
        explosion. This should also be tuned in the program, but in general, pressure from an
        explosion decreases with the cube of distance and exponentially with time.</p><p>If you want to model more complex explosion-structure interactions, there are many good
        references for how, say, buildings, react to bomb blasts. FEMA, as well as the Army and
        Navy, have several papers on the subject, such as <span class="emphasis"><em>FEMA 426 Reference Manual to
          Mitigate Potential Terrorist Attacks Against Buildings</em></span>. The general concepts
        laid out in such documents can increase the realism of the building damage due to <a id="I_indexterm4_id348264" class="indexterm"/><a id="I_indexterm4_id348273" class="indexterm"/>explosions.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 19. Sports</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Physical Modeling"/><link rel="prev" href="ch18.html" title="Chapter 18. Guns and Explosions"/><link rel="next" href="pt04.html" title="Part IV. Digital Physics"/></head><body><section class="chapter" title="Chapter 19. Sports" epub:type="chapter" id="sports"><div class="titlepage"><div><div><h2 class="title">Chapter 19. Sports</h2></div></div></div><p>The topic of <a id="I_indexterm5_id348297" class="indexterm"/>sports is nearly as vast as all of the subjects we’ve covered combined. There is a
    sport for everyone, and a sport that takes advantage of each of the physical models we’ve
    discussed so far. The topic ranges from games full of accessories, such as golf or polo, to
    running, where all you need are your own two feet.</p><p>One of the most attractive aspects of sports for the game programmer is that they take place
    in a limited physical space by design. Unlike a first-person shooter where the player will
    eventually reach an artificial boundary, in a sports game the player will not expect to be able
    to walk out of the court. Almost all sports have defined dimensions that are relatively easy to
    model. <a class="xref" href="ch19.html#various_field_dimensions" title="Table 19-1. Various field dimensions">Table 19-1</a> lists a few sports and their professional
    field dimensions.</p><div class="table"><a id="various_field_dimensions"/><div class="table-title">Table 19-1. Various field dimensions</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Sport</p>
          </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
            <p>Field size</p>
          </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Soccer (football)</p>
          </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>90–120 m long by 45–90 m wide</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Football (including end zones)</p>
          </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>109.7 m long by 48.8 m wide</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Baseball</p>
          </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>27.4 m between bases; 18.39 from pitcher’s mound to home base; outfield
              varies</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Basketball (international)</p>
          </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>28 m by 15 m</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
            <p>Ice hockey (international)</p>
          </td><td style="text-align: left; vertical-align: top; ">
            <p>61 m by 30 m</p>
          </td></tr></tbody></table></div></div><p>As you can see, other than baseball—where the shape of the outfield changes depending on
    what stadium you are in—modeling these field sizes is a rather straightforward exercise.</p><p>Additionally, the one thing that sports have in common is that they have a human actor. In
    this chapter we’ll explore how the human action can be simulated as input for the other physical
    simulations we’ve discussed. Specifically, we’ll show you an example of how to model a person
    swinging a golf club using accurate physiological models. <a id="I_indexterm5_id348542" class="indexterm"/><a id="I_indexterm5_id348548" class="indexterm"/><a id="I_indexterm5_id348558" class="indexterm"/>This is called <span class="emphasis"><em>biomechanics</em></span>. Before we get into that, another
    important thing to understand when you’re modeling sports is the limits of the human body.
    Although records are broken in every Olympics, no human being is able to jump 10 feet vertically
    into the air. Unless you are breaking the limits of biomechanics on purpose, doing so will
    decrease the realism of your game. The biomechanical statistics of what would be considered an
    outstanding athlete are given in <a class="xref" href="ch19.html#table_of_human_performance" title="Table 19-2. Table of human performance">Table 19-2</a>.</p><div class="table"><a id="table_of_human_performance"/><div class="table-title">Table 19-2. Table of human performance</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Physical attribute</p>
          </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Average value</p>
          </td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
            <p>Record value</p>
          </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Jump from standstill (vertical)</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>81 cm</p>
          </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>155 cm</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Running jump height (high jump)</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>1.83 m</p>
          </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>2.45 m</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Jump distance</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>5.0 m</p>
          </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>8.95 m</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Throwing speed</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>24.5 m/s</p>
          </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>46.0 m/s</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>Running speed over 100 m</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
            <p>7.5 m/s</p>
          </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; ">
            <p>10 m/s</p>
          </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
            <p>Running speed over 10,000 m</p>
          </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; ">
            <p>3.7 m/s</p>
          </td><td style="text-align: center; vertical-align: top; ">
            <p>6.3 m/s</p>
          </td></tr></tbody></table></div></div><p>Almost all sports records are available online somewhere, so <a class="xref" href="ch19.html#table_of_human_performance" title="Table 19-2. Table of human performance">Table 19-2</a> is by no means exhaustive. However, it is a good idea
    to use these values to limit your simulations of human actions in your video games. Obviously,
    part of the excitement of playing video games is to be able to jump higher and run faster than
    you otherwise could, but a good survey of biomechanics will at least let you know what is
    extraordinary and what is not. Now let’s take a look at how we would model a human actor in a
    sports game.</p><div class="sect1" title="Modeling a Golf Swing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="modeling_a_golf_swing">Modeling a Golf Swing</h2></div></div></div><p>Let’s say you’re writing a <a id="sp19.1" class="indexterm"/><a id="go19.1" class="indexterm"/>golf game and you want include a little realism. An obvious important element of
      the game is the golf swing. Another is the club-to-ball impact, and still another is the
      trajectory of the ball in flight. You can use the <a id="I_indexterm5_id348968" class="indexterm"/>projectile motion modeling techniques discussed earlier in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4</a>, and <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> to
      model the ball’s flight, and the collision response techniques in <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5</a>
      to model the club-to-ball impact. But what about the golf swing?</p><p>Well, before we show you one way to model a golf swing, let’s talk about why you would
      want to do so in the first place. To model club-to-ball impact, you need to know the club head
      velocity at the time of impact. That velocity is a function of the swing. The golfer raises
      the club through his backswing, torques his body, and brings the club head down in an arc
      while applying a torque with his wrists. As the club swings down, the wrist torque reverses,
      and the club whips through the downswing until the club head collides with the ball. (Or, in
      our case, collides with the ground!) Now, there are many subtle details we’ve omitted here
      with regard to technique and the physics, but you get the idea. At any rate, the swing
      determines the club head velocity at the moment of impact, which in turn determines the
      velocity of the ball after impact.</p><p>If you were writing a game for the Wii or some other platform that can capture a player’s
      motion, then you can relate the player’s swing motion to the initial torque applied to a
      virtual golf club, thus determining, through some model, the swing dynamics and resulting club
      head velocity.</p><p>Golfers take swing technique seriously and so do scientists who study golf swing dynamics.
      In an effort to understand what makes a good swing or how to improve a swing, there are many
      scientists out there actively studying the golf swing physics. As a result, there are many
      mathematical models of varying degrees of realism and complexity that aim to examine the golf
      swing. One example is the so-called <span class="emphasis"><em>two-rod model</em></span> as <a id="I_indexterm5_id349028" class="indexterm"/><a id="I_indexterm5_id349034" class="indexterm"/>described in <a id="jo19.1" class="indexterm"/>Theodore P. Jorgensen’s book <span class="emphasis"><em>The Physics of Golf</em></span>. In his
      book, Dr. Jorgensen describes the two-rod model in detail, including assumptions and
      simplifications, and provides the resulting equations that must be solved to simulate a golf
      swing based on this model. He even provides empirical data used to validate the results of the
      mathematical model. As shown in <a class="xref" href="ch19.html#two-rod_model_of_golf_swing" title="Figure 19-1. Two-rod model of golf swing">Figure 19-1</a>, the two-rod
      model assumes that the golfer’s arm is one rod that extends from the shoulders to the wrists.
      This is the<a id="I_indexterm5_id349069" class="indexterm"/>
      <span class="emphasis"><em>arm rod</em></span>. The club is represented by another rod that extends from the
      wrist end of the arm rod to the club head.</p><div class="figure"><a id="two-rod_model_of_golf_swing"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id349091"/><img src="httpatomoreillycomsourceoreillyimages1598987.png" alt="Two-rod model of golf swing"/></div></div><div class="figure-title">Figure 19-1. Two-rod model of golf swing</div></div><p>This model is essentially a double pendulum. More specifically, it is a driven double
      pendulum since the model assumes a torque applied at the shoulder end of the arm rod, and
      another torque applied at the wrist joint connecting the arm rod to the club rod. We won’t
      repeat Dr. Jorgensen’s development of the model here; instead, we’ll show you how to solve the
      resulting equations:</p><p>Those equations can be found in the Technical Appendix—Section 4 of Dr. Jorgensen’s
      book—but are listed here for convenience.</p><p>Equation 1:</p><div class="informalfigure"><a id="image_no_caption-id2"/><div class="mediaobject"><a id="I_mediaobject5_id349136"/><img src="httpatomoreillycomsourceoreillyimages1598988.png" alt="image with no caption"/></div></div><p>Equation 2:</p><div class="informalfigure"><a id="image_no_caption-id3"/><div class="mediaobject"><a id="I_mediaobject5_id349164"/><img src="httpatomoreillycomsourceoreillyimages1598989.png" alt="image with no caption"/></div></div><p><a class="xref" href="ch19.html#symbols_used_in_golf_swing_model" title="Table 19-3. Symbols used in golf swing model">Table 19-3</a> explains what each symbol
      represents.</p><div class="table"><a id="symbols_used_in_golf_swing_model"/><div class="table-title">Table 19-3. Symbols used in golf swing model</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Symbol</p>
            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
              <p>Meaning</p>
            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>J</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Mass moment of inertia of the rod representing the arm. Units are
                  kg-m<sup>2</sup>.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>I</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Mass moment of inertia of the rod representing the club. Units are
                  kg-m<sup>2</sup>.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>M<sub>c</sub></p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Mass of the club. Units are kg.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>R</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Length of the rod representing the arm. Units are m.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>S</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>First moment of the rod representing the club about the wrist axis (where the
                club rod connects to the arm rod). Units are kg-m.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>α</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Angle swept by arm rod from initial backswing position. Units are
                radians.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>β</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Wrist-cock angle. Units are radians.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>g</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Acceleration due to gravity. Constant 9.8
                m/s<sup>2</sup>.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Θ</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Angle between arm rod and vertical axis. Units are radians.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>a</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Horizontal acceleration of the shoulder. Units are
                  m/s<sup>2</sup>.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>S<sub>A</sub></p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>First moment of the arm rod about the shoulder axis. Units are kg-m.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Q<sub>α</sub></p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>Torque applied at the shoulder to the arm rod. Units are N-m.</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>Q<sub>β</sub></p>
            </td><td style="text-align: left; vertical-align: top; ">
              <p>Torque applied at the wrist joint to the club rod. Units are N-m.</p>
            </td></tr></tbody></table></div></div><p>These equations represent a coupled system of nonlinear differential equations. They are
      coupled in that they both depend on the unknown quantities α and β. They are clearly
      differential equations, as they both include time derivatives of the unknown quantities. And
      they are nonlinear because they include sines and cosines of one of the unknowns along with
      derivatives of the other unknown raised to some power greater than 1.</p><p>So, how do we solve these equations? Well, we can’t do so in closed form and must resort
      to numerical means. There are a number of ways to proceed, but the approach we’ll use is to
      first solve Equation 2 for <span class="inlinemediaobject"><img src="inleq_1901.png" alt=""/></span> and substitute the result into Equation 1. Then, we’ll numerically integrate
      the result using a fourth-order <a id="I_indexterm5_id349673" class="indexterm"/>Runge-Kutta scheme, as described in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>.</p><p>More specifically, at each time step Equation 1 with <span class="inlinemediaobject"><img src="inleq_1902.png" alt=""/></span> replaced by the expression derived from Equation 1 will be solved for <span class="inlinemediaobject"><img src="inleq_1903.png" alt=""/></span>. Once <span class="inlinemediaobject"><img src="inleq_1904.png" alt=""/></span> is found, we can find <span class="inlinemediaobject"><img src="inleq_1905.png" alt=""/></span> using the second equation previously solved for <span class="inlinemediaobject"><img src="inleq_1906.png" alt=""/></span>. Next, we can integrate <span class="inlinemediaobject"><img src="inleq_1907.png" alt=""/></span> and <span class="inlinemediaobject"><img src="inleq_1908.png" alt=""/></span> to find α and β. This process then repeats for each time step.</p><p>Again, this is only one method of solving these equations. Normally, when faced with a
      system of equations, practitioners use matrix schemes to solve the equations simultaneously.
      This is almost necessary for systems of equations that involve more than two equations.
      However, with just two equations, as we have here, we can avoid expensive matrix inversion
      computation by using the technique we just described.</p><div class="sect2" title="Solving the Golf Swing Equations"><div class="titlepage"><div><div><h3 class="title" id="solving_the_golf_swing_equations">Solving the Golf Swing Equations</h3></div></div></div><p>Now we’ll show you how to implement the solution we described in a simple console
        application. The example solves the two governing equations for α and β over time, the
        results of which can then be used to determine the club head velocity at any time instant
        using kinematic equations as described in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a> (see the section
          <a class="xref" href="ch02.html#rigid-body_kinematics" title="Rigid-Body Kinematics">Rigid-Body Kinematics</a>). Alternatively, you can use the following
        equation, which Dr. Jorgensen gives for the club head velocity in his book:</p><div class="informalfigure"><a id="image_no_caption-id4"/><div class="mediaobject"><a id="I_mediaobject5_id349805"/><img src="httpatomoreillycomsourceoreillyimages1598990.png" alt="image with no caption"/></div></div><p>We’ll use Jorgensen’s equation in this example.</p><p>Since the angles of interest are computed in units of radians, but we want to report
        them in units of degrees, we first create a few <code class="literal">define</code>s
        to make the conversions for us:</p><a id="I_programlisting5_id349838"/><pre class="programlisting">#define    RADIANS(d)    (d/180.0*3.14159)
#define    DEGREES(r)    (r*180.0/3.14159)</pre><p>Next, we declare and initialize all of the variables. The initial values used here are
        some typical values that we assumed. You can change these values to simulate different
        swings:</p><a id="I_programlisting5_id349849"/><pre class="programlisting">// Variables
double alpha = 0.0;
double alpha_dot = 0.0;
double alpha_dotdot = 0.0;
double beta = RADIANS(120.0);
double beta_dot = 0.0;
double beta_dotdot = 0.0;

double J = 1.15; // kg m^2
double I = 0.08; // kg m^2
double Mc = 0.4; // kg
double R = 0.62; // m
double L = 1.1; // m
double S = 0.4*1.1*0.75; // kg m
double g = 9.8; // m/s^2
double gamma = RADIANS(135.0);
double theta = gamma - alpha;
double SA = 7.3*0.62*0.5; // kg m
double Qalpha = 100; // N m
double Qbeta = −10; // N m
double a = 0.1*g; // m/s^2
double dt = 0.0025; // s
double time = 0; // s
double Vc = 0;</pre><p>Next we define two functions that we will use to compute the second time derivatives of
        α and β (i.e., <span class="inlinemediaobject"><img src="inleq_1909.png" alt=""/></span> and <span class="inlinemediaobject"><img src="inleq_1910.png" alt=""/></span>). These functions simply use Equations 1 and 2 solved for <span class="inlinemediaobject"><img src="inleq_1911.png" alt=""/></span> and <span class="inlinemediaobject"><img src="inleq_1912.png" alt=""/></span>, respectively.</p><p><code class="literal">ComputeAlphaDotDot</code>, which solves for <span class="inlinemediaobject"><img src="inleq_1913.png" alt=""/></span>, is shown here:</p><a id="I_programlisting5_id349925"/><pre class="programlisting">double ComputeAlphaDotDot(void)
{
    double A, B, C, D, F, G;
    double num, denom;

    A = (J + I + Mc * R * R + 2 * R * S * cos(beta));
    B = -(I + R * S * cos(beta));
    F = Qalpha - (beta_dot * beta_dot - 2 * alpha_dot * beta_dot) * R * S *
        sin(beta) + S * (g * sin(theta + beta) - a * cos(theta + beta))
        + (SA + Mc * R) * (g * sin(theta) - a * cos(theta));

    C = B;
    D = I;
    G = Qbeta - alpha_dot * alpha_dot * R * S * sin(beta) −
        S * (g * sin(theta + beta) - a * cos(theta + beta));

    num = (F - (B * G / D));
    denom = (A-(B*C/D));
    return (F - (B * G / D)) / (A-(B*C/D));
}</pre><p>The local variables <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code>, <code class="literal">D</code>,
          <code class="literal">F</code>, and <code class="literal">G</code> are
        convenience variables used to organize the terms in Equation 1. This function returns the
        second derivative of α.</p><p><code class="literal">ComputeBetaDotDot</code>, shown next, is very similar to
          <code class="literal">ComputeAlphaDotDot</code> but solves Equation 2 instead. This
        function returns the second derivative of β:</p><a id="I_programlisting5_id349993"/><pre class="programlisting">double ComputeBetaDotDot(void)
{
    double C, D, G;

    C = -(I + R * S * cos(beta));
    D = I;
    G = Qbeta - alpha_dot * alpha_dot * R * S * sin(beta) −
        S * (g * sin(theta + beta) - a * cos(theta + beta));

    return (G - C * alpha_dotdot) / D;
}</pre><p>The solution to Equations 1 and 2 follows the <a id="I_indexterm5_id350004" class="indexterm"/>Runge-Kutta scheme we showed you in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>.
        Four intermediate steps are taken for each time step. The time step size is controlled by
          <code class="literal">dt</code>, which we’ve set to 0.0025s. If you simply used <a id="I_indexterm5_id350023" class="indexterm"/>Euler’s method, you’d have to reduce this step size quite a bit to obtain a
        stable solution. We implemented the solution in the main function of our console example.
        The code is as follows:</p><a id="I_programlisting5_id350037"/><pre class="programlisting">int _tmain(int argc, _TCHAR* argv[])
{
    double    a, at;
    double    b, bt;
    int       i;
    FILE*     fp;
    double    phi;
    double    Vc2;

    double  ak1, ak2, ak3, ak4;
    double  bk1, bk2, bk3, bk4;

    FILE*     fdebug;

    fp = fopen("results.txt", "w");
    fdebug = fopen("debug.txt", "w");

    for(i = 0; i&lt;200; i++)
    {
        time += dt;

        if(time&gt;=0.1)
        {
            Qbeta = 0;
        }

        // save results of previous time step
        a = alpha;
        b = beta;
        at = alpha_dot;
        bt = beta_dot;

        // integrate alpha'' and beta''

        // The K1 Step:
        alpha_dotdot = ComputeAlphaDotDot();
        beta_dotdot = ComputeBetaDotDot();

        ak1 = alpha_dotdot * dt;
        bk1 = beta_dotdot * dt;

        alpha_dot = at + ak1/2;
        beta_dot = bt + bk1/2;

        // The K2 Step:
        alpha_dotdot = ComputeAlphaDotDot();
        beta_dotdot = ComputeBetaDotDot();

        ak2 = alpha_dotdot * dt;
        bk2 = beta_dotdot * dt;

        alpha_dot = at + ak2/2;
        beta_dot = bt + bk2/2;

        // The K3 Step:
        alpha_dotdot = ComputeAlphaDotDot();
        beta_dotdot = ComputeBetaDotDot();

        ak3 = alpha_dotdot * dt;
        bk3 = beta_dotdot * dt;

        alpha_dot = at + ak3;
        beta_dot = bt + bk3;

        // The K3 Step:
        alpha_dotdot = ComputeAlphaDotDot();
        beta_dotdot = ComputeBetaDotDot();

        ak4 = alpha_dotdot * dt;
        bk4 = beta_dotdot * dt;

        alpha_dot = at + (ak1 + 2*ak2 + 2*ak3 + ak4) / 6;
        beta_dot = bt + (bk1 + 2*bk2 + 2*bk3 + bk4) / 6;

        alpha = a + alpha_dot * dt;
        beta = b + beta_dot * dt;

        theta = gamma - alpha;
        Vc2 = (R*R + L*L + 2 * R * L * cos(beta)) * ( alpha_dot * alpha_dot)
             + L*L * beta_dot * beta_dot
              - 2 * (L*L + R * L * cos(beta)) * alpha_dot * beta_dot;

        Vc = sqrt(Vc2);

        phi = theta + beta;
        fprintf(fp, "%f, %f, %f, %f, %f, %f\n", time, DEGREES(theta),
                      DEGREES(alpha), DEGREES(beta), DEGREES(phi), Vc);

        fprintf(fdebug, "%f, %f, %f, %f, %f, %f, %f\n", time, DEGREES(alpha),
                 alpha_dot, alpha_dotdot, DEGREES(beta), beta_dot, beta_dotdot);
    }

    fclose(fp);
    fclose(fdebug);
    return 0;
}</pre><p>Local variables <code class="literal">a</code>, <code class="literal">at</code>, <code class="literal">b</code>, and <code class="literal">bt</code> are used to temporarily store the previous time step’s results for α and β
        and their first derivatives. <code class="literal">i</code> is a counter variable.
          <code class="literal">fp</code> is a file pointer that we’ll use to write results
        out to a text file. <code class="literal">phi</code> is used to store the sum of θ +
        β. And <code class="literal">Vc2</code> is the square of the club head velocity
        calculated according to Jorgensen’s equation. The variables <code class="literal">ak1</code> through <code class="literal">ak4</code>, and <code class="literal">bk1</code> through <code class="literal">bk4</code>, are used to
        store intermediate results of the Runge-Kutta integration scheme. <code class="literal">fdebug</code> is a file pointer to a file we used for writing debugging
        information.</p><p>After the output and debug files are opened, the function enters a loop to perform the
        integration over 200 time steps. You can change the number of time steps as you see fit for
        your application. Keep in mind that the swing event, from start to striking the ball, takes
        place over a very short period of time—only fractions of a second long.</p><p>Upon entering the loop, you’ll see some code that checks how much time has elapsed; if
        that time is greater than 0.1s, the wrist torque, <code class="literal">Qbeta</code>,
        is set to 0. This is a crude model of how the wrist torque that’s initially applied is
        released, allowing the club to swing past the arm. Depending on the swing you’re modeling,
        this torque could actually reverse direction, forcing the club past the arm even more. Dr.
        Jorgensen’s book explains all this in detail, even giving experimental results.</p><p>Next, results of the previous time step are saved in the variables <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">at</code>, and <code class="literal">bt</code>. The first time
        step simply stores the initial values. Now, the integration starts for the first step,
          <code class="literal">k1</code> (see <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>). Each
        of these steps involves computing <span class="inlinemediaobject"><img src="inleq_1914.png" alt=""/></span> and <span class="inlinemediaobject"><img src="inleq_1915.png" alt=""/></span> using the functions <code class="literal">ComputeAlphaDotDot</code>
        and <code class="literal">ComputeBetaDotDot</code>. The <code class="literal">k1</code> results are then calculated and used to compute intermediate results for the
        first time derivatives of α and β. All four intermediate steps are carried out in a similar
        manner.</p><p>Finally, the current time step’s results for <code class="literal">alpha_dot</code> and <code class="literal">beta_dot</code>, along with <code class="literal">alpha</code> and <code class="literal">beta</code>, are computed.
        Also, the square of the club head velocity, <code class="literal">Vc2</code>, is
        computed using Jorgensen’s equation shown earlier; and the club head velocity, <code class="literal">Vc</code>, results from the square root of <code class="literal">Vc2</code>.</p><p>Results of interest are then written to the output and debug files. So, that’s pretty
        much it. After the loop finishes, the files are closed and the application
        terminates.</p><p>If this were an actual game, you would use the club head velocity results along with the
        collision response method we showed in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> to determine the golf ball’s
        trajectory. You could model the flight path of the golf ball using the methods we <a id="I_indexterm5_id350314" class="indexterm"/><a id="I_indexterm5_id350323" class="indexterm"/><a id="I_indexterm5_id350332" class="indexterm"/>showed you in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a>.</p></div></div><div class="sect1" title="Billiards"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="billiards">Billiards</h2></div></div></div><p>Now let’s take <a id="sp19.2" class="indexterm"/><a id="bi19.2" class="indexterm"/>a look at a different example. You may not think of billiards as a sport, but it
      is recognized internationally as a cue sport. Cue sports are a family of sports that include
      billiards, pool, snooker, and other related variations. For simplicity, we’ll stick with the
      term <span class="emphasis"><em>billiards</em></span>, although the topics presented apply to all cue
      sports.</p><p>Billiards is a good example of an activity that takes place over a limited physical space.
      Thus, when writing a billiards video game you need only concern yourself with a very finite
      space composed of well-established geometry. Billiard tables are typically 1.37 m × 2.74 m
      (4.5 ft × 9 ft), with some longer and some smaller depending on the game, style, and space
      available. Tables are typically cloth-covered slate. Balls vary in size between games and
      regions, with American-style pool balls measuring about 57 mm (2.25 inches) in diameter. Balls
      used to be made of wood, clay, or ivory, but nowadays they are plastic.</p><p>All these characteristics are important little details that you must consider if you’re
      going to make a realistic billiards video game. The slate table and hard plastic balls have
      certain <a id="I_indexterm5_id350406" class="indexterm"/>impact characteristics. The cloth-covered table provides some resistance to
      rolling. Side bumpers are not as hard as the slate table, thus yielding different impact
      characteristics. Fortunately, data on billiard tables and balls is readily available on the
      Web. And simulating billiards in a video game is fairly straightforward.</p><p>Billiards makes an interesting example because <a id="I_indexterm5_id350424" class="indexterm"/>collisions are the heart of the game, and such an example also gives us an
      opportunity to demonstrate rolling contact. <a class="xref" href="ch19.html#elapsed_time_equals_0.398s" title="Figure 19-2. Elapsed time = 0.398s">Figure 19-2</a> and
        <a class="xref" href="ch19.html#elapsed_time_equals_0.440s" title="Figure 19-3. Elapsed time = 0.440s">Figure 19-3</a> illustrate the example we’ll focus on. We have
      three object balls (the ones that get struck with the cue ball) set up in the middle of the
      table in a loose triangle configuration.</p><div class="figure"><a id="elapsed_time_equals_0.398s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id350458"/><img style="width: 394.2; " src="httpatomoreillycomsourceoreillyimages1598991.png.jpg" alt="Elapsed time = 0.398s"/></div></div><div class="figure-title">Figure 19-2. Elapsed time = 0.398s</div></div><p>The cue ball comes from the right at a set speed (see <a class="xref" href="ch19.html#elapsed_time_equals_0.398s" title="Figure 19-2. Elapsed time = 0.398s">Figure 19-2</a>) and then impacts the eight ball (see <a class="xref" href="ch19.html#elapsed_time_equals_0.440s" title="Figure 19-3. Elapsed time = 0.440s">Figure 19-3</a>).</p><div class="figure"><a id="elapsed_time_equals_0.440s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id350503"/><img style="width: 394.2; " src="httpatomoreillycomsourceoreillyimages1598992.png.jpg" alt="Elapsed time = 0.440s"/></div></div><div class="figure-title">Figure 19-3. Elapsed time = 0.440s</div></div><p>After the initial impact between the cue ball and the eight ball, the eight ball moves to
      the left and impacts two more balls. These balls then shoot off diagonally. Most of the energy
      from the eight ball is transferred to the two other balls, so the eight ball quickly comes to
      rest while being kissed by the cue ball. The other two balls continue rolling away diagonally
      (see <a class="xref" href="ch19.html#elapsed_time_equals_0.566s" title="Figure 19-4. Elapsed time = 0.566s">Figure 19-4</a>).</p><div class="figure"><a id="elapsed_time_equals_0.566s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id350546"/><img src="httpatomoreillycomsourceoreillyimages1598993.png.jpg" alt="Elapsed time = 0.566s"/></div></div><div class="figure-title">Figure 19-4. Elapsed time = 0.566s</div></div><p>In this example, we’ll show you how to handle ball-ball collisions, ball-table collisions,
      ball-table contact, aerodynamic drag on the ball, rolling resistance, friction between balls
      at the time of impact, and friction between the balls and <a id="I_indexterm5_id350569" class="indexterm"/>table.</p><div class="sect2" title="Implementation"><div class="titlepage"><div><div><h3 class="title" id="implementation">Implementation</h3></div></div></div><p>If you’ve read and <a id="bi19.2.1" class="indexterm"/>studied the examples presented in <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7</a>
        through <a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13</a>, then the implementation of this billiards
        example will be very familiar to you; we use the same basic approach. During each simulation
        time step, we calculate all the forces acting on each ball; integrate the equations of
        motion, updating each ball’s position and velocity; and then check for and deal with
        collisions.</p><p>The rigid-body class used in <a id="I_indexterm5_id350626" class="indexterm"/>this example is very similar to that used for the airplane example in <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15</a>. Even though the balls are compact and round, and it’s tempting to
        treat them as particles, you must treat them as <a id="I_indexterm5_id350644" class="indexterm"/><a id="I_indexterm5_id350656" class="indexterm"/>3D rigid bodies in order to capture rolling and spinning, which are important
        elements of billiard ball dynamics. The rigid-body class adopted for this billiards example
        is as follows.</p><a id="I_programlisting5_id350672"/><pre class="programlisting">typedef struct _RigidBody {
    float        fMass;      // Total mass (constant)
    Matrix3x3    mInertia;   // Mass moment of inertia in body coordinates
    Matrix3x3    mInertiaInverse;// Inverse of mass moment of inertia matrix
    Vector    vPosition;     // Position in earth coordinates
    Vector    vVelocity;     // Velocity in earth coordinates
    Vector    vVelocityBody;  // Velocity in body coordinates
    Vector    vAcceleration;  // Acceleration of cg in earth space
    Vector    vAngularAcceleration; //Angular acceleration in body coordinates
    Vector    vAngularAccelerationGlobal; // Angular acceleration
                                          // in global coordinates
    Vector    vAngularVelocity; // Angular velocity in body coordinates
    Vector    vAngularVelocityGlobal; // Angular velocity in global coordinates
    Vector    vEulerAngles;   // Euler angles in body coordinates
    float     fSpeed;      // Speed (magnitude of the velocity)
    Quaternion  qOrientation;    // Orientation in earth coordinates
    Vector    vForces;        // Total force on body
    Vector    vMoments;       // Total moment (torque) on body
    Matrix3x3  mIeInverse;  // Inverse of moment of inertia in earth coordinates
    float      fRadius;     // Ball radius
} RigidBody, *pRigidBody;</pre><p>As you can see, this class looks very similar to the rigid-body classes we’ve used
        throughout this book, and in particular that used in the airplane example. All the usual
        suspects are here, and the comments in this code sample state what each class member
        represents. One particular property you have not seen yet is <code class="literal">fRadius</code>—this is simply the billiard ball’s radius, which is used when we are
        checking for collisions and calculating drag forces.</p><p>As we discussed in <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14</a>, since there are multiple objects
        in this simulation that may collide, we’re going to iterate through all the objects,
        checking for collisions while storing the collision data. Since there are not that many
        objects in this simulation, we don’t really need to partition the game space in order to
        optimize the collision detection checks (refer to <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14</a>). The
        data we need to store for each collision is included in the following <code class="literal">Collision</code> structure:</p><a id="I_programlisting5_id350724"/><pre class="programlisting">typedef struct    _Collision {
    int       body1;
    int       body2;
    Vector    vCollisionNormal;
    Vector    vCollisionPoint;
    Vector    vRelativeVelocity;
    Vector    vRelativeAcceleration;
    Vector    vCollisionTangent;
}   Collision, *pCollision;</pre><p>The first two properties are indices to the two bodies involved in the collision. The
        next property, <code class="literal">vCollisionNormal</code>, stores the normal vector
        at the point of contact of the collision with the vector pointing outward from <code class="literal">body2</code>. The next property, <code class="literal">vCollisionPoint</code>, stores the coordinates of the point of contact in global
        coordinates. Since we’re dealing with spheres (billiard balls), the collision manifold will
        always consist of a single point for each ball-ball or ball-table collision. The next two
        properties store the relative velocity and acceleration between the two bodies at the point
        of collision. The data is stored in <code class="literal">vRelativeVelocity</code> and
          <code class="literal">vRelativeAcceleration</code>, respectively. To capture
        friction at the point of contact, we need to know the tangent vector to the bodies at the
        point of contact. This tangent is stored in <code class="literal">vCollisionTangent</code>.</p><p>We set up several global <code class="literal">define</code>s to hold key data,
        allowing us to easily tune the simulation:</p><a id="I_programlisting5_id350788"/><pre class="programlisting">#define    BALLDIAMETER              0.05715f
#define    BALLWEIGHT                1.612f
#define    GRAVITY                   −9.87f
#define    LINEARDRAGCOEFFICIENT     0.5f
#define    ANGULARDRAGCOEFFICIENT    0.05f
#define    FRICTIONFACTOR            0.5f
#define    COEFFICIENTOFRESTITUTION  0.8f
#define    COEFFICIENTOFRESTITUTIONGROUND  0.1f
#define    FRICTIONCOEFFICIENTBALLS     0.1f
#define    FRICTIONCOEFFICIENTGROUND    0.1f
#define    ROLLINGRESISTANCECOEFFICIENT 0.025f</pre><p>The first three <code class="literal">define</code>s represent the billiard ball
        diameter in meters, the ball weight in newtons, and the acceleration due to gravity in
          m/s<sup>2</sup>. The ball diameter and weight are typical values for
        American-style billiard balls (i.e., 2.25 inches and 5.8 oz on average).</p><p>The remaining defines are self-explanatory and represent nondimensional coefficients
        such as drag coefficients and coefficients of restitution. The values you see are what we
        came up with after tuning the simulation. You’ll surely tune these yourself if you develop
        your own billiards game.</p><p>We use three important global variables for this simulation, as shown here:</p><a id="I_programlisting5_id350824"/><pre class="programlisting">RigidBody      Bodies[NUMBODIES];
Collision      Collisions[NUMBODIES*8];
int            NumCollisions = 0;</pre><p><code class="literal">Bodies</code> is an array of <code class="literal">RigidBody</code> types and represents the collection of the billiard balls. Here we’ve
        defined <code class="literal">NUMBODIES</code> as 4, so there are four billiard balls
        in this simulation. We’ve adopted the convention that the cue ball will always <a id="I_indexterm5_id350853" class="indexterm"/>be <code class="literal">Bodies[0]</code>.</p></div><div class="sect2" title="Initialization"><div class="titlepage"><div><div><h3 class="title" id="initialization">Initialization</h3></div></div></div><p>At the beginning <a id="bi19.2.2" class="indexterm"/>of the simulation, we have to initialize all four billiard balls. We use one
        function, <code class="literal">InitializeObjects</code>, for this task. It’s a long
        function, but it’s really simple. The code is shown on this and the following pages.
          <code class="literal">Bodies[0]</code> is the cue ball, and it is positioned 50 ball
        diameters along the negative x-axis away from the object balls. There’s no magic to this
        number; we picked it arbitrarily. Now, we did deliberately set the z-position of the cue
        ball (all the balls, for that matter) to one-half the diameter so that the balls would be
        just touching the table at the start of the simulation.</p><p>To have the cue ball roll from right to left, we gave it an initial velocity of 7 m/s
        along the positive x-axis. With this initial velocity, the cue ball will begin sliding
        across the table for some short distance as it also starts to roll due to the friction
        between the ball and table. You can see in the upcoming code sample that all the other
        kinematic properties are set to 0 for the cue ball. For the object balls, all of their
        kinematic properties are set to 0.</p><p>We encourage you to experiment with different initial values for the cue ball’s
        kinematic properties. For example, try setting the angular velocity about any of the
        coordinate axes to something other than 0. Doing so will allow you to see how a spinning
        ball may move slightly left or right depending on the spin. It’s also fun to see how spin
        affects the object balls upon collision with the cue ball.</p><p>Aside from setting the positions and kinematic properties of the balls, <code class="literal">InitializeObjects</code> also initializes mass properties. We used the
        previously defined <code class="literal">BALLWEIGHT</code> divided by the acceleration
        due to gravity to determine the ball mass. For mass moment of inertia, we simply used the
        equations for a solid sphere we showed you way back in <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1</a>:</p><a id="I_programlisting5_id350954"/><pre class="programlisting">void InitializeObjects(int configuration)
{
    float      iRoll, iPitch, iYaw;
    int        i;
    float      Ixx, Iyy, Izz;
    float      s;

    /////////////////////////////////////////////////////
    // Initialize the cue ball:
    // Set initial position
    Bodies[0].vPosition.x = -BALLDIAMETER*50.0f;
    Bodies[0].vPosition.y = 0.0f;
    Bodies[0].vPosition.z = BALLDIAMETER/2.0f;

    // Set initial velocity
    s = 7.0;
    Bodies[0].vVelocity.x = s;
    Bodies[0].vVelocity.y = 0.0f;
    Bodies[0].vVelocity.z = 0.0f;
    Bodies[0].fSpeed = s;

    // Set initial angular velocity
    Bodies[0].vAngularVelocity.x = 0.0f; // rotate about long'l axis
    Bodies[0].vAngularVelocity.y = 0.0f; // rotate about transverse axis
    Bodies[0].vAngularVelocity.z = 0.0f; // rotate about vertical axis

    Bodies[0].vAngularAcceleration.x = 0.0f;
    Bodies[0].vAngularAcceleration.y = 0.0f;
    Bodies[0].vAngularAcceleration.z = 0.0f;

    Bodies[0].vAcceleration.x = 0.0f;
    Bodies[0].vAcceleration.y = 0.0f;
    Bodies[0].vAcceleration.z = 0.0f;

    // Set the initial forces and moments
    Bodies[0].vForces.x = 0.0f;
    Bodies[0].vForces.y = 0.0f;
    Bodies[0].vForces.z = 0.0f;

    Bodies[0].vMoments.x = 0.0f;
    Bodies[0].vMoments.y = 0.0f;
    Bodies[0].vMoments.z = 0.0f;

    // Zero the velocity in body space coordinates
    Bodies[0].vVelocityBody.x = 0.0f;
    Bodies[0].vVelocityBody.y = 0.0f;
    Bodies[0].vVelocityBody.z = 0.0f;

    // Set the initial orientation
    iRoll = 0.0f;
    iPitch = 0.0f;
    iYaw = 0.0f;
    Bodies[0].qOrientation = MakeQFromEulerAngles(iRoll, iPitch, iYaw);

    // Set the mass properties
    Bodies[0].fMass = BALLWEIGHT/(-g);

    Ixx = 2.0f * Bodies[0].fMass / 5.0f * (BALLDIAMETER/2*BALLDIAMETER/2);
    Izz = Iyy = Ixx;

    Bodies[0].mInertia.e11 = Ixx;
    Bodies[0].mInertia.e12 = 0;
    Bodies[0].mInertia.e13 = 0;
    Bodies[0].mInertia.e21 = 0;
    Bodies[0].mInertia.e22 = Iyy;
    Bodies[0].mInertia.e23 = 0;
    Bodies[0].mInertia.e31 = 0;
    Bodies[0].mInertia.e32 = 0;
    Bodies[0].mInertia.e33 = Izz;

    Bodies[0].mInertiaInverse = Bodies[0].mInertia.Inverse();

    Bodies[0].fRadius = BALLDIAMETER/2;


    /////////////////////////////////////////////////////
    // Initialize the other balls
    for(i=1; i&lt;NUMBODIES; i++)
    {
        // Set initial position
        if(i==1)
        {
            Bodies[i].vPosition.x = 0.0;
            Bodies[i].vPosition.y = -(BALLDIAMETER/2.0f+0.25*BALLDIAMETER);
            Bodies[i].vPosition.z = BALLDIAMETER/2.0f;
        } else if(i==2) {
            Bodies[i].vPosition.x = 0.0;
            Bodies[i].vPosition.y = BALLDIAMETER/2.0f+0.25*BALLDIAMETER;
            Bodies[i].vPosition.z = BALLDIAMETER/2.0f;
        } else {
            Bodies[i].vPosition.x = -BALLDIAMETER;
            Bodies[i].vPosition.y = 0.0f;
            Bodies[i].vPosition.z = BALLDIAMETER/2.0f;
        }

        // Set initial velocity
        Bodies[i].vVelocity.x = 0.0f;
        Bodies[i].vVelocity.y = 0.0f;
        Bodies[i].vVelocity.z = 0.0f;
        Bodies[i].fSpeed = 0.0f;

        // Set initial angular velocity
        Bodies[i].vAngularVelocity.x = 0.0f;
        Bodies[i].vAngularVelocity.y = 0.0f;
        Bodies[i].vAngularVelocity.z = 0.0f;

        Bodies[i].vAngularAcceleration.x = 0.0f;
        Bodies[i].vAngularAcceleration.y = 0.0f;
        Bodies[i].vAngularAcceleration.z = 0.0f;

        Bodies[i].vAcceleration.x = 0.0f;
        Bodies[i].vAcceleration.y = 0.0f;
        Bodies[i].vAcceleration.z = 0.0f;

        // Set the initial forces and moments
        Bodies[i].vForces.x = 0.0f;
        Bodies[i].vForces.y = 0.0f;
        Bodies[i].vForces.z = 0.0f;

        Bodies[i].vMoments.x = 0.0f;
        Bodies[i].vMoments.y = 0.0f;
        Bodies[i].vMoments.z = 0.0f;

        // Zero the velocity in body space coordinates
        Bodies[i].vVelocityBody.x = 0.0f;
        Bodies[i].vVelocityBody.y = 0.0f;
        Bodies[i].vVelocityBody.z = 0.0f;

        // Set the initial orientation
        iRoll = 0.0f;
        iPitch = 0.0f;
        iYaw = 0.0f;
        Bodies[i].qOrientation = MakeQFromEulerAngles(iRoll, iPitch, iYaw);

        // Set the mass properties
        Bodies[i].fMass = BALLWEIGHT/(-g);
        Ixx = 2.0f * Bodies[i].fMass / 5.0f * (BALLDIAMETER*BALLDIAMETER);
        Izz = Iyy = Ixx;

        Bodies[i].mInertia.e11 = Ixx;
        Bodies[i].mInertia.e12 = 0;
        Bodies[i].mInertia.e13 = 0;
        Bodies[i].mInertia.e21 = 0;
        Bodies[i].mInertia.e22 = Iyy;
        Bodies[i].mInertia.e23 = 0;
        Bodies[i].mInertia.e31 = 0;
        Bodies[i].mInertia.e32 = 0;
        Bodies[i].mInertia.e33 = Izz;

        Bodies[i].mInertiaInverse = Bodies[i].mInertia.Inverse();
        Bodies[i].fRadius = BALLDIAMETER/2;
    }
}</pre></div><div class="sect2" title="Stepping the Simulation"><div class="titlepage"><div><div><h3 class="title" id="stepping_the_simulation">Stepping the Simulation</h3></div></div></div><p>During each time <a id="I_indexterm5_id351012" class="indexterm"/><a id="I_indexterm5_id351022" class="indexterm"/>step, the simulation’s main loop makes a call to <code class="literal">StepSimulation</code>. This function, shown next, is almost identical to the <code class="literal">StepSimulation</code> functions we covered in the other examples shown
        throughout this book, so there really are no surprises here. <code class="literal">StepSimulation</code> first makes a call to <code class="literal">CalcObjectForces</code>, which we’ll discuss momentarily, and then proceeds to
        integrate the equations of motion for each ball. We use a basic <a id="I_indexterm5_id351060" class="indexterm"/>Euler scheme here for simplicity. After integrating, <code class="literal">StepSimulation</code> makes a few function calls to deal with collisions. We’ll cover
        those shortly.</p><a id="I_programlisting5_id351080"/><pre class="programlisting">void StepSimulation(float dtime)
{
    Vector     Ae;
    int        i;
    float      dt = dtime;
    int        check = NOCOLLISION;
    int        c = 0;

    // Calculate all of the forces and moments on the balls:
    CalcObjectForces();

    // Integrate the equations of motion:
    for(i=0; i&lt;NUMBODIES; i++)
    {
        // Calculate the acceleration in earth space:
        Ae = Bodies[i].vForces / Bodies[i].fMass;
        Bodies[i].vAcceleration = Ae;

        // Calculate the velocity in earth space:
        Bodies[i].vVelocity += Ae * dt;

        // Calculate the position in earth space:
        Bodies[i].vPosition += Bodies[i].vVelocity * dt;

        // Now handle the rotations:
        float    mag;

        Bodies[i].vAngularAcceleration = Bodies[i].mInertiaInverse *
                                    (Bodies[i].vMoments -
                                    (Bodies[i].vAngularVelocity^
                                    (Bodies[i].mInertia *
        Bodies[i].vAngularVelocity)));

        Bodies[i].vAngularVelocity += Bodies[i].vAngularAcceleration * dt;

        // Calculate the new rotation quaternion:
        Bodies[i].qOrientation += (Bodies[i].qOrientation *
                                   Bodies[i].vAngularVelocity) *
                                   (0.5f * dt);

        // Now normalize the orientation quaternion:
        mag = Bodies[i].qOrientation.Magnitude();
        if (mag != 0)
            Bodies[i].qOrientation /= mag;

        // Calculate the velocity in body space:
        Bodies[i].vVelocityBody = QVRotate(~Bodies[i].qOrientation,
                                    Bodies[i].vVelocity);

        // Get the angular velocity in global coords:
        Bodies[i].vAngularVelocityGlobal = QVRotate(Bodies[i].qOrientation,
                                    Bodies[i].vAngularVelocity);

        // Get the angular acceleration in global coords:
        Bodies[i].vAngularAccelerationGlobal = QVRotate(Bodies[i].qOrientation,
                                    Bodies[i].vAngularAcceleration);

        // Get the inverse intertia tensor in global coordinates
        Matrix3x3 R, RT;
        R = MakeMatrixFromQuaternion(Bodies[i].qOrientation);
        RT = R.Transpose();
        Bodies[i].mIeInverse = R * Bodies[i].mInertiaInverse * RT;

        // Calculate the air speed:
        Bodies[i].fSpeed = Bodies[i].vVelocity.Magnitude();

        // Get the Euler angles for our information
        Vector u;

        u = MakeEulerAnglesFromQ(Bodies[i].qOrientation);
        Bodies[i].vEulerAngles.x = u.x;    // roll
        Bodies[i].vEulerAngles.y = u.y;    // pitch
        Bodies[i].vEulerAngles.z = u.z;    // yaw
    }

    // Handle Collisions    :
    check = CheckForCollisions();
    if(check == COLLISION)
        ResolveCollisions();
}</pre></div><div class="sect2" title="Calculating Forces"><div class="titlepage"><div><div><h3 class="title" id="calculating_forces">Calculating Forces</h3></div></div></div><p>The first <a id="bi19.2.4" class="indexterm"/><a id="fo19.2.4" class="indexterm"/>function call made by <code class="literal">StepSimulation</code> is a
        call to <code class="literal">CalcObjectForces</code>, which is responsible for
        computing all the forces on each ball except collision forces. This is the same approach
        used in previous examples. The entire <code class="literal">CalcObjectForces</code>
        source code is included here:</p><a id="I_programlisting5_id351175"/><pre class="programlisting">void CalcObjectForces(void)
{
    Vector    Fb, Mb;
    Vector    vDragVector;
    Vector    vAngularDragVector;
    int       i, j;
    Vector    ContactForce;
    Vector    pt;
    int       check = NOCOLLISION;
    pCollision    pCollisionData;
    Vector    FrictionForce;
    Vector    fDir;
    double    speed;
    Vector    FRn, FRt;

    for(i=0; i&lt;NUMBODIES; i++)
    {
        // Reset forces and moments:
        Bodies[i].vForces.x = 0.0f;
        Bodies[i].vForces.y = 0.0f;
        Bodies[i].vForces.z = 0.0f;

        Bodies[i].vMoments.x = 0.0f;
        Bodies[i].vMoments.y = 0.0f;
        Bodies[i].vMoments.z = 0.0f;

        Fb.x = 0.0f;    Mb.x = 0.0f;
        Fb.y = 0.0f;    Mb.y = 0.0f;
        Fb.z = 0.0f;    Mb.z = 0.0f;

        // Do drag force:
        vDragVector = -Bodies[i].vVelocityBody;
        vDragVector.Normalize();
        speed = Bodies[i].vVelocityBody.Magnitude();
        Fb += vDragVector * ((1.0f/2.0f)*speed * speed * rho *
            LINEARDRAGCOEFFICIENT * pow(Bodies[i].fRadius,2) *
            Bodies[i].fRadius*pi);

        vAngularDragVector = -Bodies[i].vAngularVelocity;
        vAngularDragVector.Normalize();
        Mb += vAngularDragVector * (Bodies[i].vAngularVelocity.Magnitude() *
            Bodies[i].vAngularVelocity.Magnitude() * rho * ANGULARDRAGCOEFFICIENT
            * 4 * pow(Bodies[i].fRadius,2)*pi);

        // Convert forces from model space to earth space:
        Bodies[i].vForces = QVRotate(Bodies[i].qOrientation, Fb);

        // Apply gravity:
        Bodies[i].vForces.z += GRAVITY * Bodies[i].fMass;

        // Save the moments:
        Bodies[i].vMoments += Mb;

        // Handle contacts with ground plane:
        Bodies[i].vAcceleration = Bodies[i].vForces / Bodies[i].fMass;
        Bodies[i].vAngularAcceleration = Bodies[i].mInertiaInverse *
                                    (Bodies[i].vMoments -
                                    (Bodies[i].vAngularVelocity^
                                    (Bodies[i].mInertia *
                                     Bodies[i].vAngularVelocity)));


        // Resolve ground plane contacts:
        FlushCollisionData();
        pCollisionData = Collisions;
        NumCollisions = 0;
        if(DOCONTACT)
            check = CheckGroundPlaneContacts(pCollisionData, i);
        if((check == CONTACT) &amp;&amp; DOCONTACT)
        {    j = 0;
            {
                assert(NumCollisions &lt;= 1);

                ContactForce = (Bodies[i].fMass * (-Bodies[i].vAcceleration *
                            Collisions[j].vCollisionNormal)) *
                            Collisions[j].vCollisionNormal;

                if(DOFRICTION)
                {
                    double vt = fabs(Collisions[j].vRelativeVelocity *
                            Collisions[j].vCollisionTangent);
                    if(vt &gt; VELOCITYTOLERANCE)
                    {
                        // Kinetic:
                        FrictionForce = (ContactForce.Magnitude() *
                                    FRICTIONCOEFFICIENTGROUND) *
                                    Collisions[j].vCollisionTangent;
                    } else {
                        // Static:
                        FrictionForce = (ContactForce.Magnitude() *
                                    FRICTIONCOEFFICIENTGROUND * 2 *
                                    vt/VELOCITYTOLERANCE) *
                                    Collisions[j].vCollisionTangent;
                    }

                } else
                    FrictionForce.x = FrictionForce.y = FrictionForce.z = 0;

                // Do rolling resistance:
                if(Bodies[i].vAngularVelocity.Magnitude() &gt; VELOCITYTOLERANCE)
                {
                    FRn = ContactForce.Magnitude() *
                          Collisions[j].vCollisionNormal;
                    Collisions[j].vCollisionTangent.Normalize();
                    Vector m = (Collisions[j].vCollisionTangent
                                *(ROLLINGRESISTANCECOEFFICIENT *
                                Bodies[i].fRadius))^FRn;
                    double mag = m.Magnitude();
                    Vector a = Bodies[i].vAngularVelocity;
                    a.Normalize();
                    Bodies[i].vMoments += -a * mag;
                }

                // accumlate contact and friction forces and moments
                Bodies[i].vForces += ContactForce;
                Bodies[i].vForces += FrictionForce;

                ContactForce = QVRotate(~Bodies[i].qOrientation, ContactForce);
                FrictionForce = QVRotate(~Bodies[i].qOrientation,
                                   FrictionForce);
                pt = Collisions[j].vCollisionPoint - Bodies[i].vPosition;
                pt = QVRotate(~Bodies[i].qOrientation, pt);
                Bodies[i].vMoments += pt^ContactForce;
                Bodies[i].vMoments += pt^FrictionForce;

            }
        }

    }
}</pre><p>As you can see, upon entering <code class="literal">CalcObjectForces</code> the
        code enters a loop that cycles through all the billiard ball objects, computing the forces
        acting on each. The first force computed is simple <a id="I_indexterm5_id351232" class="indexterm"/>aerodynamic drag. Both linear and angular drag are computed. We compute the
        magnitude of the linear drag by multiplying the linear drag coefficient by
          1/2ρ<span class="emphasis"><em>V</em></span>2<span class="emphasis"><em>r</em></span>2π<span class="emphasis"><em>r</em></span>, where ρ is the
        density of air, <span class="emphasis"><em>V</em></span> is the ball’s linear speed, and
          <span class="emphasis"><em>r</em></span> is the ball’s radius. We compute the magnitude of the angular drag
        moment by multiplying the angular drag coefficient by ωρ4<span class="emphasis"><em>r</em></span>2π, where ω
        is angular speed. Since drag retards motion, the linear drag and angular drag vectors are
        simply the opposite of the linear and angular velocity vectors, respectively. Normalizing
        those vectors and then multiplying by the respective drag magnitudes yields the linear and
        angular drag force and moment vectors.</p><p>The next set of forces calculated in <code class="literal">CalcObjectForces</code>
        is the <a id="I_indexterm5_id351282" class="indexterm"/>contact forces between the table top and each ball. There are three contact
        forces. One is the vertical force that keeps the balls from falling through the table,
        another is the friction force that arises as the balls slide along the table, and the third
        is rolling resistance. These forces arise only if the ball is in contact with the table.
        We’ll address how to determine whether a ball is in contact with the table later in this
        chapter. For now, we’ll assume there’s contact and show you how to compute the contact
        forces.</p><p>To compute the vertical force<a id="I_indexterm5_id351305" class="indexterm"/> required to keep the ball from falling through the table, we must first compute
        the ball’s linear acceleration<a id="I_indexterm5_id351313" class="indexterm"/><a id="I_indexterm5_id351325" class="indexterm"/>, which is equal to the sum of forces (excluding contact forces) acting on the
        ball divided by the ball’s mass. Next, we take the negative dot product of that acceleration
        and the vector perpendicular to the table surface and multiply the result by the ball’s
        mass. This yields the magnitude of the contact force, and to get the vector we multiply that
        magnitude by the unit vector perpendicular to the table’s surface. The following two lines
        of code perform these calculations:</p><a id="I_programlisting5_id351342"/><pre class="programlisting">Bodies[i].vAcceleration = Bodies[i].vForces / Bodies[i].fMass;

ContactForce = (Bodies[i].fMass * (-Bodies[i].vAcceleration *
                            Collisions[j].vCollisionNormal)) *
                            Collisions[j].vCollisionNormal;</pre><p>The <code class="literal">vCollisionNormal</code> vector is determined by <code class="literal">CheckGroundPlaneContacts</code>, which we’ll cover later. As with
        collisions, <code class="literal">CheckGroundPlaneContacts</code> fills in a data
        structure containing the point of contact, relative velocity between the ball and table at
        the point of contact, and the contact normal and tangent vectors, among other data.</p><p>To compute the <a id="I_indexterm5_id351376" class="indexterm"/><a id="I_indexterm5_id351383" class="indexterm"/>sliding friction force, we must first determine the tangential component of the
        relative velocity between the ball and table. If the ball is sliding or slipping as it
        rolls, then the relative tangential velocity will be greater than 0. If the ball is rolling
        without sliding, then the relative velocity will be 0. In either case, there will be a
        friction force; in the former case, we’ll use the kinetic friction coefficient, and in the
        latter we’ll use the static friction coefficient. Friction force is computed in the same way
        we showed you in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>. The following lines of code perform all these
        calculations:</p><a id="I_programlisting5_id351407"/><pre class="programlisting">                ContactForce = (Bodies[i].fMass * (-Bodies[i].vAcceleration *
                            Collisions[j].vCollisionNormal)) *
                            Collisions[j].vCollisionNormal;

                double vt = fabs(Collisions[j].vRelativeVelocity *
                            Collisions[j].vCollisionTangent);
                if(vt &gt; VELOCITYTOLERANCE)
                {
                    // Kinetic:
                    FrictionForce = (ContactForce.Magnitude() *
                                FRICTIONCOEFFICIENTGROUND) *
                                Collisions[j].vCollisionTangent;
                } else {
                    // Static:
                    FrictionForce = (ContactForce.Magnitude() *
                                FRICTIONCOEFFICIENTGROUND * 2 *
                                vt/VELOCITYTOLERANCE) *
                                Collisions[j].vCollisionTangent;
                }</pre><p>Keep in mind that these forces will create moments if they do not act through the ball’s
        center of gravity. So, after computing and aggregating these forces, you must also resolve
        any moments created and aggregate those using the same formulas we’ve shown through this
        book. The following lines of code take care of these tasks:</p><a id="I_programlisting5_id351428"/><pre class="programlisting">                // accumlate contact and friction forces and moments
                Bodies[i].vForces += ContactForce;
                Bodies[i].vForces += FrictionForce;

                ContactForce = QVRotate(~Bodies[i].qOrientation, ContactForce);
                FrictionForce = QVRotate(~Bodies[i].qOrientation,
                                FrictionForce);
                pt = Collisions[j].vCollisionPoint - Bodies[i].vPosition;
                pt = QVRotate(~Bodies[i].qOrientation, pt);
                Bodies[i].vMoments += pt^ContactForce;
                Bodies[i].vMoments += pt^FrictionForce;</pre><p>Rolling resistance <a id="I_indexterm5_id351441" class="indexterm"/><a id="I_indexterm5_id351447" class="indexterm"/>arises by virtue of small deformations in the cloth-covered table creating a
        little divot that the ball must overcome as it rolls. This divot shifts the center of
        application of the contact force just a little bit in the direction of rolling. That small
        offset results in a moment when multiplied by the contact force. The resulting moment
        opposes rolling; otherwise, without some other resistance the ball would continue rolling
        unrealistically. The following code <a id="I_indexterm5_id351463" class="indexterm"/><a id="I_indexterm5_id351472" class="indexterm"/>computes the rolling resistance:</p><a id="I_programlisting5_id351484"/><pre class="programlisting">                // Do rolling resistance:
                if(Bodies[i].vAngularVelocity.Magnitude() &gt; VELOCITYTOLERANCE)
                {
                    FRn = ContactForce.Magnitude() *
                          Collisions[j].vCollisionNormal;
                    Collisions[j].vCollisionTangent.Normalize();
                    Vector m = (Collisions[j].vCollisionTangent
                                *(ROLLINGRESISTANCECOEFFICIENT *
                                Bodies[i].fRadius))^FRn;
                    double mag = m.Magnitude();
                    Vector a = Bodies[i].vAngularVelocity;
                    a.Normalize();
                    Bodies[i].vMoments += -a * mag;
                }</pre></div><div class="sect2" title="Handling Collisions"><div class="titlepage"><div><div><h3 class="title" id="handling_collisions">Handling Collisions</h3></div></div></div><p>Earlier you <a id="bi19.2.5" class="indexterm"/><a id="cr19.2.5" class="indexterm"/><a id="cd19.2.5" class="indexterm"/><a id="co19.2.5" class="indexterm"/>saw where <code class="literal">StepSimulation</code> makes a few function
        calls to deal with collision checking and response. You also saw where <code class="literal">CalcObjectForces</code> makes a function call that checks for contacts.
        The functions that check for collisions or contacts make use of the <code class="literal">Collisions</code> array we showed you earlier. This array stores all the relevant
        information pertaining to collisions or contacts—the collision or contact manifold, <a id="I_indexterm5_id351590" class="indexterm"/>normal and tangent vectors, relative velocity, etc.</p><p>The first function we’ll consider is <code class="literal">CheckForCollisions</code>, which is called toward the end of <code class="literal">StepSimulation</code>. <code class="literal">CheckForCollisions</code> checks
        for ball-ball collisions; we have a separate function to check for ball-table collisions
        that we’ll get to later. <code class="literal">CheckForCollisions</code> relies on
        concepts we’ve already discussed and showed you in earlier chapters, so we’ll summarize its
        action here. Basically, two billiard balls are colliding if 1) they are headed toward each
        other, and 2) the distance separating their centers is less than or equal to the sum of
        their radii. If both of these criteria are met, then a collision is recorded and all
        relevant data is stored in the <code class="literal">Collisions</code> array:</p><a id="I_programlisting5_id351636"/><pre class="programlisting">int    CheckForCollisions(void)
{
    int         status = NOCOLLISION;
    int         i, j;
    Vector      d;
    pCollision  pCollisionData;
    int         check = NOCOLLISION;
    float       r;
    float       s;
    Vector      tmp;

    FlushCollisionData();
    pCollisionData = Collisions;
    NumCollisions = 0;

    // check object collisions with each other
    for(i=0; i&lt;NUMBODIES; i++)
    {
        for(j=0; j&lt;NUMBODIES; j++)
            if((j!=i) &amp;&amp; !CollisionRecordedAlready(i, j))
            {
                // do a bounding sphere check
                d = Bodies[i].vPosition - Bodies[j].vPosition;
                r = Bodies[i].fRadius + Bodies[j].fRadius;
                s = d.Magnitude() - r;
                if(s &lt; COLLISIONTOLERANCE)
                {// possible collision
                    Vector   pt1, pt2, vel1, vel2, n, Vr;
                    float    Vrn;

                    pt1 = (Bodies[i].vPosition + Bodies[j].vPosition)/2;
                    tmp = pt2 = pt1;

                    pt1 = pt1-Bodies[i].vPosition;
                    pt2 = pt2-Bodies[j].vPosition;

                    vel1 = Bodies[i].vVelocity +
                           (Bodies[i].vAngularVelocityGlobal^pt1);
                    vel2 = Bodies[j].vVelocity +
                           (Bodies[j].vAngularVelocityGlobal^pt2);

                    n = d;
                    n.Normalize();

                    Vr = (vel1 - vel2);
                    Vrn = Vr * n;

                    if(Vrn &lt; -VELOCITYTOLERANCE)
                    {
                        // Have a collision so fill the data structure
                        assert(NumCollisions &lt; (NUMBODIES*8));
                        if(NumCollisions &lt; (NUMBODIES*8))
                        {
                            pCollisionData-&gt;body1 = i;
                            pCollisionData-&gt;body2 = j;
                            pCollisionData-&gt;vCollisionNormal = n;
                            pCollisionData-&gt;vCollisionPoint = tmp;
                            pCollisionData-&gt;vRelativeVelocity = Vr;
                            pCollisionData-&gt;vCollisionTangent = (n^Vr)^n;
                            pCollisionData-&gt;vCollisionTangent.Normalize();

                            pCollisionData++;
                            NumCollisions++;
                            status = COLLISION;
                        }                                                }
                }
            }
    }

    for(i=0; i&lt;NUMBODIES; i++)
        {
            check = NOCOLLISION;

            assert(NumCollisions &lt; (NUMBODIES*8));
            check = CheckGroundPlaneCollisions(pCollisionData, i);
            if(check == COLLISION)
            {
                status = COLLISION;
                pCollisionData++;
                NumCollisions++;
            }
        }

    return status;
}</pre><p>Since <code class="literal">CheckForCollisions</code> loops through all of the
        balls checking for collisions with every other ball, it is possible that a collision would
        be recorded twice. For example, the <span class="emphasis"><em>i</em></span>th ball may be found to be
        colliding with the <span class="emphasis"><em>j</em></span>th ball, and later the <span class="emphasis"><em>j</em></span>th
        ball would also be found to be colliding with the <span class="emphasis"><em>i</em></span>th ball. We don’t
        want to record that information twice, so we use the following function to check if a
        collision between two particular balls is already recorded. If so, we skip re-recording the
        data:</p><a id="I_programlisting5_id351695"/><pre class="programlisting">bool CollisionRecordedAlready(int i, int j)
{
    int k;
    int b1, b2;

    for(k=0; k&lt;NumCollisions; k++)
    {
        b1 = Collisions[k].body1;
        b2 = Collisions[k].body2;

        if( ((b1 == i) &amp;&amp; (b2 == j)) ||
            ((b1 == j) &amp;&amp; (b2 == i)) )
            return true;
    }

    return false;
}</pre><p>Checking ball-table collisions is fairly straightforward as well. If 1) a ball is found
        to be headed toward the table with some velocity greater than 0 (or some small threshold),
        and 2) the ball’s vertical position to its center is less than or equal to its radius, then
        we record a collision. <code class="literal">CheckGroundPlaneCollisions</code> handles
        this for us:</p><a id="I_programlisting5_id351715"/><pre class="programlisting">int    CheckGroundPlaneCollisions(pCollision CollisionData, int body1)
{
    Vector    tmp;
    Vector    vel1;
    Vector    pt1;
    Vector    Vr;
    float     Vrn;
    Vector    n;
    int       status = NOCOLLISION;

    if(Bodies[body1].vPosition.z &lt;= (Bodies[body1].fRadius))
    {
        pt1 = Bodies[body1].vPosition;
        pt1.z = COLLISIONTOLERANCE;
        tmp = pt1;
        pt1 = pt1-Bodies[body1].vPosition;
        vel1 = Bodies[body1].vVelocity/*Body*/ +
               (Bodies[body1].vAngularVelocityGlobal^pt1);

        n.x = 0;
        n.y = 0;
        n.z = 1;

        Vr = vel1;
        Vrn = Vr * n;

        if(Vrn &lt; -VELOCITYTOLERANCE)
        {
            // Have a collision so fill the data structure
            assert(NumCollisions &lt; (NUMBODIES*8));
            if(NumCollisions &lt; (NUMBODIES*8))
            {
                CollisionData-&gt;body1 = body1;
                CollisionData-&gt;body2 = −1;
                CollisionData-&gt;vCollisionNormal = n;
                CollisionData-&gt;vCollisionPoint = tmp;
                CollisionData-&gt;vRelativeVelocity = Vr;

                CollisionData-&gt;vCollisionTangent = (n^Vr)^n;
                CollisionData-&gt;vCollisionTangent.Reverse();

                CollisionData-&gt;vCollisionTangent.Normalize();
                status = COLLISION;
            }
        }
    }

    return status;
}</pre><p>Resolving collisions, whether ball-ball or ball-table collisions, uses the same approach
        we’ve already shown you. Thus, we won’t go over the code again, and will instead just show
        you the function that implements collision response:</p><a id="I_programlisting5_id351737"/><pre class="programlisting">void ResolveCollisions(void)
{
    int       i;
    double    j;
    Vector    pt1, pt2, vB1V, vB2V, vB1AV, vB2AV;
    float     fCr = COEFFICIENTOFRESTITUTION;
    int       b1, b2;
    float     Vrt;
    float     muB = FRICTIONCOEFFICIENTBALLS;
    float     muG = FRICTIONCOEFFICIENTGROUND;
    bool      dofriction = DOFRICTION;

    for(i=0; i&lt;NumCollisions; i++)
    {
        b1 = Collisions[i].body1;
        b2 = Collisions[i].body2;

        if( (b1 != −1) &amp;&amp; (b1 != b2) )
        {
            if(b2 != −1) // not ground plane
            {
                pt1 = Collisions[i].vCollisionPoint - Bodies[b1].vPosition;
                pt2 = Collisions[i].vCollisionPoint - Bodies[b2].vPosition;

                // Calculate impulse:
                j = (-(1+fCr) * (Collisions[i].vRelativeVelocity *
                    Collisions[i].vCollisionNormal)) /
                    ((1/Bodies[b1].fMass + 1/Bodies[b2].fMass) +
                    (Collisions[i].vCollisionNormal * ( ( (pt1 ^
                     Collisions[i].vCollisionNormal) *
                     Bodies[b1].mIeInverse )^pt1) ) +
                    (Collisions[i].vCollisionNormal * ( ( (pt2 ^
                     Collisions[i].vCollisionNormal) *
                     Bodies[b2].mIeInverse )^pt2) ) );

                Vrt = Collisions[i].vRelativeVelocity *
                      Collisions[i].vCollisionTangent;

                if(fabs(Vrt) &gt; 0.0 &amp;&amp; dofriction) {
                    Bodies[b1].vVelocity +=
                            ((j * Collisions[i].vCollisionNormal) +
                            ((muB * j) * Collisions[i].vCollisionTangent)) /
                            Bodies[b1].fMass;
                    Bodies[b1].vAngularVelocityGlobal +=
                            (pt1 ^ ((j * Collisions[i].vCollisionNormal) +
                            ((muB * j) * Collisions[i].vCollisionTangent))) *
                            Bodies[b1].mIeInverse;
                    Bodies[b1].vAngularVelocity =
                            QVRotate(~Bodies[b1].qOrientation,
                            Bodies[b1].vAngularVelocityGlobal);

                    Bodies[b2].vVelocity +=
                            ((-j * Collisions[i].vCollisionNormal) + ((muB *
                            j) * Collisions[i].vCollisionTangent)) /
                            Bodies[b2].fMass;
                    Bodies[b2].vAngularVelocityGlobal +=
                            (pt2 ^ ((-j * Collisions[i].vCollisionNormal) +
                            ((muB * j) * Collisions[i].vCollisionTangent)))
                            * Bodies[b2].mIeInverse;

                    Bodies[b2].vAngularVelocity =
                            QVRotate(~Bodies[b2].qOrientation,
                            Bodies[b2].vAngularVelocityGlobal);

                } else {
                    // Apply impulse:
                    Bodies[b1].vVelocity +=
                            (j * Collisions[i].vCollisionNormal) /
                            Bodies[b1].fMass;
                    Bodies[b1].vAngularVelocityGlobal +=
                            (pt1 ^ (j * Collisions[i].vCollisionNormal)) *
                            Bodies[b1].mIeInverse;
                    Bodies[b1].vAngularVelocity =
                            QVRotate(~Bodies[b1].qOrientation,
                            Bodies[b1].vAngularVelocityGlobal);

                    Bodies[b2].vVelocity -=
                            (j * Collisions[i].vCollisionNormal) /
                            Bodies[b2].fMass;
                    Bodies[b2].vAngularVelocityGlobal -=
                            (pt2 ^ (j * Collisions[i].vCollisionNormal)) *
                            Bodies[b2].mIeInverse;
                    Bodies[b2].vAngularVelocity =
                            QVRotate(~Bodies[b2].qOrientation,
                            Bodies[b2].vAngularVelocityGlobal);
                }

            } else { // Ground plane:
                fCr = COEFFICIENTOFRESTITUTIONGROUND;
                pt1 = Collisions[i].vCollisionPoint - Bodies[b1].vPosition;

                // Calculate impulse:
                j = (-(1+fCr) * (Collisions[i].vRelativeVelocity *
                    Collisions[i].vCollisionNormal)) /
                    ( (1/Bodies[b1].fMass) +
                    (Collisions[i].vCollisionNormal *
                    ( ( (pt1 ^ Collisions[i].vCollisionNormal) *
                    Bodies[b1].mIeInverse )^pt1)));

                Vrt = Collisions[i].vRelativeVelocity *
                     Collisions[i].vCollisionTangent;

                if(fabs(Vrt) &gt; 0.0 &amp;&amp; dofriction) {
                    Bodies[b1].vVelocity +=
                            ( (j * Collisions[i].vCollisionNormal) + ((muG *
                            j) * Collisions[i].vCollisionTangent) ) /
                            Bodies[b1].fMass;
                    Bodies[b1].vAngularVelocityGlobal +=
                            (pt1 ^ ((j * Collisions[i].vCollisionNormal) +
                            ((muG * j) * Collisions[i].vCollisionTangent))) *
                            Bodies[b1].mIeInverse;
                    Bodies[b1].vAngularVelocity =
                            QVRotate(~Bodies[b1].qOrientation,
                            Bodies[b1].vAngularVelocityGlobal);
                } else {
                    // Apply impulse:
                    Bodies[b1].vVelocity +=
                            (j * Collisions[i].vCollisionNormal) /
                            Bodies[b1].fMass;
                    Bodies[b1].vAngularVelocityGlobal +=
                            (pt1 ^ (j * Collisions[i].vCollisionNormal)) *
                            Bodies[b1].mIeInverse;
                    Bodies[b1].vAngularVelocity =
                            QVRotate(~Bodies[b1].qOrientation,
                            Bodies[b1].vAngularVelocityGlobal);
                }
            }
        }
    }
}</pre><p>The final function we need to show you is <code class="literal">CheckGroundPlaneContacts</code>. Recall that this function is called from <code class="literal">CalcObjectForces</code> in order to determine if a ball is in resting
        contact with the table. If the ball’s vertical position is less than or equal to its radius
        plus some small tolerance, and if the ball’s vertical velocity is 0 (or nearly so within
        some small tolerance), then we consider the ball in contact with the table. If there’s a
        contact, the relevant data gets stored in the <code class="literal">Collisions</code>
        array and used to resolve the contact, not the collision, in <code class="literal">CalcObjectForces</code>:</p><a id="I_programlisting5_id351825"/><pre class="programlisting">int    CheckGroundPlaneContacts(pCollision CollisionData, int body1)
{

    Vector    v1[8];
    Vector    tmp;
    Vector    u, v;
    Vector    f[4];
    Vector    vel1;
    Vector    pt1;
    Vector    Vr;
    float     Vrn;
    Vector    n;
    int       status = NOCOLLISION;
    Vector    Ar;
    float     Arn;

    if(Bodies[body1].vPosition.z &lt;= (Bodies[body1].fRadius + COLLISIONTOLERANCE))
    {
        pt1 = Bodies[body1].vPosition;
        pt1.z = COLLISIONTOLERANCE;
        tmp = pt1;
        pt1 = pt1-Bodies[body1].vPosition;
        vel1 = Bodies[body1].vVelocity/*Body*/ +
              (Bodies[body1].vAngularVelocityGlobal^pt1);

        n.x = 0;
        n.y = 0;
        n.z = 1;

        Vr = vel1;
        Vrn = Vr * n;

        if(fabs(Vrn) &lt;= VELOCITYTOLERANCE) // at rest
        {
            // Check the relative acceleration:
            Ar = Bodies[body1].vAcceleration +
                (Bodies[body1].vAngularVelocityGlobal ^
                (Bodies[body1].vAngularVelocityGlobal^pt1)) +
                (Bodies[body1].vAngularAccelerationGlobal ^ pt1);

            Arn = Ar * n;

            if(Arn &lt;= 0.0f)
            {
                // We have a contact so fill the data structure
                assert(NumCollisions &lt; (NUMBODIES*8));
                if(NumCollisions &lt; (NUMBODIES*8))
                {
                    CollisionData-&gt;body1 = body1;
                    CollisionData-&gt;body2 = −1;
                    CollisionData-&gt;vCollisionNormal = n;
                    CollisionData-&gt;vCollisionPoint = tmp;
                    CollisionData-&gt;vRelativeVelocity = Vr;
                    CollisionData-&gt;vRelativeAcceleration = Ar;

                    CollisionData-&gt;vCollisionTangent = (n^Vr)^n;
                    CollisionData-&gt;vCollisionTangent.Reverse();

                    CollisionData-&gt;vCollisionTangent.Normalize();
                    CollisionData++;
                    NumCollisions++;
                    status = CONTACT;
                }
            }
        }
    }

    return status;
}</pre><p>That’s all there is to this billiards example. As you can see, we used substantially the
        same methods shown in other examples throughout this book to implement this example. About
        the only new information we’ve shown here is how to compute rolling resistance. With a
        little effort, you can combine the material presented in this example with the projectile
        motion material presented in <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6</a> to model all sorts of sports
        balls. Whether you’re modeling a billiard ball bouncing off a table or a basketball bouncing
        off a backboard, the methods are the same. The only things that will change are the
        empirical coefficients you use to model each ball and surface. Have <a id="I_indexterm5_id351860" class="indexterm"/><a id="I_indexterm5_id351871" class="indexterm"/><a id="I_indexterm5_id351880" class="indexterm"/><a id="I_indexterm5_id351889" class="indexterm"/><a id="I_indexterm5_id351899" class="indexterm"/>fun.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 20. Touch Screens</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="pt04.html" title="Part IV. Digital Physics"/><link rel="next" href="ch21.html" title="Chapter 21. Accelerometers"/></head><body><section class="chapter" title="Chapter 20. Touch Screens" epub:type="chapter" id="touch_screens"><div class="titlepage"><div><div><h2 class="title">Chapter 20. Touch Screens</h2></div></div></div><p>It is hard to deny that we are <a id="I_indexterm1_id351946" class="indexterm"/>currently moving toward a post-PC computing environment. The
  proliferation of smartphones, tablets, and other mobile computing platforms
  will have far-reaching implications for how people interact with computers.
  These form factors do not allow for the more traditional mouse and keyboard
  of input for games and therefore rely heavily on the use of touch screens.
  This chapter aims to give you some background on the different types of
  touch screens, how they work, and their technical limitations. Note that we
  will extend our particle simulator to work with the iPhone’s capacitive
  touch screen; the final product is very similar to the mouse-driven version
  but provides a starting point for a touch-driven physics simulator.</p><p>While this chapter will primarily deal with the most two most common
  types of touch-sensitive screens, <span class="emphasis"><em>resistive</em></span> and
  <span class="emphasis"><em>capacitive</em></span>, the following section gives an overview of
  many different types. In the future we may see a move to more exotic
  devices, especially for large-format computing devices.</p><div class="sect1" title="Types of Touch Screens"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="types_of_touch_screens">Types of Touch Screens</h2></div></div></div><div class="sect2" title="Resistive"><div class="titlepage"><div><div><h3 class="title" id="resistive">Resistive</h3></div></div></div><p>Resistive <a id="I_indexterm1_id351999" class="indexterm"/><a id="I_indexterm1_id352010" class="indexterm"/>touch screens are basically a giant network of tiny
      buttons. Some of them have 4,096 × 4,096 buttons in a single square
      inch! OK, so they are not quite just normal buttons, but they come
      close. Resistive touch screens have at least two layers of conductors
      with an air gap between them. As you press on the screen, you close the
      gap. Bam, circuit complete, button pressed. We will flesh out that
      simplified description shortly.</p></div><div class="sect2" title="Capacitive"><div class="titlepage"><div><div><h3 class="title" id="capacitive">Capacitive</h3></div></div></div><p>Also a topic we’ll <a id="I_indexterm1_id352035" class="indexterm"/>soon discuss in detail, capacitive touch screens are very
      common on today’s smartphones. These touch screens operate by
      calculating the change in electrical capacitance at the four corners of
      the screen when your finger influences the capacitive nature of the
      circuits under the glass. The limitation is that whatever touches the
      screen must be electrically conductive. If you insulate your fingers
      with gloves, the screen will no longer be able to locate your touch.
      However, this can be solved with a few stitches of conductive
      thread.</p></div><div class="sect2" title="Infrared and Optical Imaging"><div class="titlepage"><div><div><h3 class="title" id="infrared_and_optical_imaging">Infrared and Optical Imaging</h3></div></div></div><p>Infrared touch <a id="I_indexterm1_id352060" class="indexterm"/>screens use arrays of infrared <a id="I_indexterm1_id352068" class="indexterm"/>LED <a id="I_indexterm1_id352075" class="indexterm"/>and photodetectors to detect and interpret an object
      breaking the path of a LED-photodetector pair. This uses line-scanning
      techniques and is a very robust design.</p><p>Optical imaging <a id="I_indexterm1_id352087" class="indexterm"/>techniques are relative newcomers to the touch screen
      scene whose big advantage is that they are extremely scalable. They use
      imaging devices and light sources to detect where the screen is being
      touched by interpreting any shadows cast by an object through the
      thickness of the material.</p></div><div class="sect2" title="Exotic: Dispersive Signal and Surface Acoustic Wave"><div class="titlepage"><div><div><h3 class="title" id="exotic_colon_dispersive_signal_and_surfa">Exotic: Dispersive Signal and Surface Acoustic Wave</h3></div></div></div><p>Several other <a id="I_indexterm1_id352111" class="indexterm"/>exotic touch screen technologies exist. We won’t get into
      detail here, but 3M has a system that detects <a id="I_indexterm1_id352120" class="indexterm"/>mechanical energy in glass caused by a touch. The amount
      of <a id="I_indexterm1_id352128" class="indexterm"/>vibration energy that reaches each sensor determines the
      position.</p><p>Another example of exotic screen input, <a id="I_indexterm1_id352139" class="indexterm"/>surface acoustic wave technology detects changes in the
      pattern of ultrasonic waves traveling along the surface of the
      screen.</p></div></div><div class="sect1" title="Step-by-Step Physics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="step-by-step_physics">Step-by-Step Physics</h2></div></div></div><div class="sect2" title="Resistive Touch Screens"><div class="titlepage"><div><div><h3 class="title" id="resistive_touch_screens">Resistive Touch Screens</h3></div></div></div><p>Resistive touch screens <a id="to20.2.1" class="indexterm"/><a id="re20.2.1" class="indexterm"/>are classified as a <span class="emphasis"><em>passive</em></span> touch screen technology because
        the screen registers a touch without any active participation by the object touching the
        screen. This is their major benefit over <span class="emphasis"><em>active</em></span> technologies, such as
        capacitive touch screens, as resistive screens can be activated by nonconductive objects
        like a pen or gloved finger. In the past, resistive screens were limited to a single input,
        and that’s the type we’ll describe, but they can be made to work with two or more
        simultaneous inputs, also known as multitouch.</p><div class="sect3" title="One-dimensional resistive touch sensor"><div class="titlepage"><div><div><h4 class="title" id="one-dimensional_resistive_touch_sensor">One-dimensional resistive touch sensor</h4></div></div></div><p>To ease ourselves into this discussion, we will begin by looking
        at a one-dimensional touch screen. Let’s imagine we have built the
        machine described in <a class="xref" href="ch20.html#linear_resistive_touch_sensor" title="Figure 20-1. Linear resistive touch sensor">Figure 20-1</a>.</p><div class="figure"><a id="linear_resistive_touch_sensor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id352246"/><img src="httpatomoreillycomsourceoreillyimages1598994.png" alt="Linear resistive touch sensor"/></div></div><div class="figure-title">Figure 20-1. Linear resistive touch sensor</div></div><p>As you can see, our sensor has two states, an <span class="emphasis"><em>open circuit state</em></span>
          and a <span class="emphasis"><em>closed circuit state</em></span>. In the open circuit state, the controller
          is supplying a 5V signal to pin 2 and waiting for any return voltage on pin 1. With no
          touch to bring the wires together, the circuit is open. No voltage is present at pin 1,
          and therefore no touch is sensed. When the wires are touched, they are brought together
          and the circuit is closed. A voltage will then be present at pin 1. A touch event is
          registered.</p><p>This type of sensor, which looks only for the presence or
        absence of voltage without regard to its value, is called a
        <span class="emphasis"><em>digital sensor</em></span>. It can detect only two states: on
        or off (1 or 0, respectively). OK, so it’s not quite a touch screen
        yet; essentially at this point all we have is a simple button. Moving
        forward, let’s say that we not only want to trigger an event when we
        press our button, but we also want to simultaneously input a value
        based on the location along the wire, <span class="emphasis"><em>L</em></span>, that we
        pressed.</p><p>To accomplish this, the controller patiently waits for a voltage at pin 1. When it
          senses a voltage, that digital “on” switch causes the controller to then probe the voltage
          that is present, which we have labeled <span class="emphasis"><em>V</em></span><sub>X</sub>. Now
          we get to the reason it is called a <span class="emphasis"><em>resistive</em></span> touch sensor. Current,
          voltage, and resistance are all interrelated by Ohm’s law. This physical relationship is
          expressed as:</p><table style="border: 0; " class="simplelist"><tr><td>V = IR</td></tr></table><p>Where <span class="emphasis"><em>V</em></span> is voltage, <span class="emphasis"><em>I</em></span>
        is current, and <span class="emphasis"><em>R</em></span> is resistance. The exact
        physical meaning of each of these is less important right now than how
        they are related, so don’t get too worried if you can’t recall their
        definitions. In the case of our circuit, <span class="emphasis"><em>I</em></span>, or
        current, is going to be constant. As the controller measures the
        voltage, <span class="emphasis"><em>V</em></span>, at pin 1, we can now solve for
        resistance:</p><table style="border: 0; " class="simplelist"><tr><td>R = V/I</td></tr></table><p>With our constant current, <span class="emphasis"><em>I</em></span>, and our known
        voltage, <span class="emphasis"><em>V</em></span><sub>X</sub>, we can
        calculate the resistance of the circuit by inputting (5 –
        <span class="emphasis"><em>V</em></span><sub>X</sub>) for
        <span class="emphasis"><em>V</em></span> as follows:</p><table style="border: 0; " class="simplelist"><tr><td>R = (5 – <span class="emphasis"><em>V</em></span><sub>X</sub>) / I
          (1)</td></tr></table><p>Note that we have to have the change in voltage across our
        resistor (the wire), so be sure to use the difference between the two
        values. Every conductor has an inherent internal resistance, and
        through testing we can determine what the resistance is, measured in
        ohms per unit length, and use that to determine our total resistance
        described by:</p><table style="border: 0; " class="simplelist"><tr><td>R = 2rL</td></tr></table><p>where <span class="emphasis"><em>r</em></span> is the aforementioned ohms per unit
        length and <span class="emphasis"><em>R</em></span> is the total resistance of our
        circuit. Note that we have multiplied <span class="emphasis"><em>L</em></span> by 2 to
        account for both the wire run to the point of contact and back. If we
        substitute this for <span class="emphasis"><em>R</em></span> in our earlier equation, we
        now have:</p><table style="border: 0; " class="simplelist"><tr><td>2rL = (5 – <span class="emphasis"><em>V</em></span><sub>X</sub>) /
          I</td></tr></table><p>And finally:</p><table style="border: 0; " class="simplelist"><tr><td>L = (5 – <span class="emphasis"><em>V</em></span><sub>X</sub>) /
          (2rI)</td></tr></table><p>where <span class="emphasis"><em>L</em></span> is the only unknown. To illustrate,
        let us assume the measured voltage is 4.95V and the wires are 24-gauge
        copper wires. A quick look in a standard electrical engineering book
        gives the resistance as 0.08422 ohms per meter. When we designed our
        constant current source, let’s say we picked 50 milliamps:</p><table style="border: 0; " class="simplelist"><tr><td>L = (5 – 4.95V) / ((2)(.08422 ohms/meter)(.05A))</td></tr><tr><td>L = 5.9 meters from the controller</td></tr></table><p>As you can see, the material’s resistance per meter, the
        constant current supplied, and the sensitivity of the voltage-sensing
        circuit must all be finely tuned to ensure that the controller is
        capable of sensing touch events in the appropriate dimensions. In a
        resistive touch screen, the wires are microscopic so that the
        resistance per meter is much higher. This allows the screen to detect
        smaller distances.</p></div><div class="sect3" title="Four-wire resistive touch screen"><div class="titlepage"><div><div><h4 class="title" id="four-wire_resistive_touch_screen">Four-wire resistive touch screen</h4></div></div></div><p>With some modification, we can expand our previous model to two
        dimensions. In the four-wire touch screen, there are four basic layers
        and four wires, three of which will be used at any given time. The
        general layout is given in <a class="xref" href="ch20.html#four-wire_touch_screen" title="Figure 20-2. Four-wire touch screen">Figure 20-2</a>.
        The squares containing the <span class="emphasis"><em>X</em></span> and
        <span class="emphasis"><em>Y</em></span> wires would actually be overlapped but are
        shown skewed here for clarity.</p><div class="figure"><a id="four-wire_touch_screen"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id352536"/><img src="httpatomoreillycomsourceoreillyimages1598995.png" alt="Four-wire touch screen"/></div></div><div class="figure-title">Figure 20-2. Four-wire touch screen</div></div><p>The reason for calling it a <span class="emphasis"><em>four-wire</em></span> touch
        screen should now be obvious; however, remember that only three of the
        wires will be active at any time. The basic structure is shown in
        <a class="xref" href="ch20.html#four-wire_touch_screen_profile" title="Figure 20-3. Four-wire touch screen profile">Figure 20-3</a>.</p><div class="figure"><a id="four-wire_touch_screen_profile"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_id352580"/><img src="httpatomoreillycomsourceoreillyimages1598996.png.jpg" alt="Four-wire touch screen profile"/></div></div><div class="figure-title">Figure 20-3. Four-wire touch screen profile</div></div><p>The first layer of the screen comprises a flexible conductor
        separated by an insulating gap. Under the gap lies a solid conductor.
        When a finger presses down on the outer layer of flexible conductor,
        it crosses the gap and makes contact with the solid conductor. The
        conductors are thin layers of <span class="emphasis"><em>indium-tin oxide</em></span>
        (ITO) with silver bus bars on either end of the sheet, shown as black
        lines in <a class="xref" href="ch20.html#four-wire_touch_screen" title="Figure 20-2. Four-wire touch screen">Figure 20-2</a>.</p><p>To condense the description of its operation, we’ve outlined the
        three possible states in <a class="xref" href="ch20.html#possible_states_for_four-wire_touch_scre" title="Table 20-1. Possible states for four-wire touch screen">Table 20-1</a>.</p><div class="table"><a id="possible_states_for_four-wire_touch_scre"/><div class="table-title">Table 20-1. Possible states for four-wire touch screen</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/><col class="col5"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Activity</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pin 1</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pin 2</p></td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Pin 3</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Pin 4</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Waiting for touch
                detection</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Digital input [pull
                up]</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Ground</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read
                <span class="emphasis"><em>X</em></span> position</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Voltage
                probe</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Ground</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Voltage
                source</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Open</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Read
                <span class="emphasis"><em>Y</em></span> position</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Voltage
                source</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Open</p></td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Voltage
                probe</p></td><td style="text-align: left; vertical-align: top; "><p>Ground</p></td></tr></tbody></table></div></div><p><span class="emphasis"><em>Voltage probe</em></span> means the chip is sensing the
        voltage on that pin, <span class="emphasis"><em>voltage source</em></span> is the pin
        supplying a voltage to <span class="emphasis"><em>ground</em></span>, and
        <span class="emphasis"><em>open</em></span> means it is unused. The sequence of a touch
        event begins with pin 1 and pin 2 open. Pin 3 is configured to digital
        input with pullup signifying a voltage is supplied to the pin. When a
        finger presses on the outer layer and makes contact with the lower
        layer, pin 3 goes to ground. When the controller senses the voltage
        fall on pin 3, it moves to the second row and reads the
        <span class="emphasis"><em>X</em></span> position.</p><p>To read the <span class="emphasis"><em>X</em></span> position, the lower layer is
        energized from pin 3 to pin 2. The voltage source creates a gradient
        along the layer. Pin 1, connected to the upper layer, delivers a
        voltage to the controller when a touch pushes it down to make contact
        with the lower energized layer. The value of this voltage depends on
        where the contact is made in the gradient, much like the previous
        linear example. Once the <span class="emphasis"><em>X</em></span> position is known, the
        controller moves to the next row and reads the <span class="emphasis"><em>Y</em></span>
        position.</p><p>The method of obtaining the <span class="emphasis"><em>Y</em></span> position is
        much the same but in reverse. The voltage supply is switched to pin 1,
        which develops a voltage gradient with pin 4. Then pin 3 is probed and
        the voltage corresponds to the distance along the voltage gradient. As
        the controller is capable of repeating the detect, read
        <span class="emphasis"><em>X</em></span>, and read <span class="emphasis"><em>Y</em></span> cycles
        approximately 500 times a second, the user is not aware that the
        screen doesn’t actually register the <span class="emphasis"><em>X</em></span> and
        <span class="emphasis"><em>Y</em></span> coordinates at the same time.</p><p>While the four-wire resistive touch screen is the simplest two-dimensional touch
          sensor, there are issues with durability. The main drawback of this type of touch screen
          is that, because the layers must be separated by an insulating gap, at least one of the
          layers must be flexible. In the four-wire type, the constant flexing of the first
          conductive layer introduces microcracks in the coating, which lead to nonlinearities and
          reduce the accuracy. Other models of resistive touch screens overcome this issue with
          additional layers that remove the need for the flexible conductor. They have also been
          adapted to provide multitouch capability. We will discuss multitouch and how it works with
          capacitive touch screens in greater detail <a id="I_indexterm1_id352972" class="indexterm"/>shortly.</p></div></div><div class="sect2" title="Capacitive Touch Screens"><div class="titlepage"><div><div><h3 class="title" id="capacitive_touch_screens">Capacitive Touch Screens</h3></div></div></div><p>A capacitive screen <a id="ca20.2.2" class="indexterm"/>uses a piece of glass coated in a transparent conductor.
      When your finger or other conductor comes into contact with the screen,
      the electrostatic field is disturbed, causing a change in the
      capacitance. To understand how capacitive screens work, let’s quickly
      review capacitance in general.</p><p>A <span class="emphasis"><em>capacitor</em></span> in its simplest form is two
      conductors, usually thin plates, separated by an insulator. If you apply
      a voltage across the two conductors, a current will flow and charge will
      build up. Once the voltage across the plates is equal to the supply
      voltage, the current will stop. The amount of charge built up in the
      plates is what we measure as the capacitance. Previously, we noted that
      one issue with resistive screens is that one part must always flex to
      close a insulating gap and complete a circuit. This repetitive action
      eventually leads to mechanical failure. A capacitor can be dynamically
      formed by any two conductors separated by an insulator. Noting that
      glass is a good insulator, it is easy to see that a finger separated
      from a conductor by glass can change the capacitance of a system. In
      this way, the finger or stylus doesn’t have to cause any mechanical
      action, yet it can still effect changes to the sensors, which are then
      used to measure the location of the touch.</p><p>The methods of determining location based on capacitance on mobile
      devices are <span class="emphasis"><em>self-capacitance</em></span> and <span class="emphasis"><em>mutual
      capacitance</em></span>.</p><div class="sect3" title="Self-capacitance"><div class="titlepage"><div><div><h4 class="title" id="self-capacitance">Self-capacitance</h4></div></div></div><p>Anyone who has lived in a dry winter has felt the shock of a
        static electricity discharge. This zap is possible because the human
        body is a pretty good capacitor with a capacitance of about 22
        pico-farads. This property is known as <span class="emphasis"><em>body
        capacitance</em></span>. Self-capacitance screens take advantage of a
        physical property defined by the amount of electrical charge that must
        be added to an isolated conductor to raise its potential by one volt.
        When the fingers act as a conductor of the body’s inherent
        capacitance, the sensors on the other side of the glass experience a
        rise in electric potential. Given that the sensors are on the other
        side of a good insulator, glass, there won’t actually be any discharge
        of energy, unlike when you touch your metal car door and get “zapped.”
        Self-capacitance in this manner produces a very strong signal but
        lacks the ability to accurately resolve multiple touches. Therefore,
        it is often used in conjunction with the next type of touch screen
        we’ll discuss, mutual capacitance.</p></div><div class="sect3" title="Mutual capacitance"><div class="titlepage"><div><div><h4 class="title" id="mutual_capacitance">Mutual capacitance</h4></div></div></div><p>The other form of capacitance-sensing screen, mutual
        capacitance, is formed by a grid of independent capacitors. A probing
        charge is sent over the rows or columns. As the capacitors charge and
        discharge, the system can sense the capacitance of each individual
        capacitor. As just discussed, the body is a good capacitor, and
        bringing part of it close to the capacitor grid changes the local
        electric field. Those capacitors that are under a finger or other
        conductor will read lower values than normal. Each capacitor can be
        scanned independently, enabling high resolution of where the touch
        event is occurring. Additionally, because they act independently of
        one another, it is possible to accurately register multiple touches.
        Think of this system as taking a picture of the capacitance on the
        skin of the screen. Using algorithms similar to image processing and
        edge detection, this system can compute the extent of a touch
        <a id="I_indexterm1_id353084" class="indexterm"/><a id="I_indexterm1_id353094" class="indexterm"/>event.</p></div></div></div><div class="sect1" title="Example Program"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="example_program">Example Program</h2></div></div></div><p>Included in the <a id="to20.3" class="indexterm"/>source code accompanying this book is an example of the particle explosion program
      from <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8</a> that uses touch screen input instead of a mouse click.</p><p>The code for a <code class="literal">Cocoa touch Objective-C</code> event is as follows:</p><a id="I_programlisting1_id353150"/><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    UITouch* touch = [[event touchesForView:self] anyObject];
    firstTouch = [touch locationInView:self];
    self.status = YES;
    [self trigger];
}</pre><p>where <code class="literal">firstTouch</code> is defined by
    <code class="literal">CGPoint firstTouch;</code> in the header file.
    The <code class="literal">CGPoint</code> is a Cocoa touch object
    capable of storing an (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>)
    coordinate in the display view’s coordinate system. We can then use
    <code class="literal">firstTouch.x</code> and <code class="literal">firstTouch.y</code> later in our program to give a
    location to the particle explosion.</p><p>As you can see, it is very similar to a mouse-based event. One big
    difference is that you could adapt the code to handle multitouch events.
    Computers recognize only one mouse cursor at a time, but with a touch
    screen you can register multiple clicks simultaneously.</p><div class="sect2" title="Multitouch"><div class="titlepage"><div><div><h3 class="title" id="multitouch">Multitouch</h3></div></div></div><p>In iOS you must first enable delivery of multiple touch events by
      setting the <code class="literal">multipleTouchEnabled</code>
      property of your view to <code class="literal">YES</code>; the
      default is <code class="literal">NO</code>. Next you must create a
      class to keep track of multiple <code class="literal">TParticleExplosion</code> structures. Then it is as
      simple as polling the position of the start points of multiple touches
      to trigger multiple explosions. The Objective C code to store the start
      points of multiple touch events would look like:</p><a id="I_programlisting1_id353245"/><pre class="programlisting">- (void)storeTouchPoints:(NSSet *)touches{
    if ([touches count] &gt; 0) {
        for (UITouch *touch in touches) {
            CGPoint *point = (CGPoint                 
            *)CFDictionaryGetValue(touchBeginPoints, touch);
            if (point == NULL) {
                point = (CGPoint *)malloc(sizeof(CGPoint));
                CFDictionarySetValue(touchBeginPoints, touch, point);
            }
            *point = [touch locationInView:view.superview];
        }
    }</pre><p>where <code class="literal">CFDictionaryRef</code> is an
      immutable dictionary object that allows the copying of the object and
      its key value. One last consideration for this example is that as you
      are now creating multiple physics simulations simultaneously, you may
      have to decrease the frequency of the time steps to allow the animations
      to proceed smoothly. Multitouch can become programmatically complex, but
      the physics are pretty simple. The event-handling guide for your
      particular development language should give detailed guidance on
      handling the event <a id="I_indexterm1_id353268" class="indexterm"/>chain.</p></div></div><div class="sect1" title="Other Considerations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="other_considerations">Other Considerations</h2></div></div></div><p>One of the major advantages of touch screens is that their layout
    and actions are entirely software based. That is to say, if a certain
    button does not pertain to the current layout, it can be discarded and the
    freed space used for additional relevant controls. We will discuss other
    less obvious considerations in the following sections.</p><div class="sect2" title="Haptic Feedback"><div class="titlepage"><div><div><h3 class="title" id="haptic_feedback">Haptic Feedback</h3></div></div></div><p>The flip <a id="I_indexterm1_id353309" class="indexterm"/><a id="I_indexterm1_id353320" class="indexterm"/>side of the advantage of not being locked into a set of
      physical buttons is that the user must rely almost entirely on vision to
      interact with the controls. At least one of the authors of this book
      uses a keyboard with no letters on it at all, instead relying totally on
      the physical position of the keys to determine which key to strike. This
      would be much harder without the tactile and audio cues to signify that
      the correct key has been pressed. Indeed, it is easy to tell when he is
      typing poorly because the backspace key is much louder than the
      rest!</p><p>The method of including physical feedback to assist a user in interaction with entirely
        virtual objects is known as <span class="emphasis"><em>haptic feedback</em></span>. The first use of haptic
        feedback in games was limited to arcade games such as <span class="emphasis"><em>Motocross</em></span>, in
        which the handlebars shook after an in-game impact. It is now considered standard on video
        game controllers, which vibrate to inform the user of some event.</p><p>In the realm of touch screens, haptic feedback is used to inform
      the user of a successful key strike or other touch-based event. Some
      touch screens even incorporate some movement of the entire screen when
      pressed. This feedback still doesn’t allow touch typing, as it only
      dynamically responds and provides no static tactile feedback for
      different buttons.</p></div><div class="sect2" title="Modeling Touch Screens in Games"><div class="titlepage"><div><div><h3 class="title" id="modeling_touch_screens_in_games">Modeling Touch Screens in Games</h3></div></div></div><p>Given their planar <a id="I_indexterm1_id353366" class="indexterm"/>nature and the lack of inherent haptic feedback, touch
      screens can be an easy way to implement controls with which a character
      in a game can interact. The amount of physical modeling required to
      create a realistic in-game keyboard is pretty intense. Thus, there are
      very few examples of an in-game character having to sit down and type a
      code in to a terminal via a standard keyboard.</p><p>By using touch screens for in-play control of objects, you can
      avoid an additional physical model while retaining realism. It would
      also be interesting to see games use realistic touch screen interfaces
      so that a character would have to remove his gloves to use a capacitive
      screen. Lastly, the exotic screen technologies mentioned earlier provide
      many creative avenues of modeling those types of screens in games. For
      example, for screens measuring sound waves in the glass or other
      mechanical energy, low-grade explosions could be used to trigger these
      in-game input devices.</p></div><div class="sect2" title="Difference from Mouse-Based Input"><div class="titlepage"><div><div><h3 class="title" id="difference_from_mouse-based_input">Difference from Mouse-Based Input</h3></div></div></div><p>One important <a id="I_indexterm1_id353404" class="indexterm"/><a id="I_indexterm1_id353415" class="indexterm"/>consideration for game developers in regards to touch
      screens is the difference from traditional mouse- and keyboard-based
      gaming. As console game developers have long been aware, it is hard to
      compete with the speed and accuracy of the mouse/keyboard combination.
      Many first-person shooters segregate their online gaming between
      controllers and mouse/keyboard setups, as the accuracy and speed of the
      mouse gives those players an unfair advantage. Upon using touch screens
      on many different gaming devices and mobile computing platforms, we feel
      that this advantage is even more pronounced.</p><p>A touch by a finger is an elliptical shape whose contact patch
      depends on the specific finger being used, the pressure applied, and the
      orientation of the finger. The user generally perceives the point of
      touch to be below where the actual center of contact is, so adjustments
      must be made. This is generally all handled automatically by the
      operating system so that a single touch point is computed and handed to
      the game via an API. However, this generic approach to computing touches
      must obviously sacrifice accuracy for universality so that it is not
      calibrated for one specific user.</p><p>Another inherent drawback to touch screens is the need to touch
      the screen. This means a large portion of your hand will be blocking the
      screen when you are controlling that element. One can imagine that in a
      first-person shooter, this would be a great disadvantage over someone
      who is playing with a keyboard and mouse.</p><p>Lastly, mouseover is not available to touch-screen-based input.
      Consider a game where you would trigger actions by merely moving a mouse
      cursor over an object. These actions could be distinct from clicking on
      the same object. However, with touch-screen-based input, that object
      would be obscured by whatever is triggering the screen, therefore
      rendering the mouseover action invisible to the user.</p></div><div class="sect2" title="Custom Gestures"><div class="titlepage"><div><div><h3 class="title" id="custom_gestures">Custom Gestures</h3></div></div></div><p>As a last note, <a id="I_indexterm1_id353462" class="indexterm"/>another possibility for touch input to a game is the use of custom gestures.
        These allow the user to draw a shape on the screen that the program recognizes as a gesture.
        It can then execute arbitrary code based on that input. As this is more pattern recognition
        then physics, we won’t cover it here, but we can recommend the book <a class="ulink" href="http://shop.oreilly.com/product/9780596518394.do" target="_top"><span class="emphasis"><em>Designing Gestural Interfaces</em></span></a> by <a id="I_indexterm1_id353487" class="indexterm"/>Dan Saffer (O’Reilly) as a detailed look at this subject.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 21. Accelerometers</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch20.html" title="Chapter 20. Touch Screens"/><link rel="next" href="ch22.html" title="Chapter 22. Gaming from One Place to Another"/></head><body><section class="chapter" title="Chapter 21. Accelerometers" epub:type="chapter" id="accelerometers"><div class="titlepage"><div><div><h2 class="title">Chapter 21. Accelerometers</h2></div></div></div><p>Accelerometers are a <a id="ac21.0" class="indexterm"/>good introduction to a class of electronic <a id="mi21.0" class="indexterm"/><a id="me21.0" class="indexterm"/>components called <span class="emphasis"><em>microelectromechanical systems</em></span> (MEMS). An
    accelerometer can either be one-axis, two-axis, or three-axis. This designates how many
    different directions it can simultaneously measure acceleration. Most gaming devices have
    three-axis accelerometers.</p><p>As far as game development is concerned, acceleration values are typically delivered to your
    program via an API with units in multiples of <span class="emphasis"><em>g</em></span>. One <span class="emphasis"><em>g</em></span>
    is equal to the acceleration caused by gravity on the Earth, or 9.8
      m/s<sup>2</sup>. Let’s pretend that we have a one-axis accelerometer and we
    orient it such that the axis is pointing toward the center of the earth. It would register
      1<span class="emphasis"><em>g</em></span>. Now, if we travel far away from any mass, such that there is no
    gravity, the accelerometer will read 0. If we then accelerate it such that in one second it goes
    from 0 m/s to 9.8 m/s, the accelerometer will read a steady 1<span class="emphasis"><em>g</em></span> during that
    one-second interval. Indeed, it is impossible to tell the difference between acceleration due to
    gravity and acceleration due to changing velocity.</p><p>Real-life motion is generally nonsteady. Depending on your application’s goals, you might
    have to apply different smoothing functions such as <span class="emphasis"><em>high-pass</em></span> or
      <span class="emphasis"><em>low-pass filters</em></span>. This <a id="I_indexterm2_id353595" class="indexterm"/><a id="I_indexterm2_id353601" class="indexterm"/><a id="I_indexterm2_id353607" class="indexterm"/>amounts <a id="I_indexterm2_id353618" class="indexterm"/>to <span class="emphasis"><em>digital signal processing</em></span>, a topic that has consumed entire
    texts. One example we can recommend is <span class="emphasis"><em>Digital Signal Processing: A Computer Science
      Perspective</em></span> by <a id="I_indexterm2_id353632" class="indexterm"/>Jonathan Y. Stein (Wiley).</p><p>Also, many accelerometers have a method to set <a id="I_indexterm2_id353643" class="indexterm"/>the <span class="emphasis"><em>polling rate</em></span>, or the number of times per second that the
    program requests updates from the accelerometer. This is <a id="I_indexterm2_id353656" class="indexterm"/>called <span class="emphasis"><em>frequency</em></span> and is given in hertz (Hz). This parameter can
    be used to enhance the performance of the program when fine resolution of the acceleration over
    time is not needed.</p><p>When you accept input from an accelerometer—or do any other kind of signal processing—you
    have to accept that input won’t come precisely when you want it. The operating systems normally
    used for gaming—Windows, OS X, Linux—are not real-time environments. This means that although
    you set the polling rate at once a second, this guarantees only that the data will be delivered
      <span class="emphasis"><em>no sooner than</em></span> once a second. If something distracts the operating
    system, such as the arrival of packets on the network, the signal you get from the accelerometer
    may be delayed.</p><div class="sect1" title="Accelerometer Theory"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="accelerometer_theory">Accelerometer Theory</h2></div></div></div><p>The way in which <a id="ac21.1" class="indexterm"/>MEMS measure accelerometers is more basic in principle than you may think. The
      major accomplishment is miniaturizing the technology until it can fit inside a computer chip!
      To clearly illustrate the basic principle, we will first show you the mechanics of it in the
      macro-scale version of a known mass and spring. Let’s say you build something like the
      contraption shown in <a class="xref" href="ch21.html#simple_accelerometer_in_absence_of_accel" title="Figure 21-1. Simple accelerometer in absence of acceleration">Figure 21-1</a> and take it on
      an elevator in an area where there is no gravity. We’ll worry about the effects of gravity in
      a minute.</p><div class="figure"><a id="simple_accelerometer_in_absence_of_accel"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id353737"/><img style="width: 120.472440944882; " src="httpatomoreillycomsourceoreillyimages1598997.png" alt="Simple accelerometer in absence of acceleration"/></div></div><div class="figure-title">Figure 21-1. Simple accelerometer in absence of acceleration</div></div><p>As you can see, the device consists of a known mass at the end of a spring next to a
      measuring stick. When the elevator is not accelerating, the mass is at the 0 mark. When the
      elevator accelerates up or down, the mass at the end of the spring resists that <a id="I_indexterm2_id353763" class="indexterm"/>acceleration and tends to stay at rest. This is <a id="I_indexterm2_id353775" class="indexterm"/>Newton’s first law in action. Inertial loading causes the spring to stretch or
      compress. If the elevator is accelerating upward, the <a id="I_indexterm2_id353789" class="indexterm"/><a id="I_indexterm2_id353799" class="indexterm"/>mass will cause the <a id="I_indexterm2_id353810" class="indexterm"/>spring to stretch downward. Recall from <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a> that the force
      acting on a spring is linearly dependent on the displacement of the mass via the
      equation:</p><table style="border: 0; " class="simplelist"><tr><td>F<sub>n</sub> = kd</td></tr></table><p>We can directly measure the <a id="I_indexterm2_id353843" class="indexterm"/>displacement, <span class="emphasis"><em>d</em></span>, so we can determine the force in that
      direction, <span class="emphasis"><em>n</em></span>. As the mass is known, voilà!</p><table style="border: 0; " class="simplelist"><tr><td>a<sub>n</sub> = m/F<sub>n</sub></td></tr></table><p>As an aside, the fact that you can tell that you are accelerating without having to look
      outside the elevator is what makes this a “noninertial frame of reference,” as discussed in
        <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>. No worries if you don’t totally understand that; it isn’t
      important for what we are discussing here.</p><p>Now, let’s put our elevator back on earth. With the same device, the mass will not be at 0
      even if the elevator is not accelerating because <a id="I_indexterm2_id353893" class="indexterm"/>gravity is pulling it down. Previously we used units of inches, which we then
      converted to force and finally to acceleration. However, we now have a direct measure of the
      acceleration due to gravity and could easily place a mark on where the mass is and call it
        1<span class="emphasis"><em>g</em></span>. Also we could place marks along the ruler at the same intervals.
      Now, we accelerate the elevator upward at 9.8 m/s<sup>2</sup>. The mass should
      move down the scale to 2<span class="emphasis"><em>g</em></span>, and anyone standing in the elevator would feel
      twice as heavy as normal.</p><p>Let’s say we wanted to accelerate the elevator downward at 9.8
        m/s<sup>2</sup>. We could easily do this by just releasing the brakes and
      letting gravity do the work. Now in freefall we don’t feel gravity at all, right? That’s
      because the downward acceleration is canceling the acceleration due to gravity. The mass will
      be back at 0 just like out in space, far from any gravitational bodies. It is for this reason,
      and not a lack of gravity, that astronauts float around. They are in freefall around the
      earth.</p><p>Lastly, if we accelerate the elevator downward at 2<span class="emphasis"><em>g</em></span>, the mass would
      move to the −1<span class="emphasis"><em>g</em></span> mark on the ruler. This is because the downward
      acceleration is now overwhelming gravity. Those in the elevator would find themselves standing
      on the ceiling feeling exactly as they would standing on the ground! In fact, one of <a id="I_indexterm2_id353944" class="indexterm"/>Einstein’s accomplishments was showing that it is impossible to distinguish
      gravity from inertial accelerations. We’ll leave the details of that for independent study and
      get back to accelerometers in the form of <a id="I_indexterm2_id353954" class="indexterm"/>MEMS.</p><div class="sect2" title="MEMS Accelerometers"><div class="titlepage"><div><div><h3 class="title" id="mems_accelerometers">MEMS Accelerometers</h3></div></div></div><p>Micro-scale accelerometers are not that much different from the machine previously
        described but generally use a cantilevered beam instead of a spring. To track more than one
        axis, sometimes three discrete accelerometers are placed out of plane with respect to one
        another. Alternatively, more complex models use elements that can sense all three directions
        within a single integrated sensor. These generally give better results.</p><p>The only important difference from the aforementioned examples, besides MEMS being
        thousands of times smaller in scale than the mass and spring, is how to measure the
        deflection of the test mass. There are three common methods employed in accelerometers. For
        most game devices where extreme accuracy isn’t required, the deflection is usually measured
        as a change in capacitance. This is somewhat the same way that capacitive touch screens
        work, as described in <a class="xref" href="ch20.html" title="Chapter 20. Touch Screens">Chapter 20</a>, and is shown in <a class="xref" href="ch21.html#mems_cantilever_accelerometer" title="Figure 21-2. MEMS cantilever accelerometer">Figure 21-2</a>.</p><div class="figure"><a id="mems_cantilever_accelerometer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id354011"/><img src="httpatomoreillycomsourceoreillyimages1598998.png" alt="MEMS cantilever accelerometer"/></div></div><div class="figure-title">Figure 21-2. MEMS cantilever accelerometer</div></div><p>The beam deflects under the influence of the external accelerations of the test mass and
        brings two charged plates farther or closer together. This changes the capacitance of the
        system. This change can then be calibrated to the imposed acceleration.</p><p>Other methods include integrating <a id="I_indexterm2_id354038" class="indexterm"/>a piezoresister in the beam itself so that the deflection of the beam changes
        the resistance of the circuit. Although this ultimately gives better results, these are
        harder to manufacture. For the most demanding applications, there are accelerometers using
        piezoelectric elements based on quartz crystals. These are very sensitive even during
        high-frequency changes in acceleration but are generally not used in sensing human-input
          <a id="I_indexterm2_id354050" class="indexterm"/><a id="I_indexterm2_id354059" class="indexterm"/><a id="I_indexterm2_id354069" class="indexterm"/>motion.</p></div><div class="sect2" title="Common Accelerometer Specifications"><div class="titlepage"><div><div><h3 class="title" id="common_accelerometer_specifications">Common Accelerometer Specifications</h3></div></div></div><p>To help you better <a id="I_indexterm2_id354093" class="indexterm"/>experiment with accelerometers, we’ve collected the specifications on a few of
        the most common accelerometers in use at the time of writing. The future may hold cheap
        accelerometers based on quantum tunneling<a id="I_indexterm2_id354106" class="indexterm"/> that can provide almost limitless accuracy, but <a class="xref" href="ch21.html#current_common_accelerometers" title="Table 21-1. Current common accelerometers">Table 21-1</a> outlines what you’ll generally be working with
        for now.</p><div class="table"><a id="current_common_accelerometers"/><div class="table-title">Table 21-1. Current common accelerometers</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>Device</p>
              </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>Accelerometer chip</p>
              </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>Sensor range</p>
              </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
                <p>Sampling rate</p>
              </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>iPhone/iPad/ Motorola Droid</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>LIS331D</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>±2<span class="emphasis"><em>g</em></span>*</p>
              </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                <p>100 Hz or 400 Hz</p>
              </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>Nintendo Wii</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>ADXl330</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                <p>±3<span class="emphasis"><em>g</em></span></p>
              </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
                <p>x-/y-axis: 0.5 Hz to 1600 Hz</p>
                <p>z-axis: 0.5 Hz to 550 Hz</p>
              </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                <p>Sony Six Axis</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                <p>Not published</p>
              </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
                <p>±3<span class="emphasis"><em>g</em></span></p>
              </td><td style="text-align: left; vertical-align: top; ">
                <p>100 Hz</p>
              </td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>The chip LIS221D is actually capable of two modes. One mode is
            ±2<span class="emphasis"><em>g</em></span> and the other is ±8<span class="emphasis"><em>g</em></span>. This is dynamically
          selectable according to the chips datasheet; however, neither iOS nor Android allows
          developers to change the mode through the API.</p></div><p>The 2<span class="emphasis"><em>g</em></span> limit for phones can cause problems when you’re attempting
        to record motion. This limitation will be discussed later in this chapter. The larger range
        of Wii and Sony controllers demonstrate that they are dedicated to gaming where larger
        accelerations are expected.</p></div><div class="sect2" title="Data Clipping"><div class="titlepage"><div><div><h3 class="title" id="data_clipping">Data Clipping</h3></div></div></div><p>The human arm is <a id="I_indexterm2_id354434" class="indexterm"/><a id="I_indexterm2_id354443" class="indexterm"/>capable of exceeding the ±2<span class="emphasis"><em>g</em></span> range of the iPhone’s sensor
        easily. The values reported by the API will actually exceed 2<span class="emphasis"><em>g</em></span> up to
        about 2.3<span class="emphasis"><em>g</em></span>. The accuracy of these values that exceed the specification
        is unknown. Regardless, they are probably at least as accurate as the option of trying to
        recreate the data, so if required they can be used. All values above this upper limit will
        be reported as the upper limit such that if you graphed the values, they would look like
          <a class="xref" href="ch21.html#acceleration_graph_showing_clipping" title="Figure 21-3. Acceleration graph showing clipping">Figure 21-3</a>.</p><div class="figure"><a id="acceleration_graph_showing_clipping"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id354481"/><img src="httpatomoreillycomsourceoreillyimages1598999.png" alt="Acceleration graph showing clipping"/></div></div><div class="figure-title">Figure 21-3. Acceleration graph showing clipping</div></div><p>There are several different ways to handle data clipping. One is to discard the data and
        alert the user that he has exceeded the available range. Another is to attempt to recreate
        the missing data. If you are recording the data for later processing, you can use both
        segment 1 and segment 2 to fit the curve between the point at which the data began to be
        clipped and the point in which meaningful data collection is resumed. This is highly
        application dependent, and the curve used to fit the data will have to be matched to the
        activity at hand. If you are recording the data for later processing, you can use both
        segment 1 and segment 2 to give your data.</p><p>If you are attempting to process the signal in real time, you’ll have only segment 1 to
        work from. This could result in a discontinuity when meaningful data collection resumes, and
        you’ll have to decide how to deal with that given the particulars of what you are doing with
        the data.</p></div></div><div class="sect1" title="Sensing Orientation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sensing_orientation">Sensing Orientation</h2></div></div></div><p>Sensing rotation in <a id="I_indexterm2_id354525" class="indexterm"/><a id="I_indexterm2_id354535" class="indexterm"/><a id="I_indexterm2_id354545" class="indexterm"/>three degrees of freedom amounts to sensing a rigid body’s orientation and is a
      complex problem that cannot be fully resolved using only accelerometers. Think about holding
      the device vertically. If you rotate the device about the axis described by the gravity
      vector, none of the accelerometers will measure any change in the force acting on their test
      masses. We can’t measure that degree of freedom. To do so, we’d need to fix a <a id="I_indexterm2_id354560" class="indexterm"/>gyroscope to the device, and even these run into problems when a body is free to
      rotate about all three axes. See <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11</a> for a
      discussion on Euler angles.</p><p>Now let’s discuss what we can accomplish. First, <a class="xref" href="ch21.html#accelerometer_coordinate_system" title="Figure 21-4. Accelerometer coordinate system">Figure 21-4</a> demonstrates the coordinate system<a id="I_indexterm2_id354583" class="indexterm"/> we’ll use; the actual coordinate system used will be determined by the
      manufacturer of your device, so make sure to check its documentation.</p><div class="figure"><a id="accelerometer_coordinate_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_id354607"/><img src="httpatomoreillycomsourceoreillyimages1599000.png" alt="Accelerometer coordinate system"/></div></div><div class="figure-title">Figure 21-4. Accelerometer coordinate system</div></div><p>Now if we make some assumptions based on how a user will hold our device, we can determine
      some “gross” orientations. For illustration, <a class="xref" href="ch21.html#gross_acceleration_values_and_orientatio" title="Table 21-2. Gross acceleration values and orientations">Table 21-2</a> gives some idea of what each value
      would be for each gross direction, assuming the coordinate system shown in <a class="xref" href="ch21.html#accelerometer_coordinate_system" title="Figure 21-4. Accelerometer coordinate system">Figure 21-4</a>.</p><div class="table"><a id="gross_acceleration_values_and_orientatio"/><div class="table-title">Table 21-2. Gross acceleration values and orientations</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Device orientation</p>
            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>X</p>
            </td><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Y</p>
            </td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; ">
              <p>Z</p>
            </td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Face down on table</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>1</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Face up on table</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>−1</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Horizontal on table, right side down</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>1</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Horizontal on table, left side down</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>−1</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>Vertical on table, bottom down</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
              <p>−1</p>
            </td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; ">
              <p>0</p>
            </td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>Vertical on table, top down</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>0</p>
            </td><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; ">
              <p>1</p>
            </td><td style="text-align: left; vertical-align: top; ">
              <p>0</p>
            </td></tr></tbody></table></div></div><p>There are a few things to note here. First, if you were to hold the phone in these
      orientations with your hand, the accelerometer is sensitive enough to pick up small deviations
      from true vertical. We are considering these the “gross” orientations such that these small
      deviations should be ignored.</p></div><div class="sect1" title="Sensing Tilt"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sensing_tilt">Sensing Tilt</h2></div></div></div><p>Although we can’t <a id="ac21.3" class="indexterm"/><a id="I_indexterm2_id355087" class="indexterm"/>determine exactly what angle the user is holding the phone about all three axes,
      we can pick one axis, assume that it is pointing down, and then find the change in the angle
      from that assumption over time. For instance, if the phone is lying on a table, the average
      acceleration in the z-direction will be −1, and in the other directions, 0. Even if the user
      spins the phone, the values will remain as previously indicated and we cannot sense that
      rotation. However, if the user lifts one edge from the table—we’ll call this tilting it—then
      the accelerometer will register different values. Some of the acceleration due to gravity will
      act on the other two axes. By sensing this change, an accelerometer will allow us to determine
      at what angle the device is tilted.</p><div class="sect2" title="Using Tilt to Control a Sprite"><div class="titlepage"><div><div><h3 class="title" id="using_tilt_to_control_a_sprite">Using Tilt to Control a Sprite</h3></div></div></div><p>Here we will <a id="ti21.3.1" class="indexterm"/><a id="ac21.3.1" class="indexterm"/>show you how to implement code for a simple game that asks the user to move an
        avatar to a target by tilting the phone. First, we will briefly show an example of
        determining the rotation about a single axis. Let’s assume we have an accelerometer rotated
        at some arbitrary angle, α, which is what our algorithm will solve for. As previously
        discussed, accelerometers generally report values as multiples of near earth gravity,
          <span class="emphasis"><em>g</em></span>. For the following example, we are concerned only with the x- and
        y-axis values, a<sub>x</sub> and a<sub>y</sub>, respectively. If the
        device were in the “upright” position, then a<sub>x</sub> would equal 0 and
          a<sub>y</sub> would equal 1. After rotating the device, we’d see different
        values that are related to our angle α by use of the arctangent function. In this case,
        because <a id="I_indexterm2_id355174" class="indexterm"/>the <span class="emphasis"><em>single-argument atan function</em></span> included in most
        programming languages doesn’t differentiate between diametrically opposed directions, it is
        beneficial to use the <span class="emphasis"><em>two-argument function</em></span>. The relevant C code is as
        follows:</p><a id="I_programlisting2_id355191"/><pre class="programlisting">#define PI 3.14159

float find2dAngle(void){

    //LOCAL VARIABLES
    float alpha,
    double ax, ay;

    //POLL ACCELEROMETER FOR ACCELERATIONS, API SPECIFIC
    ax = getXacceleration();
    ay = getYacceleration();

    //FIND ANGLE
    alpha = atan2(ay,ax);

    if (alpha &gt;= 0){
        alpha = alpha * (180/PI);
    else {
        alpha = alpha * (-180/PI) + 180;
    }

    return alpha;
}</pre><p>This is pretty straightforward, but there are a few things to point out. First, the way
        in which your program will get results from the accelerometer will vary greatly between
        platforms, so we have encapsulated that API-specific code in a <code class="literal">getXacceleration()</code> function. In fact, most operating systems will be
        continuously polling the accelerometer in a separate thread, so you’ll have to have a
        logical operator that tells your accelerometer object when you actually want to see those
        values passed to your program. Example Objective-C code for the accelerometer in the iPhone
        will be shown later. Secondly, you’ll notice that we are using an <code class="literal">if</code> statement that changes the radians to degrees in such a way as to return
        proper 0°–360° answers. This avoids having to pay attention to the sign, as
          <code class="literal">atan2</code> returns only answers between 0° and 180°, using a negative value
        to represent the other half of the range. For example, an output of 0° means the device is
        vertical, an output of 90° means the device is rotated 90° to the left, and an output of
        180° means the device is upside down.</p><p>Now let’s extend this to two dimensions. This will tell us not only how far the phone is
        from vertical about one axis, but its inclination about the y-axis as well.</p></div><div class="sect2" title="Two Degrees of Freedom"><div class="titlepage"><div><div><h3 class="title" id="two_degrees_of_freedom">Two Degrees of Freedom</h3></div></div></div><p>Now let’s say that we want to <a id="de21.3.2" class="indexterm"/>develop a game in which we control a sprite moving in a 2D world. The user would
        hold the device as if it were lying on a table and look down from above. He or she would
        then tilt the phone out of that plane to get the sprite to move in the desired direction.
        The fraction of gravity that the accelerometer is now experiencing in the x- and
        y-directions will be inputs into our simulation.</p><p>The example will be demonstrated <a id="ob21.3.2" class="indexterm"/>using Objective-C code for the iPhone, and we’ll be using the Qwartz2D graphics
        framework. If you aren’t familiar with Objective-C, don’t worry—we’ll explain what we are
        doing in each step, and you can port that code to whatever language you are working
        in.</p><p>The first step will be to set up our accelerometer. In this case we are going to
        initialize it in our <em class="filename">tiltViewController.m</em> file so that
        we have:</p><a id="I_programlisting2_id355303"/><pre class="programlisting">- (void)viewDidLoad
{
    UIAccelerometer *accelerometer = [UIAccelerometer sharedAccelerometer];
    accelerometer.delegate  = self;
    accelerometer.updateInterval = kPollingRate;
    [super viewDidLoad];
}</pre><p>The important concept here is that we have defined a name for our accelerometer object,
          <code class="literal">accelerometer</code>, and we have set its <code class="literal">updateInterval</code> property to <code class="literal">kPollingRate</code>. This constant was defined in <em class="filename">tiltViewController.h</em> as <code class="literal">(1.0f/60.0f)</code>, which
        corresponds to 60 Hz. In other words, this tells the operating system to update our
        program’s accelerometer object 60 times a second. Also in <em class="filename">tiltViewController.m</em>, we write what happens when the accelerometer object gets
        updated via the accelerometer’s <code class="literal">didAccelerate:</code> function
        as follows:</p><a id="I_programlisting2_id355359"/><pre class="programlisting">- (void)accelerometer:(UIAccelerometer *)accelerometer 
didAccelerate:(UIAcceleration *)acceleration{
    [(SpriteView *)self.view setAcceleration:acceleration];
    [(SpriteView *)self.view draw];
}</pre><p>This function is called every time the acceleration object is updated and does two
        things. First, it takes the acceleration data from the accelerometer and passes it to the
          <code class="literal">SpriteView</code> class, which we’ll talk about in a second.
        Then it tells the <code class="literal">SpriteView</code> to go ahead and redraw
        itself.</p><p>The <code class="literal">SpriteView</code> class is where the action happens and
        consists of a header file, <em class="filename">SpriteView.h</em>, where we
        define the following global variables:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">UIImage *sprite</code></span></dt><dd><p>A pointer to the image that will be used to represent our sprite on the
              screen.</p></dd><dt><span class="term"><code class="literal">currentPos</code></span></dt><dd><p>The position on the screen where we want the sprite to be drawn.</p></dd><dt><span class="term"><code class="literal">prevPos</code></span></dt><dd><p>The previous position of the sprite on the screen. We will use this to tell the
              draw function what parts of the screen need to be redrawn.</p></dd><dt><span class="term"><code class="literal">UIAcceleration *acceleration</code></span></dt><dd><p>A special Objective-C data type to hold data from the accelerometer.</p></dd><dt><span class="term"><code class="literal">CGFloat xVelocity</code> and <code class="literal">CGFloat yVelocity</code></span></dt><dd><p>Float variables to hold the current velocity in the x-direction and y-direction,
              respectively.</p></dd><dt><span class="term"><code class="literal">CGFloat convertX</code> and <code class="literal">CGFloat convertY</code></span></dt><dd><p>Float variables to hold the ratios for converting our physics engine’s results in
              meters to pixels based on an assumed world size.</p></dd></dl></div><p>Additionally, we’ve defined the following global constants:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">g</code></span></dt><dd><p>Near earth gravity value, set at 9.8 m/s<sup>2</sup>. This will
              convert the accelerometer’s values from <span class="emphasis"><em>g</em></span> to
                m/s<sup>2</sup> for use in calculating velocity. This can also be
              tuned to represent an arbitrary acceleration instead of just using gravity as the
              force (e.g., percent of jet engine thrust).</p></dd><dt><span class="term"><code class="literal">kWorldHeight</code> and <code class="literal">kWorldWidth</code></span></dt><dd><p>These values are used to allow the programmer to change the assumed world
              dimensions. Higher values mean each pixel is a greater distance in meters. The world
              will always be scaled to fit on the screen, so a large world means the sprite will
              appear to move slower (a few pixels at a time) for a given acceleration. Note that our
              current code doesn’t scale the sprite.</p></dd></dl></div><p>Now we’ll show you how we use these variables in <em class="filename">SpriteView.m</em> to move our sprite on our screen as a result of the accelerometer
        values. First, we have some initialization to do, which takes place in the <code class="literal">initWithCoder:</code> method that runs the first time the view is
        loaded:</p><a id="I_programlisting2_id355617"/><pre class="programlisting">-(id)initWithCoder:(NSCoder *)coder {
    if((self = [super initWithCoder:coder])){
        self.sprite = [UIImage imageNamed:@"sprite.png"];
        self.currentPos = CGPointMake((self.bounds.size.width / 2.0f) +
(sprite.size.width / 2.0f), (self.bounds.size.height /2.0f)+(sprite.size.height /2.0f));
        xVelocity = 0.0f;
        yVelcoity = 0.0f;

        convertX = self.bounds.size.width / kWorldWidth;
        convertY = self.bounds.size.height / kWorldHeight;

    }
    return self;
}</pre><p>Most of this is pretty straightforward. We tell our program where to find the sprite
        image we’ve chosen and set its initial position to the center of the screen. We also set its
        initial velocity to 0 in both directions. We then go ahead and initialize our <code class="literal">convertX</code> and <code class="literal">convertY</code>
        variables based on the <code class="literal">self.bounds.size</code> property, which
        gives the bounds of the view in pixels. We’ll show exactly how this affects our program
        later. Next, we’ll write a custom <code class="literal">mutator</code> for the
          <code class="literal">CurrentPos</code> variable:</p><a id="I_programlisting2_id355665"/><pre class="programlisting">- (void)setCurrentPos:(CGPoint)newPos {
    prevPos = currentPos;
    currentPos = newPos;

    if(currentPos.x &lt;0){
        currentPos.x = 0;
        xVelocity = 0.0f;
    }
    if(currentPos.y &lt;0){
        currentPos.y = 0;
        yVelcoity = 0.0f;
    }
    if(currentPos.x &gt; self.bounds.size.width - sprite.size.width){
        currentPos.x = self.bounds.size.width - sprite.size.width;
        xVelocity = 0.0f;
    }
    if(currentPos.y &gt; self.bounds.size.height - sprite.size.height){
        currentPos.y = self.bounds.size.height - sprite.size.height;
        yVelocity = 0.0f;
    }

    CGRect curSpriteRect = CGRectMake(currentPos.x, currentPos.y, 
currentPos.x+sprite.size.width, currentPos.y+sprite.size.height);
    CGRect prevSpriteRect = CGRectMake(prevPos.x, prevPos.y, 
prevPos.x+sprite.size.width, currentPos.y+sprite.size.height);
    [self setNeedsDisplayInRect:CGRectUnion(curSpriteRect, prevSpriteRect)];

}</pre><p>In case you are unfamiliar with Objective-C, when you define a class instance variable
        it will automatically define a mutator that simply updates the value of the variable to the
        value you are passing it. However, in the preceding example we are overriding that mutator
        to do some additional work. The first thing we do is to set the <code class="literal">prevPos</code> variable to the current position of the sprite and then update the
          <code class="literal">currentPos</code> with the value the mutator was given.
        However, our physics engine isn’t going to include collision response with the screen
        boundaries, so we go on to check if the sprite has reached the screen edge. If so, we simply
        tell the program to leave it on the edge and to set the velocity in that direction to 0.
        Lastly, we define a couple of rectangles based on the new position of the sprite and the old
        position of the sprite. After we union those rectangles together, we tell the operating
        system to redraw the screen in that area with the <code class="literal">setNeedDisplayInRect:</code> method. As you might recall, our accelerometer object is
        calling the <code class="literal">draw</code> method every time it updates, and it is
        in this method that we will put our physics engine:</p><a id="I_programlisting2_id355714"/><pre class="programlisting">- (void)draw {
    static NSDate *lastUpdateTime;

    if (lastUpdateTime != nil) {
        NSTimeInterval secondsSinceUpdate = -([lastUpdateTime
timeIntervalSinceNow]); //calculates interval in seconds from last update

        //Calculate displacement
        CGFloat deltaX = xVelocity * secondsSinceUpdate + 
((acceleration.x*g*secondsSinceUpdate*secondsSinceUpdate)/2); // METERS
        CGFloat deltaY = yVelocity * secondsSinceUpdate + 
((acceleration.y*g*secondsSinceUpdate*secondsSinceUpdate)/2); // METERS

        //Converts from meters to pixels based on defined World size
        deltaX = deltaX * convertX;
        deltaY = deltaY * convertY;

        //Calculate new velocity at new current position
        xVelocity = xVelocity + acceleration.x * g * secondsSinceUpdate; //assumes
acceleration was constant over last update interval
        yVelocity = yVelocity - (acceleration.y * g * secondsSinceUpdate); //assumes 
acceleration was constant over last update interval

        //Mutate currentPos which will update screen
        self.currentPos = CGPointMake(self.currentPos.x + deltaX, 
self.currentPos.y + deltaY);

    }

    [lastUpdateTime release];
    lastUpdateTime = [[NSDate alloc] init];

}</pre><p>Previously, we discussed issues with timing when working with accelerometer data. In
        this case, Objective-C makes it very easy to get the correct elapsed time in seconds. We
        first define a static variable, <code class="literal">lastUpdateTime</code>, as an
          <code class="literal">NSDate</code> type. This type has a built-in function to give
        the time interval in seconds from now, which we assign to an <code class="literal">NSTimeInterval</code> variable. Skipping down to the last two lines, we are simply
        updating the last update time by releasing and reinitializing the variable. As it is static,
        it will remain even after the function returns. If you are using a lower-level language, you
        might have to write your own <code class="literal">timeIntervalSinceNow</code>
        function that takes into account the particular clock frequency of the system.</p><p>Now that we have our time interval in seconds, we can calculate our new position. Recall
        from <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>:</p><table style="border: 0; " class="simplelist"><tr><td>s<sub>2</sub> = s<sub>1</sub> + v<sub>1</sub> t
          + (a t<sup>2</sup>)/2</td></tr></table><p>which we have rearranged to be:</p><table style="border: 0; " class="simplelist"><tr><td>Δs = s<sub>2</sub> − s<sub>1</sub> =
            v<sub>1</sub> t + (a t<sup>2</sup>)/2</td></tr></table><p>This gets programmed as:</p><a id="I_programlisting2_id355829"/><pre class="programlisting">        <span class="strong"><strong>CGFloat deltaX = xVelocity * secondsSinceUpdate + ((acceleration.x*g*secondsSinceUpdate*secondsSinceUpdate)/2); // METERS</strong></span></pre><p>We then convert this displacement in meters to displacement in pixels using an
        appropriate ratio for the size of our world. Before we can move on, we have to calculate our
        new velocity at our new position. So we again assume the acceleration as constant over the
        update interval, and recalling:</p><table style="border: 0; " class="simplelist"><tr><td>v<sub>2</sub> = v<sub>1</sub> + a Δt</td></tr></table><p>from <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>, we can solve for the new <code class="literal">xVelocity</code> with:</p><a id="I_programlisting2_id355878"/><pre class="programlisting"><span class="strong"><strong>xVelocity = xVelocity + acceleration.x * g * secondsSinceUpdate;</strong></span></pre><p>As you can see from the complete method description, the code of the y-direction is
        similar. Finally, we call the <code class="literal">currentPos</code> mutator to set
        the new position based on the change in displacements. Recall that this is a custom mutator
        that also tells the operating system to update the display. After the <code class="literal">draw</code> method is finished, the accelerometer waits 1/60 of a
        second and then calls it again. You could extend this program by adding in friction, fluid
        resistance, and collisions with the screen boundaries using the methods outlined in the
        other chapters of this <a id="I_indexterm2_id355910" class="indexterm"/><a id="I_indexterm2_id355919" class="indexterm"/><a id="I_indexterm2_id355928" class="indexterm"/><a id="I_indexterm2_id355938" class="indexterm"/><a id="I_indexterm2_id355947" class="indexterm"/>book.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 22. Gaming from One Place to Another</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch21.html" title="Chapter 21. Accelerometers"/><link rel="next" href="ch23.html" title="Chapter 23. Pressure Sensors and Load Cells"/></head><body><section class="chapter" title="Chapter 22. Gaming from One Place to Another" epub:type="chapter" id="gaming_from_one_place_to_another"><div class="titlepage"><div><div><h2 class="title">Chapter 22. Gaming from One Place to Another</h2></div></div></div><p>Once a tool meant to help the <a id="I_indexterm3_id355966" class="indexterm"/><a id="I_indexterm3_id355976" class="indexterm"/>United States guide intercontinental ballistic missiles, the
  <span class="emphasis"><em>Global Positioning System</em></span> (GPS) has evolved to be a
  part of our everyday lives. The current generation will never have known a
  world where getting lost was something that couldn’t be fixed by
  trilaterating their position between satellites orbiting the planet.
  Although GPS has become commonplace in the navigational world, the
  proliferation of smartphones is just now opening the doors to GPS gaming.
  While this genre is just emerging, we’d like to give you an introduction to
  the physics behind GPS and the current applications in the gaming
  world.</p><p>Let’s recall that <a id="I_indexterm3_id356000" class="indexterm"/><a id="I_indexterm3_id356013" class="indexterm"/><a id="I_indexterm3_id356019" class="indexterm"/>positions near the earth’s surface are generally given in the
  <span class="emphasis"><em>geographic coordinate system</em></span>, more often described as
  latitude, longitude, and altitude. <span class="emphasis"><em>Latitude</em></span> is a
  <a id="I_indexterm3_id356038" class="indexterm"/>measure in degrees of how far north or south you are from the
  equator. <span class="emphasis"><em>Longitude</em></span> <a id="I_indexterm3_id356053" class="indexterm"/>is the measure in degrees of how far east or west you are from
  the prime meridian. A meridian is a line of constant latitude that runs from
  the North Pole to the South Pole. The prime meridian is arbitrarily defined
  as the meridian that passes through the <a id="I_indexterm3_id356066" class="indexterm"/>Greenwich Observatory in the <a id="I_indexterm3_id356074" class="indexterm"/>UK. <span class="emphasis"><em>Altitude</em></span> is usually given as the
  measure of how far above or below sea level you are at the point described
  by latitude and longitude.</p><div class="sect1" title="Location-Based Gaming"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="location-based_gaming">Location-Based Gaming</h2></div></div></div><p>Before getting <a id="I_indexterm3_id356101" class="indexterm"/><a id="I_indexterm3_id356111" class="indexterm"/><a id="I_indexterm3_id356121" class="indexterm"/>to the physics behind GPS, we’d like to take a moment to
    discuss how GPS is being implemented into games. Right now, this is an
    emerging market that is just starting to gain traction. There are several
    broad categories into which games fall. Another step beyond what the
    accelerometer did, GPS enables users to move computer games not only off
    the couch but also out into the world.</p><div class="sect2" title="Geocaching and Reverse Geocaching"><div class="titlepage"><div><div><h3 class="title" id="geocaching_and_reverse_geocaching">Geocaching and Reverse Geocaching</h3></div></div></div><p>Geocaching is the <a id="I_indexterm3_id356148" class="indexterm"/>oldest form of gaming involving GPS. It originated after
      selective availability was removed from GPS, making it more accurate, in
      the year 2000. In its most basic form, it is the process of hunting down
      a “cache” using provided GPS coordinates. The cache usually has a
      logbook and may contain other items such as coins with serial numbers
      that the finder can move to another cache and track online.</p><p>Because of the large amount of setup involved in implementing a
      geocaching game on a commercial scale, most implementations are
      community based. However, <a id="I_indexterm3_id356165" class="indexterm"/>reverse geocaching has more promise for the gaming
      industry. In this variation there is nothing at the supplied
      coordinates, but traveling to them is required to execute some action.
      Think of it as carrying around a cache that cannot be unlocked until it
      is within range of some specific coordinate. This could be used to force
      users to travel in order to unlock a game item. For instance, perhaps to
      gain the ability to use a sword in a game, the user must travel to the
      nearest sporting goods store. The commercial possibility of corporate
      tie-ins is an obvious plus.</p></div><div class="sect2" title="Mixed Reality"><div class="titlepage"><div><div><h3 class="title" id="mixed_reality">Mixed Reality</h3></div></div></div><p>Mixed-reality games <a id="I_indexterm3_id356191" class="indexterm"/>are similar to geocaching. They go beyond just using the coordinates of the user
        to trigger events, to using reality-based locals. A current example is Gbanga’s
          <span class="emphasis"><em>Famiglia</em></span>. In this game your movement in the real world allows you to
        discover virtual establishments in the game world. This divorces it from the actual physical
        locations that your GPS is reporting but requires moving between locations in the real world
        to move your character in the virtual world. Popular right now is the <a id="I_indexterm3_id356206" class="indexterm"/>FourSquare app on mobile devices. This is the simplest possible implementation
        of mixed-reality gaming. FourSquare allows a user to become the mayor of a place if she
        “checks in” at the locale more than anyone else.</p></div><div class="sect2" title="Street Games"><div class="titlepage"><div><div><h3 class="title" id="street_games">Street Games</h3></div></div></div><p>Street games <a id="I_indexterm3_id356228" class="indexterm"/>are another step beyond mixed reality. These turn the
      environment around the user into a virtual game board. One example is
      the recent <span class="emphasis"><em>Pac-Manhattan</em></span> multiplayer game using GPS
      in smartphones to play a live version of <span class="emphasis"><em>Pac-Man</em></span> in
      Washington Square Park. In general, the idea is to create a court for
      game play using the environment surrounding the user. The relationship
      between users is tracked in the virtual space of the game and provides
      the interactive elements.</p></div></div><div class="sect1" title="What Time Is It?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="what_time_is_it_question">What Time Is It?</h2></div></div></div><p>The story of GPS<a id="I_indexterm3_id356263" class="indexterm"/><a id="I_indexterm3_id356274" class="indexterm"/> really begins with a prize offered by the British
    government in 1717 for a simple way to determine your <a id="I_indexterm3_id356286" class="indexterm"/><a id="ti22.2" class="indexterm"/>longitude. Awarded in 1773, the accepted solution was to
    compare local noon to the official noon sighted at the <a id="I_indexterm3_id356312" class="indexterm"/>Greenwich Observatory. The difference between these two
    times would allow you to tell how far around the world you were from the
    observatory. Fast-forward three centuries, and we have satellites orbiting
    the earth, broadcasting time-stamped messages. By calculating the
    difference between the time the message was received and the time it was
    transmitted, we can calculate our distance from the satellite. In both
    cases you need an accurate way to keep or measure time. For sailors in the
    1800s, the device was the newly invented chronometer. For us, it is the
    atomic clock.</p><p>Because the signals from a GPS satellite are moving at the speed of
    light, you need a very accurate clock to keep track of how long it took to
    travel to you. For instance, if the clock you are using to time when the
    signal arrives is 1 microsecond off, you will estimate a distance over 900
    miles in error. On the supply side of the signal, each satellite has an
    atomic clock, and internal GPS time is accurate to about 14 nanoseconds.
    The problem is that you also need a very accurate clock in the receiver,
    and it would be pretty hard to fit an atomic clock into a phone
    economically. To get around this, the receiver must figure out the correct
    current time based on the signals from the satellites.</p><div class="sect2" title="Two-Dimensional Mathematical Treatment"><div class="titlepage"><div><div><h3 class="title" id="two-dimensional_mathematical_treatment">Two-Dimensional Mathematical Treatment</h3></div></div></div><p>This section will <a id="gp22.2" class="indexterm"/><a id="gl22.2" class="indexterm"/>give you a good idea of how GPS systems determine their
      location. This background will help you in many applications of geometry
      in games in general, but most GPS devices do the heavy lifting and
      report through an API your current latitude and longitude. Some APIs may
      include more information—for example, the current iOS API, called Core
      Location, gives the current <a id="la22.2.1" class="indexterm"/><a id="lo22.2.1" class="indexterm"/>latitude and longitude, the direction of travel, the
      distance traveled, and the distance in meters to a given coordinate. It
      also gives an estimate for the error associated with its position fix in
      meters.</p><p>One way to get your position via the kind of information that GPS
      provides is a technique <a id="tr22.2.1" class="indexterm"/>called <span class="emphasis"><em>trilateration</em></span>. We are going to
      give this problem a mathematical treatment in two dimensions. You could
      extend this to three dimensions by using spheres instead of
      circles.</p><p>To begin, we can list our unknowns: our <span class="emphasis"><em>x</em></span>
      coordinate and <span class="emphasis"><em>y</em></span> coordinate in space, and the error
      in our receiver’s clock (or <span class="emphasis"><em>bias</em></span>),
      <span class="emphasis"><em>b</em></span>. In a two-dimensional plane, trilateration among
      three circles gives you an exact position; in three-dimensional space,
      four spheres are required to determine all three special coordinates.
      Note that if we included an assumption about being on the surface of
      some geometric shape, such as the earth, we could reduce the number of
      unknowns. No such simplification is used here to provide you with the
      most general case.</p><p>In our example, we are somewhere on the surface of the
      two-dimensional earth, shown in <a class="xref" href="ch22.html#trilateration_in_2d" title="Figure 22-1. Trilateration in 2D">Figure 22-1</a>
      as a light gray solid disk. This disk is being orbited by several GPS
      satellites. The satellites’ orbits are regular, and their positions at
      any time are tabulated in an almanac that is stored in the receiver. The
      time of transmission is encoded in the signal so that the givens are
      <span class="emphasis"><em>x</em></span><sub>i</sub>,
      <span class="emphasis"><em>y</em></span><sub>i</sub>, and
      <span class="emphasis"><em>t</em></span><sub>i</sub>, with
      <span class="emphasis"><em>i</em></span> =1,2,3.</p><div class="figure"><a id="trilateration_in_2d"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id356508"/><img src="httpatomoreillycomsourceoreillyimages1599001.png" alt="Trilateration in 2D"/></div></div><div class="figure-title">Figure 22-1. Trilateration in 2D</div></div><p>To make things easier for us, we are going to abandon the
      coordinate system of the earth and use the coordinate system defined by
      our three satellites. The origin will be at satellite 1, the x-axis
      going directly from satellite 1 straight to satellite 2 and the y-axis
      being perpendicular to that. This is shown in <a class="xref" href="ch22.html#satellite_coordinate_system" title="Figure 22-2. Satellite coordinate system">Figure 22-2</a>.</p><div class="figure"><a id="satellite_coordinate_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id356549"/><img src="httpatomoreillycomsourceoreillyimages1599002.png" alt="Satellite coordinate system"/></div></div><div class="figure-title">Figure 22-2. Satellite coordinate system</div></div><p>The equations of the three circles are therefore:</p><table style="border: 0; " class="simplelist"><tr><td>r<sup>2</sup><sub>1</sub> =
        x<sup>2</sup>+y<sup>2</sup></td></tr><tr><td>r<sup>2</sup><sub>2</sub> =
        (x–d)<sup>2</sup>+y<sup>2</sup></td></tr><tr><td>r<sup>2</sup><sub>3</sub> =
        (x–i)<sup>2</sup>+(y–j)<sup>2</sup></td></tr></table><p>Each radius is found by subtracting the transmission time,
          <span class="emphasis"><em>t</em></span><sub>i</sub>, from the current time and multiplying by
        the speed of light. As the speed of light is very large, and our current time is only a
        rough estimate, these radii are commonly referred  <a id="I_indexterm3_id356637" class="indexterm"/>to as <span class="emphasis"><em>pseudoranges</em></span> to remind us they are still approximate.
        The <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values that satisfy these equations
        are our current location in two-dimensional space. We now subtract the second equation from
        the first:</p><table style="border: 0; " class="simplelist"><tr><td>r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> =
        x<sup>2</sup> + y<sup>2</sup> –
        (x-d)<sup>2</sup> –
        y<sup>2</sup></td></tr><tr><td>r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> =
        x<sup>2</sup> –
        (x-d)<sup>2</sup></td></tr></table><p>Solving for <span class="emphasis"><em>x</em></span> gives:</p><table style="border: 0; " class="simplelist"><tr><td><span class="emphasis"><em>x</em></span> =
        (r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup>+d<sup>2</sup>)
        / 2d</td></tr></table><p>where <span class="emphasis"><em>d</em></span> is the distance between the known
      locations of satellite 1 and satellite 2. We now substitute our
      <span class="emphasis"><em>x</em></span> coordinate back into the first circle’s
      equation:</p><table style="border: 0; " class="simplelist"><tr><td>y<sup>2</sup> =
        r<sub>1</sub><sup>2</sup> –
        [((r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> +
        d<sup>2</sup>)<sup>2</sup>) /
        (4d<sup>2</sup>)]</td></tr></table><p>and finally after we take the square root:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2201.png" alt="Satellite coordinate system"/></div></div><p>notice that the <span class="emphasis"><em>y</em></span> value is now expressed as a
      positive or negative square root. This means there can be zero, one, or
      two real-number solutions. If the circles do not intersect, then the
      quantity under the square root will be negative and the
      <span class="emphasis"><em>y</em></span> value will have zero real solutions. This is
      unlikely for the first two satellites because you have already received
      pseudoranges to them in the form of
      <span class="emphasis"><em>r</em></span><sub>1</sub> and
      <span class="emphasis"><em>r</em></span><sub>2</sub>, which the algorithm
      assumes to have zero error. If the two circles happen to intersect at
      only a single tangent point, the <span class="emphasis"><em>y</em></span> will have one
      solution and will be equal to 0. This is also unlikely. The most likely
      result will be that <span class="emphasis"><em>y</em></span> will be the set of two
      values, plus or minus the square root of a positive value, and that
      those two points will be widely separated.</p><p>Now if we included the assumption that we were on the earth’s
      surface, we could already break the tie between the two points by
      picking whichever was closest to the earth’s surface. However, we still
      would have to deal with the likelihood that there is a large error in
      our position given the imprecise clock in the receiver.</p><p>We can fix our position (<span class="emphasis"><em>x,y</em></span>) with no assumptions and account for
        clock bias by introducing the third point and its pseudorange. Now, it was very likely that
        the circles obtained from the first two satellites would intersect because of the way that
        GPS satellites are arranged around the earth. However, because our calculations use
        pseudoranges, it is relatively unlikely that the third circle will pass directly through one
        of the two points defined by the intersection of the first two circles. To remove such
        clock-related distance errors, we first calculate which point (<span class="emphasis"><em>x,y</em></span>) or
          (<span class="emphasis"><em>x,–y</em></span>) is closer to (<span class="emphasis"><em>i,j</em></span>) and choose that to be
        our assumed location. The difference between the smaller of these two distances and the
        pseudorange <span class="emphasis"><em>r</em></span><sub>3</sub> is then our distance correction,
          <span class="emphasis"><em>d</em></span><sub>a</sub>. As the signal is traveling at the <a id="I_indexterm3_id356904" class="indexterm"/><a id="I_indexterm3_id356916" class="indexterm"/>speed of light, the following quotient provides an estimate of the error between
        the correct time and the receiver’s time:</p><table style="border: 0; " class="simplelist"><tr><td>b = d<sub>a</sub>/c</td></tr></table><p>As all the GPS satellites have synchronized atomic clocks, the
      same bias exists for each. This means that the bias we calculated would
      actually affect the first pseudoranges we used to find our initial bias.
      Therefore an iterative approach is required to adjust all the variables
      in real time until they converge. A more direct, but less obvious,
      algebraic solution that requires no iteration was developed by
      <a id="I_indexterm3_id356948" class="indexterm"/>Stephen Bancroft. It is detailed in his paper “An
      Algebraic Solution of the GPS Equations” in the <span class="emphasis"><em>IEEE
      Transactions on Aerospace and Electronics Systems</em></span>
      journal.</p><p>Besides clock errors, other errors are introduced by the
      atmosphere, signals bouncing off the ground and back to the receiver,
      relativistic effects (discussed in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>), and
      <a id="I_indexterm3_id356970" class="indexterm"/><a id="I_indexterm3_id356977" class="indexterm"/><a id="I_indexterm3_id356983" class="indexterm"/>atomic clock drift. These are all accounted for in
      mathematical models applied to the raw position data. For instance, the
      GPS clocks lose about 7,214 nanoseconds every day due to their velocity
      according to special relativity. However, because they are higher up in
      the earth’s gravity well, they gain 45,850 nanoseconds every day
      according to general relativity. The net effect is found by adding these
      values together: they run 38,640 nanoseconds faster each day, which
      would cause about 10 kilometers inaccuracy to build each day they are in
      orbit. To account for this, the clocks in the GPS receivers are
      pre-adjusted from 10.23 MHz to 10.22999999543 MHz. The fact that we are
      giving you a number to 11 decimal places demonstrates the amount of
      accuracy the modern age enjoys in its time keeping.</p><p>Once the bias is taken care of and all the other possible errors
      adjusted for, the converged solution can be translated back into
      whatever coordinate system is convenient to give to the end user.
      Usually this is latitude, longitude, and <a id="I_indexterm3_id357009" class="indexterm"/>altitude. Next, we will learn how to calculate different
      quantities based in the <a id="I_indexterm3_id357020" class="indexterm"/><a id="I_indexterm3_id357025" class="indexterm"/>geographic coordinate <a id="I_indexterm3_id357036" class="indexterm"/><a id="I_indexterm3_id357046" class="indexterm"/><a id="I_indexterm3_id357055" class="indexterm"/><a id="I_indexterm3_id357065" class="indexterm"/><a id="I_indexterm3_id357074" class="indexterm"/><a id="I_indexterm3_id357083" class="indexterm"/>system.</p></div></div><div class="sect1" title="Location, Location, Location"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="location_comma_location_comma_location">Location, Location, Location</h2></div></div></div><p>Let’s take a minute to discuss distance between two <a id="gl22.3" class="indexterm"/><a id="gp22.3" class="indexterm"/><a id="la22.3" class="indexterm"/><a id="lo22.3" class="indexterm"/><a id="di22.3" class="indexterm"/>latitude and longitude coordinates. You might be tempted to
    calculate it as the distance between two points. For very small distances,
    this approximation is probably accurate enough. However, because the earth
    is actually a sphere, over great distances the calculated route will be
    much shorter than the actual distance along the surface.</p><p>The shortest distance between two points on a sphere, especially in
    problems of navigation, is <a id="I_indexterm3_id357185" class="indexterm"/>called a <span class="emphasis"><em>great circle</em></span>. A great circle
    is the intersection of a sphere and a plane defined by the center point of
    the sphere, the origin, and the destination. The resulting course actually
    has a heading that constantly changes. On ships, this is avoided in favor
    of <a id="I_indexterm3_id357198" class="indexterm"/>using a <span class="emphasis"><em>rhumb line</em></span>, which is the
    shortest path of constant heading. This makes navigation easier at the
    expense of time. Airplanes, however, do follow great-circle routes to
    minimize fuel burn.</p><div class="sect2" title="Distance"><div class="titlepage"><div><div><h3 class="title" id="distance">Distance</h3></div></div></div><p>There are several ways of <a id="I_indexterm3_id357227" class="indexterm"/>calculating the distance along a great circle. The one we will discuss here <a id="I_indexterm3_id357238" class="indexterm"/>is the <span class="emphasis"><em>haversine formula</em></span>. There are other methods like <a id="I_indexterm3_id357249" class="indexterm"/>the <span class="emphasis"><em>spherical law of cosines</em></span> and <a id="I_indexterm3_id357259" class="indexterm"/>the <span class="emphasis"><em>Vincenty formula</em></span>, but the haversine is more accurate
        for small distances than the spherical law of cosines while remaining much simpler than the
        Vincenty formula.</p><p>The haversine formula for distance is:</p><table style="border: 0; " class="simplelist"><tr><td>d = (R)(c)</td></tr></table><p>where <span class="emphasis"><em>R</em></span> = earth’s radius and
      <span class="emphasis"><em>c</em></span> is the angular distance in radians given
      by:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2202.png" alt="Distance"/></div></div><p>Here, <span class="emphasis"><em>a</em></span> is the square of half the chord
      length between the two points, calculated as:</p><table style="border: 0; " class="simplelist"><tr><td>a =
        sin<sup>2</sup>(Δ<sub>lat</sub>/2) +
        cos(lat<sub>1</sub>)cos(lat<sub>2</sub>)sin<sup>2</sup>(Δ<sub>long</sub>
        /2)</td></tr></table><p>Finally:</p><table style="border: 0; " class="simplelist"><tr><td>Δ<sub>long</sub> = long<sub>2</sub> –
        long<sub>1</sub></td></tr><tr><td>Δ<sub>lat</sub> = lat<sub>2</sub> –
        lat<sub>1</sub></td></tr></table><p>Remember to first convert the angles to radians before using them in the trig function.
        Next we will begin showing you an implementation of several different formulas in <a id="I_indexterm3_id357389" class="indexterm"/>Objective-C; however, these should translate to C with little modification.
        These all use the following data structure to hold latitude and longitude
        information:</p><a id="I_programlisting3_id357403"/><pre class="programlisting">typedef enum {
float lat;
float lon;
} Coordinate2D;</pre><p>Given this, the haversine implementation would look like:</p><a id="I_programlisting3_id357412"/><pre class="programlisting">float distanceGreatCircle(Coordinate2D startPoint, Coordinate2D endPoint){

    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * endPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //Calculate half chord legnth
float a = sin(dLat/2) * sin(dLat/2) + cos(lat1) * cos(lat2) * sin(dLon/2) 
                                                           * sin(dLon/2);

//Calculate angular distance
    float C = 2 * atan(sqrt(a)/sqrt(1-a));

//Find arclength
    float distance = 6371 * C; //6371 is radius of earth in km
    return distance;
}</pre><p>One limitation of the preceding method is that if the two locations are <a id="I_indexterm3_id357428" class="indexterm"/>nearly <span class="emphasis"><em>antipodal</em></span>—that is, on opposite sides of the
        earth—then the haversine formula may have round-off issues that could results in errors on
        the order of 2 km. These, however, will be over a distance of 20,000 km. If extreme accuracy
        is required for nearly antipodal coordinates, you can fall back to the spherical law of
        cosines, which is best suited for large distances such as the antipodal case.</p></div><div class="sect2" title="Great-Circle Heading"><div class="titlepage"><div><div><h3 class="title" id="great-circle_heading">Great-Circle Heading</h3></div></div></div><p>As discussed before, to follow the shortest path between two
      points on a <a id="I_indexterm3_id357455" class="indexterm"/><a id="I_indexterm3_id357466" class="indexterm"/>sphere you must travel along a great circle. However, this
      requires that your heading be constantly changing with time. The formula
      to calculate your initial heading, <a id="I_indexterm3_id357474" class="indexterm"/>or <span class="emphasis"><em>forward azimuth</em></span>, is:</p><table style="border: 0; " class="simplelist"><tr><td>Θ<sub>i</sub> =
        atan2[sin(Δ<sub>long</sub>)cos(lat<sub>2</sub>),
        cos(lat<sub>1</sub>)sin(lat<sub>2</sub>) –
        sin(lat<sub>1</sub>)cos(lat<sub>2</sub>)cos(Δ<sub>long</sub>)]</td></tr></table><p>Recall that <a id="I_indexterm3_id357529" class="indexterm"/><code class="literal">atan2</code> is the two-argument variation of the
          <code class="literal">arctangent</code> function. It returns a normalized angle in radians between
        −π and π (−180° and 180°). The code that calculates the value and returns the compass
        bearing is as follows:</p><a id="I_programlisting3_id357546"/><pre class="programlisting">float initialBearing (Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * startPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    // Calculate bearing in radians
float theta = atan2f( sin(dlon) * cos(lat2), cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)
                                                                        *cos(dlon));

//Convert to compass bearing
Float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range
return bearing;
}</pre><p>A negative angle involves starting at 0° and rotating in the decreasing-heading
        direction, but compasses aren’t labeled with negative values! To fix this, the line that has
        the comment “fix range” is using a ternary operator to say that if the bearing is less than
        0, return the value the compass would read. For example, if the bearing were −10°, then the
        compass bearing is −10° + 360° = 350°. If the value is positive, then it just returns the
        same value.</p><p>To find the final bearing, we simply take the initial bearing
      going from the end point to the start point and then reverse it. The
      code is produced as follows:</p><a id="I_programlisting3_id357571"/><pre class="programlisting">float finalBearing (Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * endPoint.lat;
    float lon1 = (M_PI/180.) * endPoint.longi;
float lat2 = (M_PI/180.) * startPoint.lat;
    float lon2 = (M_PI/180.) * startPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //Calculate bearing in radians
float theta = atan2f( sin(dlon) * cos(lat2), cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)
                                                                        *cos(dlon));

//Convert to compass bearing
float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range
bearing = ((bearing + 180) % 360) //reverse heading
return bearing;
}</pre><p>The difference here is that we have flipped <code class="literal">lat1</code>, <code class="literal">long1</code>
      and <code class="literal">lat2</code>, <code class="literal">long2</code> while converting the locations to
      radians. Also, before we return the bearing value, we reverse it by
      adding 180° degrees to it. The modulo operator (<code class="literal">%</code>) ensures that values over 360° are rolled
      over into compass coordinates. For example, if we calculate a bearing of
      350° and add 180° to it, we get 530° degrees. If you start at 0° and go
      around 530°, you’ll end up at 170°. The modulo operator<a id="I_indexterm3_id357622" class="indexterm"/> will result in the bearing being calculated with this
      correct compass value.</p></div><div class="sect2" title="Rhumb Line"><div class="titlepage"><div><div><h3 class="title" id="rhumb_line">Rhumb Line</h3></div></div></div><p>As discussed before, it is <a id="I_indexterm3_id357643" class="indexterm"/>sometimes preferable to take a longer path of constant
      heading, called a rhumb line, as compared to constantly changing your
      heading to follow a great circle path. The rhumb line will be longer
      than the great circle, and the distance you are from the great circle
      route at any moment is called <a id="I_indexterm3_id357654" class="indexterm"/>the <span class="emphasis"><em>cross track error</em></span>. To cross the
      Atlantic is about 5% longer if you follow a rhumb line. The extreme
      example of going from the East Coast of the United States to China is
      about 30% longer. However, such large penalties are rarely encountered
      because ships have to alter course to avoid land! This makes “as the
      crow flies” examples unrealistic.</p><p>If your game is providing navigation information to anyone but pilots, it will probably
        be using rhumb lines. The following are the formulas used to calculate distance and bearing
        between two coordinates on a rhumb line. The easiest way to begin is to flatten the globe.
        In a <a id="I_indexterm3_id357674" class="indexterm"/>Mercator projection, rhumb lines are straight. In fact, this makes graphically
        solving the problem very simple. You use a ruler. Mathematically, things get a bit more
        complicated. The following equation gives Δφ, which is the difference in latitude after
        taking into account that we have stretched them in order to flatten the sphere:</p><table style="border: 0; " class="simplelist"><tr><td>Δφ = ln[tan(lat2/2 + π/4) / tan(lat1/2 + π/4)]</td></tr></table><p>The distance between two points on a rhumb line is given
      by:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2203.png" alt="Rhumb Line"/></div></div><p>The variable <span class="emphasis"><em>q</em></span> is a value whose formula
      depends on Δφ. If Δφ is equal to 0, that means that the calculated
      course is going to be either directly east or west. If that is the case,
      then the intermediate value of <span class="emphasis"><em>q</em></span> is:</p><table style="border: 0; " class="simplelist"><tr><td>q = cos(lat1)</td></tr></table><p>if Δφ is not equal to 0, then:</p><table style="border: 0; " class="simplelist"><tr><td>q = Δ<sub>lat</sub>/Δφ</td></tr></table><p>You can see that if not properly implemented, a direct east or
      west course would result in division by 0. Finally, the constant bearing
      is:</p><table style="border: 0; " class="simplelist"><tr><td>Θ<sub>rhumb</sub> =
        atan2(Δ<sub>long</sub>, Δφ)</td></tr></table><p>There are, in fact, an infinite number of rhumb lines that will get us to our end point.
        However, the longer ones will either take us the wrong way around the globe, or spiral
        around the globe before hitting our end point. At any rate, the shortest route will be the
        one in which Δ<sub>long</sub> is less that 180°. The preceding is implemented in <a id="I_indexterm3_id357781" class="indexterm"/>Objective-C as follows:</p><a id="I_programlisting3_id357793"/><pre class="programlisting">float rhumbBearing ( Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * startPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //find delta phi
    float deltaPhi = log(tan(lat2/2+(M_PI)/4)/tan(lat1+M_PI/4))
    float q=(deltaPhi==0 ? dlat/deltaPhi : cos(lat1); //avoids division by 0

if (abs(dLon) &gt; M_PI){
        dLon = (dLon&gt;0 ? −(2*(M_PI-dLon):(2*M_PI+dLon));
}

float D = sqrt(dLat*dLat + q*q*dLon*dLo)* 6371;
float theta = atan2f(dLon, deltaPhi);

//now convert to compass heading
float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range

return bearing;
}</pre><p>There are a few things worth pointing out. First is that we are
      using a ternary function in the line commented by “avoids division by 0”
      to take care of the case when <code class="literal">deltaPhi</code> is equal to 0. If it is 0,
      <span class="emphasis"><em>q</em></span> is set to <code class="literal">cos(lat1)</code>; if not, then it is set to <code class="literal">dlat/deltaPhi</code>. The <code class="literal">if</code> statement immediately following ensures
      that if <code class="literal">dLon</code> is greater than π
      (180°), hence putting us on a longer-than-required rhumb line, then we
      should correct the value to correspond to the shortest route. This is
      achieved via the ternary, which ensures that <code class="literal">dLon</code> is less than π and nonnegative. Lastly,
      we convert from a normalized radian answer to a compass
      direction.</p><p>Now that you have a good idea about how to calculate position and
      distance in the geographic coordinate system, you can use the earlier
      chapters to determine other quantities like speed and <a id="I_indexterm3_id357858" class="indexterm"/><a id="I_indexterm3_id357868" class="indexterm"/><a id="I_indexterm3_id357878" class="indexterm"/><a id="I_indexterm3_id357887" class="indexterm"/><a id="I_indexterm3_id357896" class="indexterm"/>acceleration.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 23. Pressure Sensors and Load Cells</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch22.html" title="Chapter 22. Gaming from One Place to Another"/><link rel="next" href="ch24.html" title="Chapter 24. 3D Display"/></head><body><section class="chapter" title="Chapter 23. Pressure Sensors and Load Cells" epub:type="chapter" id="pressure_sensors_and_load_cells"><div class="titlepage"><div><div><h2 class="title">Chapter 23. Pressure Sensors and Load Cells</h2></div></div></div><p>Pressure sensors <a id="pr23.0" class="indexterm"/>are an evolution of the simple button. A simple button has two
  states, on or off, which can be used to trigger simple atomic actions in a
  video game such as firing a gun or opening a door. However, simple buttons
  are not capable of informing the program how you, the user, hits that
  button. Did you hit it quickly? Did you barely touch it at all? The only
  thing the program can interpret is that you did in fact hit the
  button.</p><p>With pressure sensors, the program has the ability to discern
  <span class="emphasis"><em>how</em></span> the user pressed the button. This information can
  be used as incremental input, such as the player raising a firearm before
  pressing the button harder to actually fire. Additionally, pressure sensors
  can be used to create novel forms of human-input devices. While pressure
  sensitivity is not uncommon in the more traditional console gaming markets,
  there is also a recent push to move the sensors into touch-screen devices
  like the Nintendo DS and cell phone gaming market. Pressure-sensitive touch
  screens are currently beyond state of the art, however, so we’ll primarily
  discuss the traditional methods already in widespread adoption.</p><p>In addition to pressure sensors, some new gaming consoles <a id="I_indexterm4_id357954" class="indexterm"/><a id="I_indexterm4_id357965" class="indexterm"/>use <span class="emphasis"><em>load cells</em></span> to allow the player to use
  shifts in his or her body weight as input. The method by which this data is
  collected and how the center of gravity is determined will be discussed in
  this chapter. Lastly, some smartphones now include <a id="I_indexterm4_id357982" class="indexterm"/>a <span class="emphasis"><em>barometer</em></span>, a pressure sensor that
  measures the pressure of the atmosphere. What it is used for and the type of
  information it can provide will also be discussed.</p><div class="sect1" title="Under Pressure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="under_pressure">Under Pressure</h2></div></div></div><p>As discussed in <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>,
    <span class="emphasis"><em>pressure</em></span> is a <a id="I_indexterm4_id358019" class="indexterm"/>force applied over an area. Imagine a concrete block sitting
    on a steel plate. The weight of the block will be evenly distributed over
    the area of contact, creating a pressure on the steel plate. Gas and
    liquid can apply pressure as well. The weight of the air pressing down on
    us is what is known <a id="I_indexterm4_id358033" class="indexterm"/><a id="I_indexterm4_id358039" class="indexterm"/>as <span class="emphasis"><em>atmospheric</em></span> pressure.</p><p>Let’s cover a quick example of how to calculate pressure just to
    illustrate the concepts involved. <a id="I_indexterm4_id358057" class="indexterm"/><a id="I_indexterm4_id358070" class="indexterm"/>Pressure has many different units, but all of them can be
    equated to a force divided by an area. For this chapter we’ll stick with
    Newtons per square meter, as this is easiest to visualize. The SI derived
    unit (a unit of measure made up of other fundamental units) is called a
    Pascal, which is just 1 N/m<sup>2</sup>.</p><div class="sect2" title="Example Effects of High Pressure"><div class="titlepage"><div><div><h3 class="title" id="example_effects_of_high_pressure">Example Effects of High Pressure</h3></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3</a>, we discussed the concept of buoyancy
      and how it arises from <a id="I_indexterm4_id358107" class="indexterm"/><a id="I_indexterm4_id358114" class="indexterm"/>hydrostatic pressure. Here, we’ll show the tremendous
      forces that hydrostatic pressure can cause on a submerged object. Let’s
      imagine we have a steel ball filled with normal atmospheric pressure at
      sea level, or about 101,000 N/m<sup>2</sup>. While this
      seems like a lot, your body is used to dealing with this pressure, so
      you don’t even notice it on a daily basis! Now we are going to take this
      ball and drop it into the Marianas trench, the deepest known part of the
      ocean. The water depth here is approximately 10,900 meters. The formula
      for calculating the pressure due to water (hydrostatic pressure)
      is:</p><table style="border: 0; " class="simplelist"><tr><td>P(h) = ρ × g × h</td></tr></table><p>where ρ is the mass density of water, <span class="emphasis"><em>g</em></span> is force due to gravity,
        and <span class="emphasis"><em>h</em></span> is the height of the water column above the object.</p><p>Here we take the standard density for saltwater, 1025
      kg/m<sup>3</sup>, and calculate what the pressure
      is:</p><table style="border: 0; " class="simplelist"><tr><td>P(10,900) = (1025 kg/m<sup>3</sup>) × (9.8
        m/s<sup>2</sup>) × (10,900 m) = 109,490,500
        N/m<sup>2</sup></td></tr></table><p><a class="xref" href="ch23.html#pressure_differential" title="Figure 23-1. Pressure differential">Figure 23-1</a> shows how the pressures
      act against our steel ball.</p><div class="figure"><a id="pressure_differential"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id358202"/><img src="httpatomoreillycomsourceoreillyimages1599003.png.jpg" alt="Pressure differential"/></div></div><div class="figure-title">Figure 23-1. Pressure differential</div></div><p>It is clear that the water pressure acting on the sphere is much
      larger than the air pressure we trapped inside before sinking it. Also,
      note that pressure always acts normal to the surface. If you happen to
      apply a force to the vertex of an object, you’ll have trouble modeling
      the right effect because a vertex does not have a well-defined normal.
      We can overcome this only by applying pressure to the faces of polygons
      or by averaging the direction of the pressure on either side of the
      vertex. Returning to our example, the net pressure differential on the
      steel ball is:</p><table style="border: 0; " class="simplelist"><tr><td>P(water) − P(air) = 10,949,100
        N/m<sup>2</sup>− 101,000
        N/m<sup>2</sup> = 10,848,100
        N/m<sup>2</sup></td></tr></table><p>This is the pressure you would feel if 1,870 elephants were
      standing on a 1-square-meter plate on top of you. If our steel ball had
      walls that were too thin to withstand this pressure differential, it
      would implode. To put this all into perspective, a steel ball in space
      would have a pressure differential of only 1 atmosphere pushing out. It
      is thus much harder to design a structure to go to the bottom of the sea
      than it is to go to the moon. Indeed, more men have stepped foot on the
      lunar surface than have visited the bottom of the sea.</p><p>If the ball were open to the sea, then the pressure would act
      equally on each side of the steel boundary. Without a pressure
      differential, there would be no force to crush the ball; however, there
      would still be compression of the steel shell <a id="I_indexterm4_id358264" class="indexterm"/>itself.</p></div></div><div class="sect1" title="Button Mashing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="button_mashing">Button Mashing</h2></div></div></div><p>While the <a id="pr23.2" class="indexterm"/><a id="bu23.2" class="indexterm"/>preceding example highlights some important concepts about
    pressure in general, it is not usually the type of pressure used as input
    to a game. The most common types of pressure sensors you’ll experience in
    video games are pressure-sensitive buttons that indirectly measure the
    amount of pressure the user is exerting on the button and convert this to
    a relative value. Both Sony and Microsoft have incorporated
    pressure-sensitive (also known as <span class="emphasis"><em>analog</em></span>) buttons
    into their controllers for the PlayStation and Xbox series of
    consoles.</p><p>The method by which you can detect how hard a user is pressing a
    button varies from very simple to very complex. We’ll focus on Sony’s
    method, which is very elegant. A typical push button is just two contacts
    separated by an insulator, most commonly air. When the button is pushed,
    the upper contact moves down and touches the lower contact. This completes
    a circuit, causing a voltage spike, which the device interprets as a
    button press. This is another example of a digital sensor—it is either on
    or off. The buttons in Sony’s controller work a bit differently. In State
    A in <a class="xref" href="ch23.html#pressure-sensitive_button" title="Figure 23-2. Pressure-sensitive button">Figure 23-2</a>, we can see that the
    button is not yet pressed and an air gap exists between the solid
    conductor and the domed flexible conductor. In State B the button is
    depressed with minimal pressure, and the dome just barely makes contact.
    The button is now activated. If the user continues to press down harder on
    the button, the dome deflects and increases the area of contact with the
    fixed conductor; the larger the contact area, the greater the conductivity
    of the connection. This causes a rise in the current flowing in the
    circuit.</p><div class="figure"><a id="pressure-sensitive_button"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id358353"/><img src="httpatomoreillycomsourceoreillyimages1599004.png.jpg" alt="Pressure-sensitive button"/></div></div><div class="figure-title">Figure 23-2. Pressure-sensitive button</div></div><p>By measuring this increase in current, the controller knows how far
    down the button is being pressed. In State D in <a class="xref" href="ch23.html#pressure-sensitive_button" title="Figure 23-2. Pressure-sensitive button">Figure 23-2</a>, the button is at its limit of
    travel and the dome has deflected to its maximum contact area. The
    difference between this maximum and the minimum required to detect contact
    determines the absolute lowest and highest pressure the button is able to
    differentiate. For instance, let us assume that if the button were
    depressed completely, the current would register at
    <span class="emphasis"><em>I</em></span><sub>max</sub>. If the button were not
    pressed at all, of course, the current would be 0. If we call the current
    <span class="emphasis"><em>I</em></span>(<span class="emphasis"><em>t</em></span>) for any time,
    <span class="emphasis"><em>t</em></span>, we see that the ratio
    <span class="emphasis"><em>I</em></span>(<span class="emphasis"><em>t</em></span>)/<span class="emphasis"><em>I</em></span><sub>max</sub>
    gives a nondimensional quantity for how far down the button is pressed.
    During this operation, the hardware converts the analog voltage to a
    digital representation suitable for input to a program. For the Sony
    example, this value is calculated by the hardware and passed as part of
    the data stream from the controller with hex values between 0x00 to 0xFF,
    or in other words, integers 0 to 255 in decimal. This means that each
    button’s travel is divided into 255 parts that your program can
    register.</p><p>While 255 individual increments are beyond the human ability to
    control fingertip pressure, different ranges of pressure have practical
    uses in games. For example, you could program your button to raise a
    weapon with a half-press (0 to 127), bring the weapon to the shoulder with
    more pressure (127 to 250), and to fire when totally depressed (250 to
    255). Of course, those values would have to be tuned for the desired level
    of sensitivity. Another example would be to control the throttle on a car
    by using the values of 0 to 255 as thrust multipliers.</p><p>Another use of knowing a button’s position <a id="I_indexterm4_id358431" class="indexterm"/>would be tracking it over time. With a time history of
    position, you can differentiate to get velocity and again to get
    acceleration. This would allow the program to differentiate between a
    button that is either slowly depressed or quickly depressed. Most hardware
    doesn’t help you here, so you’ll have to store the values and calculate
    the velocities in whatever increments are appropriate for your program. As
    real-time velocity sensing might be taxing to the user as real-time input,
    the best use would be as input to something that the user doesn’t have to
    control constantly. Imagine having to keep a button pressed down at the
    correct pressure for your gameplay for longer than a few minutes; I can
    feel my wrist cramping now. However, the pressure button is useful for
    many inputs. For example, how far a button is pressed down might be used
    to draw back the head of a putter, while the speed at which the button is
    released could be used to determine the speed at which the putter is
    brought back to the <a id="I_indexterm4_id358451" class="indexterm"/><a id="I_indexterm4_id358459" class="indexterm"/>ball.</p><div class="sect2" title="Load Cells"><div class="titlepage"><div><div><h3 class="title" id="load_cells">Load Cells</h3></div></div></div><p>Beyond simple <a id="pr23.2.1" class="indexterm"/><a id="I_indexterm4_id358498" class="indexterm"/>buttons, there are other novel ways to use pressure
      sensors to allow a user to interact with your games. For example,
      Nintendo’s Wii uses a balance board peripheral based on load cells to
      detect a person’s <a id="I_indexterm4_id358511" class="indexterm"/>stance.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The original idea for the Nintendo balance board came to video
        game designer Shigeru Miyamoto after he was inspired by watching sumo
        wrestlers weigh themselves with each leg on a different scale. They
        are too heavy to use one scale!</p></div><div class="sect3" title="Tiny scales"><div class="titlepage"><div><div><h4 class="title" id="tiny_scales">Tiny scales</h4></div></div></div><p>Load cells work <a id="I_indexterm4_id358542" class="indexterm"/>differently than the pressure-sensitive buttons
        described previously, but like pressure-sensitive buttons, they come
        in different types, all of which measure the load pressing on them.
        The most common way, and the one used in the Nintendo balance board
        we’ll discuss shortly, is through what is <a id="I_indexterm4_id358556" class="indexterm"/>called a <span class="emphasis"><em>strain gauge</em></span>.</p><p>A strain gauge, as you might be able to guess, does not measure
        force directly but instead measures how much strain the gauge is
        experiencing. Strain is a measure of how much a rigid body has
        deformed independent of its rigid-body motion. While there are several
        notions of strain in continuum mechanics, the one we are concerned
        with here is often <a id="I_indexterm4_id358574" class="indexterm"/>referred to as <span class="emphasis"><em>engineering strain</em></span>.
        This type of strain quantifies how much a structural element has
        deformed compared to its original, or <span class="emphasis"><em>rest</em></span>,
        length. We normalize this by dividing the change in length over the
        rest length. By testing the material, one can develop a stress versus
        strain curve that relates how much stress it takes to cause a certain
        amount of strain. Once the pressure that causes an amount of strain is
        known, it is possible to determine the amount of load. Now you might
        be wondering how the strain gauge measures the amount that the Wii’s
        legs compress when you stand on them.</p><p>One of the most common electronic strain <a id="I_indexterm4_id358598" class="indexterm"/>gauges is the <span class="emphasis"><em>piezoresistive strain
        gauge</em></span>. The simplest example of a piezoresistive strain
        gauge would be a single wire. If you were to elongate a wire from its
        rest length, the cross-sectional area decreases. This causes a rise in
        the electrical resistance of the wire. After measuring the rest
        resistance, you can use the difference to determine how much the wire
        has elongated. Knowing the mechanical properties of the wire, you can
        also determine how much force it takes to stretch the wire.</p><p>To make strain gauges sensitive without having long linear wire
        elements, the conductive material is often arranged in a
        strain-sensitive pattern, as shown in <a class="xref" href="ch23.html#typical_strain-sensitive_pattern" title="Figure 23-3. Typical strain-sensitive pattern">Figure 23-3</a>. This looping back and
        forth of the conductor allows for great sensitivity without increasing
        the physical space the sensor occupies. Here the rest length would be
        18 times longer than the physical length of the sensor.</p><div class="figure"><a id="typical_strain-sensitive_pattern"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id358637"/><img src="httpatomoreillycomsourceoreillyimages1599005.png" alt="Typical strain-sensitive pattern"/></div></div><div class="figure-title">Figure 23-3. Typical strain-sensitive pattern</div></div></div><div class="sect3" title="Center of gravity"><div class="titlepage"><div><div><h4 class="title" id="center_of_gravity">Center of gravity</h4></div></div></div><p>The board <a id="lo23.2.1.2" class="indexterm"/><a id="ce23.2.1.2" class="indexterm"/>has four legs, each of which houses a load sensor. The
        board uses strain gauges similar to those discussed earlier. These
        gauges elongate when a force is applied to them. The elongation
        changes the electrical resistance of the circuit of which the strips
        are a part, and this is reported back to the controller. <a class="xref" href="ch23.html#balance_board_example" title="Figure 23-4. Balance board example">Figure 23-4</a> shows two sensor outputs. The first
        is with the user standing so that her center of gravity is over the
        center of the board. The second state shows what the board’s sensors
        would measure after the user has shifted her center of gravity.</p><div class="figure"><a id="balance_board_example"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id358721"/><img src="httpatomoreillycomsourceoreillyimages1599006.png" alt="Balance board example"/></div></div><div class="figure-title">Figure 23-4. Balance board example</div></div><p>It is easy to intuitively recognize that the center of gravity
        must be over the center of the board in State A and toward the
        lower-right corner in State B. However, to get the exact location of
        the center of gravity in State B, we’ll have to do a little more work.
        First things first: we have to define a coordinate system. This is
        shown in <a class="xref" href="ch23.html#balance_board_coordinate_system" title="Figure 23-5. Balance board coordinate system">Figure 23-5</a>.</p><div class="figure"><a id="balance_board_coordinate_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id358761"/><img src="httpatomoreillycomsourceoreillyimages1599007.png" alt="Balance board coordinate system"/></div></div><div class="figure-title">Figure 23-5. Balance board coordinate system</div></div><p>This coordinate system is arbitrary. If the board isn’t a
        perfect square, such as with the Wii board, then the coordinates of
        the load cells must be changed accordingly. Now that we have defined
        the location of the center of the board and the position of the load
        cells, we can use a <a id="we23.2.1.2" class="indexterm"/>weighted average to compute the location of the user’s
        center of gravity. The weight that we give each value will depend on
        how much of the user’s weight is on each of the four corners. That
        weight will “pull” the center of gravity toward the location of the
        load cells as defined in our coordinate system. How much each load
        cell mathematically pulls the center of gravity will be based on the
        weight supported at that location. This is most easily determined via
        two tables, one for the <span class="emphasis"><em>x</em></span> coordinate (<a class="xref" href="ch23.html#x_coordinate_weighted_average" title="Table 23-1. x coordinate weighted average">Table 23-1</a>) and one for the
        <span class="emphasis"><em>y</em></span> coordinate (<a class="xref" href="ch23.html#y_coordinate_weighted_average" title="Table 23-2. y coordinate weighted average">Table 23-2</a>).</p><div class="table"><a id="x_coordinate_weighted_average"/><div class="table-title">Table 23-1. x coordinate weighted average</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Load
                cell</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Weight</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Arm</p></td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Weight ×
                Arm</p></td></tr></thead><tbody><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(1,1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>30</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(−1,1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>−1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−15</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(−1,−1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>−1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−20</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(1,−1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>35</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Total:</strong></span></p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>30</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; "><p><span class="strong"><strong>Average:</strong></span></p></td><td style="text-align: center; vertical-align: top; "><p>30/100 =
                0.30</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch23.html#x_coordinate_weighted_average" title="Table 23-1. x coordinate weighted average">Table 23-1</a> takes the
        weight in each corner and multiplies that value by the value of its
        <span class="emphasis"><em>x</em></span> coordinate. This is equivalent to a moment.
        Taking the sum of those moments (30) and dividing by the total weight
        gives the average value of 0.30, or .3 units to the right in our
        coordinate system. The y-axis is treated similarly.</p><div class="table"><a id="y_coordinate_weighted_average"/><div class="table-title">Table 23-2. y coordinate weighted average</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Load
                cell</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Weight</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Arm</p></td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Weight ×
                Arm</p></td></tr></thead><tbody><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(1,1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>30</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>30</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(−1,1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>15</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(−1,−1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>20</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>−1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−20</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(1,−1)</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>−1</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−35</p></td></tr><tr><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>Total:</strong></span></p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−10</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; "><p><span class="strong"><strong>Average:</strong></span></p></td><td style="text-align: center; vertical-align: top; "><p>−10/100 =
                −0.10</p></td></tr></tbody></table></div></div><p>Using a similar weighted average as shown in <a class="xref" href="ch23.html#y_coordinate_weighted_average" title="Table 23-2. y coordinate weighted average">Table 23-2</a>, we see that the user’s
        center of gravity is −0.10, or 0.1 units behind the center. If we were
        using this to control an onscreen sprite, we could define a 2D
        direction vector based on this information.</p><p>In addition to just determining the center of gravity, you can
        use this information to make educated guesses on what else the user is
        doing to cause the load distributions. After computing the center of
        gravity, the Wii uses what Nintendo <a id="I_indexterm4_id359499" class="indexterm"/><a id="I_indexterm4_id359506" class="indexterm"/>calls a <span class="emphasis"><em>motion-identifying condition
        table</em></span> to guess what movements the user is making. The table
        correlates the ratio of the sum of the load values to the body weight
        of the user and the position of the center of gravity to determine
        body orientation. For example, the Wii can tell if both of the user’s
        feet are on the board, or if the user is accelerating part of his leg.
        The table provided in the Wii patent is reproduced in <a class="xref" href="ch23.html#motion-identifying_condition_table" title="Table 23-3. Motion-identifying condition table">Table 23-3</a>.</p><div class="table"><a id="motion-identifying_condition_table"/><div class="table-title">Table 23-3. Motion-identifying condition table</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/><col class="col3"/></colgroup><thead><tr><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Motion</p></td><td style="text-align: center; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Ratio of load
                value to body weight value</p></td><td style="text-align: center; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Position of the
                center of gravity</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Right foot
                riding</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25 to
                75%</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>+0.01 to
                +1.0</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Both feet
                riding</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>More than
                95%</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−0.7 to
                +0.7</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Left foot
                riding</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>25 to
                75%</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−1.0 to
                −0.01</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Left thigh
                lifting</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>More than
                100%</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>+0.01 to
                +1.0</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Right thigh
                lifting</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>More than
                100%</p></td><td style="text-align: center; vertical-align: top; border-bottom: 0.5pt solid ; "><p>−1.0 to
                −0.01</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Both feet putting
                <a id="I_indexterm4_id359774" class="indexterm"/><a id="I_indexterm4_id359784" class="indexterm"/><a id="I_indexterm4_id359794" class="indexterm"/><a id="I_indexterm4_id359803" class="indexterm"/>down</p></td><td style="text-align: center; vertical-align: top; border-right: 0.5pt solid ; "><p>Less than
                5%</p></td><td style="text-align: center; vertical-align: top; "><p>Not
                considered</p></td></tr></tbody></table></div></div></div></div></div><div class="sect1" title="Barometers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="barometers">Barometers</h2></div></div></div><p>Continuing our <a id="ba23.3" class="indexterm"/>exploration of new user input methods, especially in the
    rapidly maturing mobile device gaming market, now we’ll discuss an
    interesting inclusion in the latest smartphones: a barometer. Unlike
    buttons and balance boards, whose pressure sensors only indirectly handle
    pressure, barometers directly measure the fluid pressure that the
    atmosphere exerts on the sensor.</p><p>The sensors used in mobile phones today are <a id="I_indexterm4_id359867" class="indexterm"/>piezoresistive <a id="I_indexterm4_id359874" class="indexterm"/><a id="I_indexterm4_id359881" class="indexterm"/>microelectromechanical systems (MEMS) and are very accurate.
    As shown in <a class="xref" href="ch23.html#mems_piezoresistive_pressure_sensor" title="Figure 23-6. MEMS piezoresistive pressure sensor">Figure 23-6</a>, the
    sensors consist of a void machined into a piece of silicon. The diaphragm
    is then bonded to a stiff material such as steel or glass. As we are
    trying to measure <span class="emphasis"><em>absolute pressure</em></span>, this bond is
    airtight. Using a material called <span class="emphasis"><em>monocrystalline semiconductor
    silicon</em></span> to form the void ensures that the entire diaphragm acts
    much like a piezoresistive strain gauge.</p><div class="figure"><a id="mems_piezoresistive_pressure_sensor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_id359912"/><img style="width: 394.2; " src="httpatomoreillycomsourceoreillyimages1599008.png" alt="MEMS piezoresistive pressure sensor"/></div></div><div class="figure-title">Figure 23-6. MEMS piezoresistive pressure sensor</div></div><p>Now we have a situation similar to the steel ball in the ocean, only
    this time it is a tiny silicon ball in the ocean of air surrounding the
    earth. When the sensor is moved deeper or shallower in the atmospheric
    ocean, the pressure on the outside of the diaphragm changes. This causes
    the pressure differential to change and a force to be exerted on the
    silicon diaphragm. This force causes a deflection that changes the
    resistance of the piezoresistive material and can therefore be measured by
    the sensor. This part will be taken care of by the hardware and the
    encoded value sent to the operating system.</p><p>To give you an example, in the Android operating system, the API has a public method,
        <code class="literal">getAltitude(float p0, float p)</code>, to determine altitude, <a id="I_indexterm4_id359954" class="indexterm"/>in meters, between the sensor pressure and the pressure at sea level. It usually
      reads the current <a id="I_indexterm4_id359966" class="indexterm"/><a id="I_indexterm4_id359972" class="indexterm"/>atmospheric pressure, <code class="literal">p</code>, from the sensor by
      listening to sensor manager callback interface method <code class="literal">abstract void
        onSensorChanged(SensorEvent event)</code>. Here the class <code class="literal">event</code> holds the sensor values, the accuracy of those values, a reference to the
      sensor itself, and a timestamp for when the event occurred. The pressure is <a id="I_indexterm4_id360002" class="indexterm"/><a id="I_indexterm4_id360008" class="indexterm"/>reported in hectoPascals (hPa) or 100 N/m<sup>2</sup>. The
      sea-level pressure, <code class="literal">p0</code>, that this is compared to is either
      obtained from an online database or is set at the constant <code class="literal">SensorManager.PRESSURE_STANDARD_ATMOSPHERE</code>. As pressure at sea level changes with
      different weather conditions, we obtain higher accuracy by retrieving it from a nearby airport
      or other weather station via the Internet. To get the change in altitude between two points,
      you must repeat this process twice as follows:</p><a id="I_programlisting4_id359946"/><pre class="programlisting">float altitude_difference = 
getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, 
     pressure_at_point2) -
getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE,
     pressure_at_point1);</pre><p>At first it may seem strange for your cell phone to have a barometer
    in it; however, the barometer’s ability to detect the air pressure allows
    you to make a good guess on your altitude. As shown in <a class="xref" href="ch22.html" title="Chapter 22. Gaming from One Place to Another">Chapter 22</a>, in order to determine your
    position via <a id="I_indexterm4_id360051" class="indexterm"/><a id="I_indexterm4_id360060" class="indexterm"/>GPS you have to solve a four-dimensional set of linear
    equations. The time required to solve these equations can be dramatically
    decreased if you know approximately where you are to begin with.
    Currently, the position of which cell phone tower your phone is connected
    to is used as a starting point. Using a barometer allows the device to
    guess its altitude to further reduce the time to obtain a GPS fix.</p><p>While the sensor was included for a specific purpose, it can also be
    adapted as an input device. For instance, the Bosch BMP180 currently being
    included in devices is accurate to plus or minus one meter. In fact,
    Google Maps<a id="I_indexterm4_id360081" class="indexterm"/> now provides indoor directions, including knowing what
    floor you are on in airports and shopping malls. This functionality could
    be used to aid in the location-based gaming discussed in <a class="xref" href="ch22.html" title="Chapter 22. Gaming from One Place to Another">Chapter 22</a> by giving it greater
    resolution in the vertical dimension. It could also be used to determine
    if the user is holding the phone near her feet or her head, further
    augmenting the orientation sensing discussed in <a class="xref" href="ch21.html" title="Chapter 21. Accelerometers">Chapter 21</a>. Of course, it can also be used to help
    weather forecasting and allow you to have real-life changes in pressure
    affect in-game <a id="I_indexterm4_id360103" class="indexterm"/>events.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 24. 3D Display</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch23.html" title="Chapter 23. Pressure Sensors and Load Cells"/><link rel="next" href="ch25.html" title="Chapter 25. Optical Tracking"/></head><body><section class="chapter" title="Chapter 24. 3D Display" epub:type="chapter" id="d_display"><div class="titlepage"><div><div><h2 class="title">Chapter 24. 3D Display</h2></div></div></div><p>For all the work <a id="I_indexterm5_id360128" class="indexterm"/>we’ve done to make programs’ graphics more realistic, the best
  we can do is project our realistic simulations onto a two-dimensional
  screen. Although graphics libraries such as Microsoft DirectX and OpenGL can
  provide photorealistic renderings in real time, they still lack the ability
  to truly immerse the user in the works you have so carefully created.
  Three-dimensional display is something that the entertainment industry has
  attempted to make standard for some time. In reality, almost all
  “three-dimensional” display technologies are what are technically <a id="I_indexterm5_id360147" class="indexterm"/><a id="I_indexterm5_id360157" class="indexterm"/>called <span class="emphasis"><em>stereoscopic</em></span> displays. These
  displays use the way in which your eyes perceive depth to trick your brain
  into thinking it is seeing a three-dimensional image while the display
  remains two-dimensional. In contrast, displays that actually involve
  creating a rendering in three dimensions are <a id="I_indexterm5_id360174" class="indexterm"/>called <span class="emphasis"><em>volumetric</em></span> displays. We’ll cover
  these later as part of our effort to discuss emerging technologies.</p><div class="sect1" title="Binocular Vision"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="binocular_vision">Binocular Vision</h2></div></div></div><p>The trick to <a id="tr24.1" class="indexterm"/><a id="bi24.1" class="indexterm"/>displaying objects so that they appear to be
    three-dimensional depends on the method by which the human brain perceives
    the world around it. Indeed, animals that have two eyes engage in what is
    called <span class="emphasis"><em>binocular vision</em></span>. Because each eye is in a
    slightly different position relative to the objects it is viewing, the
    left and right eye provide an image that is distinct to the brain. This is
    called<a id="I_indexterm5_id360239" class="indexterm"/> <span class="emphasis"><em>binocular disparity</em></span>. There are three
    possible results when the brain encounters these two different images:
    suppression, fusion, or summation. <span class="emphasis"><em>Suppression</em></span> is
    <a id="I_indexterm5_id360254" class="indexterm"/>when the brain ignores one of the images,
    <span class="emphasis"><em>summation</em></span> is <a id="I_indexterm5_id360266" class="indexterm"/>when the brain tries to perceive both images at the same
    time (double vision), and <a id="I_indexterm5_id360273" class="indexterm"/>finally <span class="emphasis"><em>fusion</em></span> is mixing the two images
    to create a depth of field. The process of binocular fusion is something
    our brain learns to do when we are first born.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Given the way that eyes focus light, we are born seeing the world
      upside down! After a few days, our brains instinctively flip the images
      over so that the motion of our hands matches the motion that we observe.
      There have even been tests where people wearing glasses that invert your
      vision will eventually see the images right side up. When they take off
      the glasses, everything looks upside down again until their brain has
      time to correct the image.</p></div><p>Binocular fusion is also a learned behavior of the brain. The visual
    cortex takes the independent visual information from each eye and fuses it
    into a single image. Your brain does this as a way of organically
    calculating the distance to objects so that you can efficiently interact
    with the three-dimensional world. The exact process by which your brain
    accomplishes this is an area of active research. In fact, researchers have
    found that two images need not have any geometrical disparity in order to
    be fused. That is, if you take the exact same photograph of the same
    object and the same angle, but with different lighting, the shadows being
    cast can also cause the brain to recreate the object in three
    dimensions.</p><p><span class="emphasis"><em>Parallax</em></span> is the <a id="I_indexterm5_id360310" class="indexterm"/>distance an object moves between the left- and right-eye
    images. You can easily demonstrate it by holding your thumb six inches
    from your face and closing one of your eyes. Block some of the words on
    this page with your thumb. Now open that eye and close the other one. The
    words that were behind your thumb should now be visible. This is because
    your eyes are not in the same position, so the different angles provide
    slightly different pictures of the page. This distance your thumb appeared
    to move is the parallax at that distance from your eye.</p><p>Fusion is a little harder to achieve, but <a class="xref" href="ch24.html#cone_stereopair" title="Figure 24-1. Cone stereopair">Figure 24-1</a> provides an interesting example. The two
    circles are set a specific distance apart and show the top of a truncated
    cone coming out of the page. The top of the cone is offset compared to the
    bottom. This offset is in opposite directions, mimicking how your eyes
    would see it if you were directly over the cylinder.</p><div class="figure"><a id="cone_stereopair"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id360346"/><img src="httpatomoreillycomsourceoreillyimages1599009.png" alt="Cone stereopair"/></div></div><div class="figure-title">Figure 24-1. Cone stereopair</div></div><p>The best way to view the stereopair shown in <a class="xref" href="ch24.html#cone_stereopair" title="Figure 24-1. Cone stereopair">Figure 24-1</a> is to begin by looking above this book at a
    far-off object. Now lower your gaze without refocusing your eyes and stare
    between the two sets of circles. With some trying, your brain should be
    able to fuse the images so that there are now three sets of circles. The
    original two will be out of focus, and the center set should appear to be
    three-dimensional. You can also get the sets to fuse by crossing your
    eyes; however, this is much less comfortable than using your eyes in their
    distance-viewing configuration.</p><p>Given that your brain is excellent at real-time pattern recognition,
    it can also compare visual information over time to get a sense of size
    and relative distance. This is <a id="I_indexterm5_id360386" class="indexterm"/>called <span class="emphasis"><em>movement parallax</em></span>, and it causes
    objects that are closer to you to appear to move faster when you move your
    head than objects that are farther away. For example, if you are driving
    in a car, you’ll notice that the trees appear to move faster than the
    moon. This is because the trees are very close in comparison to the moon.
    Your brain uses this apparent speed disparity to help conclude that the
    moon is very far away indeed. In the next chapter we’ll discuss how
    computer algorithms attempt this sort of pattern recognition.</p><p>In fact, according to <span class="emphasis"><em>Flight Simulation</em></span> (edited
    by J. M. Rolfe and K. J. Staples; Cambridge University Press), the process
    of 3D visualization depends on the following eight major factors.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Occlusion of one object by another</p></li><li class="listitem"><p>Subtended visual angle of an object of known size</p></li><li class="listitem"><p>Linear perspective (convergence of parallel edges)</p></li><li class="listitem"><p>Vertical position (objects higher in the scene generally tend to
        be perceived as farther away)</p></li><li class="listitem"><p>Haze, desaturation, and a shift to bluishness</p></li><li class="listitem"><p>Change in size of textured pattern detail</p></li><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/stereopsis" target="_top">Stereopsis</a></p></li><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/accommodation_(eye)" target="_top">Accommodation
        of the eyeball</a> (eyeball focus)</p></li></ul></div><p>A standard 3D graphics library is capable of giving the appearance
    of three dimensions on the screen, just as any good painter on a canvas.
    Both standard 3D libraries and painters do their job by recreating the
    first six items in the preceding list. To further the illusion, 3D display
    technology simulates the seventh, stereopsis. Stereopsis <a id="I_indexterm5_id360490" class="indexterm"/>is impression of depth generated by the fact that you have
    two eyeballs looking at slightly different angles. In short, the graphics
    library renders two different images, one for each eye, that have a
    parallax shift. These images are then delivered to each eye separately.
    The method by which the images are segregated varies from technology to
    technology. We will discuss these in a little bit.</p><p>The last item on the list, accommodation of the eyeball, is the
    process by which your eye changes shape to focus at different distances.
    By correlating the shape of your eye with the distance to the object,
    accommodation works as one of the pieces of information your brain uses to
    determine depth. As current 3D displays still use a 2D screen, the eyes
    are still focusing on the same plane regardless of the object’s perceived
    depth; therefore, the eighth item in the list is not recreated. This is
    why most 3D displays still do not seem completely real. Some technologies,
    such as holograms and volumetric displays, allow for accommodation of the
    eyeball, but usually at the expense of some other factor. We’ll touch on
    these beyond state-of-the-art technologies near the end of the <a id="I_indexterm5_id360514" class="indexterm"/><a id="I_indexterm5_id360524" class="indexterm"/>chapter.</p></div><div class="sect1" title="Stereoscopic Basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="stereoscopic_basics">Stereoscopic Basics</h2></div></div></div><p>There are <a id="th24.2" class="indexterm"/><a id="I_indexterm5_id360563" class="indexterm"/>some extra considerations when it comes using today’s 3D
    display technologies to recreate the images that would usually be provided
    to the visual cortex by binocular vision. Normally two eyes create two
    images that the brain combines with a biological depth map. The earliest
    stereoscopic images were generated in the 1800s from two photographs taken
    from slightly different positions. The viewer would then look at the
    photos through what came to be known as a stereoscope. This device was
    essentially an early example of the View-Master that some of you might
    remember from childhood. While the principle of showing unique images to
    each eye is straightforward in this case, it doesn’t allow group viewing
    and requires that the user have something pressed against his eyes. To
    make 3D display something that a group of people can all experience
    together and in some cases even without the aid of any headgear, we must
    look at some more sophisticated methods of segregating the right and left
    images.</p><div class="sect2" title="The Left and Right Frustums"><div class="titlepage"><div><div><h3 class="title" id="the_left_and_right_frustum">The Left and Right Frustums</h3></div></div></div><p>If you are <a id="st24.2.1" class="indexterm"/><a id="vi24.2.1" class="indexterm"/><a id="fr24.2.1" class="indexterm"/>familiar with computer graphics, the concept of the
      <span class="emphasis"><em>viewing frustum</em></span> is not alien to you. If you aren’t,
      we’ll take a second to go over it, but it might be worthwhile to read
      about it in detail before you continue. The viewing frustum is the
      region of space in the model world that the camera can see from its
      given position in that world. In a normal 3D graphic rendering, the
      frustum is clipped by a near plane that represents the screen distance.
      In essence, you cannot render something closer to the user than the
      screen plane. If you remember things jumping out of the screen in the
      last 3D movie you saw, you can probably guess that when we are using
      stereoscopic rendering, this no longer holds true. A normal computer
      graphics frustum is shown in <a class="xref" href="ch24.html#normal_viewing_frustum" title="Figure 24-2. Normal viewing frustum">Figure 24-2</a>.</p><div class="figure"><a id="normal_viewing_frustum"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id360669"/><img src="httpatomoreillycomsourceoreillyimages1599010.png" alt="Normal viewing frustum"/></div></div><div class="figure-title">Figure 24-2. Normal viewing frustum</div></div><p>When using a stereoscopic 3D display library, we no longer have a
      single viewing frustum. Instead we have two cameras that are
      horizontally displaced from the 2D camera, as shown in <a class="xref" href="ch24.html#viewing_geometry_of_a_stereoscopic_displ" title="Figure 24-3. Viewing geometry of a stereoscopic display">Figure 24-3</a>.</p><div class="figure"><a id="viewing_geometry_of_a_stereoscopic_displ"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id360718"/><img src="httpatomoreillycomsourceoreillyimages1599011.png" alt="Viewing geometry of a stereoscopic display"/></div></div><div class="figure-title">Figure 24-3. Viewing geometry of a stereoscopic display</div></div><p>These two cameras, offset from the monocular camera, generate a left and right frustums.
        As you can see, there is a location where these two frustums intersect; this is <a id="I_indexterm5_id360744" class="indexterm"/><a id="I_indexterm5_id360751" class="indexterm"/>called the <span class="emphasis"><em>convergence distance</em></span>. Objects that are placed at
        the convergence distance will have the same appearance to both cameras. Note that the
        cameras are all pointed in the same direction; this is called the <span class="emphasis"><em>off-axis
          method</em></span>. <a id="I_indexterm5_id360770" class="indexterm"/>This requires the frustums to be asymmetric, which most modern graphics
        libraries support. Now, at first glance, it might be tempting to toe-in the two frustums so
        that each <a id="I_indexterm5_id360779" class="indexterm"/>camera’s frustums are symmetrical, as shown in <a class="xref" href="ch24.html#toe-in_method_open_parenthesis_incorrect" title="Figure 24-4. Toe-in method (incorrect)">Figure 24-4</a>.</p><div class="figure"><a id="toe-in_method_open_parenthesis_incorrect"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id360812"/><img src="httpatomoreillycomsourceoreillyimages1599012.png" alt="Toe-in method (incorrect)"/></div></div><div class="figure-title">Figure 24-4. Toe-in method (incorrect)</div></div><p>This will create workable stereopairs, but along with the
      horizontal parallax will introduce some vertical parallax. This can
      cause eyestrain to the viewer and should be avoided. Instead, the
      off-axis technique should be used; it is illustrated in <a class="xref" href="ch24.html#off-axis_method_open_parenthesis_correct" title="Figure 24-5. Off-axis method (correct)">Figure 24-5</a>. One of the
      objects is beyond the screen in the background, and one is in front of
      the screen.</p><div class="figure"><a id="off-axis_method_open_parenthesis_correct"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id360864"/><img src="httpatomoreillycomsourceoreillyimages1599013.png" alt="Off-axis method (correct)"/></div></div><div class="figure-title">Figure 24-5. Off-axis method (correct)</div></div><p>You can see that if you wish to move something to greater than
      screen depth, the object must be shown farther to the left than if it
      were at screen depth for the left eye image. For the right eye image,
      the object must be shown farther to the right. If you want to show
      something coming out of the screen, the opposite is true. The left eye
      will see the object as farther to the right than if it were at screen
      depth. Also note that each object will have a slightly different angle
      as well. Again, the distance between the right eye image placement and
      the left eye image placement is referred to as parallax. The amount and
      relative orientation of parallax is the chief way your brain creates 3D
      images. In fact, the most important aspect of the physics of
      stereoscopic display for programmers to understand is that there is a
      parallax budget that they must use wisely in developing programs that
      take advantage of 3D display. This budget defines the ranges of parallax
      that your viewer’s brain will be able to accept comfortably. We’ll
      discuss this in detail at the end of the chapter.</p><p>For now, we’ll consider that if we were to just show the right and
      left images on a screen without further work, you’d end up seeing two
      images with both eyes and no 3D effect would be produced. It is
      paramount that the image intended for the left eye is seen only by the
      left eye and vice versa. These two channels, the left and right eye,
      must be kept as separate as possible. Let’s see what the current options
      are for achieving <a id="I_indexterm5_id360901" class="indexterm"/><a id="I_indexterm5_id360910" class="indexterm"/><a id="I_indexterm5_id360919" class="indexterm"/><a id="I_indexterm5_id360928" class="indexterm"/>such separation.</p></div></div><div class="sect1" title="Types of Display"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="types_of_display">Types of Display</h2></div></div></div><p>As just explained, <a id="th24.3" class="indexterm"/>3D display technology depends on providing two distinct
    images, one to each eye. In the next sections we’ll discuss the common
    techniques used today.</p><div class="sect2" title="Complementary-Color Anaglyphs"><div class="titlepage"><div><div><h3 class="title" id="complementary-color_anaglyphs">Complementary-Color Anaglyphs</h3></div></div></div><p>Anyone who saw a 3D movie in the 80s <a id="I_indexterm5_id360987" class="indexterm"/><a id="I_indexterm5_id360994" class="indexterm"/>remembers the cheap red and blue glasses one had to wear
      to get the effect. These were <span class="emphasis"><em>complementary-color
      anaglyphs</em></span>. An anaglyph is the technique of encoding the
      separate images in a single photograph or video frame using color
      filters. The method calls for two horizontally shifted images to be
      viewed simultaneously. The images will contain the two images tinted in
      opposite colors of the scheme. While there are many color combinations
      that can be used, the most common today are red and cyan. These colors
      are chosen because the cyan and red filters are the most exclusive. Red
      and green filters were used earlier, but the green filter allows too
      much red light to leak through. This can <a id="I_indexterm5_id361011" class="indexterm"/>cause what is called <span class="emphasis"><em>binocular
      rivalry</em></span>, where your brain has a hard time figuring out which
      depth map to use. One way to illustrate this is via the simple drawing
      of a transparent cube, as shown in <a class="xref" href="ch24.html#cube_demonstrating_binocular_rivalry" title="Figure 24-6. Cube demonstrating binocular rivalry">Figure 24-6</a>.</p><div class="figure"><a id="cube_demonstrating_binocular_rivalry"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id361039"/><img src="httpatomoreillycomsourceoreillyimages1599014.png" alt="Cube demonstrating binocular rivalry"/></div></div><div class="figure-title">Figure 24-6. Cube demonstrating binocular rivalry</div></div><p>If you focus on the cube in <a class="xref" href="ch24.html#cube_demonstrating_binocular_rivalry" title="Figure 24-6. Cube demonstrating binocular rivalry">Figure 24-6</a>, your brain may start
      to flip between interpreting the upper face as forward of the lower
      face, and the lower face being forward. While this is caused by
      incomplete depth cues, the same uneasy feeling can be caused when your
      brain receives leaks across the two channels in a stereoscopic display.
      As you can imagine, this would be pretty annoying during a video
      game.</p><p>As the glasses don’t require any electronics to do this, it is an
      example of passive 3D technology. The major drawback of this method is
      that the red component of the images is muted to the viewer. There are
      many improvements that can be made to the system to correct the color
      and account for some fuzziness. One example is the patented ColorCode
      3D, which uses amber and blue filters. The advantage of this system is a
      nearly full color space and a fairly good image when not viewed with the
      glasses.</p><p>Anaglyphs fell out of favor with movie and game producers when
      polarization techniques came into maturity. These produce better color
      reproduction and reduce eyestrain. However, given the relatively
      inexpensive glasses required and that nothing special is required of the
      display other than that it be capable of displaying colors, anaglyphs
      have had a resurgence in printed material and online.</p></div><div class="sect2" title="Linear and Circular Polarization"><div class="titlepage"><div><div><h3 class="title" id="linear_and_circular_polarization">Linear and Circular Polarization</h3></div></div></div><p>As polarized light plays a very<a id="lip24.3.2" class="indexterm"/><a id="ci24.3.2" class="indexterm"/><a id="po24.3.2" class="indexterm"/><a id="li24.3.2" class="indexterm"/> important part in the largest 3D displays, movie screens,
      we’ll review what polarization of light means and how to accomplish it.
      Light can be thought of as an electromagnetic wave traveling through
      space. Let’s begin our discussion by considering a common light bulb. It
      emits electromagnetic waves in all directions and is nominally “white.”
      An electromagnetic wave <a id="I_indexterm5_id361150" class="indexterm"/>oscillates perpendicularly to its line of travel. This is
      <a id="I_indexterm5_id361158" class="indexterm"/>called a <span class="emphasis"><em>transverse wave</em></span>. In
      comparison, sound waves oscillate in the same direction they travel,
      creating regions of higher density. These <a id="I_indexterm5_id361170" class="indexterm"/>are called <span class="emphasis"><em>longitudinal waves</em></span>. Only
      transverse waves can be polarized because only transverse waves have
      oscillation in multiple orientations. Going back to our light bulb, it
      is emitting “dirty” light in that the electromagnetic waves are all at
      random orientations.</p><p>Most sources of electromagnetic radiation (i.e., light) are
      composed of many molecules that all have different orientations when
      they emit light, so the light is unpolarized. If that light passes
      through a polarization filter, it leaves the filter with the
      oscillations in only one direction. In fact, there are two types of
      filters. <span class="emphasis"><em>Linear filters</em></span> <a id="I_indexterm5_id361193" class="indexterm"/>produce oscillations in one direction. <span class="emphasis"><em>Circular
      filters</em></span> (a special case of elliptical filters) create
      circularly polarized light that rotates in an either righthand or
      lefthand direction. As circular filters depend on linear filters first,
      we’ll discuss those now.</p><p>The simplest and most common linear filter is the <a id="I_indexterm5_id361214" class="indexterm"/>wire-grid polarizer. Imagine many very fine wires running
      parallel to one another with small gaps between them, as shown in <a class="xref" href="ch24.html#wire-grid_polarization" title="Figure 24-7. Wire-grid polarization">Figure 24-7</a>. When unpolarized light hits the
      wires, the oscillations that are parallel to the waves excite the
      electrons in the wire and move them along the length of the wire. This
      phenomenon causes that component of the oscillations to be reflected.
      However, the electrons cannot easily move perpendicular to the length of
      the wires, so the reflection phenomenon doesn’t occur. What we are left
      with on the far side of the filter is a beam of light with the
      oscillations all in the same direction.</p><div class="figure"><a id="wire-grid_polarization"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id361243"/><img src="httpatomoreillycomsourceoreillyimages1599015.png" alt="Wire-grid polarization"/></div></div><div class="figure-title">Figure 24-7. Wire-grid polarization</div></div><p>Early 3D display systems used linearly polarized light to separate
      the right eye channel from the left eye channel. However, there is one
      problem with using linear polarizers. It follows that if you place
      another wire-grid polarizer after the first, with its wires rotated 90
      degrees, no light will pass through! In fact, if you have an old pair of
      sunglasses or 3D glasses and you hold the right eye lens against the
      left eye lens, you won’t be able to see anything. That is because each
      filter is blocking out one direction of oscillations, preventing any
      light from coming through. If you rotated one of the lenses, then the
      combined lens will lighten as you align the polarization directions. The
      problem with these types of lenses is that if you were watching a movie
      and tilted your head to one side, the same effect would occur and the
      image would be greatly dimmed. This means your date could no longer rest
      his or her head on your shoulder while watching the movie. Something had
      to be done.</p><p>Circular polarization is another form of filtering out certain
      orientations so that you can control which light beams pass through
      which lens. However, in this case the direction of oscillation is not a
      single orientation but more accurately a pattern of oscillations
      parameterized by time. The first step to achieve circular polarization
      is to send the light through a linear polarizer as just discussed. That
      light is then sent through what is known as a <span class="emphasis"><em>quarter-wave
      filter</em></span>. A typical arrangement is shown in <a class="xref" href="ch24.html#circular_polarization_filter_open_parent" title="Figure 24-8. Circular polarization filter (public domain image by Dave3457; )">Figure 24-8</a>.</p><div class="figure"><a id="circular_polarization_filter_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id361312"/><img src="httpatomoreillycomsourceoreillyimages1599016.png.jpg" alt="Circular polarization filter (public domain image by Dave3457; )"/></div></div><div class="figure-title">Figure 24-8. Circular polarization filter (public domain image by Dave3457;
        <a class="ulink" href="http://commons.wikimedia.org" target="_top">http://commons.wikimedia.org</a>)</div></div><p>First a linear polarizer rotated to 45 degrees accepts incoming
      light and polarizes as we discussed earlier. The circular polarization
      effect is accomplished when a light wave polarized at 45 degrees hits
      the filter that accepts both 0- and 90-degree oscillations. As
      previously noted, this is called a quarter-wave filter. The resulting
      combination of 0- and 90-degree components of the intermediate 45-degree
      beam results in oscillations that turn right or left in a regular
      pattern. Patterns that turn counterclockwise are called left-handed.
      Patterns that turn clockwise are called right-handed.</p><p>The main benefit is that the lenses create the same pattern
      regardless of their rotation about the center of the lens. In other
      words, if you rotated the assembly shown in <a class="xref" href="ch24.html#circular_polarization_filter_open_parent" title="Figure 24-8. Circular polarization filter (public domain image by Dave3457; )">Figure 24-8</a>, meaning both
      lenses about the center axis, there will be no change in the
      polarization. This reduces the effect of head position on the viewer’s
      ability to fuse the right and left eye channels, reducing eyestrain and
      increasing comfort. As a side note, it is also required for use in
      digital cameras, as linear polarization would affect the autofocus and
      light-metering features of SLRs.</p><p>Like anaglyphs, polarized 3D systems also use glasses to separate
      two channels that are projected at the same time. The first systems used
      two projectors, each with a different linear polarization filter
      projecting on to the same screen with precise timing. As the glasses
      would allow only the correctly polarized light to be seen by either eye,
      the viewer perceived binocular disparity. However, the precise timing
      between the projectors would be subject to errors that cause eyestrain
      and binocular rivalry. Newer systems, including RealD, use an active
      polarization filter fitted to the projector. However, this is still
      classified as a passive system, because the glasses the user has are
      just normal passive filters. In this system, there is a single filter
      that can change its polarization up to 200 times a second. Every other
      frame is separately polarized, and binocular disparity is experienced
      without the complexity of an additional projector. Although this system
      uses an active filter, the glasses don’t have to actively change to
      separate the two channels, so this is another example of passive
      technology.</p><p>The main benefit of polarized systems over anaglyphs is that they
      provide full-color viewing and avoid binocular rivalry. This can
      increase the viewers’ comfort when they are watching feature-length
      films. The disadvantages are cost and dimness. The glasses cost much
      more, and the complexity of projection is increased. It is impossible to
      create the effect in static media like print or web pages using standard
      displays. Also, because the lens on the projector is blocking out the
      portions of the light that don’t have the correct polarization, the
      images appear dimmer to the viewer. This can cause up to 30% reduction
      in brightness and is the main point of contention for many <a id="I_indexterm5_id361373" class="indexterm"/><a id="I_indexterm5_id361383" class="indexterm"/><a id="I_indexterm5_id361393" class="indexterm"/><a id="I_indexterm5_id361402" class="indexterm"/>directors.</p></div><div class="sect2" title="Liquid-Crystal Plasma"><div class="titlepage"><div><div><h3 class="title" id="liquid-crystal_plasma">Liquid-Crystal Plasma</h3></div></div></div><p>The other display technologies <a id="I_indexterm5_id361425" class="indexterm"/>discussed were passive technologies. The projection
      carries the two channels and the glasses separate the channels, one for
      each eye, without active participation from the glasses. Active
      technologies require that the glasses do the work of separating the
      channels while the display is less important. As the gaming industry is
      more sensitive to adapting 3D display technologies to work with existing
      computer monitors or TVs, it has generally focused on active
      technologies. The most common active technologies are based <a id="I_indexterm5_id361437" class="indexterm"/><a id="I_indexterm5_id361443" class="indexterm"/>on <span class="emphasis"><em>liquid-crystal shutter glasses</em></span>, or
      LC glasses. The LC glasses work by exploiting a property of liquid
      crystals that causes them to turn black when a voltage is applied to
      them. This is the same technology that creates the eight-segment digits
      on a simple calculator.</p><p>Basically, every other frame being displayed is shown only to one
      eye, as the LC glasses cause the lens to darken when the opposing eye’s
      frame is being displayed. To make sure the glasses are preventing the
      correct image from being seen by the corresponding eye, the computer
      broadcasts a timing signal to the glasses either over a wire or
      wirelessly. At the appropriate time, the right eye lens has a voltage
      applied to it and the entire lens quickly turns black. As light can
      enter only the left eye, that eye sees the image on the screen. As the
      video being displayed moves to the next frame, this time for the right
      eye, the glasses simultaneously are triggered to remove the voltage from
      the right lens and apply it to the left lens. With the left lens now
      darkened, only the right eye sees the right eye image. As long as this
      is happening very quickly,—on the order of 60 times per second per eye,
      or a total refresh rate of 120 Hz—your brain can’t detect that only one
      eye is seeing the information on the display at a time. Instead, it
      interprets it as each eye seeing distinct images continuously, and as
      long as the image follows the rules we discussed earlier, it interprets
      it as having depth.</p><p>As you can imagine, the main disadvantage of this technology for
      gaming would be that you have to ensure the frame rate stays relatively
      high. You are now rendering twice as many images as you normally would
      require. We’ll discuss more about the rendering pipeline later. Also
      related to frame rate is the refresh rate of the display. As each eye is
      really seeing only half the frames, the overall frame rate is half
      whatever the refresh rate is on the screen. Older displays have refresh
      rates at 60 Hz and effectively halving that can create issues with
      eyestrain; however, new displays support 120 Hz refresh rates so that
      halving it still allows for smooth display. Also, the display will seem
      much dimmer with the glasses on, as your eyes are seeing, on average,
      only half the light they normally would. As you can see, dimness is a
      common problem among 3D display technologies.</p><p>The main advantage is that you don’t need a special display. As long as your display is
        capable of the required refresh rate, then you can retrofit it with a pair of LC shutter
        glasses and get 3D display out of it. Nvidia released such a kit in 2008, called 3D Vision,
        that is relatively popular. Graphics cards are capable of automatically converting the depth
        of the object in the model world into a parallax so that older games can also be rendered in
        stereoscopy. This is something to consider as you design your next game and something we’ll
        touch on again in a moment.</p></div><div class="sect2" title="Autostereoscopy"><div class="titlepage"><div><div><h3 class="title" id="autostereoscopy">Autostereoscopy</h3></div></div></div><p>While the newer 3D <a id="I_indexterm5_id361507" class="indexterm"/>technologies are a far cry from the 3D of several decades
      ago, they still rely on people wearing glasses to view the image. This
      means the displays can never be used in a casual setting such as an
      arcade or street advertisement. Also, the younger segment of the gaming
      population might break or lose the glasses. Having to put on glasses to
      view the 3D images also provides a signal to your brain that what you
      are about to view is optical illusion. Put on the glasses, and your
      brain is already thinking that this isn’t really in 3D.</p><p>Autosterescopy endeavors to create the illusion of depth without
      the aid of any glasses or other wearable device. The first and most
      common way it does this is by <a id="I_indexterm5_id361525" class="indexterm"/>introducing a <span class="emphasis"><em>parallax barrier</em></span>
      between the display and the user. As discussed earlier, parallax—and by
      extension, binocular disparity—is what gives our brain a main source of
      information on depth. A parallax barrier uses the fact that each of your
      eyes sees things from a slightly different angle to separate the two
      channels required for stereoscopy. Physically, the barrier is a layer
      placed in or on the screen with a series of very precisely cut slits.
      Because your eyes are not in the same spot, the slits reveal different
      pixels on the screen to each eye. A basic illustration of this method is
      shown in <a class="xref" href="ch24.html#parallax_barrier" title="Figure 24-9. Parallax barrier">Figure 24-9</a>.</p><div class="figure"><a id="parallax_barrier"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id361558"/><img src="httpatomoreillycomsourceoreillyimages1599017.png" alt="Parallax barrier"/></div></div><div class="figure-title">Figure 24-9. Parallax barrier</div></div><p>As shown in this figure, older screens used the slits to bar
      certain pixels from being seen by placing them above the screen. Newer
      screens like the one on the Nintendo DS place the barrier lower than the
      pixels, but before the backlight. This prevents your eyes from receiving
      the light from those pixels that are being shaded by the solid spaces
      between the slits. This results in a clearer image and a wider viewing
      angle.</p><p>Speaking of viewing angle, if the method works because your eyes
      aren’t in the same spot, it is obvious that if you move your whole head
      then you’ll also be seeing a different set of pixels. This is the
      drawback: that there is a relatively small area called the “sweet spot”
      that the user must position his head relative to the screen to perceive
      the 3D effect. It makes it inappropriate for movies, as only a portion
      of the seats would be in the sweet spot, but it is in use for handhelds
      where only one user will be viewing the screen at any given time.
      Another drawback is that because the slits are eliminating half the
      pixels from each eye, the system reduces the effective pixel count by
      one-half. This causes a reduction in resolution that can be countered by
      even higher pixel density.</p><p>Another method very similar to the parallax method is replacing
      the layer of slits with a series of lenses that direct light from
      certain pixels to a certain eye. These are <a id="I_indexterm5_id361598" class="indexterm"/>called <span class="emphasis"><em>lenticular lenses</em></span> and are
      illustrated in <a class="xref" href="ch24.html#lenticular_lens_screen" title="Figure 24-10. Lenticular lens screen">Figure 24-10</a>.</p><div class="figure"><a id="lenticular_lens_screen"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id361626"/><img src="httpatomoreillycomsourceoreillyimages1599018.png" alt="Lenticular lens screen"/></div></div><div class="figure-title">Figure 24-10. Lenticular lens screen</div></div><p>Here microscopic domed lenses are placed between the viewer and
      the screen. The lens focuses the light such that only certain pixels are
      seen by each eye, due to the slightly different angles by which the eyes
      view the lens. Benefits over the parallax barrier are that the position
      of the user is less restricted and the image is brighter. With both
      parallax barriers and lenticular lens arrays, it is possible to retrofit
      current screens with removable slide-in-place filters that allow for
      viewing of 3D content designed for use with those filters. At the time
      of writing, several large TV manufacturers are doing active research
      into widening the field of view of these technologies for use in a home
      entertainment environment.</p></div><div class="sect2" title="Advanced Technologies"><div class="titlepage"><div><div><h3 class="title" id="advanced_technologies">Advanced Technologies</h3></div></div></div><p>The displays we have discussed so far have all lacked some level
      of realism. For one, the eye doesn’t have to refocus to observe objects
      at different depths, so your brain isn’t totally fooled. Additionally,
      when you move around the object being projected and it doesn’t change
      view, you still see the object at whatever angle the object was
      recorded. If you were viewing the world through a window, you could walk
      to the right and see more of the left-handed view. However, try as you
      might, you can’t see around the corner of a building in a video game by
      moving your head at an angle of the screen. While it might be possible
      to recreate that effect with some sort of head tracking, there are some
      beyond-state-of-the-art technologies that could take this steps
      further.</p><p>One technology that is commonly thought of being able to produce
      3D images <a id="I_indexterm5_id361677" class="indexterm"/>is the <span class="emphasis"><em>holograph</em></span>, a staple of science
      fiction. It seems like we should be able to just whip up some dynamic
      holographs and be done with screens all together. Who wouldn’t like to
      play a sports game as if it were a table-top miniature? However, due to
      the way they are recorded, holographs as we know them are static images.
      Once recorded, holographic images cannot be changed. Due to their
      ability to encode multiple angles of viewing, they would make wonderful
      display technology, and research is under way to find a material that
      can hold holographic data and be rewritten fast enough to induce the
      illusion of motion to the viewer. From time to time, you may see in the
      news some event incorporating computer-generated imagery displayed in
      what is called holographic display. These are not true holographs, but
      usually just a projection on a semitransparent screen. The images are
      still completely flat, and the illusion of 3D comes solely from the
      brain not registering the presence of the screen.</p><p>Another technology being actively <a id="I_indexterm5_id361701" class="indexterm"/>researched is called <span class="emphasis"><em>integral
      photography</em></span>. This is a lot like the use of a lenticular lens;
      however, instead of linear cylinders in an array, the lens field is more
      like a fly’s eye. Each lens in the array captures a complete picture
      from a slightly different angle. Now, when projected through a similar
      integral lens, the light forms a 4D field that the viewer sees as a 3D
      scene appropriate for his or her viewing angle. If the view moves to the
      side, then he or she will see a new portion of the object that wasn’t
      visible previously. This type of movement parallax creates very
      realistic 3D experiences. The advanced displays so accurately recreate
      the light that recorded the images that the eye can focus on different
      parts of the object (this is called the <span class="emphasis"><em>wave front</em></span>)
      and therefore experience accommodation of the eyeball. Recall that this
      is the eighth item in our list from earlier in the chapter, and it is
      something the other displays are lacking. Some crude demonstrations of
      this technology have been presented, and it will be exciting to see how
      the research progresses.</p><p>Beyond any other method, the last one we’ll talk about takes the
      bull by the horns. If you want a 3D image, just make the image
      three-dimensional. The other displays we discussed all attempt to
      recreate 3D screens using projection from a 2D surface. There is a group
      of display technologies known as <span class="emphasis"><em>volumetric</em></span> that
      <a id="I_indexterm5_id361738" class="indexterm"/>dispense with any 2D elements and attempt to create a
      light field with well-defined <span class="emphasis"><em>x</em></span>,
      <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> coordinates. These
      displays are far enough away from consumers that the definition of a
      volumetric display is still being argued. One of the biggest problems
      with the technology will <a id="I_indexterm5_id361760" class="indexterm"/>be <span class="emphasis"><em>occlusion</em></span>—that is, when an object
      passes in front of another object, you can’t see the object behind the
      object that is closer to you. Pretty basic depth information, right?
      Well, if you are attempting to create a 3D light field, it is difficult
      to get the light to be blocked out when another rendered object passes
      in front of the original object. Simply not creating light there won’t
      work, as each viewer would expect the farther object to be blocked at
      different angles. There are some existing demonstrators that use lasers
      to excite electrons in the air. When the lasers are focused on the same
      three-dimensional point, the combined energy creates a small pocket of
      plasma that gives off light. These small volumes of light are often
      referred to <a id="I_indexterm5_id361777" class="indexterm"/>as <span class="emphasis"><em>voxels</em></span> and correspond to pixels in
      2D display technology. The current resolution and refresh rate is not
      going to be wowing any gamers in the near future, but I for one can’t
      wait for the day I can watch the New Orleans Saints play as a
      three-dimensional <a id="I_indexterm5_id361791" class="indexterm"/>table-top game.</p></div></div><div class="sect1" title="Programming Considerations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="programming_considerations">Programming Considerations</h2></div></div></div><p>Now that you <a id="th24.4" class="indexterm"/>have a background in how the current 3D display technologies
    work, there are some aspects of each that you as the programmer should
    consider when writing games. There are two ways to add 3D stereoscopic
    content to games: active stereoization and <a id="I_indexterm5_id361832" class="indexterm"/>passive stereoization. These are not to be confused with the
    passive and active technologies for viewing the 3D images. The
    stereoization process is the method by which the 3D images get created in
    the first place.</p><p><span class="emphasis"><em>Active stereoization</em></span> is the<a id="ac24.4" class="indexterm"/><a id="st24.4" class="indexterm"/> process by which the programmer creates two cameras,
    rendering separate images for each <a id="I_indexterm5_id361878" class="indexterm"/><a id="I_indexterm5_id361885" class="indexterm"/>eye. <span class="emphasis"><em>Passive stereoization</em></span> removes the
    requirements for two cameras, and adds the stereoization at the GPU level.
    Either method is going to cost something in performance. The worst-case
    cost is twice a monocular scene; however, some elements of the scene, like
    the shadow map, will not require recalculation for each eye.</p><div class="sect2" title="Active Stereoization"><div class="titlepage"><div><div><h3 class="title" id="active_stereoization">Active Stereoization</h3></div></div></div><p>Active stereoization is conceptually simpler and offers greater
      control over the process of stereoization. The most naive implementation
      is to simply have two cameras that render complete scenes and then pass
      the buffers labeled one for each eye. The buffers are then swapped in
      and out with the traditional definition of frame rate being half the
      actual frame rate. However, this simple implementation duplicates some
      elements of the scenes that are not eye dependent.</p><p>The advantage of this technique is precise control of what each eye is seeing. This
        allows the programmer to determine eye separation for each frame and could be used to
        actually disorient the user as a game element. Consider a flash-bang grenade going off: the
        programmer could alter the position of the cameras such that it would disorient the user in
        3D for a short period after detonation. However, this technique would cause very real
        discomfort to the user, so it should be not used frequently!</p><p>The disadvantages are that the programmer is now responsible for
      managing an extra camera that must be rendered for each frame. For
      commercial titles, this method can be difficult considering that most
      games already have to be careful about how many times they invoke the
      render pipeline in order to maintain playable frame rates. Having to
      manage two cameras creates additional runtime burden on the program and
      makes the use of existing game engines a little more difficult.</p><p>Also due to the fact that not everyone’s eyes have the same
      <span class="emphasis"><em>separation</em></span> (intraocular distance) <a id="I_indexterm5_id361945" class="indexterm"/><a id="I_indexterm5_id361951" class="indexterm"/>and not everyone’s brain is willing to accept fabricated
      binocular disparity, the program must also provide options for the user
      to adjust the depth and complexity of the stereo effect. If you do not
      provide a way for the user to tune the experience, a vocal minority will
      claim your game gives them a splitting headache. However, as stated
      before, if you are a curious amateur, the process of moving the camera
      and rendering stereoscopic images gives you a lot of insight into how
      the process works.</p><p>As discussed previously, we must take into account the intraocular distance of the
        viewer. This is the amount of parallax we want to give objects at infinity. This distance
        usually ranges between 3 cm and 6.5 cm. The large differences can arise when considering
        that you must consider both adults and children when creating your 3D scene. Now it is
        useful to develop a normalized measure of intraocular distance. Nvidia calls this
          <span class="emphasis"><em>real eye separation</em></span> and gives the following formula for the
        value:</p><table style="border: 0; " class="simplelist"><tr><td>Real eye separation = intraocular distance / real screen
        width</td></tr></table><p>Note that this value will change depending on the width of the
      user’s screen. This value is important because it is used as a reference
      for the maximum camera separation when rendering your stereoscopic
      images. Separations higher than this value will cause discomfort in the
      viewer. In fact, for computer screens where the user is relatively close
      to the screen, most people don’t feel comfortable when the camera
      separation is more than half the real eye separation. This is why it is
      a good practice to allow the user to change the separation as a
      parameter of the program. It is also important to remember that the
      separation of the cameras is also the parallax value at an infinite
      distance. When two images display parallax equal to separation, it is as
      if your eyes are perfectly parallel. This is something that happens only
      when you are looking at something very far away, like a mountaintop. If
      you increase parallax beyond separation, you would essentially be asking
      your viewer to diverge her eyes beyond parallel. This is sort of the
      opposite of crossing your eyes, and obviously is going to cause some
      discomfort.</p><p>As we now have an upper bound to our parallax, we can begin to
      create a <span class="emphasis"><em>parallax budget</em></span>. Recall that the distance
      at which the two frustums intersect is called <a id="I_indexterm5_id362010" class="indexterm"/><a id="I_indexterm5_id362017" class="indexterm"/>convergence. Well, at 100 times this distance, the value
      of parallax is 99% of separation. That means that for objects in the
      scene being rendered at that depth value, they will appear flat and all
      similarly far away. This is analogous to not being able to tell which
      peak of a faraway mountain range is the closest.</p><p>Objects between 10 and 100 times the convergence distance have
      parallax that varies by about 10%. This results in a subtle but
      perceptible depth differentiation. As you approach convergence, the
      parallax exponentially decreases. At the convergence distance, the
      parallax is equal to 0. At a distance closer to the viewer than the
      screen, the parallax is negative. A distance out of the screen half that
      of the convergence distance creates a negative parallax that is equal to
      the separation. If the object is any closer to the viewer, her eyes
      verge on crossing and eyestrain becomes a problem. Now we can draw what
      our budget looks like (see <a class="xref" href="ch24.html#parallax_budget" title="Figure 24-11. Parallax budget">Figure 24-11</a>).</p><div class="figure"><a id="parallax_budget"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_id362057"/><img src="httpatomoreillycomsourceoreillyimages1599019.png" alt="Parallax budget"/></div></div><div class="figure-title">Figure 24-11. Parallax budget</div></div><p>The budget scales with convergence distance and separation. You
      should make sure as much of the important 3D action occurs between
      convergence and 10 times convergence. Your entire scene should be
      contained with negative convergence/2 to positive 100 times
      convergence.</p><p>In general, you must be most careful when trying to execute an
      out-of-screen effect.<a id="I_indexterm5_id362084" class="indexterm"/><a id="I_indexterm5_id362090" class="indexterm"/> These effects are very impressive to the viewer but cause
      the most eyestrain due to the rapid change in parallax. Having the
      object first appear farther away than the screen and then moving it
      closer to the user provides a context for the brain and encourages
      fusion. If an object is going to be closer to the user than the screen,
      it is also important to prevent that image from being clipped by the
      edge of the screen. That would make a portion of the 3D object
      disappear, and the clipping always occurs at the convergence point. This
      will give conflicting cues to the viewer and cause the 3D effect to be
      diminished. Given the amount of control you need in order to prevent
      out-of-screen effects from causing viewer discomfort, it is often best
      to use in non-player-controlled scenes.</p><p>Another difficult part of the game to render is the 2D elements.
      The user interface or other menu items that have no depth are normally
      rendered at convergence depth. However, there are some elements that are
      2D but should be rendered at some nonzero depth. The most important of
      these are mouse pointers and crosshairs. These should be rendered at the
      depth of the object below them. This change in depth of the
      user-controlled pointer helps maintain the idea that the objects are at
      different <a id="I_indexterm5_id362117" class="indexterm"/><a id="I_indexterm5_id362126" class="indexterm"/>depths.</p></div><div class="sect2" title="Passive Stereoization"><div class="titlepage"><div><div><h3 class="title" id="passive_stereoization">Passive Stereoization</h3></div></div></div><p>Passive stereoization takes <a id="I_indexterm5_id362147" class="indexterm"/><a id="I_indexterm5_id362154" class="indexterm"/>the responsibility for managing the stereoization process
      out of the programmer’s hands. The programmer sends the render pipeline
      a single render command as usual, and the GPU handles generating the
      stereo images. Most systems rely on <span class="emphasis"><em>heuristic
      subroutines<a id="I_indexterm5_id362170" class="indexterm"/></em></span> in the driver to take the monocular scene and
      generate binocular images. A heuristic subroutine is one that attempts
      to give a computer “common sense” about what it is trying to do to avoid
      having to do an exhaustive search for solutions to an existing problem.
      They are algorithms not based on rigid mathematical formulas but more
      like neural networks; they must be trained to do what you want them to.
      These algorithms decide which elements of the scene are eye dependent
      and which are not in a process that occurs entirely in the render
      pipeline.</p><p>It is possible for the programmer to defeat the “common sense” rules the computer is
        using in the pipeline so the method is not entirely fire-and-forget but does reduce a lot of
        the workload for development. One of the biggest benefits for larger game studios is that it
        avoids anyone having to reprogram existing game engines. By the same token, it allows
        existing games to be easily played in stereoscopic 3D. All of the preceding recommendations
        apply to passive stereoization except that there should be no user-adjustable settings in
        the game. Passive stereoization relies on third-party profiles that help the GPU do the
        work. The user will have set up a profile with whatever stereoization software he or she is
        using, such as NVIDIA’s 3D Vision. Other recommendations may be specific to the stereoizer,
        and manufacturers usually publish a best practices guide. The NVIDIA one is very helpful,
        and we recommend you read it if you are interested in using stereoization in your <a id="I_indexterm5_id362196" class="indexterm"/>games.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 25. Optical Tracking</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch24.html" title="Chapter 24. 3D Display"/><link rel="next" href="ch26.html" title="Chapter 26. Sound"/></head><body><section class="chapter" title="Chapter 25. Optical Tracking" epub:type="chapter" id="optical_tracking"><div class="titlepage"><div><div><h2 class="title">Chapter 25. Optical Tracking</h2></div></div></div><p>In previous chapters we discussed how accelerometers have changed the
  way that people interact with video games. The same sort of innovation is
  occurring with <a id="I_indexterm6_id362222" class="indexterm"/>optical sensors. Cameras, both in visual and infrared
  spectrums, are being used to generate input for games. This chapter will
  focus on the Microsoft Kinect for Windows SDK and give an overview of how to
  make a simple game that combines optical tracking with physics. First we’ll
  give a short introduction on the technologies these systems use to turn a
  camera into a tracking device.</p><p>Without getting too detailed, we should start by discussing a few
  things about digital cameras. First, most of us are familiar with the
  “megapixel” metric used to describe digital cameras. This number is a
  measure of how many pixels of information the camera records in a single
  frame. It is equal to the height of the frame in pixels multiplied by the
  width of the frame in pixels. A pixel, or picture element, contains
  information on intensity, color, and the location of the pixel relative to
  some origin. The amount of information depends on the bits per pixel and
  corresponds to the amount of color variation a particular pixel can display.
  Perhaps you’ve seen your graphics set to 16-bit or 24-bit modes. This
  describes how many colors a particular pixel can display. A 24-bit pixel can
  be one of 16.8 million different colors at any instant. It is commonly held
  that the human eye can differentiate among about 10 million colors; 24-bit
  color is called “true color,” as it can display more colors than your eye
  can recognize. You might also see 32-bit color modes; these include an extra
  8 bits for a transparency channel that tells the computer what to do if this
  image were put on top of another image. This is sometimes referred to
  <a id="I_indexterm6_id362250" class="indexterm"/><a id="I_indexterm6_id362256" class="indexterm"/>as <span class="emphasis"><em>opacity</em></span> or
  <span class="emphasis"><em>alpha</em></span>.</p><p>Optical tracking and computer vision, in general, work by detecting
  <a id="I_indexterm6_id362274" class="indexterm"/>patterns in this wealth of pixel data. Pattern recognition is
  a mature field of computer science research. The human brain is an excellent
  pattern recognizer. For instance, look at <a class="xref" href="ch25.html#four_unrelated_geometric_entities" title="Figure 25-1. Four unrelated geometric entities">Figure 25-1</a>. Most of us can’t help but
  see a face in what is in reality a collection of three random shapes. Our
  brains are so primed to recognize the basic pattern of a human face that we
  can do it even when we don’t want to!</p><div class="figure"><a id="four_unrelated_geometric_entities"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_id362302"/><img src="httpatomoreillycomsourceoreillyimages1599020.png.jpg" alt="Four unrelated geometric entities"/></div></div><div class="figure-title">Figure 25-1. Four unrelated geometric entities</div></div><p>Computers, on the other hand, have a harder time looking at two
  circles and a few lines and saying, “Hey, this is a smiling face.”</p><div class="sect1" title="Sensors and SDKs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sensors_and_sdks">Sensors and SDKs</h2></div></div></div><p>The modern <a id="I_indexterm6_id362336" class="indexterm"/>interest in computer vision as a consumer input for computer
    games has led to the development of several SDKs for performing
    computer-vision pattern recognition. One such system is Kinect for
    Windows. Although Microsoft provides a very high-level API with the
    Kinect, the downside is that you are locked into its hardware. The popular
    open source alternative is OpenCV, a library of computer-vision
    algorithms. Its advantage is that it can use a wide variety of camera
    hardware and not just the Kinect sensor.</p><div class="sect2" title="Kinect"><div class="titlepage"><div><div><h3 class="title" id="kinect">Kinect</h3></div></div></div><p>The Kinect was <a id="I_indexterm6_id362364" class="indexterm"/><a id="I_indexterm6_id362376" class="indexterm"/>originally developed for the Xbox 360 but has recently
      been rebranded to include Kinect for Windows. As console game design has
      high entrance requirements, the Kinect for Windows allows more casual
      developers to try their hand at creating games with optical input. The
      system has a hardware component, called the Kinect sensor, and the
      previously mentioned Kinect SDK that does a lot of the heavy lifting for
      us in terms of pattern recognition and depth sensing. The hardware
      component consists of an infrared projector, infrared camera, visible
      light camera, and an array of microphones. The two cameras and the
      projector form the basis of the optical tracking system. The projector
      sends out infrared light that is invisible to humans. This light bounces
      off objects and is reflected back to the Kinect. The infrared camera
      records the reflected light pattern, and based on how it has been
      distorted, calculates how far the object is from the sensor. This exact
      method is carried out in the hardware of the sensor and is proprietary.
      However, the patent applications reveal that a special lens projects
      circles that, when reflected, become ellipses of varying shapes. The
      shape of the ellipse depends on the depth of the object reflecting it.
      In general, this is a much-improved <a id="I_indexterm6_id362394" class="indexterm"/>version of <span class="emphasis"><em>depth from focus</em></span>, in which
      the computer assumes that blurry objects are farther away than objects
      in focus.</p><p>As for object detection, the Kinect comes with a great set of
      algorithms for skeleton direction. It can also be trained to detect
      other objects, but skeleton detection is really its forte. The skeleton
      detection is good because of the massive amount of training Microsoft
      used for the algorithms when creating the SDK. If you were to use an
      average computer to run the Kinect skeleton training program, it would
      take about three years. Luckily, Microsoft had 1,000 computers lying
      around, so it takes them only a day to run the training simulation. This
      gives you an idea of the amount of training you need to provide for
      consumer-level tracking in your own algorithms. The Kinect can track up
      to six people with two of them being in “active” mode. For these 2
      people, 20 individual joints are tracked. The sensor can also track
      people while standing or sitting.</p></div><div class="sect2" title="OpenCV"><div class="titlepage"><div><div><h3 class="title" id="opencv">OpenCV</h3></div></div></div><p>The OpenCV method <a id="I_indexterm6_id362434" class="indexterm"/><a id="I_indexterm6_id362444" class="indexterm"/>for 3D reconstruction is, well, more open! The library is
      designed to work with any common webcam or other camera you can get
      connected to your computer. OpenCV works well with stereoscopic cameras
      and is also capable of attempting to map depth with a single camera.
      However, those results would not be accurate enough to control a game,
      so we suggest you stick with two cameras if you’re trying to use regular
      webcams.</p><p>Indeed, finding depth is relatively straightforward using OpenCV. The built-in function
          <code class="literal">ReprojectImageTo3D</code> calculates a vector for each pixel
          (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) based on a <span class="emphasis"><em>disparity
          map</em></span>. A disparity map<a id="I_indexterm6_id362480" class="indexterm"/> is a data set that describes how pixels have changed from one image to the
        next; if you have stereoscopic cameras, this essentially is the reverse of the technique we
        use in <a class="xref" href="ch24.html" title="Chapter 24. 3D Display">Chapter 24</a> when dealing with 3D displays. To create a disparity map,
        OpenCV provides the handy function <code class="literal">FindStereoCorrespondenceGC()</code>. This function takes a set of images, assumes them
        to be from a sterescopic source, and generates a disparity map by systematically comparing
        them. The documentation is very complete, and there are several books on the subject of
        OpenCV, including <a class="ulink" href="http://shop.oreilly.com/product/0636920022497.do" target="_top"><span class="emphasis"><em>Learning OpenCV</em></span></a> by <a id="I_indexterm6_id362512" class="indexterm"/>Gary Bradski and Adrian Kaehler<a id="I_indexterm6_id362520" class="indexterm"/> (O’Reilly), so we again will save the details for independent study.</p><p>Object detection is also <a id="I_indexterm6_id362529" class="indexterm"/>possible with OpenCV. The common example in the OpenCV
      project uses <span class="emphasis"><em>Harr-like</em></span> features to <a id="I_indexterm6_id362540" class="indexterm"/>recognize objects. These features are rectangles whose
      mathematical structure allows for very fast computation. By developing
      patterns of these rectangles for a given object, a program can detect
      objects out of the background. For example, one such pattern could be if
      a selection rectangle includes an edge. The program would detect an edge
      in the pixel data by finding a sharp gradient between color and/or other
      attributes. If you detect the right number of edges in the right
      position, you have detected your object.</p><p>Hardcoding a pattern for the computer to look for would result in
      a very narrow set of recognition criteria. Therefore, computer-vision
      algorithms rely on a system of training rather than hard programming.
      Specifically, they use <span class="emphasis"><em>cascade classifier
      training</em></span>.</p><p>The training process works well but requires a large image set.
      Typical examples require 6,000 negative images and 1,500 positive
      images. The negative images are commonly called background images. When
      training the algorithm, you take 1,200 of your positive images and draw
      selection rectangles around the object you are trying to detect. The
      computer learns that the pattern in the selection rectangles you’ve
      given it is one to be identified. This will take the average computer a
      long, long time. The remaining images are used for testing to ensure
      that your algorithm has satisfactory accuracy in detecting the patterns
      you’ve shown it. The larger the sample set, including different
      lighting, the more accurate the system will be. Once the algorithm is
      trained to detect a particular object, all you need is the training
      file—usually an <span class="emphasis"><em>.xml</em></span> file—to share that training
      with another computer.</p></div></div><div class="sect1" title="Numerical Differentiation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="numerical_differentiation">Numerical Differentiation</h2></div></div></div><p>As previously noted, <a id="op25.2" class="indexterm"/><a id="di25.2" class="indexterm"/>there are many ways to collect optical tracking data, but
    since we are focusing on the physics aspects, we’ll now talk about how to
    process the data to get meaningfully physical simulation. By combining
    object detection with depth sensing, we can detect and then track an
    object as it moves in the camera’s field of vision. Let’s assume that you
    have used the frame rate or internal clock to generate data of the
    following format:</p><a id="I_programlisting6_id362625"/><pre class="programlisting">{(x[i],y[i],z[i],t[i]),(x[i+1],y[i+1],z[i+1],t[i+1]) ,
(x[i+2],y[i+2],z[i+2],t[i+2]), ...}</pre><p>Now, a single data point consisting of three coordinates and a
    timestamp doesn’t allow us to determine what is going on with an object’s
    velocity or acceleration. However, as the camera is supplying new position
    data at around 20–30 Hz, we will generate a time history of position or
    displacement. Using techniques similar to the numerical integration we
    used to take acceleration and turn it into velocities and then turn those
    velocities into position in earlier chapters, we can apply numerical
    differentiation to accomplish the reverse. Specifically, we can use the
    finite difference method.</p><p>For velocity, we need a first-order finite difference numerical
    differentiation scheme. Because we know the current data point and the
    previous data point, we are looking backward in time to get the current
    position. This is known <a id="I_indexterm6_id362645" class="indexterm"/>as the <span class="emphasis"><em>backward difference scheme</em></span>. In
    general, the backward difference is given by:</p><table style="border: 0; " class="simplelist"><tr><td>f’(x) = lim h→0 (f(x+h) – f(x)) / h</td></tr></table><p>We must use the backward difference for the first-order
    differentiation, as we know only the present position and past positions.
    In our case, <span class="emphasis"><em>h</em></span> is the difference in time between two
    data points and has a nonzero, fixed value. Therefore, the equation can be
    rewritten as:</p><table style="border: 0; " class="simplelist"><tr><td>(f(x+h) – f(x)) / h = ∆f(x)/h</td></tr></table><p>where ∆<span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>x</em></span>) is the
    position at the second timestamp minus the position at the first
    timestamp, and <span class="emphasis"><em>h</em></span> is the difference in time. This is
    relatively straightforward, as we are just calculating the distance
    traveled divided by the time it took to travel that distance. This is the
    definition of average velocity.</p><p>Note that because we are finding the average velocity between the two data points, if the
      time delta, <span class="emphasis"><em>h</em></span>, is too large, this will not accurately approximate the
      instantaneous velocity of the object. You may be tempted to push whatever hardware you have to
      its limit and get the highest possible sampling rate; however, if the time step is too small,
      the subtraction of one displacement from another will result in significant round-off error
      using floating-point arithmetic. You must take care to ensure that when you’re selecting a
      timestamp, (<span class="emphasis"><em>t[i] + h</em></span>) <span class="emphasis"><em>– t</em></span>[<span class="emphasis"><em>i</em></span>] is
      exactly <span class="emphasis"><em>h</em></span>. For more information on tuning these parameters, refer to the
      classic <span class="emphasis"><em>Numerical Recipes in C</em></span>. The function to find velocity from our
      data structure would be as follows. Note that in our notation,
        <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>−<span class="emphasis"><em>1</em></span>] is behind in time
      compared to <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>], so we are using the backward form.
      Your program needs to ensure that <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>−1] exists
      before executing this function:</p><a id="I_programlisting6_id362709"/><pre class="programlisting">Vector findVelocity (x[i-1], y[i-1], z[i-1], t[i-1], x[i], y[i], z[i], t[i]){

    float vx, vy, vz;

    vx = (x[i] − x[i-1])/(t[i]-t[i-1]);
    vy = (y[i] − y[i-1])/(t[i]-t[i-1]);
    vz = (z[i] − z[i-1])/(t[i]-t[i-1]);

    vector velocity = {vx, vy, vz};

    return velocity;

}</pre><p>To compute the acceleration vector<a id="I_indexterm6_id362773" class="indexterm"/><a id="I_indexterm6_id362780" class="indexterm"/>, we need to compare two velocities. However, we note that
    to get a velocity, we need two data points. Therefore, a total of three
    data points is required. The acceleration we solve for will actually be
    the acceleration for the middle data point as we compare the backward and
    forward difference. This technique is named the <span class="emphasis"><em>second-order
    central difference</em></span>. In <a id="I_indexterm6_id362797" class="indexterm"/><a id="I_indexterm6_id362804" class="indexterm"/>general, that form is as follows:</p><table style="border: 0; " class="simplelist"><tr><td>f’’(x) = (f(x+2h) – 2f(x+h) + f(x)) /
      h<sup>2</sup></td></tr></table><p>This allows you to compute the acceleration directly without first finding the velocities.
      Here again, <span class="emphasis"><em>f</em></span>(<span class="emphasis"><em>x</em></span>) is the position reported by the
      sensor and <span class="emphasis"><em>h</em></span> is the time step between data points. The same discussion of
        <span class="emphasis"><em>h</em></span> applies here as well. Some tuning of the time step might be required
      to provide a stable differential. Of particular note with central difference forms is that
      periodic functions that are in sync with your time step may result in zero slope. If the
      motion you are tracking is periodic, you should take care to avoid a time step near the period
      of oscillation. This is called <span class="emphasis"><em>aliasing</em></span> and is a problem with all signal
      analysis, including computer graphics displays. Also, note that this cannot be computed until
      at least three time steps have been stored. In our notation,
        <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>−1] is the center data point,
        <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>−2] the backward value, and
        <span class="emphasis"><em>t</em></span>[<span class="emphasis"><em>i</em></span>] the forward value. The acceleration function
      would therefore be as follows:</p><a id="I_programlisting6_id362830"/><pre class="programlisting">Vector findAcceleration (x[i-2], y[i-2], z[i-2], t[i-2], x[i-1], y[i-1], z[i-1], 
                         t[i-1], x[i], y[i], z[i], t[i] ){

    float ax, ay, az, h;
    vector acceleration;

    h = t[i]-t[i-1];

    ax = (x[i] − 2*x[i-1] + x[i-2]) / h;
    ay = (y[i] − 2*y[i-1] + y[i-2]) / h;
    az = (z[i] − 2*z[i-1] + z[i-2]) / h;

    return acceleration = {ax, ay, az};
}</pre><p>Now, let’s say that you are tracking a ball in someone’s hand. Until
    he lets it go, the velocity and acceleration we are calculating could
    change at any moment in any number of ways. It is not until the user lets
    go of the ball that the physics we have discussed takes over. Hence, you
    have to optically track it until he completes the throw. Once the ball is
    released, the physics from the rest of this book applies! You can then use
    the position at time of release, the velocity vector, and the acceleration
    vector to plot its trajectory in the <a id="I_indexterm6_id362892" class="indexterm"/><a id="I_indexterm6_id362902" class="indexterm"/>game.</p></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 26. Sound</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch25.html" title="Chapter 25. Optical Tracking"/><link rel="next" href="apa.html" title="Appendix A. Vector Operations"/></head><body><section class="chapter" title="Chapter 26. Sound" epub:type="chapter" id="sound"><div class="titlepage"><div><div><h2 class="title">Chapter 26. Sound</h2></div></div></div><p>In this chapter we’ll explore <a id="so26.0" class="indexterm"/>some basic physics of sound and how you can capture 3D sound effects in games. We’ll
    refer to the <span class="emphasis"><em>OpenAL</em></span> audio API for some code examples, but the physics we
    discuss is independent of any particular API. If you’re new to OpenAL, it’s basically OpenGL for
    audio. <a id="I_indexterm7_id362948" class="indexterm"/>OpenAL uses some very easy-to-understand abstractions for creating sound effects and
    handles all the mixing, filters, and 3D synthesis for you. You basically create sound
      <span class="emphasis"><em>sources</em></span>, associate those sources with <span class="emphasis"><em>buffers</em></span> that
    store the sound data, and then manipulate those sources by positioning them and setting their
    velocity (among other properties). You can have multiple sources, of course, but there’s only
    one <span class="emphasis"><em>listener</em></span>. You do have to set properties of the listener, such as the
    listener’s position and velocity, in order to properly simulate 3D sound. We’ll talk more about
    these things throughout the chapter.</p><div class="sect1" title="What Is Sound?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="what_is_sound_question">What Is Sound?</h2></div></div></div><p>If you look up the definition of sound online, you’ll get answers
    like sound is a vibration; a sensation perceived by our brains through
    stimulation of organs in our inner ear; and a density or pressure
    fluctuation, or wave, traveling through a medium. So which is it? Well,
    it’s all of them, and the interpretation you use depends on the context in
    which you’re examining sound. For example, noise control engineers aiming
    to minimize noise on ships focus on vibrations propagating through the
    ship’s structure, while medical doctors worry more about the biomechanics
    of our inner ear and how our brains interpret the sensations picked up by
    our ears, and physicists take a fundamental look at density and pressure
    fluctuations through compressible materials and how these waves interact
    with each other and the environment. We don’t mean to suggest that each of
    these disciplines views sound only in a single way or context, but what
    we’re saying is that each discipline often has its own perspective,
    priorities, and standard language for the subject. To us, in the context
    of games, sound is what the player hears through his speakers or
    headphones that helps to create an immersive gaming environment. However,
    in order to create realistic sounds that lend themselves to creating an
    immersive environment, complimenting immersive visuals and in-game
    behaviors, we need to understand the physics of sound, how we perceive it,
    and what sound tells us about its source and the environment.</p><p>Given that this is a book on game physics, we’re going to take a
    fundamental view of sound, which is that sound is what our brain perceives
    as our ears sense density and pressure fluctuations in the air surrounding
    us. These density and pressure fluctuations are waves, and as such we’ll
    refer to <span class="emphasis"><em>sound waves</em></span>. Let’s take a closer
    look.</p><p>If a compressible medium experiences a pressure change—say, due to a
    driven piston—its volume will change and thus its density will change. In
    the case of a driven piston, the region directly in front of the piston
    will experience the compression first, resulting in a region of increased
    density and increased pressure. This is called<a id="I_indexterm7_id363018" class="indexterm"/> <span class="emphasis"><em>condensation</em></span>. For sound, you can think
    of that piston as the cone of a loudspeaker. That region of increased
    <a id="I_indexterm7_id363031" class="indexterm"/><a id="I_indexterm7_id363040" class="indexterm"/>density and pressure will propagate through the medium,
    traveling at the speed of sound in that given medium. <a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a> illustrates this
    concept.</p><div class="figure"><a id="driven_piston_and_loudspeaker_analogue"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363070"/><img src="httpatomoreillycomsourceoreillyimages1599021.png" alt="Driven piston and loudspeaker analogue"/></div></div><div class="figure-title">Figure 26-1. Driven piston and loudspeaker analogue</div></div><p><a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a>(a)
    illustrates the driven piston concept, while <a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a>(b) illustrates the
    loudspeaker analogue. As the piston or cone displaces fluid (say, air),
    causing compression, and then withdraws, a single high-pressure region
    followed by a low-pressure region will be created. The low-pressure region
    resulting from withdrawal of the piston is called<a id="I_indexterm7_id363103" class="indexterm"/> <span class="emphasis"><em>rarefaction</em></span>. That resulting solitary
    wave of pressure will head off through the air to the right in <a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a> at the speed
    corresponding to the speed of sound in air. If the piston, or speaker
    cone, pulses back and forth, as illustrated in <a class="xref" href="ch26.html#sound_wave" title="Figure 26-2. Sound wave">Figure 26-2</a>, a series of these high-/low-pressure regions will
    be created, resulting in a continuous series of waves—a sound
    wave—propagating to the right.</p><div class="figure"><a id="sound_wave"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363137"/><img src="httpatomoreillycomsourceoreillyimages1599022.png" alt="Sound wave"/></div></div><div class="figure-title">Figure 26-2. Sound wave</div></div><p>The <span class="emphasis"><em>wavelength</em></span> of this sound wave (i.e., the
    distance measured from pressure peak to pressure peak) is a function of
    the frequency of pulsation, or vibration, of the cone. The resulting sound
    wave’s frequency is related to the inverse of its wavelength—that is,
    <span class="emphasis"><em>f</em></span> = 1/λ. The pressure amplitude versus time waveform
    for this scenario is illustrated in <a class="xref" href="ch26.html#sound_wave" title="Figure 26-2. Sound wave">Figure 26-2</a>. We’ve
    illustrated the pressure wave as a <a id="I_indexterm7_id363173" class="indexterm"/>harmonic sine wave, which need not be the case in reality
    since the sound coming from a speaker could be composed of an aggregate of
    many different wave components. We’ll say more on this later.</p><p>One thing we do want to point out is that a sound wave is a
    longitudinal wave and not a transverse wave like an ocean wave, for
    example. In a transverse wave, the displacement of the medium due to the
    wave is perpendicular to the direction of travel of the wave. In a
    longitudinal wave, the displacement is along the direction of travel of
    the wave. The higher density and pressure regions of a sound wave are due
    to compression of the medium along the direction of travel of the wave.
    Thus, sound waves are longitudinal waves.</p><p>So, sound waves are variations in density and pressure moving
    through a medium. But how do we hear them? In essence the pressure wave,
    created by some mechanical vibration like that of a speaker cone, gets
    converted back to a vibration in our inner ear. And that vibration gets
    interpreted by our brains as sound—the sound we hear. <a class="xref" href="ch26.html#illustration_of_how_we_hear" title="Figure 26-3. Illustration of how we hear">Figure 26-3</a> illustrates this concept.</p><div class="figure"><a id="illustration_of_how_we_hear"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363213"/><img src="httpatomoreillycomsourceoreillyimages1599023.png" alt="Illustration of how we hear"/></div></div><div class="figure-title">Figure 26-3. Illustration of how we hear</div></div><p>Our outer ears help capture and direct pressure waves into our ear
    canals. These pressure waves travel down the ear canal, impinging on the
    eardrum, which causes the eardrum to vibrate. This is where the pressure
    variations get converted back to mechanical vibration. Beyond the eardrum,
    biology and chemistry work their magic to convert those vibrations into
    electrical impulses that our brains interpret as sound.</p><p>Our ears are sensitive enough to detect pressure <a id="I_indexterm7_id363241" class="indexterm"/>waves in the 20 to 20,000 hertz (Hz) <a id="I_indexterm7_id363255" class="indexterm"/>frequency range. (A hertz is one cycle per second.) We interpret frequency as
      pitch. High-pitch sounds (think tweeters) correspond to high frequencies, and low-pitch sounds
      (think bass) correspond to low frequencies.</p><p>Aside from <a id="I_indexterm7_id363271" class="indexterm"/>pitch, an obvious characteristic of sound that we perceive
    is its loudness. Loudness <a id="I_indexterm7_id363286" class="indexterm"/>is related to the amplitude of the pressure wave, among
    other factors such as duration. We often think of loudness in terms of
    volume, or power, or intensity. All these characteristics are related, and
    we can write various formulas relating these characteristics to other
    features of the sound wave. Sound waves have <a id="I_indexterm7_id363296" class="indexterm"/>kinetic energy, which is related to the mass of the medium
    disturbed by the pressure wave and the speed at which that mass is
    disturbed. Power <a id="I_indexterm7_id363310" class="indexterm"/>is the time rate of change of energy transference. And
    intensity is related to how much power flows through a given area. The
    bottom line is that the more power a sound has, or the more intense it is,
    the louder it seems to you, the listener. At some point, a sound can be so
    intense as to cause discomfort or pain.</p><p>Customarily, intensity is measured in units of decibels. A decibel
    represents the <a id="I_indexterm7_id363330" class="indexterm"/>intensity of a sound relative to some standard reference,
    which is usually taken as the sound intensity corresponding to the
    threshold of hearing. Zero decibels, or 0 dB, corresponds to the threshold
    of hearing. The intensity is so low you can’t hear it. When sounds reach
    about 120–130 dB, they start to cause pain. <a class="xref" href="ch26.html#typical_sound_intensities" title="Table 26-1. Typical sound intensities">Table 26-1</a> lists some typical intensity values
    for common sounds.</p><div class="table"><a id="typical_sound_intensities"/><div class="table-title">Table 26-1. Typical sound intensities</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col1"/><col class="col2"/></colgroup><thead><tr><td style="text-align: left; vertical-align: bottom; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sound</p></td><td style="text-align: left; vertical-align: bottom; border-bottom: 0.5pt solid ; "><p>Typical
            intensity</p></td></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Jet airplane, fairly
            close</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>150 dB</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Gun shot</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>160 to 180 dB depending on
            the gun</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Crying baby</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>130 dB
            (painful!)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Loud scream</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>Up to 128 dB (world record
            set in 1988)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Typical
            conversation</p></td><td style="text-align: left; vertical-align: top; border-bottom: 0.5pt solid ; "><p>50 to 60 dB</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 0.5pt solid ; "><p>Whisper</p></td><td style="text-align: left; vertical-align: top; "><p>About 10 dB</p></td></tr></tbody></table></div></div><p>The intensity values shown in <a class="xref" href="ch26.html#typical_sound_intensities" title="Table 26-1. Typical sound intensities">Table 26-1</a> are typical and surely there’s wide
    variation in those levels depending on, for example, the type of aircraft,
    or the person you’re talking to, or the softness of the person’s voice
    whispering to you. It’s common sense, but if you’re writing a game you’ll
    want to reflect some level of realism in the intensity of various sound
    effects in your game.</p><p>Now, intensity is actually a logarithmic scale. It is generally
    accepted that a sound measured 10 dB higher than another is considered
    twice as loud. This is perceived loudness. Thus, a crying baby is way more
    than twice as loud as a normal conversation. Parents <a id="I_indexterm7_id363562" class="indexterm"/>already know that.</p></div><div class="sect1" title="Characteristics of and Behavior of Sound Waves"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="characteristics_of_and_behavior_of_sound">Characteristics of and Behavior of Sound Waves</h2></div></div></div><p>Now that we’ve <a id="so26.2" class="indexterm"/>established what sound is, we’re going to generally refer to
    <span class="emphasis"><em>sound waves</em></span> throughout the remainder of this chapter.
    Remember, sound waves are pressure waves that get interpreted by our
    brains as sound. The bottom line is that we’re dealing with waves,
    longitudinal waves. Therefore, we can use principles of wave mechanics to
    describe sound waves. Furthermore, since sound waves (think pressure
    waves) displace real mass, they can interact with the environment. We
    already know that pressure waves interact with our eardrums to trigger
    some biochemical action, causing our brains to interpret sound.
    Conversely, the environment can interact with the pressure wave to alter
    its characteristics.</p><div class="sect2" title="Harmonic Wave"><div class="titlepage"><div><div><h3 class="title" id="harmonic_wave">Harmonic Wave</h3></div></div></div><p>Let’s consider a one-dimensional <a id="I_indexterm7_id363626" class="indexterm"/>harmonic pressure wave—one that could be created by the
      driven piston shown in <a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a>(a). Let the
      x-direction correspond to distance, positive from left to right. Thus,
      the wave of <a class="xref" href="ch26.html#driven_piston_and_loudspeaker_analogue" title="Figure 26-1. Driven piston and loudspeaker analogue">Figure 26-1</a>(a)
      travels in the positive x-direction. Let Δ<span class="emphasis"><em>P</em></span>
      represent the change in pressure from the ambient pressure at any given
      time. Let <span class="emphasis"><em>A</em></span><sub>P</sub> represent the
      amplitude of the pressure wave. Remember, the pressure will vary by some
      amount greater than the ambient pressure when condensation occurs to
      some amount lower than ambient pressure when rarefaction occurs. The
      range in peak pressures relative to ambient is
      <span class="emphasis"><em>−A</em></span><sub>P</sub> to
      +<span class="emphasis"><em>A</em></span><sub>P</sub>. Assuming a harmonic
      wave, we can write:</p><table style="border: 0; " class="simplelist"><tr><td>ΔP = A<sub>P</sub> sin(kx – ωt – φ)</td></tr></table><p><span class="emphasis"><em>k</em></span> is called the wave number and is equal to
      2π/λ, where λ is the wave length. <span class="emphasis"><em>x</em></span> is the
      coordinate representing the position under consideration. ω is called
      angular, or circular, frequency and is equal to
      2π<span class="emphasis"><em>f</em></span>, where <span class="emphasis"><em>f</em></span> is the frequency
      of the sound wave. <span class="emphasis"><em>t</em></span> represents time. Finally, φ is
      called the phase angle, also known as the phase shift. It represents an
      offset of the wave along the x-axis in this case.</p><p>With this equation, we can plot what Δ<span class="emphasis"><em>P</em></span> at a
      particular x-location as a function of time. <a class="xref" href="ch26.html#harmonic_wave-id1" title="Figure 26-4. Harmonic wave">Figure 26-4</a> illustrates such a plot assuming that
      <span class="emphasis"><em>A</em></span><sub>P</sub>, λ, and
      <span class="emphasis"><em>f</em></span> are all equal to 1 and φ is equal to 0.</p><div class="figure"><a id="harmonic_wave-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363739"/><img src="httpatomoreillycomsourceoreillyimages1599024.png" alt="Harmonic wave"/></div></div><div class="figure-title">Figure 26-4. Harmonic wave</div></div><p>Physically, if you were to measure the change in pressure over
      time at some point, <span class="emphasis"><em>x</em></span>, the plot would look like
      that shown in <a class="xref" href="ch26.html#harmonic_wave-id1" title="Figure 26-4. Harmonic wave">Figure 26-4</a>.</p></div><div class="sect2" title="Superposition"><div class="titlepage"><div><div><h3 class="title" id="superposition">Superposition</h3></div></div></div><p>In general, sound waves <a id="I_indexterm7_id363783" class="indexterm"/>don’t look like the pure harmonic wave shown in <a class="xref" href="ch26.html#harmonic_wave-id1" title="Figure 26-4. Harmonic wave">Figure 26-4</a> unless the sound is a pure tone. A
      non-pure tone will have other wiggles in its plot resulting from
      components at other frequencies and phases. Similarly, if you record the
      sound pressure at a single point in a room, for example, where multiple
      sound sources exist, the pressure recording at the point in question
      will not correspond to the sound of any particular sound source.
      Instead, the recorded pressure time history will be some combination of
      all the sources present, and what you hear is some combination of all
      the sound sources.</p><p>A good approximation for how these various sound components
      combine is simply to sum the results of each component at the particular
      point in question. This is the principle of superposition.</p><p><a class="xref" href="ch26.html#ten_different_waves" title="Figure 26-5. Ten different waves">Figure 26-5</a> shows 10 different
      waveforms, each with different amplitudes, frequencies, and phases. The
      principle of superposition says that we can add all these waveforms to
      determine the combined result.</p><div class="figure"><a id="ten_different_waves"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363826"/><img src="httpatomoreillycomsourceoreillyimages1599025.png" alt="Ten different waves"/></div></div><div class="figure-title">Figure 26-5. Ten different waves</div></div><p><a class="xref" href="ch26.html#resulting_wave" title="Figure 26-6. Resulting wave">Figure 26-6</a> shows the resulting wave. Note
      that the individual waves are added algebraically. At any given instant
      in time, some waves produce positive pressure changes, while others
      produce negative pressure changes. This means that some waves add
      together to make bigger pressure changes, but it also means that some
      can add together to make smaller pressure changes. In other words, waves
      can be either constructive or destructive. Some waves can cancel each
      other out completely, which is the basis for noise cancellation
      technologies.</p><div class="figure"><a id="resulting_wave"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id363868"/><img src="httpatomoreillycomsourceoreillyimages1599026.png" alt="Resulting wave"/></div></div><div class="figure-title">Figure 26-6. Resulting wave</div></div></div><div class="sect2" title="Speed of Sound"><div class="titlepage"><div><div><h3 class="title" id="speed_of_sound">Speed of Sound</h3></div></div></div><p>Sound waves <a id="I_indexterm7_id363899" class="indexterm"/>travel through a medium at some finite speed, which is a
      function of that medium’s elastic and inertial properties. In general,
      sound travels faster in stiffer, less compressible mediums than it does
      in softer or more compressible mediums. For example, the speed of sound
      in air is about 340 m/s, depending on temperature, moisture content, and
      other factors, but it’s about 1500 m/s in seawater. Water is a lot less
      compressible than air. Taking this a step further, the speed of sound in
      a solid such as iron is about 5,100 m/s.</p><p>You might say, “So what; why do I have to worry about the speed of
      sound in my game?” Well, the speed at which sound waves travel tells us
      something about the sound source, and you can leverage those cues in
      your game to enhance its immersive feel. Let’s say an enemy unit fires a
      gun in your 3D shooter, and that enemy is some distance from your
      player. The player should see the muzzle flash before she hears the
      sound of the gun firing. This delay is due to the fact that light
      travels far faster than sound. The delay between seeing the muzzle flash
      and hearing the shot gives the player some sense of the distance from
      which the enemy is firing.</p><p>With respect to 3D sound effects, our ears hear sounds coming from
      an oblique direction at slightly different times because of the
      separation distance between our ears. That time lag, albeit very short,
      gives us some cues as to the direction from which the sound is coming.
      We’ll say more on this later on this chapter.</p><p>Additionally, the Doppler effect<a id="I_indexterm7_id363937" class="indexterm"/>, which we’ll discuss later, is also a function of the
      speed of sound.</p><p>In OpenAL you <a id="I_indexterm7_id363948" class="indexterm"/>set the desired sound speed using the <code class="literal">alSpeedOfSound</code> function, passing a single
      floating-point argument representing the sound speed. The specified
      value is saved in <a id="I_indexterm7_id363966" class="indexterm"/>the <code class="literal">AL_SPEED_OF_SOUND</code>
      property. The default value is 343.3, which is the speed of sound in air
      at 20°C expressed in m/s.</p></div><div class="sect2" title="Attenuation"><div class="titlepage"><div><div><h3 class="title" id="attenuation">Attenuation</h3></div></div></div><p>Attenuation is the <a id="I_indexterm7_id363997" class="indexterm"/>falloff in intensity of a sound over distance. Earlier we
      explained that sound intensity is related to how much power flows
      through a given area. Imagine a <span class="emphasis"><em>point sound source</em></span>,
      which <a id="I_indexterm7_id364010" class="indexterm"/>creates spherical pressure waves that propagate radially
      from the source. <a class="xref" href="ch26.html#spherical_sound_waves" title="Figure 26-7. Spherical sound waves">Figure 26-7</a> illustrates
      this concept.</p><div class="figure"><a id="spherical_sound_waves"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id364034"/><img src="httpatomoreillycomsourceoreillyimages1599027.png" alt="Spherical sound waves"/></div></div><div class="figure-title">Figure 26-7. Spherical sound waves</div></div><p>Assuming the sound is being generated with a constant power, you
      can see that the area through which that power flows grows with
      increasing distance, <span class="emphasis"><em>r</em></span>, from the source. Intensity
      is equal to power divided by area, thus the intensity at radius
      <span class="emphasis"><em>r</em></span><sub>4</sub> is less than that at,
      say, <span class="emphasis"><em>r</em></span><sub>1</sub> because the surface
      area at <span class="emphasis"><em>r</em></span><sub>4</sub> is larger. The
      surface area of a sphere is
      4π<span class="emphasis"><em>r</em></span><sup>2</sup>. Without going into
      all the details, we can state that the amplitude of the spherical sound
      wave is inversely proportional to
      <span class="emphasis"><em>r</em></span><sup>2</sup>.</p><p>This is an ideal treatment so far. In reality attenuation is also
      a function of other factors, including the scattering and absorption of
      the sound wave as it interacts with the medium and the environment. You
      can model attenuation in many ways, taking into account various levels
      of detail at increasing computational expense. However, for games,
      relatively simple distance-based models are sufficient.</p><p>Attenuation provides another cue that tells us something about the
      sound source. In your game, you wouldn’t want the intensity, or volume,
      of a sound generated far from the player to be the same as that from a
      source very close to the player. Attenuation tells the player something
      about the distance between him and the sound source.</p><p>OpenAL includes several different distance-based models from which
      you can choose. The OpenAL documentation describes the particulars of
      each, but the default model is an inverse distance-based model where the
      <span class="emphasis"><em>gain</em></span> of the source sound is adjusted in inverse
      proportion to the distance from the sound source. Gain is an
      amplification factor applied to the recorded amplitude of the sound
      effect you’re using.</p><p>You can change distance models in OpenAL <a id="I_indexterm7_id364124" class="indexterm"/>using the <code class="literal">alDistanceModel</code> function (see the OpenAL
      programmers manual for valid parameters).</p></div><div class="sect2" title="Reflection"><div class="titlepage"><div><div><h3 class="title" id="reflection">Reflection</h3></div></div></div><p>When sound waves <a id="I_indexterm7_id364155" class="indexterm"/>passing through one medium reach another medium or object,
      such as a wall, part of the original sound wave is reflected off the
      object, while part of it is absorbed by (and transmitted through) the
      object. Depending on the dispositions of the sound source and the
      listener, some sound waves will reach the listener via some direct path.
      Reflected waves may also reach the listener, although their energy may
      have been reduced after their interaction with whatever they bounced
      off. <a class="xref" href="ch26.html#reflected_waves" title="Figure 26-8. Reflected waves">Figure 26-8</a> illustrates this concept, where
      some sound waves reach the listener directly and others reach the
      listener after having been reflected from walls.</p><div class="figure"><a id="reflected_waves"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id364185"/><img src="httpatomoreillycomsourceoreillyimages1599028.png" alt="Reflected waves"/></div></div><div class="figure-title">Figure 26-8. Reflected waves</div></div><p>The degree to which sound waves are reflected has to do with the
      characteristics of the material from which they bounce. Smooth, hard
      surfaces will tend to reflect more of the sound energy, while softer,
      irregular surfaces will tend to absorb more energy and scatter the waves
      that are reflected. These characteristics lend a certain quality to the
      ultimate sound the listener hears. The same sound played in a tiled
      bathroom will have a distinctly different quality than if it were played
      in a room with carpet, drapes, and tapestries. In the bathroom the sound
      may sound echoic, while in the carpeted room it may sound muted.
      Somewhere in between these two types of rooms, the sound may
      reverberate. Reverberation is a perceived prolonging of the original
      sound due to reflections of the sound within the space.</p><p>In your games, it would be prohibitively expensive
      (computationally speaking) to try to model various sound sources
      interacting with all the walls and objects in any given space within the
      game in real time. Such computations are possible and are often used in
      acoustic engineering and noise control applications, but again, it’s too
      costly for a game. What you can do, however, is mimic the reflective or
      reverberant qualities of any given space in your game environment by
      adjusting the reverberation of your sound sources. One approach is to
      record sound effects with the quality you’re looking for to represent
      the space in which that sound effect would apply. For example, you could
      record the echoic sound of dripping water in a stone room to enhance the
      atmosphere of a dungeon.</p><p>Alternatively, if you’re using a system such as <a id="I_indexterm7_id364228" class="indexterm"/><a id="I_indexterm7_id364238" class="indexterm"/><a id="I_indexterm7_id364247" class="indexterm"/>OpenAL and if the reverberation special effect is
      available on your sound card, you can assign certain reverberation
      characteristics to individual sound sources to mimic specific
      environments. This sort of approach falls within the realm of
      environmental modeling, and the OpenAL Effects Extension Guide (part of
      the OpenAL documentation) gives some pretty good tips on how to use its
      special effects extensions for environmental modeling.</p></div><div class="sect2" title="Doppler Effect"><div class="titlepage"><div><div><h3 class="title" id="doppler_effect">Doppler Effect</h3></div></div></div><p>The Doppler effect<a id="I_indexterm7_id364272" class="indexterm"/> results when there is a relative motion between a sound
      source and the listener. It manifests itself as an increase in frequency
      when the source and listener are approaching each other, and a decrease
      in frequency when the source and listener are moving away from each
      other. For example, the horn of an approaching train seems to increase
      in pitch as it gets closer but seems to decrease in pitch as the train
      passes and moves away. The Doppler effect is a very obvious clue as to
      the relative motion of a sound source that you can capture in your
      games. For example, you could model the sound of a speeding car with a
      Doppler effect complimenting visual cues of a car approaching and
      passing by a player.</p><p>What’s happening physically is that the encounter frequency of the
      sound waves relative to the listener is augmented, owing to the relative
      velocity. An approaching velocity means there are more waves encountered
      by the listener per unit of time, which is heard as a higher frequency
      than the source frequency. Conversely, a departing velocity means there
      are fewer waves encountered per unit of time, which is heard as a lower
      frequency. Assuming still air, the increased frequency heard when the
      sound source and listener are approaching each other is given by the
      relation:</p><table style="border: 0; " class="simplelist"><tr><td>f<sub>h</sub> = f [(c +
        v<sub>l</sub>)/(c + v<sub>s</sub>)]</td></tr></table><p>where <span class="emphasis"><em>f</em></span><sub>h</sub> is the
      frequency heard by the listener, <span class="emphasis"><em>c</em></span> is the speed of
      sound, <span class="emphasis"><em>v</em></span><sub>l</sub> is the speed of
      the listener, and <span class="emphasis"><em>v</em></span><sub>s</sub> is the
      speed of the source. This equation shows that the frequency heard by the
      listener is increased in proportion to the ratio of the sum of the speed
      of sound plus the relative speed of the source and listener to the speed
      of sound. If the source and listener are moving away from each other,
      then <span class="emphasis"><em>v</em></span><sub>r</sub> is negative and the
      frequency heard is reduced.</p><p>For your game, you could use prerecorded sounds with Doppler
      effects for passing cars or other moving sound sources; however, you
      won’t be able to adjust the Doppler effect to represent the actual
      relative speed between sound source and listener if you’re simulating
      the object to which the sound is attached using the techniques discussed
      in this book. Your prerecorded sound is fixed. It may work just fine, by
      the way. That said, if you’re using an audio system such as <a id="I_indexterm7_id364360" class="indexterm"/>OpenAL, you can use its built-in Doppler effect
      capabilities. Basically, if you’re simulating an object that’s
      generating a sound, you update its sound source to reflect the object’s
      velocity while at the same time updating the listener object to reflect
      the player’s velocity. OpenAL will handle the rest for you. We’ll show a
      simple example of this in the next <a id="I_indexterm7_id364374" class="indexterm"/>section.</p></div></div><div class="sect1" title="3D Sound"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="d_sound">3D Sound</h2></div></div></div><p>At one time <a id="so26.3" class="indexterm"/><a id="th26.3" class="indexterm"/>not so long ago, “3D sound” was hyped as the next big thing.
    There’s no doubt that for a long time, game sound lagged far behind
    graphics capabilities. It’s also true that good 3D sound can compliment
    good visuals, helping to create a more immersive gaming environment.
    Unfortunately, a lot of early 3D sound just wasn’t that good. Things are
    getting better, though, and with the use of headphones and a good sound
    card, some amazing 3D sounds can be generated.</p><p>If used properly, 3D sound can give your player the sensation that
    sounds are coming from different distinct directions. For example, a shot
    fired from behind the player would be accompanied by the player hearing a
    gunshot sound as though it really were coming from behind. Such
    directional sound really adds to the immersive experience of a
    game.</p><div class="sect2" title="How We Hear in 3D"><div class="titlepage"><div><div><h3 class="title" id="how_we_hear_in_3d">How We Hear in 3D</h3></div></div></div><p>3D sound—or more specifically, our ability to localize a sound—is
      the result of a complex interaction between the sound source and our
      bodies, not to mention the room or environment we happen to be in.
      Ignoring environmental interactions, <a class="xref" href="ch26.html#d_sound-id1" title="Figure 26-9. 3D sound">Figure 26-9</a>
      illustrates how a sound wave interacts with one’s body.</p><div class="figure"><a id="d_sound-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_id364474"/><img src="httpatomoreillycomsourceoreillyimages1599029.png" alt="3D sound"/></div></div><div class="figure-title">Figure 26-9. 3D sound</div></div><p>One of the first things you may notice is that our ears are
      separated by some finite distance. This means that the sound coming from
      the source on the right will reach the right ear before it reaches the
      left ear. The time delay between the sound reaching each ear is called
      <a id="I_indexterm7_id364497" class="indexterm"/>the <span class="emphasis"><em>interaural delay</em></span>. We can
      approximately calculate the delay from a sound coming from the side by
      taking the distance separating the ears and dividing it by the speed of
      sound. In air and for a typical head size, that delay is around half a
      millisecond. The delay will be shorter depending on the orientation of
      your head with respect to the sound source. Whatever the delay is, our
      brains use that information to help determine the location from which
      the sound is coming.</p><p>Additionally, as the sound coming from the right in <a class="xref" href="ch26.html#d_sound-id1" title="Figure 26-9. 3D sound">Figure 26-9</a> reaches the head, some of the energy is
      reflected off the head. Reflections also occur off the shoulders and
      torso. Further, as the sound waves pass the head they tend to bend
      around it. Higher-frequency waves tend to get blocked by the head, and
      lower-frequency waves tend to pass by with little interruption. The
      resulting sound in the shadow region behind the head is somewhat
      different than the source due to the effective filtering that has
      occurred via interaction with the head. Also, notice that the
      orientation of the ears with respect to the sound source is different,
      and sound waves will interact with the ear and ear canal differently due
      to this differing orientation.</p><p>If the sound is coming from above or below the person in addition
      to being offset laterally, the sound will reflect off and diffract
      around different parts of the body in different ways.</p><p>Considering all these interactions, it would seem that the sound
      we end up hearing is quite different from the pure source sound. Well,
      the differences may not be that dramatic, but they are sufficient to
      allow our brains to pick up on all these cues, allowing us to locate the
      sound source. Given that we are all different shapes and sizes, our
      brains are tuned to our specific bodies when processing these
      localization cues.</p><p>It would seem that including believable 3D sound is virtually
      impossible to achieve in games given the complexity of sounds
      interacting with the listener. Certainly you can’t model every potential
      game player along with your game sounds to compute how they interact
      with each other. That said, one approach to capturing the important
      localization cues is to use what are <a id="I_indexterm7_id364547" class="indexterm"/><a id="I_indexterm7_id364553" class="indexterm"/>called <span class="emphasis"><em>head-related transfer
      functions</em></span> (HRTFs).</p><p>If you were to place a small microphone in each ear and then
      record the sound reaching each ear from some known source, you’d have
      what is called a <span class="emphasis"><em>binaural recording</em></span>. In <a id="I_indexterm7_id364572" class="indexterm"/>other words, the two recordings—one for each ear—capture
      the sound received by each, which, given all the factors we described
      earlier, are different from each other. These two recordings contain
      information that our brains use to help us localize the source
      sound.</p><p>Now, if you compare these binaural recordings by taking the ratio
      of each to the source sound, you’d end up with what’s called <a id="I_indexterm7_id364587" class="indexterm"/>a <span class="emphasis"><em>transfer function</em></span> for each ear.
      (The math is more complicated than we imply here.) These are the HRTFs.
      And you can derive an HRTF for a sound located at any position relative
      to a listener. So, the binaural recordings for a source located at a
      specific location yield a pair of HRTFs. That’s not too bad, but that’s
      only for one single source location. You need HRTFs for every location
      if you are to emulate a 3D sound from any location. Obviously,
      generating HRTFs for every possible relative location isn’t practical,
      so HRTFs are typically derived from binaural recordings taken at many
      discrete locations to create a library, so to speak, of transfer
      functions.</p><p>The HRTFs are then used to derive filters for a given sound you
      want to play back with 3D emulation. Two <a id="I_indexterm7_id364608" class="indexterm"/>filters are required—one for each ear. And the HRTFs used
      to derive those filters are those that correspond closest to the
      location of the 3D sound source you’re trying to emulate.</p><p>It is a lot of work to make all these recordings and derive the
      corresponding HRTFs. Sometimes the recordings are made using a dummy,
      and sometimes real humans are used. In either case, it is unlikely that
      you or your player resemble exactly the dummy or human subject used to
      make the recordings and HRTFs. This means the synthesized 3D sound may
      only approximate the cues for any particular person.</p></div><div class="sect2" title="A Simple Example"><div class="titlepage"><div><div><h3 class="title" id="a_simple_example">A Simple Example</h3></div></div></div><p>OpenAL allows you to <a id="op26.3.2" class="indexterm"/>simulate 3D sound via easy-to-use source and listener objects with associated
        properties of each, such as position, velocity, and orientation, among others. You need only
        associate the sound data to a source and set its properties, listener position, velocity,
        and orientation. OpenAL will handle the rest for you. How good the results sound depends on
        the OpenAL implementation you’re using and the sound hardware in use. OpenAL leaves
        implementation of things such as HRTFs to the hardware.</p><p>For demonstration purposes, we took the PlayStatic example
      provided in the Creative Labs OpenAL SDK and modified it slightly to
      have the sound source move around the listener. We’ve also included the
      Doppler effect to give the impression of the source moving toward or
      away from the listener. The relevant code is as follows:</p><a id="I_programlisting7_id364674"/><pre class="programlisting">int main()
{
    ALuint      uiBuffer;
    ALuint      uiSource;
    ALint       iState;

    // Initialize Framework
    ALFWInit();

    if (!ALFWInitOpenAL())
    {
        ALFWprintf("Failed to initialize OpenAL\n");
        ALFWShutdown();
        return 0;
    }

    // Generate an AL Buffer
    alGenBuffers( 1, &amp;uiBuffer );

    // Load Wave file into OpenAL Buffer
    if (!ALFWLoadWaveToBuffer((char*)ALFWaddMediaPath(TEST_WAVE_FILE), uiBuffer))
    {
        ALFWprintf("Failed to load %s\n", ALFWaddMediaPath(TEST_WAVE_FILE));
    }

    // Specify the location of the Listener
    alListener3f(AL_POSITION, 0, 0, 0);

    // Generate a Source to playback the Buffer
    alGenSources( 1, &amp;uiSource );

    // Attach Source to Buffer
    alSourcei( uiSource, AL_BUFFER, uiBuffer );

    // Set the Doppler effect factor
    alDopplerFactor(10);

    // Initialize variables used to reposition the source
    float x = 75;
    float y = 0;
    float z = −10;
    float dx = −1;
    float dy = 0.1;
    float dz = 0.25;

    // Set Initial Source properties
    alSourcei(uiSource, AL_LOOPING, AL_TRUE);
    alSource3f(uiSource, AL_POSITION, x, y, z);
    alSource3f(uiSource, AL_VELOCITY, dx, dy, dz);

    // Play Source
    alSourcePlay( uiSource );

    do
    {
        Sleep(100);

        if(fabs(x) &gt; 75) dx = -dx;
        if(fabs(y) &gt; 5) dy = -dy;
        if(fabs(z) &gt; 10) dz = -dz;
        alSource3f(uiSource, AL_VELOCITY, dx, dy, dz);

        x += dx;
        y += dy;
        z += dz;
        alSource3f(uiSource, AL_POSITION, x, y, z);

        // Get Source State
        alGetSourcei( uiSource, AL_SOURCE_STATE, &amp;iState);
    } while (iState == AL_PLAYING);

    // Clean up by deleting Source(s) and Buffer(s)
    alSourceStop(uiSource);
    alDeleteSources(1, &amp;uiSource);
    alDeleteBuffers(1, &amp;uiBuffer);

    ALFWShutdownOpenAL();

    ALFWShutdown();

    return 0;
}</pre><p>There’s nothing fancy about this demonstration, and in fact there
      are no graphics. The program runs in a console window. That’s OK,
      however, since you really need your ears and not your eyes to appreciate
      this demonstration. Be sure to use headphones if you test it yourself.
      The 3D effect is much better with headphones.</p><p>The lines of code within <code class="literal">main()</code>
      all the way up to the comment <code class="literal">Specify the
      location of the Listener</code> are just OpenAL initialization calls
      required to set up the framework and associate a sound file with a sound
      buffer that will hold the sound data for later playback.</p><p>The next line of code after the aforementioned comment sets the
      location of the listener. We specify the listener’s location at the
      origin. In a game, you would set the listener location to the player’s
      location as the player moves about your game world. In this example, the
      listener stays put.</p><p>A source is then created and associated with the previously
      created sound buffer. Since we want to include the Doppler effect, we
      set the Doppler factor to 10. The default is 1, but we amped it up to
      enhance the effect.</p><p>Next we create six new local variables to store the source’s
      <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and
      <span class="emphasis"><em>z</em></span> coordinates and the increments in position by
      which we’ll move the source around. After initializing those variables,
      we set a few properties of the source—namely, we specify that we want
      the source sound to loop and then we set its initial position and
      velocity. The velocity properties are important for the Doppler effect.
      If you forget to set the velocity properties, you’ll get no Doppler
      effect even if you move the source around by changing its position
      coordinates.</p><p>Next, the source is set to play, and a loop is entered to
      continuously update the source’s position every 100 milliseconds. The
      code within the loop simply adds the coordinate increments to the
      current coordinates for the source and checks to be sure the source
      remains within certain bounds. If the source gets too far away,
      attenuation will be such that you won’t hear it any longer, which just
      gets boring.</p><p>The remainder of the code takes care of housecleaning upon
      exit.</p><p>That’s really all there is to creating 3D sound effects using
      OpenAL. Of course, managing multiple sounds with environmental effects
      in a real game is certainly more involved, but the fundamentals are the
      <a id="I_indexterm7_id364766" class="indexterm"/><a id="I_indexterm7_id364776" class="indexterm"/><a id="I_indexterm7_id364785" class="indexterm"/>same.</p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Colophon</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="author_bios.html" title="About the Authors"/><link rel="next" href="upgrade_offer_back.html" title="Special Upgrade Offer"/></head><body><div class="colophon" title="Colophon" epub:type="colophon" id="colophon"><h2 class="title">Colophon</h2><p>The animals on the cover of  <span class="emphasis"><em>Physics for Game Developers, 2nd Edition</em></span>
     are a cat and a mouse. The age-old rivalry between cat and mouse has been the topic of many
    children’s books and Saturday cartoons. From traditional folk tales, such as Aesop’s fables and
    Grimm Brothers’ fairy tales, to today’s cartoons, such as  <span class="emphasis"><em>Tom &amp; Jerry</em></span>
    , the cat has chased and bullied the mouse and the mouse has avoided becoming lunch. The cat may
    be bigger and stronger, but the mouse is small, fast, and can fit in tight spaces, so the end
    result is often a battle of wits.  </p><p>The cover image is from a 19-century engraving from the Dover Pictorial Archive. The cover
    font is Adobe ITC Garamond. The text font is Adobe Minion Pro; the heading font is Adobe Myriad
    Condensed; and the code font is Dalton Maag’s Ubuntu Mono.</p></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="upgrade_offer_back.html" title="Special Upgrade Offer"/></head><body><div class="colophon" epub:type="colophon" id="copyright_page_orm"><h2 class="title"/><div><h1 class="title">Physics for Game Developers</h1></div><div><div class="author"><h3 class="author"><span class="firstname">David M Bourg</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Bryan Bywalec</span></h3></div></div><div class="editor"><h4>Editor</h4><h3 class="editor"><span class="firstname">Isabel Kunkle</span></h3></div><div><div class="revhistory"><table style="border: 1; width: 100%; "><tr><td style="text-align: left; vertical-align: top; " colspan="2"><strong>Revision History</strong></td></tr><tr class="revision"><td class="revdate">2013-04-09</td><td class="revremark">First release</td></tr></table></div></div><div><p class="copyright">Copyright © 2013 David M. Bourg and Bryan Bywalec, David M. Bourg, Kenneth Humphreys and Bryan Bywalec</p></div><div><div class="legalnotice" title="Legal Notice"><a id="id559552"/><p>O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most 
          titles (<a class="ulink" href="http://my.safaribooksonline.com/?portal=oreilly" target="_top">http://my.safaribooksonline.com</a>). For more information, contact our corporate/institutional sales department:
          800-998-9938 or <span class="email"><a class="email" href="mailto:corporate@oreilly.com">corporate@oreilly.com</a></span>.</p></div></div><div><div class="legalnotice" title="Legal Notice"><a id="id624160"/><p>Nutshell Handbook, the Nutshell Handbook logo, and the O’Reilly logo are registered
      trademarks of O’Reilly Media, Inc. <span class="emphasis"><em>Physics for Game Developers</em></span>, 2nd
      Edition, the image of a cat and mouse, and related trade dress are trademarks of O’Reilly
      Media, Inc. </p><p>Many of the designations used by manufacturers and sellers to distinguish
          their products are claimed as trademarks. Where those designations appear
          in this book, and O’Reilly Media, Inc., was aware of a trademark claim,
          the designations have been printed in caps or initial caps.    </p></div></div><div><div class="legalnotice" title="Legal Notice"><a id="id507811"/><p>While every precaution has been taken in the preparation of this book,
        the publisher and authors assume no responsibility for errors or omissions, 
        or for damages resulting from the use of the information contained herein.</p></div></div><div><div class="legalnotice" title="Legal Notice"><a id="id642462"/><p/></div></div><div class="publisher"><span class="publishername">O’Reilly Media<br/></span><div class="address"><p><span class="street">1005 Gravenstein Highway North</span></p><p><span class="city">Sebastopol</span>, <span class="state">CA</span> <span class="postcode">95472</span> </p></div></div><div class="timestamp"><p>2013-04-10T06:37:45-07:00</p></div><p/></div></body></html>
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cover</title><style type="text/css"> img { max-width: 100%; }</style></head><body><div id="cover-image"><img src="orm_front_cover.jpg" alt="Second Edition"/></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Physics for Game Developers</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><meta name="description" content="&lt;p&gt;If you want to enrich your game&amp;#8217;s experience with physics-based realism, the expanded edition of this classic book details physics principles applicable to game development. You&amp;#8217;ll learn about collisions, explosions, sound, projectiles, and other effects used in games on Wii, PlayStation, Xbox, smartphones, and tablets. You&amp;#8217;ll also get a handle on how to take advantage of various sensors such as accelerometers and optical tracking devices.&lt;/p&gt;"/><link rel="next" href="upgrade_offer_front.html" title="Special Upgrade Offer"/></head><body><div class="book" title="Physics for Game Developers" id="I_book_id284733"><div class="titlepage"><div><div><h1 class="title">Physics for Game Developers</h1></div><div><div class="author"><h3 class="author"><span class="firstname">David M Bourg</span></h3></div></div><div><div class="author"><h3 class="author"><span class="firstname">Bryan Bywalec</span></h3></div></div><div class="locations"><div class="informalfigure"><div class="mediaobject"><img src="oreilly_large.png.jpg" alt="image with no caption"/></div></div><p class="cities">Beijing • Cambridge • Farnham • Köln • Sebastopol • Tokyo</p></div></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Index</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="apd.html" title="Appendix D. Bibliography"/><link rel="next" href="author_bios.html" title="About the Authors"/></head><body><div class="index" title="Index" epub:type="index" id="id792021"><div class="titlepage"><div><div><h2 class="title">Index</h2></div></div></div><div class="note" title="A note on the digital index"><h3 class="title">A note on the digital index</h3><p>A link in an index entry is displayed as the section title in which that entry appears. Because some sections have multiple index markers, it is not unusual for an entry to have several links to the same section. Clicking on any link will take you directly to the place in the text in which the marker appears.</p></div><div class="index"><div class="indexdiv"><h3>Symbols</h3><dl><dt>* (multiplication) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368676">Matrix Multiplication: The * Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368781">Scalar Multiplication: The * Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368862">Vector Multiplication: The * Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id330950">Quaternion multiplication: The * operator</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id331270">Vector multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370369">Quaternion Multiplication: The * Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370687">Scalar Multiplication: The * Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370758">Vector Multiplication: The * Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366763">Vector Dot Product: The * Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366996">Scalar Multiplication: The * Operator</a></dt><dd/></dl></dd><dt>*= (multiplication) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368242">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369821">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365756">Scalar Multiplication: The *= Operator</a></dt><dd/></dl></dd><dt>+ (addition) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368463">Matrix Addition: The + Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id370223">Quaternion Addition: The + Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366063">Vector Addition: The + Operator</a></dt><dd/></dl></dd><dt>+= (addition) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id367953">Matrix Addition: The += Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369244">Quaternion Addition: The += Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365518">Vector Addition: The += Operator</a></dt><dd/></dl></dd><dt>/ (division) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368598">Scalar Divide: The / Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id367070">Scalar Division: The / Operator</a></dt><dd/></dl></dd><dt>/= (division) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368361">Scalar Division: The /= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369900">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370850">Scalar Division: The / Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365873">Scalar Division: The /= Operator</a></dt><dd/></dl></dd><dt>^ (cross-product) operator, in vector operations, <a class="indexterm" href="ch01.html#I_indexterm1_id290276">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id366330">Vector Cross Product: The ^ Operator</a></dt><dd/><dt>~ (conjugate) operator in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id330665">Conjugate: The ~ operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id369979">Conjugate: The ~ Operator</a></dt><dd/><dt>− (conjugate) operator in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365957">Conjugate: The − Operator</a></dt><dd/><dt>− (subtraction) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368525">Matrix Subtraction: The − Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id370295">Quaternion Subtraction: The − Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366197">Vector Subtraction: The − Operator</a></dt><dd/></dl></dd><dt>−= (subtraction) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368162">Matrix Subtraction: The −= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369565">Quaternion Subtraction: The −= Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365637">Vector Subtraction: The −= Operator</a></dt><dd/></dl></dd></dl></div><div class="indexdiv"><h3>A</h3><dl><dt>Abbott, Ira H., <a class="indexterm" href="ch15.html#I_indexterm1_id339394">Lift and Drag</a></dt><dd/><dt>acceleration</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id296736">Velocity and Acceleration</a></dt><dd/><dt>accelerometer theory on, <a class="indexterm" href="ch21.html#I_indexterm2_id353763">Accelerometer Theory</a></dt><dd/><dt>angular, <a class="indexterm" href="ch01.html#I_indexterm1_id289046">Units and Measures</a>, <a class="indexterm" href="ch02.html#aca2.9">Angular Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id303172">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch04.html#I_indexterm4_id310297">Rigid-Body Kinetics</a></dt><dd/><dt>average, <a class="indexterm" href="ch02.html#I_indexterm2_id296770">Velocity and Acceleration</a></dt><dd/><dt>centrifugal, <a class="indexterm" href="ch17.html#I_indexterm3_id344585">Steering</a></dt><dd/><dt>centripetal, <a class="indexterm" href="ch02.html#I_indexterm2_id302274">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id344564">Steering</a></dt><dd/><dt>constant, <a class="indexterm" href="ch02.html#ac2.2">Constant Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id298133">Constant Acceleration</a></dt><dd/><dt>equations for, <a class="indexterm" href="ch04.html#I_indexterm4_id307778">Particle Kinetics in 2D</a></dt><dd/><dt>equations of motion and, <a class="indexterm" href="ch04.html#I_indexterm4_id308054">Particle Kinetics in 2D</a></dt><dd/><dt>instantaneous, <a class="indexterm" href="ch02.html#I_indexterm2_id296813">Velocity and Acceleration</a></dt><dd/><dt>linear, <a class="indexterm" href="ch01.html#I_indexterm1_id288247">Newton’s Laws of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id288464">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id288967">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id293306">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id305887">Force and Torque</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id351325">Calculating Forces</a></dt><dd/><dt>nonconstant, <a class="indexterm" href="ch02.html#I_indexterm2_id298181">Nonconstant Acceleration</a></dt><dd/><dt>relative, <a class="indexterm" href="ch02.html#I_indexterm2_id302999">Angular Velocity and Acceleration</a></dt><dd/><dt>rotational, <a class="indexterm" href="ch03.html#I_indexterm3_id305917">Force and Torque</a></dt><dd/><dt>second derivatives of, <a class="indexterm" href="ch02.html#I_indexterm2_id297020">Velocity and Acceleration</a></dt><dd/><dt>tangential, <a class="indexterm" href="ch02.html#I_indexterm2_id302299">Angular Velocity and Acceleration</a></dt><dd/><dt>velocity and, <a class="indexterm" href="ch02.html#ac2.1">Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id296947">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>acceleration vector, computing, <a class="indexterm" href="ch01.html#I_indexterm1_id293386">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch25.html#I_indexterm6_id362773">Numerical Differentiation</a></dt><dd/><dt>accelerometers</dt><dd><dl><dt>about, <a class="indexterm" href="ch21.html#ac21.0">Accelerometers</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id353954">Accelerometer Theory</a></dt><dd/><dt>common specifications, <a class="indexterm" href="ch21.html#I_indexterm2_id354093">Common Accelerometer Specifications</a></dt><dd/><dt>controlling sprites example, <a class="indexterm" href="ch21.html#ac21.3.1">Using Tilt to Control a Sprite</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id355947">Two Degrees of Freedom</a></dt><dd/><dt>data clipping, <a class="indexterm" href="ch21.html#I_indexterm2_id354434">Data Clipping</a></dt><dd/><dt>digital, <a class="indexterm" href="ch04.html#I_indexterm4_id306859">Kinetics</a></dt><dd/><dt>MEMS, <a class="indexterm" href="ch21.html#ac21.1">Accelerometer Theory</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id354069">MEMS Accelerometers</a></dt><dd/><dt>sensing orientation with, <a class="indexterm" href="ch08.html#I_indexterm2_id322589">Simple Particle Model</a>, <a class="indexterm" href="ch21.html#I_indexterm2_id354525">Sensing Orientation</a></dt><dd/><dt>sensing tilt, <a class="indexterm" href="ch21.html#ac21.3">Sensing Tilt</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id355910">Two Degrees of Freedom</a></dt><dd/></dl></dd><dt>active stereoization, <a class="indexterm" href="ch24.html#ac24.4">Programming Considerations</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id362117">Active Stereoization</a></dt><dd/><dt>ACVs (air cushion vehicles) (see hovercraft)</dt><dd/><dt>adaptive step size method, <a class="indexterm" href="ch07.html#I_indexterm1_id321116">Euler’s Method</a></dt><dd/><dt>addition (+) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368474">Matrix Addition: The + Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id370233">Quaternion Addition: The + Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366073">Vector Addition: The + Operator</a></dt><dd/></dl></dd><dt>addition (+=) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id367963">Matrix Addition: The += Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369254">Quaternion Addition: The += Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365528">Vector Addition: The += Operator</a></dt><dd/></dl></dd><dt>aerodynamic drag</dt><dd><dl><dt>in billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id351232">Calculating Forces</a></dt><dd/><dt>in cars, <a class="indexterm" href="ch17.html#I_indexterm3_id343931">Resistance</a></dt><dd/><dt>on hovercraft, <a class="indexterm" href="ch14.html#I_indexterm8_id338164">Force Effectors</a>, <a class="indexterm" href="ch17.html#ae17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345838">Resistance</a></dt><dd/></dl></dd><dt>aerostatic lift, <a class="indexterm" href="ch17.html#I_indexterm3_id345024">How Hovercraft Work</a></dt><dd/><dt>ailerons, in aircraft, <a class="indexterm" href="ch12.html#I_indexterm6_id333485">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338680">Geometry</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339945">Control</a></dt><dd/><dt>aim (guns)</dt><dd><dl><dt>breathing and body position, <a class="indexterm" href="ch18.html#ai18.2.2">Breathing and Body Position</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347416">Breathing and Body Position</a></dt><dd/><dt>defined, <a class="indexterm" href="ch18.html#I_indexterm4_id346099">Projectile Motion</a></dt><dd/><dt>elevation adjustments, <a class="indexterm" href="ch18.html#I_indexterm4_id347089">Bullet drop: Gravity and air resistance</a></dt><dd/><dt>shooting positions, <a class="indexterm" href="ch18.html#I_indexterm4_id347347">Breathing and Body Position</a></dt><dd/><dt>taking aim, <a class="indexterm" href="ch18.html#I_indexterm4_id346311">Taking Aim</a></dt><dd/><dt>zeroing the sights, <a class="indexterm" href="ch18.html#ai18.2.1">Zeroing the Sights</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347210">Wind</a></dt><dd/></dl></dd><dt>air cushion vehicles (ACVs) (see hovercraft)</dt><dd/><dt>air drag</dt><dd><dl><dt>particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id323377">Implementing External Forces</a></dt><dd/><dt>for ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id342642">General Resistance</a></dt><dd/><dt>shooting guns example, <a class="indexterm" href="ch06.html#I_indexterm6_id318201">Drag</a></dt><dd/></dl></dd><dt>aircraft</dt><dd><dl><dt>control surfaces in, <a class="indexterm" href="ch15.html#I_indexterm1_id338722">Geometry</a></dt><dd/><dt>controlling, <a class="indexterm" href="ch15.html#I_indexterm1_id339916">Control</a></dt><dd/><dt>flight controls in, <a class="indexterm" href="ch11.html#I_indexterm5_id329032">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch12.html#ai12.3">Flight Controls</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333751">Flight Controls</a></dt><dd/><dt>forces acting on, <a class="indexterm" href="ch15.html#I_indexterm1_id338402">Aircraft</a>, <a class="indexterm" href="ch15.html#ai15.2">Lift and Drag</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id339892">Other Forces</a></dt><dd/><dt>geometry of, <a class="indexterm" href="ch15.html#I_indexterm1_id338565">Geometry</a></dt><dd/><dt>modeling, <a class="indexterm" href="ch15.html#ai15.5">Modeling</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id340946">Modeling</a></dt><dd/><dt>parts of, <a class="indexterm" href="ch15.html#I_indexterm1_id338589">Geometry</a></dt><dd/><dt>quaternion operations in, <a class="indexterm" href="ch11.html#ai11.3">Quaternions in 3D Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332341">Quaternions in 3D Simulators</a></dt><dd/><dt>weather helm and, <a class="indexterm" href="ch17.html#I_indexterm3_id345558">Resistance</a></dt><dd/></dl></dd><dt>airfoil</dt><dd><dl><dt>about, <a class="indexterm" href="ch15.html#I_indexterm1_id338779">Geometry</a></dt><dd/><dt>lift and drag forces, <a class="indexterm" href="ch15.html#aif15.2">Lift and Drag</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id339252">Lift and Drag</a></dt><dd/><dt>stalled, <a class="indexterm" href="ch15.html#I_indexterm1_id339542">Lift and Drag</a></dt><dd/></dl></dd><dt>alpha (opacity), <a class="indexterm" href="ch25.html#I_indexterm6_id362256">Optical Tracking</a></dt><dd/><dt>altitude</dt><dd><dl><dt>barometers and, <a class="indexterm" href="ch23.html#I_indexterm4_id359954">Barometers</a></dt><dd/><dt>defined, <a class="indexterm" href="ch22.html#I_indexterm3_id356074">Gaming from One Place to Another</a></dt><dd/><dt>gravity and, <a class="indexterm" href="ch03.html#I_indexterm3_id303520">Force Fields</a></dt><dd/><dt>trilateration technique and, <a class="indexterm" href="ch22.html#I_indexterm3_id357009">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>anaglyphs, complementary-color, <a class="indexterm" href="ch24.html#I_indexterm5_id360994">Complementary-Color Anaglyphs</a></dt><dd/><dt>Anderson, Byron, <a class="indexterm" href="ch16.html#I_indexterm2_id343485">Propulsion</a></dt><dd/><dt>angle of attack</dt><dd><dl><dt>critical, <a class="indexterm" href="ch15.html#I_indexterm1_id339518">Lift and Drag</a></dt><dd/><dt>defined, <a class="indexterm" href="ch15.html#I_indexterm1_id338828">Geometry</a></dt><dd/><dt>lift and drag forces, <a class="indexterm" href="ch15.html#I_indexterm1_id339051">Lift and Drag</a></dt><dd/><dt>in lift and drag, <a class="indexterm" href="ch15.html#I_indexterm1_id339262">Lift and Drag</a></dt><dd/><dt>stalls and, <a class="indexterm" href="ch15.html#I_indexterm1_id339552">Lift and Drag</a></dt><dd/></dl></dd><dt>angular acceleration</dt><dd><dl><dt>angular velocity and, <a class="indexterm" href="ch02.html#aa2.9">Angular Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id303163">Angular Velocity and Acceleration</a></dt><dd/><dt>rigid-body kinetics and, <a class="indexterm" href="ch04.html#I_indexterm4_id310288">Rigid-Body Kinetics</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289036">Units and Measures</a></dt><dd/></dl></dd><dt>angular displacement, <a class="indexterm" href="ch02.html#I_indexterm2_id301883">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id302095">Angular Velocity and Acceleration</a></dt><dd/><dt>angular effects in collision response, <a class="indexterm" href="ch10.html#an10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328833">Angular Effects</a></dt><dd/><dt>angular impulse</dt><dd><dl><dt>in collisions, <a class="indexterm" href="ch05.html#an5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314587">Linear and Angular Impulse</a></dt><dd/><dt>golf example, <a class="indexterm" href="ch05.html#I_indexterm5_id315035">Friction</a></dt><dd/><dt>in impulse-momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id310974">Impulse-Momentum Principle</a></dt><dd/></dl></dd><dt>angular kinetic energy, <a class="indexterm" href="ch05.html#I_indexterm5_id311541">Impact</a></dt><dd/><dt>angular momentum</dt><dd><dl><dt>equation for, <a class="indexterm" href="ch01.html#I_indexterm1_id294579">Inertia Tensor</a></dt><dd/><dt>laws of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id293665">Newton’s Second Law of Motion</a></dt><dd/></dl></dd><dt>angular motion</dt><dd><dl><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290508">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>particle explosions and, <a class="indexterm" href="ch18.html#I_indexterm4_id347760">Particle Explosions</a></dt><dd/><dt>rigid-body kinetics and, <a class="indexterm" href="ch04.html#an4.3">Rigid-Body Kinetics</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310720">Rigid-Body Kinetics</a></dt><dd/></dl></dd><dt>angular velocity</dt><dd><dl><dt>angular acceleration and, <a class="indexterm" href="ch02.html#av2.9">Angular Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id303191">Angular Velocity and Acceleration</a></dt><dd/><dt>Euler integration and, <a class="indexterm" href="ch12.html#I_indexterm6_id332998">Integration</a></dt><dd/><dt>laws of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id293934">Newton’s Second Law of Motion</a></dt><dd/><dt>rotation in 3D rigid-body simulation and, <a class="indexterm" href="ch11.html#I_indexterm5_id329679">Rotation Matrices</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id330240">Quaternions</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289830">Units and Measures</a></dt><dd/></dl></dd><dt>anisotropic materials, <a class="indexterm" href="ch01.html#I_indexterm1_id294218">Newton’s Second Law of Motion</a></dt><dd/><dt>antipodal locations, <a class="indexterm" href="ch22.html#I_indexterm3_id357428">Distance</a></dt><dd/><dt>Archimedes’ principle of buoyancy, <a class="indexterm" href="ch16.html#I_indexterm2_id341343">Stability</a></dt><dd/><dt>arm rod (golf swings), <a class="indexterm" href="ch19.html#I_indexterm5_id349069">Modeling a Golf Swing</a></dt><dd/><dt>aspect ratio, aircraft wing area, <a class="indexterm" href="ch15.html#I_indexterm1_id338666">Geometry</a></dt><dd/><dt>atan function, <a class="indexterm" href="ch21.html#I_indexterm2_id355174">Using Tilt to Control a Sprite</a></dt><dd/><dt>atan2 function, <a class="indexterm" href="ch22.html#I_indexterm3_id357529">Great-Circle Heading</a></dt><dd/><dt>atmospheric pressure, <a class="indexterm" href="ch23.html#I_indexterm4_id358033">Under Pressure</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id359966">Barometers</a></dt><dd/><dt>atomic clock drift, <a class="indexterm" href="ch22.html#I_indexterm3_id356970">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>attentuation in sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363997">Attenuation</a></dt><dd/><dt>automobiles (see cars)</dt><dd/><dt>autosterescopy, <a class="indexterm" href="ch24.html#I_indexterm5_id361507">Autostereoscopy</a></dt><dd/><dt>average acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id296764">Velocity and Acceleration</a></dt><dd/></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>backward difference scheme, <a class="indexterm" href="ch25.html#I_indexterm6_id362645">Numerical Differentiation</a></dt><dd/><dt>ballistic coefficient (BC), <a class="indexterm" href="ch18.html#I_indexterm4_id346209">Projectile Motion</a></dt><dd/><dt>ballistics and firearms, <a class="indexterm" href="ch18.html#I_indexterm4_id345997">Projectile Motion</a></dt><dd><dl><dt>(see also shooting guns example)</dt><dd/><dt>about, <a class="indexterm" href="ch18.html#I_indexterm4_id345987">Projectile Motion</a></dt><dd/><dt>particle explosions, <a class="indexterm" href="ch18.html#bf18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348024">Particle Explosions</a></dt><dd/><dt>projectile motion, <a class="indexterm" href="ch18.html#gu18.1">Projectile Motion</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id346237">Projectile Motion</a></dt><dd/><dt>recoil and impact, <a class="indexterm" href="ch18.html#I_indexterm4_id347437">Recoil and Impact</a></dt><dd/><dt>taking aim, <a class="indexterm" href="ch18.html#gu18.2">Taking Aim</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347397">Breathing and Body Position</a></dt><dd/></dl></dd><dt>Bancroft, Stephen, <a class="indexterm" href="ch22.html#I_indexterm3_id356948">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>barometers, <a class="indexterm" href="ch23.html#I_indexterm4_id357982">Pressure Sensors and Load Cells</a>, <a class="indexterm" href="ch23.html#ba23.3">Barometers</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id360103">Barometers</a></dt><dd/><dt>baseball examples</dt><dd><dl><dt>collisions in, <a class="indexterm" href="ch05.html#ba5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313126">Impact</a></dt><dd/><dt>Magnus effect in, <a class="indexterm" href="ch06.html#I_indexterm6_id319283">Magnus Effect</a></dt><dd/></dl></dd><dt>BC (ballistic coefficient), <a class="indexterm" href="ch18.html#I_indexterm4_id346215">Projectile Motion</a></dt><dd/><dt>Bernouilli, David, <a class="indexterm" href="ch06.html#I_indexterm6_id317502">Drag</a></dt><dd/><dt>Bernoulli’s equation, <a class="indexterm" href="ch06.html#I_indexterm6_id317473">Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339126">Lift and Drag</a></dt><dd/><dt>billiards</dt><dd><dl><dt>about, <a class="indexterm" href="ch19.html#bi19.2">Billiards</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id350569">Billiards</a></dt><dd/><dt>calculating forces, <a class="indexterm" href="ch19.html#bi19.2.4">Calculating Forces</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351463">Calculating Forces</a></dt><dd/><dt>collision example, <a class="indexterm" href="ch05.html#bi5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id312452">Impact</a></dt><dd/><dt>handling collisions, <a class="indexterm" href="ch19.html#bi19.2.5">Handling Collisions</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351871">Handling Collisions</a></dt><dd/><dt>implementing example, <a class="indexterm" href="ch19.html#bi19.2.1">Implementation</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id350853">Implementation</a></dt><dd/><dt>initializing example, <a class="indexterm" href="ch19.html#bi19.2.2">Initialization</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351012">Stepping the Simulation</a></dt><dd/><dt>stepping simulation, <a class="indexterm" href="ch19.html#I_indexterm5_id351022">Stepping the Simulation</a></dt><dd/></dl></dd><dt>binaural recording, <a class="indexterm" href="ch26.html#I_indexterm7_id364572">How We Hear in 3D</a></dt><dd/><dt>binocular disparity, <a class="indexterm" href="ch24.html#I_indexterm5_id360239">Binocular Vision</a></dt><dd/><dt>binocular rivalry, <a class="indexterm" href="ch24.html#I_indexterm5_id361011">Complementary-Color Anaglyphs</a></dt><dd/><dt>binocular vision, <a class="indexterm" href="ch24.html#bi24.1">Binocular Vision</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360524">Binocular Vision</a></dt><dd/><dt>biomechanics, <a class="indexterm" href="ch19.html#I_indexterm5_id348542">Sports</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id348548">Sports</a></dt><dd><dl><dt>(see also sports)</dt><dd/></dl></dd><dt>boats (see ships and boats)</dt><dd/><dt>Borst, Henry V., <a class="indexterm" href="ch15.html#I_indexterm1_id339470">Lift and Drag</a></dt><dd/><dt>boundary layer in fluid dynamic drag, <a class="indexterm" href="ch06.html#I_indexterm6_id317617">Drag</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342924">Virtual mass</a></dt><dd/><dt>bounding boxes, <a class="indexterm" href="ch14.html#I_indexterm8_id337824">Collision Detection</a></dt><dd/><dt>bounding circle check, <a class="indexterm" href="ch10.html#I_indexterm4_id327359">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id328196">Angular Effects</a></dt><dd/><dt>bounding spheres, <a class="indexterm" href="ch14.html#I_indexterm8_id337808">Collision Detection</a></dt><dd/><dt>Bourg, David M., <a class="indexterm" href="ch08.html#I_indexterm2_id322138">Particles</a></dt><dd/><dt>Bradski, Gary, <a class="indexterm" href="ch25.html#I_indexterm6_id362512">OpenCV</a></dt><dd/><dt>breadth-to-draft ratio, <a class="indexterm" href="ch16.html#I_indexterm2_id342469">General Resistance</a></dt><dd/><dt>breadth-to-length ratio, <a class="indexterm" href="ch16.html#I_indexterm2_id342968">Virtual mass</a></dt><dd/><dt>buoyancy</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#bu3.6">Buoyancy</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id305341">Buoyancy</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch03.html#I_indexterm3_id305275">Buoyancy</a></dt><dd/><dt>pressure and, <a class="indexterm" href="ch03.html#I_indexterm3_id304949">Buoyancy</a></dt><dd/><dt>in ship stability, <a class="indexterm" href="ch16.html#I_indexterm2_id341350">Stability</a></dt><dd/></dl></dd><dt>buttons, pressure-sensitive, <a class="indexterm" href="ch23.html#bu23.2">Button Mashing</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id358459">Button Mashing</a></dt><dd/></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>cannon ball game example (see shooting guns example)</dt><dd/><dt>capacitive touch screens, <a class="indexterm" href="ch20.html#I_indexterm1_id352035">Capacitive</a>, <a class="indexterm" href="ch20.html#ca20.2.2">Capacitive Touch Screens</a>–<a class="indexterm" href="ch20.html#I_indexterm1_id353094">Mutual capacitance</a></dt><dd/><dt>capsizing ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341301">Stability</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341681">Sinking</a></dt><dd/><dt>cars</dt><dd><dl><dt>about, <a class="indexterm" href="ch17.html#I_indexterm3_id343862">Cars</a></dt><dd/><dt>power and, <a class="indexterm" href="ch17.html#I_indexterm3_id344167">Power</a></dt><dd/><dt>resistance and, <a class="indexterm" href="ch17.html#I_indexterm3_id343894">Resistance</a></dt><dd/><dt>steering, <a class="indexterm" href="ch17.html#ca17.1.4">Steering</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id344907">Steering</a></dt><dd/><dt>stopping distance in, <a class="indexterm" href="ch17.html#I_indexterm3_id344340">Stopping Distance</a></dt><dd/></dl></dd><dt>Cartesian coordinate system</dt><dd><dl><dt>about, <a class="indexterm" href="ch01.html#I_indexterm1_id289966">Coordinate System</a></dt><dd/><dt>2D particle
        kinematics and, <a class="indexterm" href="ch02.html#I_indexterm2_id298532">2D Particle Kinematics</a></dt><dd/></dl></dd><dt>Cavendish, Henry, <a class="indexterm" href="ch03.html#I_indexterm3_id303472">Force Fields</a></dt><dd/><dt>cavitation, <a class="indexterm" href="ch16.html#I_indexterm2_id343563">Propulsion</a></dt><dd/><dt>center of gravity (see center of mass)</dt><dd/><dt>center of mass</dt><dd><dl><dt>calculating, <a class="indexterm" href="ch01.html#ce1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id291115">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290578">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>impact and, <a class="indexterm" href="ch05.html#I_indexterm5_id312604">Impact</a></dt><dd/><dt>load cells and, <a class="indexterm" href="ch23.html#ce23.2.1.2">Center of gravity</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id359794">Center of gravity</a></dt><dd/><dt>local coordinate system and, <a class="indexterm" href="ch02.html#I_indexterm2_id301617">Local Coordinate Axes</a></dt><dd/><dt>quaternion rotation and, <a class="indexterm" href="ch11.html#I_indexterm5_id330172">Quaternions</a></dt><dd/><dt>rigid-body kinematics and, <a class="indexterm" href="ch02.html#I_indexterm2_id301520">Rigid-Body Kinematics</a></dt><dd/><dt>in ship stability, <a class="indexterm" href="ch16.html#I_indexterm2_id341437">Stability</a></dt><dd/><dt>torque and, <a class="indexterm" href="ch03.html#I_indexterm3_id306615">Force and Torque</a></dt><dd/><dt>2D example, <a class="indexterm" href="ch01.html#I_indexterm1_id292322">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/></dl></dd><dt>center of percussion, <a class="indexterm" href="ch05.html#I_indexterm5_id312566">Impact</a></dt><dd/><dt>center of pressure, <a class="indexterm" href="ch14.html#I_indexterm8_id338124">Force Effectors</a></dt><dd/><dt>central difference, second-order, <a class="indexterm" href="ch25.html#I_indexterm6_id362804">Numerical Differentiation</a></dt><dd/><dt>central impact, <a class="indexterm" href="ch05.html#I_indexterm5_id311815">Impact</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327309">Linear Collision Response</a></dt><dd/><dt>centrifugal acceleration, <a class="indexterm" href="ch17.html#I_indexterm3_id344579">Steering</a></dt><dd/><dt>centripetal acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id302268">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id344557">Steering</a></dt><dd/><dt>chord length, aircraft wings, <a class="indexterm" href="ch15.html#I_indexterm1_id338638">Geometry</a></dt><dd/><dt>chord line, <a class="indexterm" href="ch15.html#I_indexterm1_id338801">Geometry</a></dt><dd/><dt>circular cylinder, mass moment of inertia formula, <a class="indexterm" href="ch01.html#I_indexterm1_id291542">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>circular cylindrical shell, mass moment of inertia formula, <a class="indexterm" href="ch01.html#I_indexterm1_id291548">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>circular polarization of light, <a class="indexterm" href="ch24.html#ci24.3.2">Linear and Circular Polarization</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id361373">Linear and Circular Polarization</a></dt><dd/><dt>cloth simulation, <a class="indexterm" href="ch13.html#I_indexterm7_id333844">Connecting Objects</a></dt><dd/><dt>coefficient of restitution</dt><dd><dl><dt>applying formula for, <a class="indexterm" href="ch05.html#I_indexterm5_id312940">Impact</a></dt><dd/><dt>collision response and, <a class="indexterm" href="ch14.html#I_indexterm8_id337905">Collision Response</a></dt><dd/><dt>defined, <a class="indexterm" href="ch05.html#I_indexterm5_id311727">Impact</a></dt><dd/><dt>physics models and, <a class="indexterm" href="ch14.html#I_indexterm8_id337480">Physics Models</a></dt><dd/></dl></dd><dt>coefficient of rolling resistance, <a class="indexterm" href="ch17.html#I_indexterm3_id344117">Resistance</a></dt><dd/><dt>coefficients of friction, <a class="indexterm" href="ch03.html#I_indexterm3_id303886">Friction</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337493">Physics Models</a></dt><dd/><dt>collision detection</dt><dd><dl><dt>about, <a class="indexterm" href="ch05.html#I_indexterm5_id310783">Collisions</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327140">Linear Collision Response</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337690">Collision Detection</a></dt><dd/><dt>billiards example, <a class="indexterm" href="ch19.html#cd19.2.5">Handling Collisions</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351880">Handling Collisions</a></dt><dd/><dt>bounding circle check, <a class="indexterm" href="ch10.html#I_indexterm4_id327366">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id328202">Angular Effects</a></dt><dd/><dt>collision response and, <a class="indexterm" href="ch14.html#I_indexterm8_id337931">Collision Response</a></dt><dd/><dt>continuous, <a class="indexterm" href="ch14.html#I_indexterm8_id337764">Collision Detection</a></dt><dd/><dt>particle-to-ground, <a class="indexterm" href="ch08.html#co8.4.1">Particle-to-Ground Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324357">Particle-to-Ground Collisions</a></dt><dd/><dt>particle-to-obstacle, <a class="indexterm" href="ch08.html#co8.4.2">Particle-to-Obstacle Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324917">Particle-to-Obstacle Collisions</a></dt><dd/><dt>physics engines and, <a class="indexterm" href="ch14.html#I_indexterm8_id337273">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337673">Collision Detection</a></dt><dd/><dt>vertex-edge collisions, <a class="indexterm" href="ch10.html#cove10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328861">Angular Effects</a></dt><dd/><dt>vertex-vertex collisions, <a class="indexterm" href="ch10.html#covv10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328438">Angular Effects</a></dt><dd/></dl></dd><dt>collision response</dt><dd><dl><dt>about, <a class="indexterm" href="ch05.html#I_indexterm5_id310796">Collisions</a></dt><dd/><dt>angular effects in, <a class="indexterm" href="ch10.html#co10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328842">Angular Effects</a></dt><dd/><dt>billiards example, <a class="indexterm" href="ch19.html#cr19.2.5">Handling Collisions</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351889">Handling Collisions</a></dt><dd/><dt>collision detection and, <a class="indexterm" href="ch14.html#I_indexterm8_id337921">Collision Response</a></dt><dd/><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311322">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312819">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347507">Recoil and Impact</a></dt><dd/><dt>implementing, <a class="indexterm" href="ch10.html#co10.0">Implementing Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328805">Angular Effects</a></dt><dd/><dt>impulse-momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id310941">Impulse-Momentum Principle</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337889">Collision Response</a></dt><dd/><dt>linear, <a class="indexterm" href="ch10.html#co10.1">Linear Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id327955">Linear Collision Response</a></dt><dd/><dt>particle-to-ground, <a class="indexterm" href="ch08.html#cor8.4.1">Particle-to-Ground Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324376">Particle-to-Ground Collisions</a></dt><dd/><dt>particle-to-obstacle, <a class="indexterm" href="ch08.html#cor8.4.2">Particle-to-Obstacle Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324927">Particle-to-Obstacle Collisions</a></dt><dd/><dt>physics engines and, <a class="indexterm" href="ch14.html#I_indexterm8_id337283">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337860">Collision Response</a></dt><dd/></dl></dd><dt>collisions</dt><dd><dl><dt>about, <a class="indexterm" href="ch05.html#I_indexterm5_id310757">Collisions</a></dt><dd/><dt>angular impulse in, <a class="indexterm" href="ch05.html#coa5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314635">Linear and Angular Impulse</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id315054">Friction</a></dt><dd/><dt>baseball and bat example, <a class="indexterm" href="ch05.html#cobb5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313135">Impact</a></dt><dd/><dt>billiard ball example, <a class="indexterm" href="ch05.html#cob5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id312461">Impact</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id350424">Billiards</a></dt><dd/><dt>friction and, <a class="indexterm" href="ch05.html#co5.4">Friction</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id315449">Friction</a></dt><dd/><dt>golf example, <a class="indexterm" href="ch05.html#cg5.4">Friction</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id315468">Friction</a></dt><dd/><dt>handling in billiards example, <a class="indexterm" href="ch19.html#co19.2.5">Handling Collisions</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351899">Handling Collisions</a></dt><dd/><dt>impact force and, <a class="indexterm" href="ch05.html#co5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313098">Impact</a></dt><dd/><dt>implementing in particle simulation, <a class="indexterm" href="ch08.html#co8.4">Implementing Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324899">Particle-to-Obstacle Collisions</a></dt><dd/><dt>impulse-momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id310906">Impulse-Momentum Principle</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337879">Collision Response</a></dt><dd/><dt>inelastic, <a class="indexterm" href="ch05.html#I_indexterm5_id311631">Impact</a></dt><dd/><dt>line of action of, <a class="indexterm" href="ch05.html#I_indexterm5_id311765">Impact</a></dt><dd/><dt>linear impulse in, <a class="indexterm" href="ch05.html#co5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314597">Linear and Angular Impulse</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327295">Linear Collision Response</a></dt><dd/><dt>penetration in, <a class="indexterm" href="ch10.html#I_indexterm4_id327252">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327681">Linear Collision Response</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337950">Collision Response</a></dt><dd/><dt>plastic, <a class="indexterm" href="ch05.html#I_indexterm5_id311647">Impact</a></dt><dd/></dl></dd><dt>compartments in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341633">Sinking</a></dt><dd/><dt>complementary-color anaglyphs, <a class="indexterm" href="ch24.html#I_indexterm5_id360987">Complementary-Color Anaglyphs</a></dt><dd/><dt>condensation, <a class="indexterm" href="ch26.html#I_indexterm7_id363018">What Is Sound?</a></dt><dd/><dt>condition table, motion-identifying, <a class="indexterm" href="ch23.html#I_indexterm4_id359506">Center of gravity</a></dt><dd/><dt>conjugate operator</dt><dd><dl><dt>in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id330672">Conjugate: The ~ operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id369989">Conjugate: The ~ Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365947">Conjugate: The − Operator</a></dt><dd/></dl></dd><dt>connecting objects</dt><dd><dl><dt>about, <a class="indexterm" href="ch13.html#I_indexterm7_id333789">Connecting Objects</a></dt><dd/><dt>connecting particles, <a class="indexterm" href="ch13.html#cop13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335362">Update the simulation</a></dt><dd/><dt>connecting rigid bodies, <a class="indexterm" href="ch13.html#cc13.3">Connecting Rigid Bodies</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336971">Rotational Restraint</a></dt><dd/><dt>hanging rope or vine example, <a class="indexterm" href="ch13.html#co13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335343">Update the simulation</a></dt><dd/><dt>linked-chain example, <a class="indexterm" href="ch13.html#cl13.3">Connecting Rigid Bodies</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336981">Rotational Restraint</a></dt><dd/></dl></dd><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311333">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312813">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347470">Recoil and Impact</a></dt><dd/><dt>constant acceleration, <a class="indexterm" href="ch02.html#co2.2">Constant Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id298143">Constant Acceleration</a></dt><dd/><dt>contact forces</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id303254">Forces</a></dt><dd/><dt>in billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id351282">Calculating Forces</a></dt><dd/><dt>center of mass and, <a class="indexterm" href="ch03.html#I_indexterm3_id306646">Force and Torque</a></dt><dd/><dt>collision response and, <a class="indexterm" href="ch14.html#I_indexterm8_id337988">Collision Response</a></dt><dd/><dt>friction as, <a class="indexterm" href="ch03.html#co3.3">Friction</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id304485">Friction</a></dt><dd/></dl></dd><dt>contact manifold, <a class="indexterm" href="ch14.html#I_indexterm8_id337702">Collision Detection</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id351590">Handling Collisions</a></dt><dd/><dt>continuous collision detection, <a class="indexterm" href="ch14.html#I_indexterm8_id337758">Collision Detection</a></dt><dd/><dt>convergence distance, <a class="indexterm" href="ch24.html#I_indexterm5_id360744">The Left and Right Frustums</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id362010">Active Stereoization</a></dt><dd/><dt>conversion functions, in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id371854">Conversion Functions</a></dt><dd/><dt>coordinate systems</dt><dd><dl><dt>accelerometer example, <a class="indexterm" href="ch21.html#I_indexterm2_id354583">Sensing Orientation</a></dt><dd/><dt>Cartesian, <a class="indexterm" href="ch01.html#I_indexterm1_id289956">Coordinate System</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id298544">2D Particle Kinematics</a></dt><dd/><dt>in particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id322640">Simple Particle Model</a></dt><dd/><dt>geographic, <a class="indexterm" href="ch22.html#I_indexterm3_id356019">Gaming from One Place to Another</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id357025">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>local, <a class="indexterm" href="ch02.html#I_indexterm2_id301628">Local Coordinate Axes</a></dt><dd/><dt>rotating, <a class="indexterm" href="ch11.html#I_indexterm5_id329310">Rotation Matrices</a></dt><dd/><dt>3D rigid-body simulation, <a class="indexterm" href="ch12.html#I_indexterm6_id332446">3D Rigid-Body Simulator</a></dt><dd/></dl></dd><dt>coordinate transformation, 2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id325781">Transforming Coordinates</a></dt><dd/><dt>coupled motions, <a class="indexterm" href="ch16.html#I_indexterm2_id341813">Ship Motions</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342145">Coupled Motions</a></dt><dd/><dt>critical attack angle, <a class="indexterm" href="ch15.html#I_indexterm1_id339530">Lift and Drag</a></dt><dd/><dt>cross track error, <a class="indexterm" href="ch22.html#I_indexterm3_id357654">Rhumb Line</a></dt><dd/><dt>cross-product (^) operator, in vector operations, <a class="indexterm" href="ch01.html#I_indexterm1_id290298">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id366324">Vector Cross Product: The ^ Operator</a></dt><dd/></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>dampers</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id305523">Springs and Dampers</a></dt><dd/><dt>connecting objects, <a class="indexterm" href="ch13.html#I_indexterm7_id333981">Springs and Dampers</a></dt><dd/><dt>equation for, <a class="indexterm" href="ch03.html#I_indexterm3_id305573">Springs and Dampers</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id334062">Springs and Dampers</a></dt><dd/><dt>uses for, <a class="indexterm" href="ch03.html#I_indexterm3_id305773">Springs and Dampers</a></dt><dd/></dl></dd><dt>data clipping in accelerometers, <a class="indexterm" href="ch21.html#I_indexterm2_id354443">Data Clipping</a></dt><dd/><dt>degrees of freedom</dt><dd><dl><dt>controlling sprites example, <a class="indexterm" href="ch21.html#de21.3.2">Two Degrees of Freedom</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id355928">Two Degrees of Freedom</a></dt><dd/><dt>rigid bodies and, <a class="indexterm" href="ch11.html#I_indexterm5_id328955">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch21.html#I_indexterm2_id354545">Sensing Orientation</a></dt><dd/><dt>ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341694">Sinking</a>, <a class="indexterm" href="ch16.html#de16.2">Ship Motions</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id342122">Pitch</a></dt><dd/></dl></dd><dt>DegreesToRadians function, <a class="indexterm" href="apc.html#I_indexterm_id371822">Conversion Functions</a></dt><dd/><dt>density</dt><dd><dl><dt>sound and, <a class="indexterm" href="ch26.html#I_indexterm7_id363031">What Is Sound?</a></dt><dd/><dt>uniform, <a class="indexterm" href="ch04.html#I_indexterm4_id310428">Rigid-Body Kinetics</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288641">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id289115">Units and Measures</a></dt><dd/></dl></dd><dt>depth from focus (cameras), <a class="indexterm" href="ch25.html#I_indexterm6_id362394">Kinect</a></dt><dd/><dt>derivatives</dt><dd><dl><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290356">Derivatives and Integrals</a></dt><dd/><dt>second, <a class="indexterm" href="ch02.html#I_indexterm2_id296979">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>determinant, in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id367388">Determinant</a></dt><dd/><dt>differentiation schemes (optical tracking), <a class="indexterm" href="ch25.html#di25.2">Numerical Differentiation</a>–<a class="indexterm" href="ch25.html#I_indexterm6_id362902">Numerical Differentiation</a></dt><dd/><dt>digital accelerometers, <a class="indexterm" href="ch04.html#I_indexterm4_id306868">Kinetics</a></dt><dd/><dt>digital signal processing, <a class="indexterm" href="ch21.html#I_indexterm2_id353618">Accelerometers</a></dt><dd/><dt>dihedral angle, <a class="indexterm" href="ch15.html#I_indexterm1_id340650">Modeling</a></dt><dd/><dt>direct central impact, <a class="indexterm" href="ch05.html#I_indexterm5_id311831">Impact</a></dt><dd/><dt>direct force effectors, <a class="indexterm" href="ch14.html#I_indexterm8_id338068">Force Effectors</a></dt><dd/><dt>direct impact, <a class="indexterm" href="ch05.html#I_indexterm5_id311787">Impact</a></dt><dd/><dt>direction</dt><dd><dl><dt>acceleration and, <a class="indexterm" href="ch01.html#I_indexterm1_id293342">Newton’s Second Law of Motion</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="ch01.html#I_indexterm1_id290123">Vectors</a></dt><dd/><dt>of rotation, <a class="indexterm" href="ch02.html#I_indexterm2_id302409">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id305973">Force and Torque</a></dt><dd/><dt>tensors and, <a class="indexterm" href="ch01.html#I_indexterm1_id294201">Newton’s Second Law of Motion</a></dt><dd/><dt>velocity and, <a class="indexterm" href="ch02.html#I_indexterm2_id296283">Velocity and Acceleration</a>, <a class="indexterm" href="ch02.html#di2.5.1">X Components</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299943">X Components</a></dt><dd/><dt>wind, <a class="indexterm" href="ch04.html#I_indexterm4_id308651">Particle Kinetics in 3D</a></dt><dd/></dl></dd><dt>direction angles, <a class="indexterm" href="apa.html#I_indexterm_id365044">Magnitude</a></dt><dd/><dt>direction cosines, vector, <a class="indexterm" href="ch02.html#I_indexterm2_id299709">X Components</a>, <a class="indexterm" href="apa.html#I_indexterm_id365158">Magnitude</a></dt><dd/><dt>disparity maps, <a class="indexterm" href="ch25.html#I_indexterm6_id362480">OpenCV</a></dt><dd/><dt>dispersive signal technology, <a class="indexterm" href="ch20.html#I_indexterm1_id352120">Exotic: Dispersive Signal and Surface Acoustic Wave</a></dt><dd/><dt>displacement</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id296702">Velocity and Acceleration</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341059">Ships and Boats</a></dt><dd/><dt>accelerometer theory on, <a class="indexterm" href="ch21.html#I_indexterm2_id353843">Accelerometer Theory</a></dt><dd/><dt>angular, <a class="indexterm" href="ch02.html#I_indexterm2_id301873">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id302085">Angular Velocity and Acceleration</a></dt><dd/><dt>distance traveled versus, <a class="indexterm" href="ch02.html#I_indexterm2_id296680">Velocity and Acceleration</a></dt><dd/><dt>formula for, <a class="indexterm" href="ch02.html#I_indexterm2_id297376">Constant Acceleration</a></dt><dd/><dt>volume of ships and, <a class="indexterm" href="ch16.html#I_indexterm2_id341332">Stability</a></dt><dd/><dt>weight of ship and, <a class="indexterm" href="ch16.html#I_indexterm2_id341389">Stability</a></dt><dd/></dl></dd><dt>distance</dt><dd><dl><dt>calculating between latitude and longitude
        coordinates, <a class="indexterm" href="ch22.html#di22.3">Location, Location, Location</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357858">Rhumb Line</a></dt><dd/><dt>convergence, <a class="indexterm" href="ch24.html#I_indexterm5_id360751">The Left and Right Frustums</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id362017">Active Stereoization</a></dt><dd/><dt>equations of motion and, <a class="indexterm" href="ch04.html#I_indexterm4_id308044">Particle Kinetics in 2D</a></dt><dd/><dt>intraocular, <a class="indexterm" href="ch24.html#I_indexterm5_id361951">Active Stereoization</a></dt><dd/><dt>skidding, <a class="indexterm" href="ch17.html#I_indexterm3_id344417">Stopping Distance</a></dt><dd/><dt>stopping, <a class="indexterm" href="ch17.html#I_indexterm3_id344357">Stopping Distance</a></dt><dd/></dl></dd><dt>distance tolerance, <a class="indexterm" href="ch10.html#I_indexterm4_id327524">Linear Collision Response</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337969">Collision Response</a></dt><dd/><dt>distance traveled</dt><dd><dl><dt>displacement versus, <a class="indexterm" href="ch02.html#I_indexterm2_id296690">Velocity and Acceleration</a></dt><dd/><dt>equations for, <a class="indexterm" href="ch04.html#I_indexterm4_id307595">Particle Kinetics in 2D</a></dt><dd/><dt>second derivatives of, <a class="indexterm" href="ch02.html#I_indexterm2_id297041">Velocity and Acceleration</a></dt><dd/><dt>time and, <a class="indexterm" href="ch02.html#I_indexterm2_id296340">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>division (/) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368608">Scalar Divide: The / Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id367080">Scalar Division: The / Operator</a></dt><dd/></dl></dd><dt>division (/=) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368371">Scalar Division: The /= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369912">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370860">Scalar Division: The / Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365884">Scalar Division: The /= Operator</a></dt><dd/></dl></dd><dt>Doppler effect, <a class="indexterm" href="ch26.html#I_indexterm7_id363937">Speed of Sound</a>, <a class="indexterm" href="ch26.html#I_indexterm7_id364272">Doppler Effect</a></dt><dd/><dt>dot-product (*) operator, <a class="indexterm" href="ch01.html#I_indexterm1_id290308">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id366789">Vector Dot Product: The * Operator</a></dt><dd/><dt>drag coefficient</dt><dd><dl><dt>aircraft and, <a class="indexterm" href="ch15.html#I_indexterm1_id339784">Other Forces</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch06.html#I_indexterm6_id318014">Drag</a></dt><dd/><dt>cars and, <a class="indexterm" href="ch17.html#I_indexterm3_id344047">Resistance</a></dt><dd/><dt>fluid dynamic drag and, <a class="indexterm" href="ch03.html#I_indexterm3_id304570">Fluid Dynamic Drag</a></dt><dd/><dt>hovercraft and, <a class="indexterm" href="ch17.html#I_indexterm3_id345438">Resistance</a></dt><dd/><dt>physics models and, <a class="indexterm" href="ch14.html#I_indexterm8_id337503">Physics Models</a></dt><dd/><dt>terminal velocity and, <a class="indexterm" href="ch06.html#I_indexterm6_id318473">Drag</a></dt><dd/></dl></dd><dt>drag forces</dt><dd><dl><dt>aircraft in flight and, <a class="indexterm" href="ch15.html#I_indexterm1_id338450">Aircraft</a>, <a class="indexterm" href="ch15.html#dr15.2">Lift and Drag</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id339703">Lift and Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339760">Other Forces</a></dt><dd/><dt>on cars, <a class="indexterm" href="ch17.html#I_indexterm3_id343916">Resistance</a></dt><dd/><dt>fluid dynamic, <a class="indexterm" href="ch03.html#I_indexterm3_id304529">Fluid Dynamic Drag</a></dt><dd/><dt>on hovercraft, <a class="indexterm" href="ch17.html#dr17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345847">Resistance</a></dt><dd/><dt>nonconstant acceleration and, <a class="indexterm" href="ch02.html#I_indexterm2_id298201">Nonconstant Acceleration</a></dt><dd/><dt>particle kinetics in 3D, <a class="indexterm" href="ch04.html#I_indexterm4_id308408">Particle Kinetics in 3D</a></dt><dd/><dt>resistance in ships and, <a class="indexterm" href="ch16.html#dr16.3.1">General Resistance</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id342734">General Resistance</a></dt><dd/><dt>speed and, <a class="indexterm" href="ch06.html#I_indexterm6_id317380">Drag</a></dt><dd/><dt>viscous, <a class="indexterm" href="ch03.html#I_indexterm3_id304552">Fluid Dynamic Drag</a></dt><dd/></dl></dd></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>Einstein, Albert, <a class="indexterm" href="ch01.html#I_indexterm1_id295675">Relativistic Time</a>, <a class="indexterm" href="ch21.html#I_indexterm2_id353944">Accelerometer Theory</a></dt><dd/><dt>electromagnetic waves, <a class="indexterm" href="ch24.html#I_indexterm5_id361150">Linear and Circular Polarization</a></dt><dd/><dt>elevators, in aircraft, <a class="indexterm" href="ch12.html#I_indexterm6_id333544">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339964">Control</a></dt><dd/><dt>engineering strain, <a class="indexterm" href="ch23.html#I_indexterm4_id358574">Tiny scales</a></dt><dd/><dt>equal and opposite forces, <a class="indexterm" href="ch03.html#I_indexterm3_id305511">Springs and Dampers</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id338308">Numerical Integrator</a></dt><dd/><dt>equations of motion</dt><dd><dl><dt>defined, <a class="indexterm" href="ch04.html#I_indexterm4_id306828">Kinetics</a></dt><dd/><dt>linked-chain example, <a class="indexterm" href="ch13.html#I_indexterm7_id336522">Update</a></dt><dd/><dt>numerical integrators and, <a class="indexterm" href="ch14.html#I_indexterm8_id338214">Numerical Integrator</a></dt><dd/><dt>particle kinetics in 2D, <a class="indexterm" href="ch04.html#eq4.1">Particle Kinetics in 2D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308105">Particle Kinetics in 2D</a></dt><dd/><dt>particle kinetics in 3D, <a class="indexterm" href="ch04.html#I_indexterm4_id308188">Particle Kinetics in 3D</a></dt><dd/><dt>in particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id322820">Integrator</a></dt><dd/><dt>real-time simulations and, <a class="indexterm" href="ch07.html#eq7.1">Integrating the Equations of Motion</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id320129">Integrating the Equations of Motion</a></dt><dd/><dt>in 2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id325801">Transforming Coordinates</a></dt><dd/></dl></dd><dt>Euler angles</dt><dd><dl><dt>constructing quaternions from, <a class="indexterm" href="ch11.html#I_indexterm5_id331381">MakeQFromEulerAngles</a>, <a class="indexterm" href="apc.html#I_indexterm_id371236">MakeQFromEulerAngles</a></dt><dd/><dt>extracting from quaternions, <a class="indexterm" href="ch11.html#I_indexterm5_id331653">MakeEulerAnglesFromQ</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333195">Integration</a>, <a class="indexterm" href="apc.html#I_indexterm_id371512">MakeEulerAnglesFromQ</a></dt><dd/><dt>steering cars and, <a class="indexterm" href="ch17.html#I_indexterm3_id344537">Steering</a></dt><dd/><dt>in 3D motion, <a class="indexterm" href="ch02.html#I_indexterm2_id301712">Local Coordinate Axes</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id328969">Rotation in 3D Rigid-Body Simulators</a></dt><dd/></dl></dd><dt>Euler’s method</dt><dd><dl><dt>for billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id351060">Stepping the Simulation</a></dt><dd/><dt>improved, <a class="indexterm" href="ch07.html#eu7.3">Better Methods</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321989">Better Methods</a></dt><dd/><dt>modeling golf swings, <a class="indexterm" href="ch19.html#I_indexterm5_id350023">Solving the Golf Swing Equations</a></dt><dd/><dt>in particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id322852">Integrator</a></dt><dd/><dt>in real-time
        simulations, <a class="indexterm" href="ch07.html#eu7.2">Euler’s Method</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321272">Euler’s Method</a></dt><dd/><dt>in 3D rigid-body simulation, <a class="indexterm" href="ch12.html#I_indexterm6_id332915">Integration</a></dt><dd/><dt>in 2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id325937">Integrator</a></dt><dd/></dl></dd><dt>exotic touch screens technologies, <a class="indexterm" href="ch20.html#I_indexterm1_id352111">Exotic: Dispersive Signal and Surface Acoustic Wave</a></dt><dd/><dt>explosions</dt><dd><dl><dt>about, <a class="indexterm" href="ch18.html#I_indexterm4_id347599">Explosions</a></dt><dd/><dt>kinematic particle explosion, <a class="indexterm" href="ch02.html#ex2.6">Kinematic Particle Explosion</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id301463">Kinematic Particle Explosion</a></dt><dd/><dt>kinematic particle explosions, <a class="indexterm" href="ch18.html#exk18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348033">Particle Explosions</a></dt><dd/><dt>particle, <a class="indexterm" href="ch18.html#ex18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348014">Particle Explosions</a></dt><dd/><dt>polygon, <a class="indexterm" href="ch18.html#ex18.4.2">Polygon Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348264">Polygon Explosions</a></dt><dd/></dl></dd><dt>external ballistics, <a class="indexterm" href="ch18.html#I_indexterm4_id346060">Projectile Motion</a></dt><dd/></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>fade effect, <a class="indexterm" href="ch02.html#I_indexterm2_id301417">Kinematic Particle Explosion</a></dt><dd/><dt>far zero, <a class="indexterm" href="ch18.html#I_indexterm4_id346770">Bullet drop: Gravity and air resistance</a></dt><dd/><dt>field forces</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id303272">Forces</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id303377">Force Fields</a></dt><dd/><dt>center of mass and, <a class="indexterm" href="ch03.html#I_indexterm3_id306636">Force and Torque</a></dt><dd/></dl></dd><dt>filters</dt><dd><dl><dt>accelerometers and, <a class="indexterm" href="ch21.html#I_indexterm2_id353607">Accelerometers</a></dt><dd/><dt>polarized light and, <a class="indexterm" href="ch24.html#I_indexterm5_id361193">Linear and Circular Polarization</a></dt><dd/><dt>in 3D sound, <a class="indexterm" href="ch26.html#I_indexterm7_id364608">How We Hear in 3D</a></dt><dd/></dl></dd><dt>firearms (see ballistics and firearms)</dt><dd/><dt>fireworks exploding, <a class="indexterm" href="ch02.html#I_indexterm2_id301437">Kinematic Particle Explosion</a></dt><dd/><dt>flag model, <a class="indexterm" href="ch13.html#I_indexterm7_id333867">Connecting Objects</a></dt><dd/><dt>flaps, in aircraft, <a class="indexterm" href="ch12.html#I_indexterm6_id333492">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338692">Geometry</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339652">Lift and Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339929">Control</a></dt><dd/><dt>flight controls, 3D rigid-body simulation, <a class="indexterm" href="ch11.html#I_indexterm5_id328992">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch12.html#fl12.3">Flight Controls</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333742">Flight Controls</a>, <a class="indexterm" href="ch15.html#fl15.5">Modeling</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id340965">Modeling</a></dt><dd/><dt>flight simulation (see aircraft)</dt><dd/><dt>fluid dynamic drag</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id304519">Fluid Dynamic Drag</a></dt><dd/><dt>around a sphere, <a class="indexterm" href="ch06.html#fls6.2">Drag</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id317924">Drag</a></dt><dd/><dt>boundary layer in, <a class="indexterm" href="ch06.html#I_indexterm6_id317607">Drag</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342930">Virtual mass</a></dt><dd/><dt>drag coefficient, <a class="indexterm" href="ch03.html#I_indexterm3_id304580">Fluid Dynamic Drag</a>, <a class="indexterm" href="ch06.html#I_indexterm6_id318025">Drag</a></dt><dd/><dt>laminar flow, <a class="indexterm" href="ch03.html#I_indexterm3_id304637">Fluid Dynamic Drag</a></dt><dd/><dt>in projectiles, <a class="indexterm" href="ch06.html#fl6.2">Drag</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id318155">Drag</a></dt><dd/><dt>Reynolds number, <a class="indexterm" href="ch06.html#I_indexterm6_id317827">Drag</a></dt><dd/><dt>separation point in, <a class="indexterm" href="ch06.html#I_indexterm6_id317685">Drag</a></dt><dd/><dt>of spinning sphere, <a class="indexterm" href="ch06.html#I_indexterm6_id318945">Magnus Effect</a></dt><dd/><dt>turbulent flow, <a class="indexterm" href="ch03.html#I_indexterm3_id304693">Fluid Dynamic Drag</a></dt><dd/><dt>turbulent wake, <a class="indexterm" href="ch06.html#I_indexterm6_id317706">Drag</a></dt><dd/></dl></dd><dt>football simulation game, <a class="indexterm" href="ch02.html#I_indexterm2_id301056">Kinematic Particle Explosion</a></dt><dd/><dt>force</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id303234">Forces</a></dt><dd/><dt>aggregating, <a class="indexterm" href="ch14.html#I_indexterm8_id338253">Numerical Integrator</a></dt><dd/><dt>on aircraft in flight, <a class="indexterm" href="ch15.html#I_indexterm1_id338389">Aircraft</a>, <a class="indexterm" href="ch15.html#fo15.2">Lift and Drag</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id339882">Other Forces</a></dt><dd/><dt>buoyancy, <a class="indexterm" href="ch03.html#fo3.6">Buoyancy</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id305332">Buoyancy</a></dt><dd/><dt>calculating in billiards example, <a class="indexterm" href="ch19.html#fo19.2.4">Calculating Forces</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351472">Calculating Forces</a></dt><dd/><dt>equal and opposite, <a class="indexterm" href="ch03.html#I_indexterm3_id305502">Springs and Dampers</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id338288">Numerical Integrator</a></dt><dd/><dt>fluid dynamic drag, <a class="indexterm" href="ch03.html#I_indexterm3_id304509">Fluid Dynamic Drag</a></dt><dd/><dt>impact, <a class="indexterm" href="ch05.html#fo5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313107">Impact</a></dt><dd/><dt>impulse, <a class="indexterm" href="ch05.html#I_indexterm5_id310931">Impulse-Momentum Principle</a></dt><dd/><dt>linear acceleration and, <a class="indexterm" href="ch03.html#I_indexterm3_id305897">Force and Torque</a></dt><dd/><dt>Newton’s second law of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id288207">Newton’s Laws of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id293266">Newton’s Second Law of Motion</a></dt><dd/><dt>pressure versus, <a class="indexterm" href="ch03.html#I_indexterm3_id304771">Pressure</a></dt><dd/><dt>springs and dampers, <a class="indexterm" href="ch03.html#I_indexterm3_id305365">Springs and Dampers</a></dt><dd/><dt>static, <a class="indexterm" href="ch03.html#I_indexterm3_id303792">Friction</a></dt><dd/><dt>torque versus, <a class="indexterm" href="ch03.html#fo3.8">Force and Torque</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id306660">Force and Torque</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288442">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id289185">Units and Measures</a></dt><dd/></dl></dd><dt>force effectors, <a class="indexterm" href="ch14.html#I_indexterm8_id338047">Force Effectors</a></dt><dd/><dt>forces at a distance, <a class="indexterm" href="ch03.html#I_indexterm3_id303286">Forces</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id303388">Force Fields</a></dt><dd/><dt>forward azimuth, <a class="indexterm" href="ch22.html#I_indexterm3_id357474">Great-Circle Heading</a></dt><dd/><dt>FourSquare app, <a class="indexterm" href="ch22.html#I_indexterm3_id356206">Mixed Reality</a></dt><dd/><dt>frequency</dt><dd><dl><dt>measuring for accelerometers, <a class="indexterm" href="ch21.html#I_indexterm2_id353656">Accelerometers</a></dt><dd/><dt>measuring for sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363255">What Is Sound?</a></dt><dd/></dl></dd><dt>friction</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#fr3.3">Friction</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id304475">Friction</a></dt><dd/><dt>in billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id351383">Calculating Forces</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch03.html#I_indexterm3_id303746">Friction</a></dt><dd/><dt>coefficients of, <a class="indexterm" href="ch03.html#I_indexterm3_id303892">Friction</a></dt><dd/><dt>collisions and, <a class="indexterm" href="ch05.html#fr5.4">Friction</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id315440">Friction</a></dt><dd/><dt>recoil and, <a class="indexterm" href="ch18.html#I_indexterm4_id347537">Recoil and Impact</a></dt><dd/><dt>skidding distance and, <a class="indexterm" href="ch17.html#I_indexterm3_id344370">Stopping Distance</a></dt><dd/></dl></dd><dt>frictional drag</dt><dd><dl><dt>aircraft and, <a class="indexterm" href="ch15.html#I_indexterm1_id339847">Other Forces</a></dt><dd/><dt>Bernouilli’s equation and, <a class="indexterm" href="ch06.html#I_indexterm6_id317508">Drag</a></dt><dd/><dt>moving through fluid and, <a class="indexterm" href="ch01.html#I_indexterm1_id288552">Units and Measures</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342314">General Resistance</a></dt><dd/></dl></dd><dt>frustum, viewing, <a class="indexterm" href="ch24.html#fr24.2.1">The Left and Right Frustums</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360928">The Left and Right Frustums</a></dt><dd/><dt>fuselage, in aircraft, <a class="indexterm" href="ch15.html#I_indexterm1_id338600">Geometry</a></dt><dd/><dt>fusion in binocular vision, <a class="indexterm" href="ch24.html#I_indexterm5_id360273">Binocular Vision</a></dt><dd/></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>game engines, <a class="indexterm" href="ch14.html#I_indexterm8_id337258">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338372">Aircraft</a></dt><dd/><dt>geocaching, <a class="indexterm" href="ch22.html#I_indexterm3_id356148">Geocaching and Reverse Geocaching</a></dt><dd/><dt>geographic coordinate system, <a class="indexterm" href="ch22.html#I_indexterm3_id356013">Gaming from One Place to Another</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id357020">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>Gillespie, Thomas, <a class="indexterm" href="ch17.html#I_indexterm3_id344931">Steering</a></dt><dd/><dt>Global Positioning System (GPS)</dt><dd><dl><dt>about, <a class="indexterm" href="ch22.html#I_indexterm3_id355966">Gaming from One Place to Another</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356274">What Time Is It?</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id360060">Barometers</a></dt><dd/><dt>calculating between latitude and longitude, <a class="indexterm" href="ch22.html#gl22.3">Location, Location, Location</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357868">Rhumb Line</a></dt><dd/><dt>location-based gaming and, <a class="indexterm" href="ch22.html#I_indexterm3_id356121">Location-Based Gaming</a></dt><dd/><dt>trilateration technique, <a class="indexterm" href="ch22.html#gl22.2">Two-Dimensional Mathematical Treatment</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357036">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>GM (stability index), <a class="indexterm" href="ch16.html#I_indexterm2_id341521">Stability</a></dt><dd/><dt>golf examples</dt><dd><dl><dt>in collisions, <a class="indexterm" href="ch05.html#go5.4">Friction</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id315459">Friction</a></dt><dd/><dt>Magnus effect in, <a class="indexterm" href="ch06.html#I_indexterm6_id319234">Magnus Effect</a></dt><dd/><dt>modeling golf swings, <a class="indexterm" href="ch19.html#go19.1">Modeling a Golf Swing</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id350323">Solving the Golf Swing Equations</a></dt><dd/><dt>physics engine considerations, <a class="indexterm" href="ch14.html#I_indexterm8_id337211">Building Your Own Physics Engine</a></dt><dd/><dt>two-rod model, <a class="indexterm" href="ch19.html#I_indexterm5_id349034">Modeling a Golf Swing</a></dt><dd/></dl></dd><dt>Google Maps, <a class="indexterm" href="ch23.html#I_indexterm4_id360081">Barometers</a></dt><dd/><dt>GPS (Global Positioning System)</dt><dd><dl><dt>about, <a class="indexterm" href="ch22.html#I_indexterm3_id355976">Gaming from One Place to Another</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356263">What Time Is It?</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id360051">Barometers</a></dt><dd/><dt>calculating between latitude and longitude, <a class="indexterm" href="ch22.html#gp22.3">Location, Location, Location</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357878">Rhumb Line</a></dt><dd/><dt>location-based gaming and, <a class="indexterm" href="ch22.html#I_indexterm3_id356111">Location-Based Gaming</a></dt><dd/><dt>trilateration technique, <a class="indexterm" href="ch22.html#gp22.2">Two-Dimensional Mathematical Treatment</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357046">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>gravitational force</dt><dd><dl><dt>accelerometer theory on, <a class="indexterm" href="ch21.html#I_indexterm2_id353893">Accelerometer Theory</a></dt><dd/><dt>aircraft in flight and, <a class="indexterm" href="ch15.html#I_indexterm1_id338413">Aircraft</a></dt><dd/><dt>as force effector, <a class="indexterm" href="ch14.html#I_indexterm8_id338089">Force Effectors</a></dt><dd/><dt>Newton’s law of grativation, <a class="indexterm" href="ch03.html#I_indexterm3_id303409">Force Fields</a></dt><dd/><dt>particle simulation and, <a class="indexterm" href="ch08.html#gr8.1">Simple Particle Model</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id322758">Simple Particle Model</a></dt><dd/><dt>projectiles and, <a class="indexterm" href="ch06.html#I_indexterm6_id315636">Projectiles</a></dt><dd/><dt>zeroing the sights and, <a class="indexterm" href="ch18.html#gr18.2.1.1">Bullet drop: Gravity and air resistance</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347130">Bullet drop: Gravity and air resistance</a></dt><dd/></dl></dd><dt>great-circle heading, <a class="indexterm" href="ch22.html#I_indexterm3_id357185">Location, Location, Location</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id357466">Great-Circle Heading</a></dt><dd/><dt>Greenwich Observatory (UK), <a class="indexterm" href="ch22.html#I_indexterm3_id356066">Gaming from One Place to Another</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356312">What Time Is It?</a></dt><dd/><dt>grid partitioning, game space, <a class="indexterm" href="ch14.html#I_indexterm8_id337785">Collision Detection</a></dt><dd/><dt>ground plane, particle-to-ground collisions, <a class="indexterm" href="ch08.html#gr8.4.1">Particle-to-Ground Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324367">Particle-to-Ground Collisions</a></dt><dd/><dt>guns, shooting (see ballistics and firearms)</dt><dd/><dt>gyroscopes, <a class="indexterm" href="ch21.html#I_indexterm2_id354560">Sensing Orientation</a></dt><dd/></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>Hamilton, William, <a class="indexterm" href="ch11.html#I_indexterm5_id329931">Quaternions</a></dt><dd/><dt>haptic feedback in touch screens, <a class="indexterm" href="ch20.html#I_indexterm1_id353320">Haptic Feedback</a></dt><dd/><dt>harmonic wave, <a class="indexterm" href="ch26.html#I_indexterm7_id363173">What Is Sound?</a>, <a class="indexterm" href="ch26.html#I_indexterm7_id363626">Harmonic Wave</a></dt><dd/><dt>Harr-like features (optical tracking), <a class="indexterm" href="ch25.html#I_indexterm6_id362540">OpenCV</a></dt><dd/><dt>haversine formula for distance, <a class="indexterm" href="ch22.html#I_indexterm3_id357238">Distance</a></dt><dd/><dt>head-related transfer functions (HRTFs), <a class="indexterm" href="ch26.html#I_indexterm7_id364547">How We Hear in 3D</a></dt><dd/><dt>heave motion in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341924">Ship Motions</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341948">Heave</a></dt><dd/><dt>hectoPascals (hPa), <a class="indexterm" href="ch23.html#I_indexterm4_id360002">Barometers</a></dt><dd/><dt>heuristic subroutines, <a class="indexterm" href="ch24.html#I_indexterm5_id362170">Passive Stereoization</a></dt><dd/><dt>high lift devices, <a class="indexterm" href="ch15.html#I_indexterm1_id339666">Lift and Drag</a></dt><dd/><dt>high-pass filters (accelerometers), <a class="indexterm" href="ch21.html#I_indexterm2_id353595">Accelerometers</a></dt><dd/><dt>higher-order terms, <a class="indexterm" href="ch07.html#I_indexterm1_id320424">Euler’s Method</a></dt><dd/><dt>Hoerner, Sighard F., <a class="indexterm" href="ch15.html#I_indexterm1_id339464">Lift and Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339812">Other Forces</a></dt><dd/><dt>holographs, <a class="indexterm" href="ch24.html#I_indexterm5_id361677">Advanced Technologies</a></dt><dd/><dt>Hooke’s law, <a class="indexterm" href="ch03.html#I_indexterm3_id305388">Springs and Dampers</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id333993">Springs and Dampers</a></dt><dd/><dt>horsepower in cars, <a class="indexterm" href="ch17.html#I_indexterm3_id344187">Power</a></dt><dd/><dt>hovercraft</dt><dd><dl><dt>about, <a class="indexterm" href="ch17.html#ho17.2">Hovercraft</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345174">How Hovercraft Work</a></dt><dd/><dt>aerodynamic drag on, <a class="indexterm" href="ch14.html#I_indexterm8_id338143">Force Effectors</a>, <a class="indexterm" href="ch17.html#hoa17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345829">Resistance</a></dt><dd/><dt>implementing collision response, <a class="indexterm" href="ch10.html#ho10.0">Implementing Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328796">Angular Effects</a></dt><dd/><dt>resistance in, <a class="indexterm" href="ch17.html#ho17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345810">Resistance</a></dt><dd/><dt>steering, <a class="indexterm" href="ch17.html#I_indexterm3_id345152">How Hovercraft Work</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id345880">Steering</a></dt><dd/><dt>2D rigid-body
      simulation, <a class="indexterm" href="ch09.html#ho9.0">2D Rigid-Body Simulator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326818">Tuning</a></dt><dd/></dl></dd><dt>hPa (hectoPascals), <a class="indexterm" href="ch23.html#I_indexterm4_id360008">Barometers</a></dt><dd/><dt>HRTFs (head-related transfer functions), <a class="indexterm" href="ch26.html#I_indexterm7_id364553">How We Hear in 3D</a></dt><dd/><dt>hull in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341112">Ships and Boats</a></dt><dd/><dt>hull speed, <a class="indexterm" href="ch16.html#I_indexterm2_id343380">Guidance speeds</a></dt><dd/><dt>human action modeling (see sports)</dt><dd/><dt>hydrodynamic lift, <a class="indexterm" href="ch16.html#I_indexterm2_id341089">Ships and Boats</a></dt><dd/><dt>hydrostatic pressure, <a class="indexterm" href="ch03.html#I_indexterm3_id304868">Pressure</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id358107">Example Effects of High Pressure</a></dt><dd/></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>impact</dt><dd><dl><dt>billiard characteristics for, <a class="indexterm" href="ch19.html#I_indexterm5_id350406">Billiards</a></dt><dd/><dt>center of mass and, <a class="indexterm" href="ch05.html#I_indexterm5_id312614">Impact</a></dt><dd/><dt>central, <a class="indexterm" href="ch05.html#I_indexterm5_id311805">Impact</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327315">Linear Collision Response</a></dt><dd/><dt>collisions and, <a class="indexterm" href="ch05.html#im5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313117">Impact</a></dt><dd/><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311312">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312828">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347497">Recoil and Impact</a></dt><dd/><dt>direct, <a class="indexterm" href="ch05.html#I_indexterm5_id311793">Impact</a></dt><dd/><dt>direct central, <a class="indexterm" href="ch05.html#I_indexterm5_id311837">Impact</a></dt><dd/><dt>oblique, <a class="indexterm" href="ch05.html#I_indexterm5_id311856">Impact</a></dt><dd/></dl></dd><dt>improved Euler method, <a class="indexterm" href="ch07.html#im7.3">Better Methods</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321980">Better Methods</a></dt><dd/><dt>impulse</dt><dd><dl><dt>angular, <a class="indexterm" href="ch05.html#I_indexterm5_id310998">Impulse-Momentum Principle</a>, <a class="indexterm" href="ch05.html#ia5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314607">Linear and Angular Impulse</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id315044">Friction</a></dt><dd/><dt>defined, <a class="indexterm" href="ch05.html#I_indexterm5_id310922">Impulse-Momentum Principle</a></dt><dd/><dt>linear, <a class="indexterm" href="ch05.html#I_indexterm5_id311007">Impulse-Momentum Principle</a>, <a class="indexterm" href="ch05.html#il5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314616">Linear and Angular Impulse</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327285">Linear Collision Response</a></dt><dd/><dt>projectiles and, <a class="indexterm" href="ch06.html#I_indexterm6_id315606">Projectiles</a></dt><dd/></dl></dd><dt>impulse torque, <a class="indexterm" href="ch05.html#I_indexterm5_id311119">Impulse-Momentum Principle</a></dt><dd/><dt>impulse-momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id310916">Impulse-Momentum Principle</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337872">Collision Response</a></dt><dd/><dt>indirect force effectors, <a class="indexterm" href="ch14.html#I_indexterm8_id338081">Force Effectors</a></dt><dd/><dt>induced drag, <a class="indexterm" href="ch17.html#I_indexterm3_id345328">Resistance</a></dt><dd/><dt>inelastic collisions, <a class="indexterm" href="ch05.html#I_indexterm5_id311624">Impact</a></dt><dd/><dt>inertia tensors</dt><dd><dl><dt>about, <a class="indexterm" href="ch01.html#I_indexterm1_id294523">Inertia Tensor</a></dt><dd/><dt>angular momentum equation, <a class="indexterm" href="ch01.html#I_indexterm1_id294568">Inertia Tensor</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch01.html#I_indexterm1_id295579">Inertia Tensor</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332637">Model</a></dt><dd/><dt>products of inertia, <a class="indexterm" href="ch01.html#I_indexterm1_id295202">Inertia Tensor</a></dt><dd/><dt>symmetry and, <a class="indexterm" href="ch01.html#I_indexterm1_id295457">Inertia Tensor</a></dt><dd/><dt>transfer of axis formula, <a class="indexterm" href="ch01.html#I_indexterm1_id295305">Inertia Tensor</a></dt><dd/></dl></dd><dt>inertia, defined, <a class="indexterm" href="ch17.html#I_indexterm3_id344595">Steering</a></dt><dd/><dt>infrared touch screens, <a class="indexterm" href="ch20.html#I_indexterm1_id352060">Infrared and Optical Imaging</a></dt><dd/><dt>initial value problem, <a class="indexterm" href="ch07.html#I_indexterm1_id319956">Integrating the Equations of Motion</a></dt><dd/><dt>instantaneous acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id296806">Velocity and Acceleration</a></dt><dd/><dt>instantaneous velocity</dt><dd><dl><dt>calculating, <a class="indexterm" href="ch02.html#I_indexterm2_id297267">Constant Acceleration</a></dt><dd/><dt>defined, <a class="indexterm" href="ch02.html#I_indexterm2_id296551">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>integral photography, <a class="indexterm" href="ch24.html#I_indexterm5_id361701">Advanced Technologies</a></dt><dd/><dt>integrals, defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290412">Derivatives and Integrals</a></dt><dd/><dt>integrators</dt><dd><dl><dt>3D rigid-body simulation, <a class="indexterm" href="ch12.html#in12.2">Integration</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333236">Integration</a></dt><dd/><dt>about, <a class="indexterm" href="ch08.html#I_indexterm2_id322230">Particles</a></dt><dd/><dt>numerical, <a class="indexterm" href="ch14.html#I_indexterm8_id338225">Numerical Integrator</a></dt><dd/><dt>particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id322809">Integrator</a></dt><dd/><dt>2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#in9.1.2">Integrator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326186">Integrator</a></dt><dd/></dl></dd><dt>intensity of sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363330">What Is Sound?</a></dt><dd/><dt>interaural delay, <a class="indexterm" href="ch26.html#I_indexterm7_id364497">How We Hear in 3D</a></dt><dd/><dt>internal ballistics, <a class="indexterm" href="ch18.html#I_indexterm4_id346040">Projectile Motion</a></dt><dd/><dt>International System of Units (SI), <a class="indexterm" href="ch01.html#I_indexterm1_id288535">Units and Measures</a></dt><dd/><dt>International Towing Tank Conference (ITTC), <a class="indexterm" href="ch16.html#I_indexterm2_id342412">General Resistance</a></dt><dd/><dt>intraocular distance, <a class="indexterm" href="ch24.html#I_indexterm5_id361945">Active Stereoization</a></dt><dd/><dt>inverse, in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id367737">Inverse</a></dt><dd/><dt>isotropic materials, <a class="indexterm" href="ch01.html#I_indexterm1_id294230">Newton’s Second Law of Motion</a></dt><dd/><dt>ITTC ( International Towing Tank Conference), <a class="indexterm" href="ch16.html#I_indexterm2_id342418">General Resistance</a></dt><dd/></dl></div><div class="indexdiv"><h3>J</h3><dl><dt>jittering problem in objects, <a class="indexterm" href="ch14.html#I_indexterm8_id338012">Collision Response</a></dt><dd/><dt>Jorgensen, Theodore P., <a class="indexterm" href="ch19.html#jo19.1">Modeling a Golf Swing</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id350332">Solving the Golf Swing Equations</a></dt><dd/></dl></div><div class="indexdiv"><h3>K</h3><dl><dt>Kaehler, Adrian, <a class="indexterm" href="ch25.html#I_indexterm6_id362520">OpenCV</a></dt><dd/><dt>Kinect system, <a class="indexterm" href="ch25.html#I_indexterm6_id362376">Kinect</a></dt><dd/><dt>kinematic viscosity, <a class="indexterm" href="ch01.html#I_indexterm1_id289254">Units and Measures</a></dt><dd/><dt>kinematics</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id296124">Kinematics</a></dt><dd/><dt>angular velocity and acceleration, <a class="indexterm" href="ch02.html#ki2.9">Angular Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id303153">Angular Velocity and Acceleration</a></dt><dd/><dt>constant acceleration, <a class="indexterm" href="ch02.html#ki2.2">Constant Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id298124">Constant Acceleration</a></dt><dd/><dt>local coordinate axes, <a class="indexterm" href="ch02.html#I_indexterm2_id301601">Local Coordinate Axes</a></dt><dd/><dt>nonconstant acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id298165">Nonconstant Acceleration</a></dt><dd/><dt>particle explosion, <a class="indexterm" href="ch02.html#ki2.6">Kinematic Particle Explosion</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id301444">Kinematic Particle Explosion</a>, <a class="indexterm" href="ch18.html#ki18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348042">Particle Explosions</a></dt><dd/><dt>rigid-body, <a class="indexterm" href="ch02.html#I_indexterm2_id301500">Rigid-Body Kinematics</a></dt><dd/><dt>3D particle, <a class="indexterm" href="ch02.html#ki2.5">3D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300870">Hitting the Target</a></dt><dd/><dt>2D particle, <a class="indexterm" href="ch02.html#ki2.4">2D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299190">2D Particle Kinematics</a></dt><dd/><dt>velocity and acceleration, <a class="indexterm" href="ch02.html#ki2.1">Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id296928">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>kinetic energy</dt><dd><dl><dt>about, <a class="indexterm" href="ch05.html#I_indexterm5_id311500">Impact</a></dt><dd/><dt>of bullets, <a class="indexterm" href="ch18.html#I_indexterm4_id347558">Recoil and Impact</a>, <a class="indexterm" href="ch18.html#kib18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348080">Particle Explosions</a></dt><dd/><dt>converting, <a class="indexterm" href="ch05.html#I_indexterm5_id311454">Impact</a></dt><dd/><dt>of sound waves, <a class="indexterm" href="ch26.html#I_indexterm7_id363296">What Is Sound?</a></dt><dd/></dl></dd><dt>kinetic weapons, <a class="indexterm" href="ch18.html#I_indexterm4_id347571">Recoil and Impact</a></dt><dd/><dt>kinetics</dt><dd><dl><dt>about, <a class="indexterm" href="ch04.html#ki4.0">Kinetics</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id306982">Kinetics</a></dt><dd/><dt>problem-solving guidelines, <a class="indexterm" href="ch04.html#I_indexterm4_id306900">Kinetics</a></dt><dd/><dt>rigid-body, <a class="indexterm" href="ch04.html#ki4.3">Rigid-Body Kinetics</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310701">Rigid-Body Kinetics</a></dt><dd/><dt>3D particle, <a class="indexterm" href="ch04.html#ki4.2">Particle Kinetics in 3D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310043">Cannon Revised</a></dt><dd/><dt>2D particle, <a class="indexterm" href="ch04.html#ki4.1">Particle Kinetics in 2D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308076">Particle Kinetics in 2D</a></dt><dd/></dl></dd><dt>kneeling (shooting position), <a class="indexterm" href="ch18.html#I_indexterm4_id347373">Breathing and Body Position</a></dt><dd/><dt>Kutta condition, <a class="indexterm" href="ch15.html#I_indexterm1_id339080">Lift and Drag</a></dt><dd/><dt>Kutta-Joukouski theorem, <a class="indexterm" href="ch06.html#I_indexterm6_id319058">Magnus Effect</a></dt><dd/></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>laminar flow, <a class="indexterm" href="ch03.html#I_indexterm3_id304631">Fluid Dynamic Drag</a></dt><dd/><dt>latitude</dt><dd><dl><dt>calculating distance between longitude and, <a class="indexterm" href="ch22.html#la22.3">Location, Location, Location</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357887">Rhumb Line</a></dt><dd/><dt>defined, <a class="indexterm" href="ch22.html#I_indexterm3_id356038">Gaming from One Place to Another</a></dt><dd/><dt>trilateration technique and, <a class="indexterm" href="ch22.html#la22.2.1">Two-Dimensional Mathematical Treatment</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357074">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>LC (liquid-crystal) shutter glasses, <a class="indexterm" href="ch24.html#I_indexterm5_id361443">Liquid-Crystal Plasma</a></dt><dd/><dt>LED technology, <a class="indexterm" href="ch20.html#I_indexterm1_id352068">Infrared and Optical Imaging</a></dt><dd/><dt>length</dt><dd><dl><dt>of aircraft wings, <a class="indexterm" href="ch15.html#I_indexterm1_id338645">Geometry</a></dt><dd/><dt>of ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341131">Ships and Boats</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288341">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id289321">Units and Measures</a></dt><dd/></dl></dd><dt>lenticular lenses, <a class="indexterm" href="ch24.html#I_indexterm5_id361598">Autostereoscopy</a></dt><dd/><dt>lift force</dt><dd><dl><dt>about, <a class="indexterm" href="ch06.html#li6.3">Magnus Effect</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id319174">Magnus Effect</a></dt><dd/><dt>aerostatic lift, <a class="indexterm" href="ch17.html#I_indexterm3_id345031">How Hovercraft Work</a></dt><dd/><dt>aircraft in flight and, <a class="indexterm" href="ch15.html#I_indexterm1_id338425">Aircraft</a>, <a class="indexterm" href="ch15.html#li15.2">Lift and Drag</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id339693">Lift and Drag</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch06.html#I_indexterm6_id319190">Magnus Effect</a></dt><dd/></dl></dd><dt>lift-to-drag ratio, <a class="indexterm" href="ch15.html#I_indexterm1_id339437">Lift and Drag</a></dt><dd/><dt>light</dt><dd><dl><dt>polarization of, <a class="indexterm" href="ch24.html#li24.3.2">Linear and Circular Polarization</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id361383">Linear and Circular Polarization</a></dt><dd/><dt>speed of, <a class="indexterm" href="ch01.html#li1.9">Relativistic Time</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id296096">Relativistic Time</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356916">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>linear acceleration</dt><dd><dl><dt>in billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id351313">Calculating Forces</a></dt><dd/><dt>force and, <a class="indexterm" href="ch03.html#I_indexterm3_id305877">Force and Torque</a></dt><dd/><dt>Newton’s second law of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id288236">Newton’s Laws of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id293296">Newton’s Second Law of Motion</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288453">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id288957">Units and Measures</a></dt><dd/></dl></dd><dt>linear collision response, <a class="indexterm" href="ch10.html#li10.1">Linear Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id327946">Linear Collision Response</a></dt><dd/><dt>linear impulse</dt><dd><dl><dt>in collisions, <a class="indexterm" href="ch05.html#li5.3">Linear and Angular Impulse</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id314625">Linear and Angular Impulse</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327273">Linear Collision Response</a></dt><dd/><dt>in impulse-momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id310986">Impulse-Momentum Principle</a></dt><dd/></dl></dd><dt>linear kinetic energy, <a class="indexterm" href="ch05.html#I_indexterm5_id311514">Impact</a></dt><dd/><dt>linear momentum, <a class="indexterm" href="ch01.html#I_indexterm1_id293491">Newton’s Second Law of Motion</a></dt><dd/><dt>linear motion, <a class="indexterm" href="ch01.html#I_indexterm1_id290491">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>linear polarization of light, <a class="indexterm" href="ch24.html#lip24.3.2">Linear and Circular Polarization</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id361393">Linear and Circular Polarization</a></dt><dd/><dt>linear velocity</dt><dd><dl><dt>equation for, <a class="indexterm" href="ch02.html#I_indexterm2_id302131">Angular Velocity and Acceleration</a></dt><dd/><dt>linked-chain example, <a class="indexterm" href="ch13.html#I_indexterm7_id336465">Update</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289768">Units and Measures</a></dt><dd/></dl></dd><dt>linked-chain example, <a class="indexterm" href="ch13.html#li13.3">Connecting Rigid Bodies</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336990">Rotational Restraint</a></dt><dd/><dt>liquid-crystal (LC) shutter glasses, <a class="indexterm" href="ch24.html#I_indexterm5_id361437">Liquid-Crystal Plasma</a></dt><dd/><dt>liquid-crystal plasma displays, <a class="indexterm" href="ch24.html#I_indexterm5_id361425">Liquid-Crystal Plasma</a></dt><dd/><dt>load cells</dt><dd><dl><dt>center of gravity and, <a class="indexterm" href="ch23.html#lo23.2.1.2">Center of gravity</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id359784">Center of gravity</a></dt><dd/><dt>defined, <a class="indexterm" href="ch23.html#I_indexterm4_id357954">Pressure Sensors and Load Cells</a></dt><dd/><dt>gaming uses for, <a class="indexterm" href="ch23.html#I_indexterm4_id357965">Pressure Sensors and Load Cells</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id358498">Load Cells</a></dt><dd/><dt>strain gauges and, <a class="indexterm" href="ch23.html#I_indexterm4_id358542">Tiny scales</a></dt><dd/></dl></dd><dt>local coordinate system, <a class="indexterm" href="ch02.html#I_indexterm2_id301611">Local Coordinate Axes</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338851">Geometry</a></dt><dd/><dt>locality principle, <a class="indexterm" href="ch01.html#I_indexterm1_id295737">Relativistic Time</a></dt><dd/><dt>location-based gaming</dt><dd><dl><dt>about, <a class="indexterm" href="ch22.html#I_indexterm3_id356101">Location-Based Gaming</a></dt><dd/><dt>geographic coordinate system and, <a class="indexterm" href="ch22.html#I_indexterm3_id356000">Gaming from One Place to Another</a></dt><dd/></dl></dd><dt>longitude</dt><dd><dl><dt>calculating distance between latitude and, <a class="indexterm" href="ch22.html#lo22.3">Location, Location, Location</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357896">Rhumb Line</a></dt><dd/><dt>defined, <a class="indexterm" href="ch22.html#I_indexterm3_id356053">Gaming from One Place to Another</a></dt><dd/><dt>origin of determining, <a class="indexterm" href="ch22.html#I_indexterm3_id356286">What Time Is It?</a></dt><dd/><dt>trilateration technique and, <a class="indexterm" href="ch22.html#lo22.2.1">Two-Dimensional Mathematical Treatment</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357083">Two-Dimensional Mathematical Treatment</a></dt><dd/></dl></dd><dt>longitudinal waves, <a class="indexterm" href="ch24.html#I_indexterm5_id361170">Linear and Circular Polarization</a></dt><dd/><dt>Lorentz factor, <a class="indexterm" href="ch01.html#I_indexterm1_id295985">Relativistic Time</a></dt><dd/><dt>Lorentz transformation, <a class="indexterm" href="ch01.html#lo1.9">Relativistic Time</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id296106">Relativistic Time</a></dt><dd/><dt>loudness in sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363286">What Is Sound?</a></dt><dd/><dt>low-pass filters (accelerometers), <a class="indexterm" href="ch21.html#I_indexterm2_id353601">Accelerometers</a></dt><dd/></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>magnitude</dt><dd><dl><dt>in polygon explosions, <a class="indexterm" href="ch18.html#I_indexterm4_id348214">Polygon Explosions</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id330574">Magnitude</a>, <a class="indexterm" href="apc.html#I_indexterm_id369068">Magnitude</a></dt><dd/><dt>scalars and, <a class="indexterm" href="ch01.html#I_indexterm1_id290158">Vectors</a></dt><dd/><dt>tensors and, <a class="indexterm" href="ch01.html#I_indexterm1_id294191">Newton’s Second Law of Motion</a></dt><dd/><dt>of torque, <a class="indexterm" href="ch03.html#I_indexterm3_id306057">Force and Torque</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="ch01.html#I_indexterm1_id290101">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id364933">Magnitude</a></dt><dd/><dt>of velocity, <a class="indexterm" href="ch02.html#I_indexterm2_id296314">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>Magnus effect, <a class="indexterm" href="ch06.html#ma6.3">Magnus Effect</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id319445">Magnus Effect</a></dt><dd/><dt>MakeEulerAnglesFromQ function, <a class="indexterm" href="ch11.html#I_indexterm5_id331647">MakeEulerAnglesFromQ</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333189">Integration</a>, <a class="indexterm" href="apc.html#I_indexterm_id371506">MakeEulerAnglesFromQ</a></dt><dd/><dt>MakeQFromEulerAngles function, <a class="indexterm" href="ch11.html#I_indexterm5_id331375">MakeQFromEulerAngles</a>, <a class="indexterm" href="apc.html#I_indexterm_id371229">MakeQFromEulerAngles</a></dt><dd/><dt>maneuverability of ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id343610">Maneuverability</a></dt><dd/><dt>mass, <a class="indexterm" href="ch21.html#I_indexterm2_id353799">Accelerometer Theory</a></dt><dd><dl><dt>(see also center of mass)</dt><dd/><dt>accelerometer theory on, <a class="indexterm" href="ch21.html#I_indexterm2_id353789">Accelerometer Theory</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch01.html#I_indexterm1_id290687">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290551">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>Newton’s second law of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id288222">Newton’s Laws of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id293281">Newton’s Second Law of Motion</a></dt><dd/><dt>2D example, <a class="indexterm" href="ch01.html#I_indexterm1_id292196">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288330">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id288423">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id289402">Units and Measures</a></dt><dd/><dt>variable, <a class="indexterm" href="ch06.html#I_indexterm6_id319519">Variable Mass</a></dt><dd/><dt>virtual, <a class="indexterm" href="ch16.html#I_indexterm2_id342898">Virtual mass</a></dt><dd/></dl></dd><dt>mass flow rate, <a class="indexterm" href="ch17.html#I_indexterm3_id345492">Resistance</a></dt><dd/><dt>mass moment of inertia</dt><dd><dl><dt>calculating, <a class="indexterm" href="ch01.html#ma1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id291835">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290642">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>physics models and, <a class="indexterm" href="ch14.html#I_indexterm8_id337466">Physics Models</a></dt><dd/><dt>2D example, <a class="indexterm" href="ch01.html#mmi1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id293197">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289558">Units and Measures</a></dt><dd/></dl></dd><dt>mass properties</dt><dd><dl><dt>center of mass, <a class="indexterm" href="ch01.html#I_indexterm1_id290597">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch01.html#mc1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id291125">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290465">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>mass, <a class="indexterm" href="ch01.html#I_indexterm1_id290560">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id290698">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>mass moment of inertia, <a class="indexterm" href="ch01.html#I_indexterm1_id290652">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch01.html#mm1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id291844">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>2D example, <a class="indexterm" href="ch01.html#mp1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id293188">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/></dl></dd><dt>matrix addition, <a class="indexterm" href="apb.html#I_indexterm_id367927">Matrix Addition: The += Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368484">Matrix Addition: The + Operator</a></dt><dd/><dt>matrix functions and operators</dt><dd><dl><dt>matrix addition, <a class="indexterm" href="apb.html#I_indexterm_id367933">Matrix Addition: The += Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368490">Matrix Addition: The + Operator</a></dt><dd/><dt>matrix multiplication, <a class="indexterm" href="apb.html#I_indexterm_id368702">Matrix Multiplication: The * Operator</a></dt><dd/><dt>matrix subtraction, <a class="indexterm" href="apb.html#I_indexterm_id368143">Matrix Subtraction: The −= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368552">Matrix Subtraction: The − Operator</a></dt><dd/><dt>scalar division, <a class="indexterm" href="apb.html#I_indexterm_id368342">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368628">Scalar Divide: The / Operator</a></dt><dd/><dt>scalar multiplication, <a class="indexterm" href="apb.html#I_indexterm_id368222">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368811">Scalar Multiplication: The * Operator</a></dt><dd/><dt>vector multiplication, <a class="indexterm" href="apb.html#I_indexterm_id368891">Vector Multiplication: The * Operator</a></dt><dd/></dl></dd><dt>matrix multiplication, <a class="indexterm" href="apb.html#I_indexterm_id368696">Matrix Multiplication: The * Operator</a></dt><dd/><dt>matrix operations</dt><dd><dl><dt>matrix functions and operators, <a class="indexterm" href="apb.html#mab.2">Matrix Functions and Operators</a>–<a class="indexterm" href="apb.html#I_indexterm_id368911">Vector Multiplication: The * Operator</a></dt><dd/><dt>Matrix3x3 class, <a class="indexterm" href="apb.html#mab.1">Matrix3×3 Class</a>–<a class="indexterm" href="apb.html#I_indexterm_id368383">Scalar Division: The /= Operator</a></dt><dd/></dl></dd><dt>matrix subtraction, <a class="indexterm" href="apb.html#I_indexterm_id368136">Matrix Subtraction: The −= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368545">Matrix Subtraction: The − Operator</a></dt><dd/><dt>Matrix3x3 class</dt><dd><dl><dt>about, <a class="indexterm" href="apb.html#I_indexterm_id367275">Matrix3×3 Class</a></dt><dd/><dt>det method, <a class="indexterm" href="apb.html#I_indexterm_id367396">Determinant</a></dt><dd/><dt>Inverse method, <a class="indexterm" href="apb.html#I_indexterm_id367744">Inverse</a></dt><dd/><dt>matrix addition, <a class="indexterm" href="apb.html#I_indexterm_id367943">Matrix Addition: The += Operator</a></dt><dd/><dt>matrix subtraction, <a class="indexterm" href="apb.html#I_indexterm_id368152">Matrix Subtraction: The −= Operator</a></dt><dd/><dt>scalar division, <a class="indexterm" href="apb.html#I_indexterm_id368352">Scalar Division: The /= Operator</a></dt><dd/><dt>scalar multiplication, <a class="indexterm" href="apb.html#I_indexterm_id368232">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>Transpose method, <a class="indexterm" href="apb.html#I_indexterm_id367526">Transpose</a></dt><dd/></dl></dd><dt>mean camber line, <a class="indexterm" href="ch15.html#I_indexterm1_id338814">Geometry</a></dt><dd/><dt>measures (see units and measures)</dt><dd/><dt>MEMS (microelectromechanical systems), <a class="indexterm" href="ch21.html#me21.0">Accelerometers</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id354050">MEMS Accelerometers</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id359874">Barometers</a></dt><dd/><dt>Mercator projection, <a class="indexterm" href="ch22.html#I_indexterm3_id357674">Rhumb Line</a></dt><dd/><dt>metacenter, in ship stability, <a class="indexterm" href="ch16.html#I_indexterm2_id341497">Stability</a></dt><dd/><dt>microelectromechanical systems (MEMS), <a class="indexterm" href="ch21.html#mi21.0">Accelerometers</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id354059">MEMS Accelerometers</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id359881">Barometers</a></dt><dd/><dt>mixed-reality games, <a class="indexterm" href="ch22.html#I_indexterm3_id356191">Mixed Reality</a></dt><dd/><dt>Miyamoto, Shigeru, <a class="indexterm" href="ch23.html#I_indexterm4_id358511">Load Cells</a></dt><dd/><dt>models</dt><dd><dl><dt>3D rigid-body simulation, <a class="indexterm" href="ch12.html#mo12.1">Model</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id332826">Model</a></dt><dd/><dt>about, <a class="indexterm" href="ch08.html#I_indexterm2_id322217">Particles</a></dt><dd/><dt>aircraft flight, <a class="indexterm" href="ch15.html#mo15.5">Modeling</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id340936">Modeling</a></dt><dd/><dt>connecting objects examples, <a class="indexterm" href="ch13.html#mo13.0">Connecting Objects</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336962">Rotational Restraint</a></dt><dd/><dt>particle simulation, <a class="indexterm" href="ch08.html#mo8.1">Simple Particle Model</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id322749">Simple Particle Model</a></dt><dd/><dt>physics, <a class="indexterm" href="ch14.html#I_indexterm8_id337442">Physics Models</a></dt><dd/><dt>2D rigid-body
        simulation, <a class="indexterm" href="ch09.html#mo9.1">Model</a></dt><dd/></dl></dd><dt>modulo operator, <a class="indexterm" href="ch22.html#I_indexterm3_id357622">Great-Circle Heading</a></dt><dd/><dt>moment (see torque)</dt><dd/><dt>moment of inertia</dt><dd><dl><dt>calculating, <a class="indexterm" href="ch01.html#mo1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id291853">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id295553">Inertia Tensor</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332647">Model</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290627">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>laws of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id293982">Newton’s Second Law of Motion</a></dt><dd/><dt>rigid-body kinetics and, <a class="indexterm" href="ch04.html#I_indexterm4_id310274">Rigid-Body Kinetics</a></dt><dd/><dt>3D example, <a class="indexterm" href="ch01.html#I_indexterm1_id294257">Newton’s Second Law of Motion</a></dt><dd/><dt>2D example, <a class="indexterm" href="ch01.html#mi1.6">Mass, Center of Mass, and Moment of Inertia</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id293207">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/></dl></dd><dt>momentum</dt><dd><dl><dt>angular, <a class="indexterm" href="ch01.html#I_indexterm1_id293655">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id294589">Inertia Tensor</a></dt><dd/><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311349">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312838">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347487">Recoil and Impact</a></dt><dd/><dt>linear, <a class="indexterm" href="ch01.html#I_indexterm1_id293497">Newton’s Second Law of Motion</a></dt><dd/></dl></dd><dt>momentum drag, <a class="indexterm" href="ch17.html#I_indexterm3_id345482">Resistance</a></dt><dd/><dt>motion</dt><dd><dl><dt>angular, <a class="indexterm" href="ch01.html#I_indexterm1_id290518">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch04.html#mo4.3">Rigid-Body Kinetics</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310730">Rigid-Body Kinetics</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347770">Particle Explosions</a></dt><dd/><dt>coupled, <a class="indexterm" href="ch16.html#I_indexterm2_id341819">Ship Motions</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342152">Coupled Motions</a></dt><dd/><dt>linear, <a class="indexterm" href="ch01.html#I_indexterm1_id290498">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>plane, <a class="indexterm" href="ch02.html#I_indexterm2_id301562">Rigid-Body Kinematics</a></dt><dd/><dt>projectile, <a class="indexterm" href="ch18.html#mo18.1">Projectile Motion</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id346247">Projectile Motion</a></dt><dd/><dt>ship, <a class="indexterm" href="ch16.html#mo16.2">Ship Motions</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id342180">Coupled Motions</a></dt><dd/></dl></dd><dt>motion-identifying condition table, <a class="indexterm" href="ch23.html#I_indexterm4_id359499">Center of gravity</a></dt><dd/><dt>mouse-based input versus touch screens, <a class="indexterm" href="ch20.html#I_indexterm1_id353415">Difference from Mouse-Based Input</a></dt><dd/><dt>movement parallax, <a class="indexterm" href="ch24.html#I_indexterm5_id360386">Binocular Vision</a></dt><dd/><dt>multiplication (*) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368686">Matrix Multiplication: The * Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368791">Scalar Multiplication: The * Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368872">Vector Multiplication: The * Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id330960">Quaternion multiplication: The * operator</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id331280">Vector multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370379">Quaternion Multiplication: The * Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370698">Scalar Multiplication: The * Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370768">Vector Multiplication: The * Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366754">Vector Dot Product: The * Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id367006">Scalar Multiplication: The * Operator</a></dt><dd/></dl></dd><dt>multiplication (*=) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368252">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369831">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365766">Scalar Multiplication: The *= Operator</a></dt><dd/></dl></dd><dt>muzzle velocity, <a class="indexterm" href="ch18.html#I_indexterm4_id346125">Projectile Motion</a></dt><dd/></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>NACA foil sections, <a class="indexterm" href="ch15.html#I_indexterm1_id339383">Lift and Drag</a></dt><dd/><dt>neutral axis, <a class="indexterm" href="ch01.html#I_indexterm1_id291412">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>Newton, Isaac, <a class="indexterm" href="ch01.html#I_indexterm1_id288108">Newton’s Laws of Motion</a></dt><dd/><dt>Newton’s laws</dt><dd><dl><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311339">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312858">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347477">Recoil and Impact</a></dt><dd/><dt>equal and opposite forces, <a class="indexterm" href="ch03.html#I_indexterm3_id305492">Springs and Dampers</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id338298">Numerical Integrator</a></dt><dd/><dt>equations of motion and, <a class="indexterm" href="ch04.html#I_indexterm4_id306742">Kinetics</a>, <a class="indexterm" href="ch04.html#I_indexterm4_id307363">Particle Kinetics in 2D</a></dt><dd/><dt>Impulse-Momentum Principle and, <a class="indexterm" href="ch05.html#I_indexterm5_id311246">Impulse-Momentum Principle</a></dt><dd/><dt>of motion, <a class="indexterm" href="ch21.html#I_indexterm2_id353775">Accelerometer Theory</a></dt><dd/><dt>of gravitation, <a class="indexterm" href="ch03.html#I_indexterm3_id303399">Force Fields</a></dt><dd/><dt>of motion, <a class="indexterm" href="ch01.html#I_indexterm1_id288114">Newton’s Laws of Motion</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id288499">Units and Measures</a>, <a class="indexterm" href="ch01.html#ne1.7">Newton’s Second Law of Motion</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id294504">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id303313">Forces</a>, <a class="indexterm" href="ch03.html#I_indexterm3_id303533">Force Fields</a></dt><dd/></dl></dd><dt>nonconstant acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id298175">Nonconstant Acceleration</a></dt><dd/><dt>normalize, in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365232">Normalize</a></dt><dd/><dt>numerical integrators, <a class="indexterm" href="ch14.html#I_indexterm8_id338208">Numerical Integrator</a></dt><dd/></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>object detection (optical tracking), <a class="indexterm" href="ch25.html#I_indexterm6_id362529">OpenCV</a></dt><dd/><dt>Objective-C</dt><dd><dl><dt>accelerometer code example, <a class="indexterm" href="ch21.html#ob21.3.2">Two Degrees of Freedom</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id355938">Two Degrees of Freedom</a></dt><dd/><dt>calculating distances code example, <a class="indexterm" href="ch22.html#I_indexterm3_id357389">Distance</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id357781">Rhumb Line</a></dt><dd/></dl></dd><dt>objects</dt><dd><dl><dt>aggregating forces, <a class="indexterm" href="ch14.html#I_indexterm8_id338268">Numerical Integrator</a></dt><dd/><dt>collision detection considerations, <a class="indexterm" href="ch14.html#I_indexterm8_id337794">Collision Detection</a></dt><dd/><dt>connecting, <a class="indexterm" href="ch13.html#ob13.0">Connecting Objects</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id337037">Rotational Restraint</a></dt><dd/><dt>jittering problem, <a class="indexterm" href="ch14.html#I_indexterm8_id338002">Collision Response</a></dt><dd/><dt>simulated objects manager for, <a class="indexterm" href="ch14.html#I_indexterm8_id337568">Simulated Objects Manager</a></dt><dd/><dt>weight of, <a class="indexterm" href="ch01.html#I_indexterm1_id288387">Units and Measures</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341373">Stability</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id346158">Projectile Motion</a></dt><dd/></dl></dd><dt>oblique impact, <a class="indexterm" href="ch05.html#I_indexterm5_id311850">Impact</a></dt><dd/><dt>occlusion in volumetric displays, <a class="indexterm" href="ch24.html#I_indexterm5_id361760">Advanced Technologies</a></dt><dd/><dt>off-axis method (cameras), <a class="indexterm" href="ch24.html#I_indexterm5_id360770">The Left and Right Frustums</a></dt><dd/><dt>opacity (alpha), <a class="indexterm" href="ch25.html#I_indexterm6_id362250">Optical Tracking</a></dt><dd/><dt>OpenAL API</dt><dd><dl><dt>about, <a class="indexterm" href="ch26.html#I_indexterm7_id362948">Sound</a></dt><dd/><dt>alDistanceModel function, <a class="indexterm" href="ch26.html#I_indexterm7_id364124">Attenuation</a></dt><dd/><dt>alSpeedOfSound function, <a class="indexterm" href="ch26.html#I_indexterm7_id363948">Speed of Sound</a></dt><dd/><dt>AL_SPEED_OF_SOUND property, <a class="indexterm" href="ch26.html#I_indexterm7_id363966">Speed of Sound</a></dt><dd/><dt>Doppler effect, <a class="indexterm" href="ch26.html#I_indexterm7_id364360">Doppler Effect</a></dt><dd/><dt>reverberation special effect, <a class="indexterm" href="ch26.html#I_indexterm7_id364228">Reflection</a></dt><dd/><dt>3D sound example, <a class="indexterm" href="ch26.html#op26.3.2">A Simple Example</a>–<a class="indexterm" href="ch26.html#I_indexterm7_id364785">A Simple Example</a></dt><dd/></dl></dd><dt>OpenCV method for 3D reconstruction, <a class="indexterm" href="ch25.html#I_indexterm6_id362444">OpenCV</a></dt><dd/><dt>optical sensors and tracking</dt><dd><dl><dt>about, <a class="indexterm" href="ch25.html#I_indexterm6_id362222">Optical Tracking</a>, <a class="indexterm" href="ch25.html#I_indexterm6_id362336">Sensors and SDKs</a></dt><dd/><dt>Kinect system, <a class="indexterm" href="ch25.html#I_indexterm6_id362364">Kinect</a></dt><dd/><dt>numerical differentiation, <a class="indexterm" href="ch25.html#op25.2">Numerical Differentiation</a>–<a class="indexterm" href="ch25.html#I_indexterm6_id362892">Numerical Differentiation</a></dt><dd/><dt>OpenCV method for 3D reconstruction, <a class="indexterm" href="ch25.html#I_indexterm6_id362434">OpenCV</a></dt><dd/></dl></dd><dt>optimal imaging techniques, <a class="indexterm" href="ch20.html#I_indexterm1_id352087">Infrared and Optical Imaging</a></dt><dd/><dt>orientation</dt><dd><dl><dt>computing in 2D rigid-body simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id325538">Model</a>, <a class="indexterm" href="ch09.html#I_indexterm3_id326087">Integrator</a></dt><dd/><dt>defining in cannon ball game example, <a class="indexterm" href="ch02.html#I_indexterm2_id299787">X Components</a></dt><dd/><dt>expressing in 3D rigid-body simulations, <a class="indexterm" href="ch11.html#I_indexterm5_id328936">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id329657">Rotation Matrices</a></dt><dd/><dt>importance in rigid bodies, <a class="indexterm" href="ch02.html#I_indexterm2_id296169">Kinematics</a></dt><dd/><dt>quaternions and, <a class="indexterm" href="ch11.html#I_indexterm5_id330001">Quaternions</a>, <a class="indexterm" href="ch11.html#or11.3">Quaternions in 3D Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332351">Quaternions in 3D Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332556">Model</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333082">Integration</a></dt><dd/><dt>sensing with accelerometers, <a class="indexterm" href="ch08.html#I_indexterm2_id322599">Simple Particle Model</a>, <a class="indexterm" href="ch21.html#I_indexterm2_id354535">Sensing Orientation</a></dt><dd/><dt>tracking during body rotation, <a class="indexterm" href="ch02.html#I_indexterm2_id301642">Local Coordinate Axes</a></dt><dd/></dl></dd><dt>out-of-screen effects, <a class="indexterm" href="ch24.html#I_indexterm5_id362084">Active Stereoization</a></dt><dd/><dt>overshoot angle, <a class="indexterm" href="ch16.html#I_indexterm2_id343720">Rudders and Thrust Vectoring</a></dt><dd/><dt>oversteering cars, <a class="indexterm" href="ch17.html#I_indexterm3_id344712">Steering</a></dt><dd/></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>parallax, <a class="indexterm" href="ch24.html#I_indexterm5_id360310">Binocular Vision</a></dt><dd/><dt>parallax barrier in autostereoscopy, <a class="indexterm" href="ch24.html#I_indexterm5_id361525">Autostereoscopy</a></dt><dd/><dt>parallel axis theorem, <a class="indexterm" href="ch01.html#I_indexterm1_id291428">Mass, Center of Mass, and Moment of Inertia</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id292648">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>parameter tuning, <a class="indexterm" href="ch06.html#I_indexterm6_id315553">Projectiles</a></dt><dd/><dt>particle explosions, <a class="indexterm" href="ch02.html#pae2.6">Kinematic Particle Explosion</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id301472">Kinematic Particle Explosion</a>, <a class="indexterm" href="ch18.html#pe18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348052">Particle Explosions</a></dt><dd/><dt>particle kinematics</dt><dd><dl><dt>particle explosions, <a class="indexterm" href="ch02.html#pa2.6">Kinematic Particle Explosion</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id301453">Kinematic Particle Explosion</a>, <a class="indexterm" href="ch18.html#pk18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348061">Particle Explosions</a></dt><dd/><dt>3D, <a class="indexterm" href="ch02.html#pa2.5">3D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300936">Hitting the Target</a></dt><dd/><dt>2D, <a class="indexterm" href="ch02.html#pa2.4">2D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299219">2D Particle Kinematics</a></dt><dd/></dl></dd><dt>particle kinetics</dt><dd><dl><dt>3D, <a class="indexterm" href="ch04.html#pa4.2">Particle Kinetics in 3D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310051">Cannon Revised</a></dt><dd/><dt>2D, <a class="indexterm" href="ch04.html#pa4.1">Particle Kinetics in 2D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308086">Particle Kinetics in 2D</a></dt><dd/></dl></dd><dt>particle simulation</dt><dd><dl><dt>about, <a class="indexterm" href="ch08.html#pa8.0">Particles</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id322397">Particles</a></dt><dd/><dt>basic simulator, <a class="indexterm" href="ch08.html#pa8.2">The Basic Simulator</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id323336">The Basic Simulator</a></dt><dd/><dt>implementing collisions, <a class="indexterm" href="ch08.html#pa8.4">Implementing Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324889">Particle-to-Obstacle Collisions</a></dt><dd/><dt>implementing external forces, <a class="indexterm" href="ch08.html#pa8.3">Implementing External Forces</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id323659">Implementing External Forces</a></dt><dd/><dt>integrating particles, <a class="indexterm" href="ch08.html#I_indexterm2_id322789">Integrator</a></dt><dd/><dt>rendering particles, <a class="indexterm" href="ch08.html#I_indexterm2_id323027">Rendering</a></dt><dd/><dt>simple model, <a class="indexterm" href="ch08.html#pa8.1">Simple Particle Model</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id322739">Simple Particle Model</a></dt><dd/><dt>tuning, <a class="indexterm" href="ch08.html#I_indexterm2_id324947">Tuning</a></dt><dd/></dl></dd><dt>particle-to-ground collisions, <a class="indexterm" href="ch08.html#pa8.4.1">Particle-to-Ground Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324348">Particle-to-Ground Collisions</a></dt><dd/><dt>particle-to-obstacle collisions, <a class="indexterm" href="ch08.html#pa8.4.2">Particle-to-Obstacle Collisions</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id324908">Particle-to-Obstacle Collisions</a></dt><dd/><dt>particles</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id296184">Kinematics</a></dt><dd/><dt>cloth simulation, <a class="indexterm" href="ch13.html#I_indexterm7_id333827">Connecting Objects</a></dt><dd/><dt>connecting, <a class="indexterm" href="ch13.html#pc13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335371">Update the simulation</a></dt><dd/><dt>hanging rope or vine example, <a class="indexterm" href="ch13.html#pa13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335352">Update the simulation</a></dt><dd/><dt>integrating in simulator, <a class="indexterm" href="ch08.html#I_indexterm2_id322799">Integrator</a></dt><dd/><dt>rendering in simulator, <a class="indexterm" href="ch08.html#I_indexterm2_id323038">Rendering</a></dt><dd/><dt>uses for, <a class="indexterm" href="ch08.html#I_indexterm2_id322157">Particles</a></dt><dd/></dl></dd><dt>passive stereoization, <a class="indexterm" href="ch24.html#I_indexterm5_id361878">Programming Considerations</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id362147">Passive Stereoization</a></dt><dd/><dt>pattern recognition, <a class="indexterm" href="ch25.html#I_indexterm6_id362274">Optical Tracking</a></dt><dd/><dt>penalty methods, <a class="indexterm" href="ch05.html#I_indexterm5_id310845">Collisions</a></dt><dd/><dt>penetration in collisions, <a class="indexterm" href="ch10.html#I_indexterm4_id327246">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327675">Linear Collision Response</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337944">Collision Response</a></dt><dd/><dt>percussion, center of, <a class="indexterm" href="ch05.html#I_indexterm5_id312572">Impact</a></dt><dd/><dt>photodetectors, <a class="indexterm" href="ch20.html#I_indexterm1_id352075">Infrared and Optical Imaging</a></dt><dd/><dt>photons, defined, <a class="indexterm" href="ch01.html#I_indexterm1_id295748">Relativistic Time</a></dt><dd/><dt>physics engines</dt><dd><dl><dt>about, <a class="indexterm" href="ch14.html#I_indexterm8_id337060">Physics Engines</a></dt><dd/><dt>building, <a class="indexterm" href="ch14.html#ph14.1">Building Your Own Physics Engine</a>–<a class="indexterm" href="ch14.html#I_indexterm8_id337350">Building Your Own Physics Engine</a></dt><dd/><dt>collision detection in, <a class="indexterm" href="ch14.html#I_indexterm8_id337292">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337663">Collision Detection</a></dt><dd/><dt>collision response in, <a class="indexterm" href="ch14.html#I_indexterm8_id337302">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337849">Collision Response</a></dt><dd/><dt>force effectors and, <a class="indexterm" href="ch14.html#I_indexterm8_id338037">Force Effectors</a></dt><dd/><dt>general-purpose, <a class="indexterm" href="ch14.html#I_indexterm8_id337113">Building Your Own Physics Engine</a></dt><dd/><dt>numerical integrators and, <a class="indexterm" href="ch14.html#I_indexterm8_id338197">Numerical Integrator</a></dt><dd/><dt>physics models, <a class="indexterm" href="ch14.html#I_indexterm8_id337432">Physics Models</a></dt><dd/><dt>purpose-built, <a class="indexterm" href="ch14.html#I_indexterm8_id337129">Building Your Own Physics Engine</a></dt><dd/><dt>simulated objects manager, <a class="indexterm" href="ch14.html#I_indexterm8_id337552">Simulated Objects Manager</a></dt><dd/></dl></dd><dt>physics models, <a class="indexterm" href="ch14.html#I_indexterm8_id337452">Physics Models</a></dt><dd/><dt>piezoresisters, <a class="indexterm" href="ch21.html#I_indexterm2_id354038">MEMS Accelerometers</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id359867">Barometers</a></dt><dd/><dt>piezoresistive strain gauge, <a class="indexterm" href="ch23.html#I_indexterm4_id358598">Tiny scales</a></dt><dd/><dt>pinned joint, <a class="indexterm" href="ch13.html#I_indexterm7_id336711">Rotational Restraint</a></dt><dd/><dt>pitch</dt><dd><dl><dt>flight control action for, <a class="indexterm" href="ch11.html#I_indexterm5_id328999">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333359">Flight Controls</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333553">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339985">Control</a></dt><dd/><dt>local coordinate axes and, <a class="indexterm" href="ch02.html#I_indexterm2_id301746">Local Coordinate Axes</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338867">Geometry</a></dt><dd/><dt>quarter-chord point and, <a class="indexterm" href="ch15.html#I_indexterm1_id339618">Lift and Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id340002">Control</a></dt><dd/><dt>in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341469">Stability</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341896">Ship Motions</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342080">Pitch</a></dt><dd/><dt>in sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363271">What Is Sound?</a></dt><dd/></dl></dd><dt>plane motion, <a class="indexterm" href="ch02.html#I_indexterm2_id301556">Rigid-Body Kinematics</a></dt><dd/><dt>planing vessels, <a class="indexterm" href="ch16.html#I_indexterm2_id341081">Ships and Boats</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342759">Planing craft</a></dt><dd/><dt>plastic collisions, <a class="indexterm" href="ch05.html#I_indexterm5_id311641">Impact</a></dt><dd/><dt>plenum chamber (hovercraft), <a class="indexterm" href="ch17.html#I_indexterm3_id345093">How Hovercraft Work</a></dt><dd/><dt>point sound source, <a class="indexterm" href="ch26.html#I_indexterm7_id364010">Attenuation</a></dt><dd/><dt>point-blank weapons, <a class="indexterm" href="ch18.html#I_indexterm4_id346325">Taking Aim</a></dt><dd/><dt>polarization of light, <a class="indexterm" href="ch24.html#po24.3.2">Linear and Circular Polarization</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id361402">Linear and Circular Polarization</a></dt><dd/><dt>polling rate, <a class="indexterm" href="ch21.html#I_indexterm2_id353643">Accelerometers</a></dt><dd/><dt>polygon explosions, <a class="indexterm" href="ch18.html#po18.4.2">Polygon Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348273">Polygon Explosions</a></dt><dd/><dt>pounds per square foot (psf), <a class="indexterm" href="ch03.html#I_indexterm3_id304818">Pressure</a></dt><dd/><dt>pounds per square inch (psi), <a class="indexterm" href="ch03.html#I_indexterm3_id304797">Pressure</a></dt><dd/><dt>power</dt><dd><dl><dt>of car engines, <a class="indexterm" href="ch17.html#I_indexterm3_id344193">Power</a></dt><dd/><dt>defined, <a class="indexterm" href="ch17.html#I_indexterm3_id344177">Power</a></dt><dd/><dt>hovercraft hover height and, <a class="indexterm" href="ch17.html#I_indexterm3_id345042">How Hovercraft Work</a></dt><dd/><dt>of sound wave, <a class="indexterm" href="ch26.html#I_indexterm7_id363310">What Is Sound?</a></dt><dd/></dl></dd><dt>pressure</dt><dd><dl><dt>atmospheric, <a class="indexterm" href="ch23.html#I_indexterm4_id358039">Under Pressure</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id359972">Barometers</a></dt><dd/><dt>Bernoulli’s equation and, <a class="indexterm" href="ch06.html#I_indexterm6_id317479">Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339133">Lift and Drag</a></dt><dd/><dt>buoyancy and, <a class="indexterm" href="ch03.html#I_indexterm3_id304939">Buoyancy</a></dt><dd/><dt>center of, <a class="indexterm" href="ch14.html#I_indexterm8_id338130">Force Effectors</a></dt><dd/><dt>defined, <a class="indexterm" href="ch23.html#I_indexterm4_id358019">Under Pressure</a></dt><dd/><dt>force versus, <a class="indexterm" href="ch03.html#I_indexterm3_id304761">Pressure</a></dt><dd/><dt>hydrostatic, <a class="indexterm" href="ch03.html#I_indexterm3_id304875">Pressure</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id358114">Example Effects of High Pressure</a></dt><dd/><dt>sound and, <a class="indexterm" href="ch26.html#I_indexterm7_id363040">What Is Sound?</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289628">Units and Measures</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id358070">Under Pressure</a></dt><dd/></dl></dd><dt>pressure drag, <a class="indexterm" href="ch16.html#I_indexterm2_id342479">General Resistance</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id343985">Resistance</a></dt><dd/><dt>pressure sensors</dt><dd><dl><dt>about, <a class="indexterm" href="ch23.html#pr23.0">Pressure Sensors and Load Cells</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id358264">Example Effects of High Pressure</a></dt><dd/><dt>load cells and, <a class="indexterm" href="ch23.html#pr23.2.1">Load Cells</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id359774">Center of gravity</a></dt><dd/><dt>pressure-sensitive buttons and, <a class="indexterm" href="ch23.html#pr23.2">Button Mashing</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id358451">Button Mashing</a></dt><dd/></dl></dd><dt>principal axes, <a class="indexterm" href="ch01.html#I_indexterm1_id295411">Inertia Tensor</a></dt><dd/><dt>products of inertia, <a class="indexterm" href="ch01.html#I_indexterm1_id295212">Inertia Tensor</a></dt><dd/><dt>projectiles</dt><dd><dl><dt>about, <a class="indexterm" href="ch06.html#pr6.0">Projectiles</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id315700">Projectiles</a></dt><dd/><dt>bullets in motion, <a class="indexterm" href="ch18.html#pr18.1">Projectile Motion</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id346256">Projectile Motion</a></dt><dd/><dt>drag and, <a class="indexterm" href="ch06.html#pr6.2">Drag</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id318868">Drag</a></dt><dd/><dt>football simulation game, <a class="indexterm" href="ch02.html#I_indexterm2_id301046">Kinematic Particle Explosion</a></dt><dd/><dt>golf ball flight, <a class="indexterm" href="ch19.html#I_indexterm5_id348968">Modeling a Golf Swing</a></dt><dd/><dt>hitting the target example, <a class="indexterm" href="ch02.html#pr2.5.5">Hitting the Target</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300927">Hitting the Target</a></dt><dd/><dt>impulse forces, <a class="indexterm" href="ch05.html#I_indexterm5_id310953">Impulse-Momentum Principle</a></dt><dd/><dt>Magnus effect, <a class="indexterm" href="ch06.html#pr6.3">Magnus Effect</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id319436">Magnus Effect</a></dt><dd/><dt>particle explosions as, <a class="indexterm" href="ch02.html#pr2.6">Kinematic Particle Explosion</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id301481">Kinematic Particle Explosion</a>, <a class="indexterm" href="ch18.html#pr18.4.1">Particle Explosions</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id348070">Particle Explosions</a></dt><dd/><dt>recoil and impact, <a class="indexterm" href="ch18.html#I_indexterm4_id347447">Recoil and Impact</a></dt><dd/><dt>simple trajectories, <a class="indexterm" href="ch06.html#pr6.1">Simple Trajectories</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id317266">Simple Trajectories</a></dt><dd/><dt>taking aim, <a class="indexterm" href="ch18.html#pr18.2">Taking Aim</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347406">Breathing and Body Position</a></dt><dd/><dt>terminal velocity and, <a class="indexterm" href="ch06.html#I_indexterm6_id318318">Drag</a></dt><dd/><dt>variable mass and, <a class="indexterm" href="ch06.html#I_indexterm6_id319509">Variable Mass</a></dt><dd/></dl></dd><dt>prone (shooting position), <a class="indexterm" href="ch18.html#I_indexterm4_id347380">Breathing and Body Position</a></dt><dd/><dt>propeller walk, <a class="indexterm" href="ch16.html#I_indexterm2_id343786">Propeller walk</a></dt><dd/><dt>propulsion of ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id343472">Propulsion</a></dt><dd/><dt>pseudoranges, <a class="indexterm" href="ch22.html#I_indexterm3_id356637">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>psf (pounds per square foot), <a class="indexterm" href="ch03.html#I_indexterm3_id304824">Pressure</a></dt><dd/><dt>psi (pounds per square inch), <a class="indexterm" href="ch03.html#I_indexterm3_id304804">Pressure</a></dt><dd/></dl></div><div class="indexdiv"><h3>Q</h3><dl><dt>QGetAngle function, <a class="indexterm" href="apc.html#I_indexterm_id370946">QGetAngle</a></dt><dd/><dt>QGetAxis function, <a class="indexterm" href="apc.html#I_indexterm_id370984">QGetAxis</a></dt><dd/><dt>QRotate function, <a class="indexterm" href="apc.html#I_indexterm_id371030">QRotate</a></dt><dd/><dt>quantum tunneling, <a class="indexterm" href="ch21.html#I_indexterm2_id354106">Common Accelerometer Specifications</a></dt><dd/><dt>quarter-chord point, <a class="indexterm" href="ch15.html#I_indexterm1_id339608">Lift and Drag</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id340012">Control</a></dt><dd/><dt>quaternion addition, <a class="indexterm" href="apc.html#I_indexterm_id369264">Quaternion Addition: The += Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370243">Quaternion Addition: The + Operator</a></dt><dd/><dt>Quaternion class</dt><dd><dl><dt>about, <a class="indexterm" href="ch11.html#I_indexterm5_id330482">Quaternion Operations</a>, <a class="indexterm" href="apc.html#I_indexterm_id368990">Quaternion Class</a></dt><dd/><dt>conjugate operator, <a class="indexterm" href="ch11.html#I_indexterm5_id330691">Conjugate: The ~ operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370008">Conjugate: The ~ Operator</a></dt><dd/><dt>GetScalar method, <a class="indexterm" href="apc.html#I_indexterm_id369211">GetScalar</a></dt><dd/><dt>GetVector method, <a class="indexterm" href="apc.html#I_indexterm_id369162">GetVector</a></dt><dd/><dt>Magnitude method, <a class="indexterm" href="ch11.html#I_indexterm5_id330587">Magnitude</a>, <a class="indexterm" href="apc.html#I_indexterm_id369080">Magnitude</a></dt><dd/><dt>quaternion addition, <a class="indexterm" href="apc.html#I_indexterm_id369280">Quaternion Addition: The += Operator</a></dt><dd/><dt>quaternion subtraction, <a class="indexterm" href="apc.html#I_indexterm_id369599">Quaternion Subtraction: The −= Operator</a></dt><dd/><dt>scalar division, <a class="indexterm" href="apc.html#I_indexterm_id369941">Scalar Division: The /= Operator</a></dt><dd/><dt>scalar multiplication, <a class="indexterm" href="apc.html#I_indexterm_id369861">Scalar Multiplication: The *= Operator</a></dt><dd/></dl></dd><dt>quaternion functions and operators</dt><dd><dl><dt>conjugate operator, <a class="indexterm" href="ch11.html#I_indexterm5_id330682">Conjugate: The ~ operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id369998">Conjugate: The ~ Operator</a></dt><dd/><dt>conversion functions, <a class="indexterm" href="apc.html#I_indexterm_id371844">Conversion Functions</a></dt><dd/><dt>DegreesToRadians function, <a class="indexterm" href="apc.html#I_indexterm_id371809">Conversion Functions</a></dt><dd/><dt>MakeEulerAnglesFromQ function, <a class="indexterm" href="ch11.html#I_indexterm5_id331636">MakeEulerAnglesFromQ</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333178">Integration</a>, <a class="indexterm" href="apc.html#I_indexterm_id371495">MakeEulerAnglesFromQ</a></dt><dd/><dt>MakeQFromEulerAngles function, <a class="indexterm" href="ch11.html#I_indexterm5_id331365">MakeQFromEulerAngles</a>, <a class="indexterm" href="apc.html#I_indexterm_id371219">MakeQFromEulerAngles</a></dt><dd/><dt>QGetAngle function, <a class="indexterm" href="apc.html#I_indexterm_id370936">QGetAngle</a></dt><dd/><dt>QGetAxis function, <a class="indexterm" href="apc.html#I_indexterm_id370973">QGetAxis</a></dt><dd/><dt>QRotate function, <a class="indexterm" href="apc.html#I_indexterm_id371020">QRotate</a></dt><dd/><dt>quaternion addition, <a class="indexterm" href="apc.html#I_indexterm_id369270">Quaternion Addition: The += Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370249">Quaternion Addition: The + Operator</a></dt><dd/><dt>quaternion multiplication, <a class="indexterm" href="ch11.html#I_indexterm5_id330977">Quaternion multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370396">Quaternion Multiplication: The * Operator</a></dt><dd/><dt>quaternion subtraction, <a class="indexterm" href="apc.html#I_indexterm_id369590">Quaternion Subtraction: The −= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370321">Quaternion Subtraction: The − Operator</a></dt><dd/><dt>QVRotate function, <a class="indexterm" href="ch11.html#I_indexterm5_id330762">QVRotate</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id332119">Quaternions in 3D Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332815">Model</a>, <a class="indexterm" href="apc.html#I_indexterm_id371119">QVRotate</a></dt><dd/><dt>RadiansToDegrees function, <a class="indexterm" href="apc.html#I_indexterm_id371828">Conversion Functions</a></dt><dd/><dt>scalar division, <a class="indexterm" href="apc.html#I_indexterm_id369932">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370881">Scalar Division: The / Operator</a></dt><dd/><dt>scalar multiplication, <a class="indexterm" href="apc.html#I_indexterm_id369851">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370718">Scalar Multiplication: The * Operator</a></dt><dd/><dt>vector multiplication, <a class="indexterm" href="ch11.html#I_indexterm5_id331300">Vector multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370788">Vector Multiplication: The * Operator</a></dt><dd/></dl></dd><dt>quaternion multiplication, <a class="indexterm" href="ch11.html#I_indexterm5_id330970">Quaternion multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370389">Quaternion Multiplication: The * Operator</a></dt><dd/><dt>quaternion operations</dt><dd><dl><dt>Quaternion class, <a class="indexterm" href="ch11.html#I_indexterm5_id330493">Quaternion Operations</a>, <a class="indexterm" href="apc.html#quc.1">Quaternion Class</a>–<a class="indexterm" href="apc.html#I_indexterm_id370106">Conjugate: The ~ Operator</a></dt><dd/><dt>quaternion functions and operators, <a class="indexterm" href="apc.html#quc.2">Quaternion Functions and Operators</a>–<a class="indexterm" href="apc.html#I_indexterm_id371863">Conversion Functions</a></dt><dd/><dt>for rigid-body rotation, <a class="indexterm" href="ch11.html#qu11.2">Quaternions</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id331925">MakeEulerAnglesFromQ</a></dt><dd/><dt>3D simulation and, <a class="indexterm" href="ch11.html#qu11.3">Quaternions in 3D Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332332">Quaternions in 3D Simulators</a></dt><dd/></dl></dd><dt>quaternion subtraction, <a class="indexterm" href="apc.html#I_indexterm_id369584">Quaternion Subtraction: The −= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370315">Quaternion Subtraction: The − Operator</a></dt><dd/><dt>QVRotate function, <a class="indexterm" href="ch11.html#I_indexterm5_id330772">QVRotate</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id332129">Quaternions in 3D Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332808">Model</a>, <a class="indexterm" href="apc.html#I_indexterm_id371129">QVRotate</a></dt><dd/></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>RadiansToDegrees function, <a class="indexterm" href="apc.html#I_indexterm_id371838">Conversion Functions</a></dt><dd/><dt>rarefaction, <a class="indexterm" href="ch26.html#I_indexterm7_id363103">What Is Sound?</a></dt><dd/><dt>real-time simulations</dt><dd><dl><dt>about, <a class="indexterm" href="ch07.html#I_indexterm1_id319702">Real-Time Simulations</a></dt><dd/><dt>equations of motion and, <a class="indexterm" href="ch07.html#re7.1">Integrating the Equations of Motion</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id320139">Integrating the Equations of Motion</a></dt><dd/><dt>Euler’s method, <a class="indexterm" href="ch07.html#re7.2">Euler’s Method</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321282">Euler’s Method</a></dt><dd/><dt>improved Euler method, <a class="indexterm" href="ch07.html#re7.3">Better Methods</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321970">Better Methods</a></dt><dd/><dt>physics engine considerations, <a class="indexterm" href="ch14.html#I_indexterm8_id337183">Building Your Own Physics Engine</a></dt><dd/><dt>Runge-Kutta method in, <a class="indexterm" href="ch07.html#ret7.3">Better Methods</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id322008">Better Methods</a></dt><dd/><dt>Taylor’s theorem in, <a class="indexterm" href="ch07.html#I_indexterm1_id320212">Euler’s Method</a>, <a class="indexterm" href="ch07.html#I_indexterm1_id321382">Better Methods</a></dt><dd/></dl></dd><dt>recoil of firearms, <a class="indexterm" href="ch18.html#I_indexterm4_id347457">Recoil and Impact</a></dt><dd/><dt>rectangular cylinder, mass moment of inertia formula, <a class="indexterm" href="ch01.html#I_indexterm1_id291554">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>reflection in sound waves, <a class="indexterm" href="ch26.html#I_indexterm7_id364155">Reflection</a></dt><dd/><dt>relative acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id302993">Angular Velocity and Acceleration</a></dt><dd/><dt>relative normal velocity, <a class="indexterm" href="ch10.html#I_indexterm4_id327488">Linear Collision Response</a></dt><dd/><dt>relative velocity</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id302818">Angular Velocity and Acceleration</a></dt><dd/><dt>between connected objects, <a class="indexterm" href="ch13.html#I_indexterm7_id334288">Springs and Dampers</a></dt><dd/><dt>collision detection and, <a class="indexterm" href="ch10.html#I_indexterm4_id327154">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327462">Linear Collision Response</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337724">Collision Detection</a></dt><dd/><dt>particle-to-ground collisions and, <a class="indexterm" href="ch08.html#I_indexterm2_id324145">Particle-to-Ground Collisions</a></dt><dd/></dl></dd><dt>relativistic time, <a class="indexterm" href="ch01.html#re1.9">Relativistic Time</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id296068">Relativistic Time</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356977">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>rendering</dt><dd><dl><dt>about, <a class="indexterm" href="ch08.html#I_indexterm2_id322196">Particles</a></dt><dd/><dt>particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id323048">Rendering</a></dt><dd/><dt>simulated objects manager and, <a class="indexterm" href="ch14.html#I_indexterm8_id337634">Simulated Objects Manager</a></dt><dd/><dt>2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id326223">Rendering</a></dt><dd/></dl></dd><dt>residual resistance, <a class="indexterm" href="ch16.html#I_indexterm2_id342520">General Resistance</a></dt><dd/><dt>resistance</dt><dd><dl><dt>in cars, <a class="indexterm" href="ch17.html#I_indexterm3_id343904">Resistance</a></dt><dd/><dt>equation for, <a class="indexterm" href="ch04.html#I_indexterm4_id307254">Particle Kinetics in 2D</a></dt><dd/><dt>in hovercraft, <a class="indexterm" href="ch17.html#re17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345819">Resistance</a></dt><dd/><dt>residual, <a class="indexterm" href="ch16.html#I_indexterm2_id342526">General Resistance</a></dt><dd/><dt>rolling, <a class="indexterm" href="ch17.html#I_indexterm3_id344074">Resistance</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id351447">Calculating Forces</a></dt><dd/><dt>in ships and boats, <a class="indexterm" href="ch16.html#re16.3.1">General Resistance</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id343433">Guidance speeds</a></dt><dd/><dt>zeroing the sights and, <a class="indexterm" href="ch18.html#re18.2.1.1">Bullet drop: Gravity and air resistance</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347139">Bullet drop: Gravity and air resistance</a></dt><dd/></dl></dd><dt>resistive touch screens, <a class="indexterm" href="ch20.html#I_indexterm1_id352010">Resistive</a>, <a class="indexterm" href="ch20.html#re20.2.1">Resistive Touch Screens</a>–<a class="indexterm" href="ch20.html#I_indexterm1_id352972">Four-wire resistive touch screen</a></dt><dd/><dt>restitution, coefficient of (see coefficient of restitution)</dt><dd/><dt>reverberation special effect, <a class="indexterm" href="ch26.html#I_indexterm7_id364247">Reflection</a></dt><dd/><dt>reverse geocaching, <a class="indexterm" href="ch22.html#I_indexterm3_id356165">Geocaching and Reverse Geocaching</a></dt><dd/><dt>reverse, in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365428">Reverse</a></dt><dd/><dt>Reynolds number, <a class="indexterm" href="ch06.html#I_indexterm6_id317836">Drag</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342398">General Resistance</a></dt><dd/><dt>rhumb line, <a class="indexterm" href="ch22.html#I_indexterm3_id357198">Location, Location, Location</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id357643">Rhumb Line</a></dt><dd/><dt>right hand rule, <a class="indexterm" href="ch03.html#I_indexterm3_id305986">Force and Torque</a></dt><dd/><dt>rigid bodies</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id296154">Kinematics</a></dt><dd/><dt>billiards example, <a class="indexterm" href="ch19.html#I_indexterm5_id350626">Implementation</a></dt><dd/><dt>circular path of particles making up, <a class="indexterm" href="ch02.html#I_indexterm2_id302037">Angular Velocity and Acceleration</a></dt><dd/><dt>connecting, <a class="indexterm" href="ch13.html#rc13.3">Connecting Rigid Bodies</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336999">Rotational Restraint</a></dt><dd/><dt>conservation of momentum principle, <a class="indexterm" href="ch05.html#I_indexterm5_id311374">Impact</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id312848">Impact</a>, <a class="indexterm" href="ch18.html#I_indexterm4_id347517">Recoil and Impact</a></dt><dd/><dt>linked-chain example, <a class="indexterm" href="ch13.html#rl13.3">Connecting Rigid Bodies</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id337009">Rotational Restraint</a></dt><dd/><dt>penalty methods for, <a class="indexterm" href="ch05.html#I_indexterm5_id310834">Collisions</a></dt><dd/><dt>rotation in 3D simulation, <a class="indexterm" href="ch11.html#ri11.0">Rotation in 3D Rigid-Body Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332295">Quaternions in 3D Simulators</a></dt><dd/><dt>3D simulation for, <a class="indexterm" href="ch12.html#ri12.0">3D Rigid-Body Simulator</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333714">Flight Controls</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id350656">Implementation</a></dt><dd/><dt>2D simulation for, <a class="indexterm" href="ch09.html#ri9.0">2D Rigid-Body Simulator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326808">Tuning</a></dt><dd/></dl></dd><dt>rigid-body kinematics, <a class="indexterm" href="ch02.html#I_indexterm2_id301511">Rigid-Body Kinematics</a></dt><dd/><dt>rigid-body kinetics, <a class="indexterm" href="ch04.html#ri4.3">Rigid-Body Kinetics</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310711">Rigid-Body Kinetics</a></dt><dd/><dt>roadway bank, <a class="indexterm" href="ch17.html#I_indexterm3_id344794">Steering</a></dt><dd/><dt>Robbins effect, <a class="indexterm" href="ch06.html#ro6.3">Magnus Effect</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id319455">Magnus Effect</a></dt><dd/><dt>roll</dt><dd><dl><dt>flight control action for, <a class="indexterm" href="ch11.html#I_indexterm5_id329010">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333318">Flight Controls</a></dt><dd/><dt>local coordinate axes and, <a class="indexterm" href="ch02.html#I_indexterm2_id301756">Local Coordinate Axes</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338876">Geometry</a></dt><dd/><dt>in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341457">Stability</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id341884">Ship Motions</a>, <a class="indexterm" href="ch16.html#I_indexterm2_id342003">Roll</a></dt><dd/></dl></dd><dt>roll period, <a class="indexterm" href="ch16.html#I_indexterm2_id342018">Roll</a></dt><dd/><dt>rolling resistance, <a class="indexterm" href="ch17.html#I_indexterm3_id344066">Resistance</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id351441">Calculating Forces</a></dt><dd/><dt>rope example, <a class="indexterm" href="ch13.html#ro13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335390">Update the simulation</a></dt><dd/><dt>rotation in 3D rigid-body simulation</dt><dd><dl><dt>about, <a class="indexterm" href="ch11.html#I_indexterm5_id328892">Rotation in 3D Rigid-Body Simulators</a></dt><dd/><dt>quaternions and, <a class="indexterm" href="ch11.html#ro11.2">Quaternions</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332313">Quaternions in 3D Simulators</a></dt><dd/><dt>rotation matrices and, <a class="indexterm" href="ch11.html#ro11.1">Rotation Matrices</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id329866">Rotation Matrices</a></dt><dd/><dt>rotational restraint, <a class="indexterm" href="ch13.html#ro13.3.2">Rotational Restraint</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id337018">Rotational Restraint</a></dt><dd/></dl></dd><dt>rotation matrices, <a class="indexterm" href="ch11.html#rom11.1">Rotation Matrices</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id329876">Rotation Matrices</a></dt><dd/><dt>rotational acceleration, <a class="indexterm" href="ch03.html#I_indexterm3_id305926">Force and Torque</a></dt><dd/><dt>rotational inertia (see mass moment of inertia)</dt><dd/><dt>rotational restraint, <a class="indexterm" href="ch13.html#rr13.3.2">Rotational Restraint</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id337027">Rotational Restraint</a></dt><dd/><dt>rudders</dt><dd><dl><dt>in aircraft, <a class="indexterm" href="ch15.html#I_indexterm1_id338704">Geometry</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id340029">Control</a></dt><dd/><dt>in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id343636">Rudders and Thrust Vectoring</a></dt><dd/></dl></dd><dt>Runge-Kutta method, <a class="indexterm" href="ch07.html#ru7.3">Better Methods</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id321998">Better Methods</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id349673">Modeling a Golf Swing</a>, <a class="indexterm" href="ch19.html#I_indexterm5_id350004">Solving the Golf Swing Equations</a></dt><dd/></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>Saffer, Dan, <a class="indexterm" href="ch20.html#I_indexterm1_id353487">Custom Gestures</a></dt><dd/><dt>scalar division</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368332">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368618">Scalar Divide: The / Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369922">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370871">Scalar Division: The / Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365904">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id367060">Scalar Division: The / Operator</a></dt><dd/></dl></dd><dt>scalar multiplication</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368212">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apb.html#I_indexterm_id368801">Scalar Multiplication: The * Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369841">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370708">Scalar Multiplication: The * Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365776">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366986">Scalar Multiplication: The * Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id367150">Triple Scalar Product</a></dt><dd/></dl></dd><dt>scalars</dt><dd><dl><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290148">Vectors</a></dt><dd/><dt>examples of, <a class="indexterm" href="ch01.html#I_indexterm1_id290192">Vectors</a></dt><dd/><dt>magnitude and, <a class="indexterm" href="ch01.html#I_indexterm1_id290168">Vectors</a></dt><dd/><dt>tensors and, <a class="indexterm" href="ch01.html#I_indexterm1_id294106">Newton’s Second Law of Motion</a></dt><dd/></dl></dd><dt>second derivatives, <a class="indexterm" href="ch02.html#I_indexterm2_id296990">Velocity and Acceleration</a></dt><dd/><dt>second zero, <a class="indexterm" href="ch18.html#I_indexterm4_id346776">Bullet drop: Gravity and air resistance</a></dt><dd/><dt>second-order central difference, <a class="indexterm" href="ch25.html#I_indexterm6_id362797">Numerical Differentiation</a></dt><dd/><dt>separation point in fluid dynamic drag, <a class="indexterm" href="ch06.html#I_indexterm6_id317695">Drag</a></dt><dd/><dt>ships and boats</dt><dd><dl><dt>about, <a class="indexterm" href="ch16.html#sh16.0">Ships and Boats</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id341229">Ships and Boats</a></dt><dd/><dt>geometry of, <a class="indexterm" href="ch16.html#I_indexterm2_id341176">Ships and Boats</a></dt><dd/><dt>maneuverability of, <a class="indexterm" href="ch16.html#sh16.4">Maneuverability</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id343811">Propeller walk</a></dt><dd/><dt>parts of, <a class="indexterm" href="ch16.html#I_indexterm2_id341118">Ships and Boats</a></dt><dd/><dt>propulsion of, <a class="indexterm" href="ch16.html#I_indexterm2_id343462">Propulsion</a></dt><dd/><dt>resistance in, <a class="indexterm" href="ch16.html#sh16.3.1">General Resistance</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id343442">Guidance speeds</a></dt><dd/><dt>ship motions, <a class="indexterm" href="ch16.html#sh16.2">Ship Motions</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id342170">Coupled Motions</a></dt><dd/><dt>sinking, <a class="indexterm" href="ch16.html#I_indexterm2_id341615">Sinking</a></dt><dd/><dt>stability of, <a class="indexterm" href="ch16.html#sh16.1.1">Stability</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id341580">Stability</a></dt><dd/><dt>2D particle
        kinetics example, <a class="indexterm" href="ch04.html#sh4.1">Particle Kinetics in 2D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308114">Particle Kinetics in 2D</a></dt><dd/><dt>types of, <a class="indexterm" href="ch16.html#I_indexterm2_id341026">Ships and Boats</a></dt><dd/><dt>typical speeds for, <a class="indexterm" href="ch16.html#I_indexterm2_id343020">Guidance speeds</a></dt><dd/></dl></dd><dt>shooting guns example</dt><dd><dl><dt>air drag and, <a class="indexterm" href="ch06.html#I_indexterm6_id318182">Drag</a></dt><dd/><dt>challenges of, <a class="indexterm" href="ch18.html#I_indexterm4_id346180">Projectile Motion</a></dt><dd/><dt>particle kinematics suggestions, <a class="indexterm" href="ch02.html#I_indexterm2_id301091">Kinematic Particle Explosion</a></dt><dd/><dt>physics engine considerations, <a class="indexterm" href="ch14.html#I_indexterm8_id337154">Building Your Own Physics Engine</a></dt><dd/><dt>taking aim, <a class="indexterm" href="ch18.html#I_indexterm4_id346369">Taking Aim</a></dt><dd/><dt>3D particle
        kinematics, <a class="indexterm" href="ch02.html#sh2.5">3D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300889">Hitting the Target</a></dt><dd/><dt>3D particle
        kinetics, <a class="indexterm" href="ch04.html#sh4.2">Particle Kinetics in 3D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310060">Cannon Revised</a></dt><dd/><dt>2D particle
        kinematics, <a class="indexterm" href="ch02.html#sh2.4">2D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299209">2D Particle Kinematics</a></dt><dd/></dl></dd><dt>shooting positions, <a class="indexterm" href="ch18.html#I_indexterm4_id347365">Breathing and Body Position</a></dt><dd/><dt>SI (International System of Units), <a class="indexterm" href="ch01.html#I_indexterm1_id288541">Units and Measures</a></dt><dd/><dt>simulated objects manager, <a class="indexterm" href="ch14.html#I_indexterm8_id337562">Simulated Objects Manager</a></dt><dd/><dt>simulations</dt><dd><dl><dt>cloth, <a class="indexterm" href="ch13.html#I_indexterm7_id333850">Connecting Objects</a></dt><dd/><dt>football game, <a class="indexterm" href="ch02.html#I_indexterm2_id301062">Kinematic Particle Explosion</a></dt><dd/><dt>force effectors in, <a class="indexterm" href="ch14.html#I_indexterm8_id338053">Force Effectors</a></dt><dd/><dt>hitting the target example, <a class="indexterm" href="ch02.html#si2.5.5">Hitting the Target</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300917">Hitting the Target</a></dt><dd/><dt>implementing collision response, <a class="indexterm" href="ch10.html#si10.0">Implementing Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328814">Angular Effects</a></dt><dd/><dt>particle, <a class="indexterm" href="ch08.html#si8.0">Particles</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id325012">Tuning</a></dt><dd/><dt>physics engine considerations, <a class="indexterm" href="ch14.html#I_indexterm8_id337331">Building Your Own Physics Engine</a></dt><dd/><dt>real-time, <a class="indexterm" href="ch07.html#si7.0">Real-Time Simulations</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id322037">Summary</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337193">Building Your Own Physics Engine</a></dt><dd/><dt>springs and dampers in, <a class="indexterm" href="ch03.html#I_indexterm3_id305795">Springs and Dampers</a></dt><dd/><dt>3D rigid-body, <a class="indexterm" href="ch11.html#si11.0">Rotation in 3D Rigid-Body Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332304">Quaternions in 3D Simulators</a>, <a class="indexterm" href="ch12.html#si12.0">3D Rigid-Body Simulator</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333723">Flight Controls</a></dt><dd/><dt>2D rigid-body, <a class="indexterm" href="ch09.html#si9.0">2D Rigid-Body Simulator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326799">Tuning</a></dt><dd/><dt>updating, <a class="indexterm" href="ch13.html#si13.2.1.3">Update the simulation</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335408">Update the simulation</a>, <a class="indexterm" href="ch13.html#si13.3.1.3">Update</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id336684">Update</a></dt><dd/></dl></dd><dt>sinking ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341625">Sinking</a></dt><dd/><dt>skidding distance, <a class="indexterm" href="ch17.html#I_indexterm3_id344427">Stopping Distance</a></dt><dd/><dt>skin friction</dt><dd><dl><dt>on aircraft, <a class="indexterm" href="ch15.html#I_indexterm1_id339834">Other Forces</a></dt><dd/><dt>on cars, <a class="indexterm" href="ch17.html#I_indexterm3_id343973">Resistance</a></dt><dd/><dt>on hovercraft, <a class="indexterm" href="ch17.html#I_indexterm3_id345306">Resistance</a></dt><dd/><dt>planing vessels and, <a class="indexterm" href="ch16.html#I_indexterm2_id342820">Planing craft</a></dt><dd/></dl></dd><dt>sliding friction force, <a class="indexterm" href="ch19.html#I_indexterm5_id351376">Calculating Forces</a></dt><dd/><dt>sound and sound waves</dt><dd><dl><dt>about, <a class="indexterm" href="ch26.html#so26.0">Sound</a>–<a class="indexterm" href="ch26.html#I_indexterm7_id363562">What Is Sound?</a></dt><dd/><dt>characteristics of, <a class="indexterm" href="ch26.html#so26.2">Characteristics of and Behavior of Sound Waves</a>–<a class="indexterm" href="ch26.html#I_indexterm7_id364374">Doppler Effect</a></dt><dd/><dt>3D, <a class="indexterm" href="ch26.html#so26.3">3D Sound</a>–<a class="indexterm" href="ch26.html#I_indexterm7_id364766">A Simple Example</a></dt><dd/></dl></dd><dt>span, aircraft wings, <a class="indexterm" href="ch15.html#I_indexterm1_id338627">Geometry</a></dt><dd/><dt>special effects</dt><dd><dl><dt>fade effect, <a class="indexterm" href="ch02.html#I_indexterm2_id301424">Kinematic Particle Explosion</a></dt><dd/><dt>out-of-screen effects, <a class="indexterm" href="ch24.html#I_indexterm5_id362090">Active Stereoization</a></dt><dd/><dt>particle explosions, <a class="indexterm" href="ch02.html#I_indexterm2_id301118">Kinematic Particle Explosion</a></dt><dd/><dt>reverberation, <a class="indexterm" href="ch26.html#I_indexterm7_id364238">Reflection</a></dt><dd/></dl></dd><dt>specific weight, <a class="indexterm" href="ch03.html#I_indexterm3_id305287">Buoyancy</a></dt><dd/><dt>speed</dt><dd><dl><dt>acceleration and, <a class="indexterm" href="ch02.html#I_indexterm2_id296748">Velocity and Acceleration</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch02.html#I_indexterm2_id296458">Velocity and Acceleration</a></dt><dd/><dt>defined, <a class="indexterm" href="ch02.html#I_indexterm2_id296329">Velocity and Acceleration</a></dt><dd/><dt>drag and, <a class="indexterm" href="ch06.html#I_indexterm6_id317370">Drag</a></dt><dd/><dt>equations of motion and, <a class="indexterm" href="ch04.html#I_indexterm4_id308024">Particle Kinetics in 2D</a></dt><dd/><dt>hull, <a class="indexterm" href="ch16.html#I_indexterm2_id343030">Guidance speeds</a></dt><dd/><dt>of light, <a class="indexterm" href="ch01.html#sp1.9">Relativistic Time</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id296087">Relativistic Time</a>, <a class="indexterm" href="ch22.html#I_indexterm3_id356904">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>of sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363899">Speed of Sound</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288651">Units and Measures</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id296398">Velocity and Acceleration</a></dt><dd/><dt>velocity and, <a class="indexterm" href="ch02.html#I_indexterm2_id296294">Velocity and Acceleration</a></dt><dd/></dl></dd><dt>spheres</dt><dd><dl><dt>bounding, <a class="indexterm" href="ch14.html#I_indexterm8_id337814">Collision Detection</a></dt><dd/><dt>calculating distance along, <a class="indexterm" href="ch22.html#I_indexterm3_id357227">Distance</a></dt><dd/><dt>fluid dynamic drag around, <a class="indexterm" href="ch06.html#sp6.2">Drag</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id317916">Drag</a></dt><dd/><dt>great-circle heading, <a class="indexterm" href="ch22.html#I_indexterm3_id357455">Great-Circle Heading</a></dt><dd/><dt>Magnus effect and, <a class="indexterm" href="ch06.html#I_indexterm6_id318935">Magnus Effect</a></dt><dd/><dt>mass moment of inertia formula, <a class="indexterm" href="ch01.html#I_indexterm1_id291815">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/></dl></dd><dt>spherical law of cosines, <a class="indexterm" href="ch22.html#I_indexterm3_id357249">Distance</a></dt><dd/><dt>spherical shell, mass moment of inertia formula, <a class="indexterm" href="ch01.html#I_indexterm1_id291825">Mass, Center of Mass, and Moment of Inertia</a></dt><dd/><dt>sports</dt><dd><dl><dt>about, <a class="indexterm" href="ch19.html#I_indexterm5_id348297">Sports</a></dt><dd/><dt>baseball examples, <a class="indexterm" href="ch05.html#sb5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id313145">Impact</a>, <a class="indexterm" href="ch06.html#I_indexterm6_id319293">Magnus Effect</a></dt><dd/><dt>billiards examples, <a class="indexterm" href="ch05.html#sp5.2">Impact</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id312471">Impact</a>, <a class="indexterm" href="ch19.html#sp19.2">Billiards</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id351860">Handling Collisions</a></dt><dd/><dt>football game simulation, <a class="indexterm" href="ch02.html#I_indexterm2_id301072">Kinematic Particle Explosion</a></dt><dd/><dt>golf examples, <a class="indexterm" href="ch05.html#sp5.4">Friction</a>–<a class="indexterm" href="ch05.html#I_indexterm5_id315477">Friction</a>, <a class="indexterm" href="ch06.html#I_indexterm6_id319244">Magnus Effect</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337221">Building Your Own Physics Engine</a>, <a class="indexterm" href="ch19.html#sp19.1">Modeling a Golf Swing</a>–<a class="indexterm" href="ch19.html#I_indexterm5_id350314">Solving the Golf Swing Equations</a></dt><dd/></dl></dd><dt>spring-damper element formula, <a class="indexterm" href="ch03.html#I_indexterm3_id305603">Springs and Dampers</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id333914">Connecting Objects</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id334119">Springs and Dampers</a></dt><dd/><dt>springs</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id305375">Springs and Dampers</a></dt><dd/><dt>accelerometer theory on, <a class="indexterm" href="ch21.html#I_indexterm2_id353810">Accelerometer Theory</a></dt><dd/><dt>cloth simulation, <a class="indexterm" href="ch13.html#I_indexterm7_id333818">Connecting Objects</a></dt><dd/><dt>connecting objects, <a class="indexterm" href="ch13.html#I_indexterm7_id333971">Springs and Dampers</a></dt><dd/><dt>equation for, <a class="indexterm" href="ch03.html#I_indexterm3_id305397">Springs and Dampers</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id334002">Springs and Dampers</a></dt><dd/><dt>swinging rope example, <a class="indexterm" href="ch13.html#sp13.2.1">Rope</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335399">Update the simulation</a></dt><dd/><dt>uses for, <a class="indexterm" href="ch03.html#I_indexterm3_id305785">Springs and Dampers</a></dt><dd/></dl></dd><dt>stability index (GM), <a class="indexterm" href="ch16.html#I_indexterm2_id341515">Stability</a></dt><dd/><dt>stability of ships and boats, <a class="indexterm" href="ch16.html#st16.1.1">Stability</a>–<a class="indexterm" href="ch16.html#I_indexterm2_id341591">Stability</a></dt><dd/><dt>standing (shooting position), <a class="indexterm" href="ch18.html#I_indexterm4_id347359">Breathing and Body Position</a></dt><dd/><dt>static forces, <a class="indexterm" href="ch03.html#I_indexterm3_id303786">Friction</a></dt><dd/><dt>steering</dt><dd><dl><dt>in cars, <a class="indexterm" href="ch17.html#st17.1.4">Steering</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id344917">Steering</a></dt><dd/><dt>in hovercraft, <a class="indexterm" href="ch17.html#I_indexterm3_id345139">How Hovercraft Work</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id345890">Steering</a></dt><dd/><dt>throttle, <a class="indexterm" href="ch16.html#I_indexterm2_id343756">Rudders and Thrust Vectoring</a></dt><dd/></dl></dd><dt>Stein, Jonathan Y., <a class="indexterm" href="ch21.html#I_indexterm2_id353632">Accelerometers</a></dt><dd/><dt>stereoization process</dt><dd><dl><dt>about, <a class="indexterm" href="ch24.html#I_indexterm5_id361832">Programming Considerations</a></dt><dd/><dt>active stereoization, <a class="indexterm" href="ch24.html#st24.4">Programming Considerations</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id362126">Active Stereoization</a></dt><dd/><dt>passive stereoization, <a class="indexterm" href="ch24.html#I_indexterm5_id361885">Programming Considerations</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id362154">Passive Stereoization</a></dt><dd/></dl></dd><dt>stereopsis, <a class="indexterm" href="ch24.html#I_indexterm5_id360490">Binocular Vision</a></dt><dd/><dt>stereoscopic displays, <a class="indexterm" href="ch24.html#I_indexterm5_id360157">3D Display</a></dt><dd><dl><dt>(see also 3D display)</dt><dd/><dt>about, <a class="indexterm" href="ch24.html#I_indexterm5_id360147">3D Display</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id360563">Stereoscopic Basics</a></dt><dd/><dt>viewing frustum, <a class="indexterm" href="ch24.html#st24.2.1">The Left and Right Frustums</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360910">The Left and Right Frustums</a></dt><dd/></dl></dd><dt>stopping distance in cars, <a class="indexterm" href="ch17.html#I_indexterm3_id344351">Stopping Distance</a></dt><dd/><dt>strain energy, <a class="indexterm" href="ch05.html#I_indexterm5_id311468">Impact</a></dt><dd/><dt>strain gauges, <a class="indexterm" href="ch23.html#I_indexterm4_id358556">Tiny scales</a></dt><dd/><dt>street games, <a class="indexterm" href="ch22.html#I_indexterm3_id356228">Street Games</a></dt><dd/><dt>subtraction (−) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368535">Matrix Subtraction: The − Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id370305">Quaternion Subtraction: The − Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id366207">Vector Subtraction: The − Operator</a></dt><dd/></dl></dd><dt>subtraction (−=) operator</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368172">Matrix Subtraction: The −= Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="apc.html#I_indexterm_id369575">Quaternion Subtraction: The −= Operator</a></dt><dd/><dt>in vector operations, <a class="indexterm" href="apa.html#I_indexterm_id365647">Vector Subtraction: The −= Operator</a></dt><dd/></dl></dd><dt>summation in binocular vision, <a class="indexterm" href="ch24.html#I_indexterm5_id360266">Binocular Vision</a></dt><dd/><dt>superelevation (roadway banking), <a class="indexterm" href="ch17.html#I_indexterm3_id344800">Steering</a></dt><dd/><dt>superposition principle, <a class="indexterm" href="ch26.html#I_indexterm7_id363783">Superposition</a></dt><dd/><dt>suppression in binocular vision, <a class="indexterm" href="ch24.html#I_indexterm5_id360254">Binocular Vision</a></dt><dd/><dt>surface acoustic wave technology, <a class="indexterm" href="ch20.html#I_indexterm1_id352139">Exotic: Dispersive Signal and Surface Acoustic Wave</a></dt><dd/><dt>surface area, units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288661">Units and Measures</a></dt><dd/><dt>symmetry, plane of, <a class="indexterm" href="ch01.html#I_indexterm1_id295468">Inertia Tensor</a></dt><dd/></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>tangential acceleration, <a class="indexterm" href="ch02.html#I_indexterm2_id302293">Angular Velocity and Acceleration</a></dt><dd/><dt>tangential velocity, <a class="indexterm" href="ch02.html#I_indexterm2_id302176">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id313010">Impact</a></dt><dd/><dt>Taylor’s theorem, <a class="indexterm" href="ch07.html#I_indexterm1_id320206">Euler’s Method</a>, <a class="indexterm" href="ch07.html#I_indexterm1_id321376">Better Methods</a></dt><dd/><dt>tensors</dt><dd><dl><dt>about, <a class="indexterm" href="ch01.html#I_indexterm1_id294180">Newton’s Second Law of Motion</a></dt><dd/><dt>inertia, <a class="indexterm" href="ch01.html#te1.8">Inertia Tensor</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id295620">Inertia Tensor</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id332657">Model</a></dt><dd/><dt>scalars and, <a class="indexterm" href="ch01.html#I_indexterm1_id294125">Newton’s Second Law of Motion</a></dt><dd/><dt>vectors and, <a class="indexterm" href="ch01.html#I_indexterm1_id294116">Newton’s Second Law of Motion</a></dt><dd/></dl></dd><dt>10/10 maneuver, <a class="indexterm" href="ch16.html#I_indexterm2_id343668">Rudders and Thrust Vectoring</a></dt><dd/><dt>terminal ballistics, <a class="indexterm" href="ch18.html#I_indexterm4_id346077">Projectile Motion</a></dt><dd/><dt>terminal velocity, <a class="indexterm" href="ch06.html#I_indexterm6_id318292">Drag</a></dt><dd/><dt>3D display</dt><dd><dl><dt>about, <a class="indexterm" href="ch24.html#I_indexterm5_id360128">3D Display</a></dt><dd/><dt>binocular vision, <a class="indexterm" href="ch24.html#tr24.1">Binocular Vision</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360514">Binocular Vision</a></dt><dd/><dt>programming considerations, <a class="indexterm" href="ch24.html#th24.4">Programming Considerations</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id362196">Passive Stereoization</a></dt><dd/><dt>stereoscopic basics, <a class="indexterm" href="ch24.html#th24.2">Stereoscopic Basics</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360901">The Left and Right Frustums</a></dt><dd/><dt>types of, <a class="indexterm" href="ch24.html#th24.3">Types of Display</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id361791">Advanced Technologies</a></dt><dd/></dl></dd><dt>3D particle
        kinematics</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#I_indexterm2_id299257">3D Particle Kinematics</a></dt><dd/><dt>hitting the target, <a class="indexterm" href="ch02.html#th2.5.5">Hitting the Target</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300899">Hitting the Target</a></dt><dd/><dt>shooting guns example, <a class="indexterm" href="ch02.html#th2.5">3D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300880">Hitting the Target</a></dt><dd/><dt>vectors, <a class="indexterm" href="ch02.html#I_indexterm2_id300271">The Vectors</a></dt><dd/><dt>x components, <a class="indexterm" href="ch02.html#th2.5.1">X Components</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299933">X Components</a></dt><dd/><dt>y components, <a class="indexterm" href="ch02.html#I_indexterm2_id300012">Y Components</a></dt><dd/><dt>z components, <a class="indexterm" href="ch02.html#I_indexterm2_id300194">Z Components</a></dt><dd/></dl></dd><dt>3D particle
        kinetics</dt><dd><dl><dt>about, <a class="indexterm" href="ch04.html#th4.2">Particle Kinetics in 3D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308860">Particle Kinetics in 3D</a></dt><dd/><dt>shooting guns example, <a class="indexterm" href="ch04.html#the4.2">Particle Kinetics in 3D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id310069">Cannon Revised</a></dt><dd/><dt>x components, <a class="indexterm" href="ch04.html#I_indexterm4_id308884">X Components</a></dt><dd/><dt>y components, <a class="indexterm" href="ch04.html#I_indexterm4_id309490">Y Components</a></dt><dd/><dt>z components, <a class="indexterm" href="ch04.html#I_indexterm4_id309752">Z Components</a></dt><dd/></dl></dd><dt>3D rigid-body simulation</dt><dd><dl><dt>about, <a class="indexterm" href="ch12.html#I_indexterm6_id332372">3D Rigid-Body Simulator</a></dt><dd/><dt>billiard ball example, <a class="indexterm" href="ch19.html#I_indexterm5_id350644">Implementation</a></dt><dd/><dt>flight controls, <a class="indexterm" href="ch12.html#th12.3">Flight Controls</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333733">Flight Controls</a>, <a class="indexterm" href="ch15.html#th15.5">Modeling</a>–<a class="indexterm" href="ch15.html#I_indexterm1_id340955">Modeling</a></dt><dd/><dt>integrator for, <a class="indexterm" href="ch12.html#th12.2">Integration</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id333227">Integration</a></dt><dd/><dt>model for, <a class="indexterm" href="ch12.html#th12.1">Model</a>–<a class="indexterm" href="ch12.html#I_indexterm6_id332836">Model</a></dt><dd/><dt>quaternions in, <a class="indexterm" href="ch11.html#th11.3">Quaternions in 3D Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332323">Quaternions in 3D Simulators</a></dt><dd/><dt>rotation in, <a class="indexterm" href="ch11.html#th11.0">Rotation in 3D Rigid-Body Simulators</a>–<a class="indexterm" href="ch11.html#I_indexterm5_id332284">Quaternions in 3D Simulators</a></dt><dd/></dl></dd><dt>3D sound, <a class="indexterm" href="ch26.html#th26.3">3D Sound</a>–<a class="indexterm" href="ch26.html#I_indexterm7_id364776">A Simple Example</a></dt><dd/><dt>throttle steering, <a class="indexterm" href="ch16.html#I_indexterm2_id343750">Rudders and Thrust Vectoring</a></dt><dd/><dt>thrust</dt><dd><dl><dt>defined, <a class="indexterm" href="ch03.html#I_indexterm3_id303347">Forces</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id339722">Other Forces</a></dt><dd/><dt>flight control actions, <a class="indexterm" href="ch12.html#I_indexterm6_id333342">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338437">Aircraft</a></dt><dd/></dl></dd><dt>thrust vectoring, <a class="indexterm" href="ch16.html#I_indexterm2_id343648">Rudders and Thrust Vectoring</a></dt><dd/><dt>thrust-to-propeller RPM ratio, <a class="indexterm" href="ch16.html#I_indexterm2_id343506">Propulsion</a></dt><dd/><dt>thrust-to-throttle curve ratio, <a class="indexterm" href="ch16.html#I_indexterm2_id343515">Propulsion</a></dt><dd/><dt>thrust-to-weight ratio, <a class="indexterm" href="ch15.html#I_indexterm1_id339736">Other Forces</a></dt><dd/><dt>tilt</dt><dd><dl><dt>controlling sprite with, <a class="indexterm" href="ch21.html#ti21.3.1">Using Tilt to Control a Sprite</a>–<a class="indexterm" href="ch21.html#I_indexterm2_id355919">Two Degrees of Freedom</a></dt><dd/><dt>sensing with accelerometers, <a class="indexterm" href="ch21.html#I_indexterm2_id355087">Sensing Tilt</a></dt><dd/></dl></dd><dt>time</dt><dd><dl><dt>equations of motion and, <a class="indexterm" href="ch04.html#I_indexterm4_id308034">Particle Kinetics in 2D</a></dt><dd/><dt>GPS background and, <a class="indexterm" href="ch22.html#ti22.2">What Time Is It?</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357055">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>laws of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id293645">Newton’s Second Law of Motion</a></dt><dd/><dt>relativistic, <a class="indexterm" href="ch01.html#ti1.9">Relativistic Time</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id296078">Relativistic Time</a></dt><dd/><dt>reliativistic, <a class="indexterm" href="ch22.html#I_indexterm3_id356983">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>speed and, <a class="indexterm" href="ch02.html#I_indexterm2_id296350">Velocity and Acceleration</a></dt><dd/><dt>tracking button position over, <a class="indexterm" href="ch23.html#I_indexterm4_id358431">Button Mashing</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id288351">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id289708">Units and Measures</a></dt><dd/></dl></dd><dt>TNT equivalency, <a class="indexterm" href="ch18.html#I_indexterm4_id348160">Polygon Explosions</a></dt><dd/><dt>toe-in method (cameras), <a class="indexterm" href="ch24.html#I_indexterm5_id360779">The Left and Right Frustums</a></dt><dd/><dt>tons per centimeter immersion (TPCM), <a class="indexterm" href="ch16.html#I_indexterm2_id341962">Heave</a></dt><dd/><dt>torque</dt><dd><dl><dt>about, <a class="indexterm" href="ch03.html#I_indexterm3_id305934">Force and Torque</a></dt><dd/><dt>calculating, <a class="indexterm" href="ch03.html#I_indexterm3_id305946">Force and Torque</a></dt><dd/><dt>force versus, <a class="indexterm" href="ch03.html#to3.8">Force and Torque</a>–<a class="indexterm" href="ch03.html#I_indexterm3_id306668">Force and Torque</a></dt><dd/><dt>impulse, <a class="indexterm" href="ch05.html#I_indexterm5_id311110">Impulse-Momentum Principle</a></dt><dd/><dt>laws of motion and, <a class="indexterm" href="ch01.html#I_indexterm1_id293634">Newton’s Second Law of Motion</a></dt><dd/><dt>magnitude of, <a class="indexterm" href="ch03.html#I_indexterm3_id306047">Force and Torque</a></dt><dd/><dt>rotational acceleration and, <a class="indexterm" href="ch03.html#I_indexterm3_id305907">Force and Torque</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289479">Units and Measures</a></dt><dd/></dl></dd><dt>touch screens</dt><dd><dl><dt>about, <a class="indexterm" href="ch20.html#I_indexterm1_id351946">Touch Screens</a></dt><dd/><dt>custom gestures and, <a class="indexterm" href="ch20.html#I_indexterm1_id353462">Custom Gestures</a></dt><dd/><dt>example program, <a class="indexterm" href="ch20.html#to20.3">Example Program</a>–<a class="indexterm" href="ch20.html#I_indexterm1_id353268">Multitouch</a></dt><dd/><dt>haptic feedback, <a class="indexterm" href="ch20.html#I_indexterm1_id353309">Haptic Feedback</a></dt><dd/><dt>modeling in games, <a class="indexterm" href="ch20.html#I_indexterm1_id353366">Modeling Touch Screens in Games</a></dt><dd/><dt>mouse-based input versus, <a class="indexterm" href="ch20.html#I_indexterm1_id353404">Difference from Mouse-Based Input</a></dt><dd/><dt>step-by-step physics, <a class="indexterm" href="ch20.html#to20.2.1">Resistive Touch Screens</a>–<a class="indexterm" href="ch20.html#I_indexterm1_id353084">Mutual capacitance</a></dt><dd/><dt>types of, <a class="indexterm" href="ch20.html#I_indexterm1_id351999">Resistive</a></dt><dd/></dl></dd><dt>TPCM (tons per centimeter immersion), <a class="indexterm" href="ch16.html#I_indexterm2_id341969">Heave</a></dt><dd/><dt>trajectories</dt><dd><dl><dt>football simulation game, <a class="indexterm" href="ch02.html#I_indexterm2_id301035">Kinematic Particle Explosion</a></dt><dd/><dt>hitting the target example, <a class="indexterm" href="ch02.html#tr2.5.5">Hitting the Target</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id300908">Hitting the Target</a></dt><dd/><dt>simple, <a class="indexterm" href="ch06.html#tr6.1">Simple Trajectories</a>–<a class="indexterm" href="ch06.html#I_indexterm6_id317276">Simple Trajectories</a></dt><dd/><dt>terminal velocity and, <a class="indexterm" href="ch06.html#I_indexterm6_id318309">Drag</a></dt><dd/><dt>zeroing the sights, <a class="indexterm" href="ch18.html#tr18.2.1">Zeroing the Sights</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347218">Wind</a></dt><dd/></dl></dd><dt>transfer functions (sound), <a class="indexterm" href="ch26.html#I_indexterm7_id364587">How We Hear in 3D</a></dt><dd/><dt>transfer of axis formula, <a class="indexterm" href="ch01.html#I_indexterm1_id295299">Inertia Tensor</a></dt><dd/><dt>transforming coordinates, 2D rigid-body
          simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id325788">Transforming Coordinates</a></dt><dd/><dt>transitional ballistics, <a class="indexterm" href="ch18.html#I_indexterm4_id346047">Projectile Motion</a></dt><dd/><dt>transpose, in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id367520">Transpose</a></dt><dd/><dt>transverse waves, <a class="indexterm" href="ch24.html#I_indexterm5_id361158">Linear and Circular Polarization</a></dt><dd/><dt>trilateration technique, <a class="indexterm" href="ch22.html#tr22.2.1">Two-Dimensional Mathematical Treatment</a>–<a class="indexterm" href="ch22.html#I_indexterm3_id357065">Two-Dimensional Mathematical Treatment</a></dt><dd/><dt>triple scalar product, <a class="indexterm" href="apa.html#I_indexterm_id367134">Triple Scalar Product</a></dt><dd/><dt>triple vector product, <a class="indexterm" href="ch01.html#I_indexterm1_id294682">Inertia Tensor</a></dt><dd/><dt>truncation error, <a class="indexterm" href="ch07.html#tr7.2">Euler’s Method</a>–<a class="indexterm" href="ch07.html#I_indexterm1_id320986">Euler’s Method</a></dt><dd/><dt>tuning</dt><dd><dl><dt>particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id324957">Tuning</a></dt><dd/><dt>2D rigid-body
        simulation, <a class="indexterm" href="ch09.html#I_indexterm3_id326715">Tuning</a></dt><dd/></dl></dd><dt>turbulent flow, <a class="indexterm" href="ch03.html#I_indexterm3_id304687">Fluid Dynamic Drag</a></dt><dd/><dt>turbulent wake, <a class="indexterm" href="ch06.html#I_indexterm6_id317716">Drag</a></dt><dd/><dt>two-rod model, <a class="indexterm" href="ch19.html#I_indexterm5_id349028">Modeling a Golf Swing</a></dt><dd/><dt>2D particle
        kinematics, <a class="indexterm" href="ch02.html#tw2.4">2D Particle Kinematics</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id299200">2D Particle Kinematics</a></dt><dd/><dt>2D particle
        kinetics, <a class="indexterm" href="ch04.html#tw4.1">Particle Kinetics in 2D</a>–<a class="indexterm" href="ch04.html#I_indexterm4_id308095">Particle Kinetics in 2D</a></dt><dd/><dt>2D rigid-body
      simulation</dt><dd><dl><dt>about, <a class="indexterm" href="ch09.html#I_indexterm3_id325070">2D Rigid-Body Simulator</a></dt><dd/><dt>basic simulator, <a class="indexterm" href="ch09.html#tw9.2">The Basic Simulator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326682">The Basic Simulator</a></dt><dd/><dt>implementing collision response, <a class="indexterm" href="ch10.html#tw10.0">Implementing Collision Response</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328824">Angular Effects</a></dt><dd/><dt>integrator for, <a class="indexterm" href="ch09.html#tw9.1.2">Integrator</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id326176">Integrator</a></dt><dd/><dt>model for, <a class="indexterm" href="ch09.html#tw9.1">Model</a>–<a class="indexterm" href="ch09.html#I_indexterm3_id325747">Model</a></dt><dd/><dt>rendering, <a class="indexterm" href="ch09.html#I_indexterm3_id326210">Rendering</a></dt><dd/><dt>tuning, <a class="indexterm" href="ch09.html#I_indexterm3_id326702">Tuning</a></dt><dd/></dl></dd></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>understeering cars, <a class="indexterm" href="ch17.html#I_indexterm3_id344706">Steering</a></dt><dd/><dt>uniform density, <a class="indexterm" href="ch04.html#I_indexterm4_id310422">Rigid-Body Kinetics</a></dt><dd/><dt>unit quaternion, <a class="indexterm" href="ch11.html#I_indexterm5_id329992">Quaternions</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id332239">Quaternions in 3D Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333124">Integration</a></dt><dd/><dt>units and measures</dt><dd><dl><dt>checking dimensional consistency, <a class="indexterm" href="ch01.html#un1.2">Units and Measures</a>–<a class="indexterm" href="ch01.html#I_indexterm1_id289922">Units and Measures</a></dt><dd/><dt>common mistakes when calculating, <a class="indexterm" href="ch01.html#I_indexterm1_id288276">Units and Measures</a></dt><dd/><dt>for pressure, <a class="indexterm" href="ch03.html#I_indexterm3_id304785">Pressure</a>, <a class="indexterm" href="ch23.html#I_indexterm4_id358057">Under Pressure</a></dt><dd/><dt>for sound, <a class="indexterm" href="ch26.html#I_indexterm7_id363241">What Is Sound?</a></dt><dd/></dl></dd><dt>universal constant, <a class="indexterm" href="ch03.html#I_indexterm3_id303457">Force Fields</a></dt><dd/></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>variable mass, <a class="indexterm" href="ch06.html#I_indexterm6_id319529">Variable Mass</a></dt><dd/><dt>vector addition, <a class="indexterm" href="apa.html#I_indexterm_id365538">Vector Addition: The += Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366083">Vector Addition: The + Operator</a></dt><dd/><dt>Vector class</dt><dd><dl><dt>about, <a class="indexterm" href="apa.html#I_indexterm_id364866">Vector Class</a></dt><dd/><dt>conjugate operator, <a class="indexterm" href="apa.html#I_indexterm_id365963">Conjugate: The − Operator</a></dt><dd/><dt>Magnitude method, <a class="indexterm" href="apa.html#I_indexterm_id364922">Magnitude</a></dt><dd/><dt>Normalize method, <a class="indexterm" href="apa.html#I_indexterm_id365222">Normalize</a></dt><dd/><dt>in particle simulation, <a class="indexterm" href="ch08.html#I_indexterm2_id322527">Simple Particle Model</a></dt><dd/><dt>Reverse method, <a class="indexterm" href="apa.html#I_indexterm_id365436">Reverse</a></dt><dd/><dt>scalar division and, <a class="indexterm" href="apa.html#I_indexterm_id365894">Scalar Division: The /= Operator</a></dt><dd/><dt>scalar multiplication and, <a class="indexterm" href="apa.html#I_indexterm_id365786">Scalar Multiplication: The *= Operator</a></dt><dd/><dt>vector addition and, <a class="indexterm" href="apa.html#I_indexterm_id365544">Vector Addition: The += Operator</a></dt><dd/><dt>vector subtraction and, <a class="indexterm" href="apa.html#I_indexterm_id365663">Vector Subtraction: The −= Operator</a></dt><dd/></dl></dd><dt>vector cross product, <a class="indexterm" href="ch01.html#I_indexterm1_id290283">Vectors</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id302510">Angular Velocity and Acceleration</a>, <a class="indexterm" href="apa.html#I_indexterm_id366346">Vector Cross Product: The ^ Operator</a></dt><dd/><dt>vector direction cosines, <a class="indexterm" href="ch02.html#I_indexterm2_id299703">X Components</a>, <a class="indexterm" href="apa.html#I_indexterm_id365151">Magnitude</a></dt><dd/><dt>vector dot-product operator, <a class="indexterm" href="ch01.html#I_indexterm1_id290313">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id366783">Vector Dot Product: The * Operator</a></dt><dd/><dt>vector functions and operators</dt><dd><dl><dt>conjugate operator, <a class="indexterm" href="apa.html#I_indexterm_id365972">Conjugate: The − Operator</a></dt><dd/><dt>scalar division, <a class="indexterm" href="apa.html#I_indexterm_id365914">Scalar Division: The /= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id367090">Scalar Division: The / Operator</a></dt><dd/><dt>scalar multiplication, <a class="indexterm" href="apa.html#I_indexterm_id365796">Scalar Multiplication: The *= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id367016">Scalar Multiplication: The * Operator</a></dt><dd/><dt>triple scalar product, <a class="indexterm" href="apa.html#I_indexterm_id367140">Triple Scalar Product</a></dt><dd/><dt>vector addition, <a class="indexterm" href="apa.html#I_indexterm_id365554">Vector Addition: The += Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366053">Vector Addition: The + Operator</a></dt><dd/><dt>vector cross product, <a class="indexterm" href="ch01.html#I_indexterm1_id290289">Vectors</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id302516">Angular Velocity and Acceleration</a>, <a class="indexterm" href="apa.html#I_indexterm_id366337">Vector Cross Product: The ^ Operator</a></dt><dd/><dt>vector dot product, <a class="indexterm" href="ch01.html#I_indexterm1_id290319">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id366773">Vector Dot Product: The * Operator</a></dt><dd/><dt>vector subtraction, <a class="indexterm" href="apa.html#I_indexterm_id365673">Vector Subtraction: The −= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366186">Vector Subtraction: The − Operator</a></dt><dd/></dl></dd><dt>vector multiplication</dt><dd><dl><dt>in matrix operations, <a class="indexterm" href="apb.html#I_indexterm_id368881">Vector Multiplication: The * Operator</a></dt><dd/><dt>in quaternion operations, <a class="indexterm" href="ch11.html#I_indexterm5_id331290">Vector multiplication: The * operator</a>, <a class="indexterm" href="apc.html#I_indexterm_id370778">Vector Multiplication: The * Operator</a></dt><dd/></dl></dd><dt>vector operations</dt><dd><dl><dt>direction in, <a class="indexterm" href="ch01.html#I_indexterm1_id290133">Vectors</a></dt><dd/><dt>magnitude in, <a class="indexterm" href="ch01.html#I_indexterm1_id290114">Vectors</a>, <a class="indexterm" href="apa.html#I_indexterm_id364945">Magnitude</a></dt><dd/><dt>Vector class, <a class="indexterm" href="apa.html#vea1">Vector Class</a>–<a class="indexterm" href="apa.html#I_indexterm_id365986">Conjugate: The − Operator</a></dt><dd/><dt>vector functions and operators, <a class="indexterm" href="apa.html#vea.2">Vector Functions and Operators</a>–<a class="indexterm" href="apa.html#I_indexterm_id367213">Triple Scalar Product</a></dt><dd/></dl></dd><dt>vector subtraction, <a class="indexterm" href="apa.html#I_indexterm_id365657">Vector Subtraction: The −= Operator</a>, <a class="indexterm" href="apa.html#I_indexterm_id366217">Vector Subtraction: The − Operator</a></dt><dd/><dt>vectors</dt><dd><dl><dt>acceleration, <a class="indexterm" href="ch01.html#I_indexterm1_id293392">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch25.html#I_indexterm6_id362780">Numerical Differentiation</a></dt><dd/><dt>defined, <a class="indexterm" href="ch01.html#I_indexterm1_id290086">Vectors</a></dt><dd/><dt>examples of, <a class="indexterm" href="ch01.html#I_indexterm1_id290180">Vectors</a></dt><dd/><dt>orthogonal, <a class="indexterm" href="ch11.html#I_indexterm5_id329786">Rotation Matrices</a></dt><dd/><dt>tensors and, <a class="indexterm" href="ch01.html#I_indexterm1_id294096">Newton’s Second Law of Motion</a></dt><dd/><dt>3D particle
          kinematics and, <a class="indexterm" href="ch02.html#I_indexterm2_id300284">The Vectors</a></dt><dd/><dt>time derivative of, <a class="indexterm" href="ch01.html#I_indexterm1_id294304">Newton’s Second Law of Motion</a></dt><dd/></dl></dd><dt>velocity</dt><dd><dl><dt>about, <a class="indexterm" href="ch02.html#ve2.1">Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id296721">Velocity and Acceleration</a></dt><dd/><dt>acceleration and, <a class="indexterm" href="ch02.html#vea2.1">Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id296937">Velocity and Acceleration</a></dt><dd/><dt>angular, <a class="indexterm" href="ch01.html#I_indexterm1_id289840">Units and Measures</a>, <a class="indexterm" href="ch01.html#I_indexterm1_id293944">Newton’s Second Law of Motion</a>, <a class="indexterm" href="ch02.html#va2.9">Angular Velocity and Acceleration</a>–<a class="indexterm" href="ch02.html#I_indexterm2_id303181">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id329689">Rotation Matrices</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id330250">Quaternions</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333010">Integration</a></dt><dd/><dt>Bernoulli’s equation and, <a class="indexterm" href="ch06.html#I_indexterm6_id317489">Drag</a></dt><dd/><dt>equations for, <a class="indexterm" href="ch04.html#I_indexterm4_id307434">Particle Kinetics in 2D</a></dt><dd/><dt>instantaneous, <a class="indexterm" href="ch02.html#I_indexterm2_id296560">Velocity and Acceleration</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id297277">Constant Acceleration</a></dt><dd/><dt>linear, <a class="indexterm" href="ch01.html#I_indexterm1_id289777">Units and Measures</a>, <a class="indexterm" href="ch02.html#I_indexterm2_id302140">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id336476">Update</a></dt><dd/><dt>magnitude of, <a class="indexterm" href="ch02.html#I_indexterm2_id296304">Velocity and Acceleration</a></dt><dd/><dt>muzzle, <a class="indexterm" href="ch18.html#I_indexterm4_id346131">Projectile Motion</a></dt><dd/><dt>relative, <a class="indexterm" href="ch02.html#I_indexterm2_id302829">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch08.html#I_indexterm2_id324155">Particle-to-Ground Collisions</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327164">Linear Collision Response</a>, <a class="indexterm" href="ch10.html#I_indexterm4_id327474">Linear Collision Response</a>, <a class="indexterm" href="ch13.html#I_indexterm7_id334299">Springs and Dampers</a>, <a class="indexterm" href="ch14.html#I_indexterm8_id337734">Collision Detection</a></dt><dd/><dt>Reynolds number and, <a class="indexterm" href="ch06.html#I_indexterm6_id318221">Drag</a></dt><dd/><dt>second derivatives of, <a class="indexterm" href="ch02.html#I_indexterm2_id297051">Velocity and Acceleration</a></dt><dd/><dt>tangential, <a class="indexterm" href="ch02.html#I_indexterm2_id302182">Angular Velocity and Acceleration</a>, <a class="indexterm" href="ch05.html#I_indexterm5_id313017">Impact</a></dt><dd/><dt>terminal, <a class="indexterm" href="ch06.html#I_indexterm6_id318299">Drag</a></dt><dd/></dl></dd><dt>vertex-edge collisions, <a class="indexterm" href="ch10.html#ve10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328852">Angular Effects</a></dt><dd/><dt>vertex-vertex collisions, <a class="indexterm" href="ch10.html#vv10.2">Angular Effects</a>–<a class="indexterm" href="ch10.html#I_indexterm4_id328429">Angular Effects</a></dt><dd/><dt>vertical force, <a class="indexterm" href="ch19.html#I_indexterm5_id351305">Calculating Forces</a></dt><dd/><dt>vibration energy, <a class="indexterm" href="ch20.html#I_indexterm1_id352128">Exotic: Dispersive Signal and Surface Acoustic Wave</a></dt><dd/><dt>viewing frustum, <a class="indexterm" href="ch24.html#vi24.2.1">The Left and Right Frustums</a>–<a class="indexterm" href="ch24.html#I_indexterm5_id360919">The Left and Right Frustums</a></dt><dd/><dt>Vincenty formula, <a class="indexterm" href="ch22.html#I_indexterm3_id357259">Distance</a></dt><dd/><dt>vines (swinging) example, <a class="indexterm" href="ch13.html#vi13.2">Connecting Particles</a>–<a class="indexterm" href="ch13.html#I_indexterm7_id335380">Update the simulation</a></dt><dd/><dt>virtual mass, <a class="indexterm" href="ch16.html#I_indexterm2_id342892">Virtual mass</a></dt><dd/><dt>viscosity</dt><dd><dl><dt>kinematic, <a class="indexterm" href="ch01.html#I_indexterm1_id289261">Units and Measures</a></dt><dd/><dt>units and symbols for, <a class="indexterm" href="ch01.html#I_indexterm1_id289902">Units and Measures</a></dt><dd/></dl></dd><dt>viscous drag, <a class="indexterm" href="ch17.html#I_indexterm3_id345376">Resistance</a></dt><dd/><dt>volume of ships, displacement and, <a class="indexterm" href="ch16.html#I_indexterm2_id341326">Stability</a></dt><dd/><dt>volumetric displays, <a class="indexterm" href="ch24.html#I_indexterm5_id360174">3D Display</a>, <a class="indexterm" href="ch24.html#I_indexterm5_id361738">Advanced Technologies</a></dt><dd/><dt>Von Doenhoff, Albert E., <a class="indexterm" href="ch15.html#I_indexterm1_id339401">Lift and Drag</a></dt><dd/><dt>voxels, <a class="indexterm" href="ch24.html#I_indexterm5_id361777">Advanced Technologies</a></dt><dd/></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>wave drag, <a class="indexterm" href="ch16.html#I_indexterm2_id342502">General Resistance</a>, <a class="indexterm" href="ch17.html#I_indexterm3_id345577">Resistance</a></dt><dd/><dt>weather helm, <a class="indexterm" href="ch17.html#I_indexterm3_id345551">Resistance</a></dt><dd/><dt>weight of objects</dt><dd><dl><dt>about, <a class="indexterm" href="ch01.html#I_indexterm1_id288377">Units and Measures</a></dt><dd/><dt>ammunition, <a class="indexterm" href="ch18.html#I_indexterm4_id346149">Projectile Motion</a></dt><dd/><dt>buoyancy and, <a class="indexterm" href="ch16.html#I_indexterm2_id341363">Stability</a></dt><dd/></dl></dd><dt>weighted average, <a class="indexterm" href="ch23.html#we23.2.1.2">Center of gravity</a>–<a class="indexterm" href="ch23.html#I_indexterm4_id359803">Center of gravity</a></dt><dd/><dt>wetted drag, <a class="indexterm" href="ch17.html#we17.2.2">Resistance</a>–<a class="indexterm" href="ch17.html#I_indexterm3_id345857">Resistance</a></dt><dd/><dt>wind force</dt><dd><dl><dt>as force effector, <a class="indexterm" href="ch14.html#I_indexterm8_id338101">Force Effectors</a></dt><dd/><dt>particle kinetics in 3D, <a class="indexterm" href="ch04.html#I_indexterm4_id308669">Particle Kinetics in 3D</a></dt><dd/><dt>in particle simulation, <a class="indexterm" href="ch08.html#wi8.3">Implementing External Forces</a>–<a class="indexterm" href="ch08.html#I_indexterm2_id323668">Implementing External Forces</a></dt><dd/><dt>zeroing the sights and, <a class="indexterm" href="ch18.html#I_indexterm4_id347175">Wind</a></dt><dd/></dl></dd><dt>wings, in aircraft, <a class="indexterm" href="ch15.html#I_indexterm1_id338615">Geometry</a></dt><dd/><dt>wire-grid polarizer, <a class="indexterm" href="ch24.html#I_indexterm5_id361214">Linear and Circular Polarization</a></dt><dd/></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>x-axis, rotation around, <a class="indexterm" href="ch01.html#I_indexterm1_id290028">Coordinate System</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id329565">Rotation Matrices</a></dt><dd/></dl></div><div class="indexdiv"><h3>Y</h3><dl><dt>y-axis, rotation around, <a class="indexterm" href="ch01.html#I_indexterm1_id290035">Coordinate System</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id329572">Rotation Matrices</a></dt><dd/><dt>yaw</dt><dd><dl><dt>flight control action for, <a class="indexterm" href="ch11.html#I_indexterm5_id329022">Rotation in 3D Rigid-Body Simulators</a>, <a class="indexterm" href="ch12.html#I_indexterm6_id333330">Flight Controls</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id340042">Control</a></dt><dd/><dt>local coordinate axes and, <a class="indexterm" href="ch02.html#I_indexterm2_id301736">Local Coordinate Axes</a>, <a class="indexterm" href="ch15.html#I_indexterm1_id338857">Geometry</a></dt><dd/><dt>in ships and boats, <a class="indexterm" href="ch16.html#I_indexterm2_id341909">Ship Motions</a></dt><dd/></dl></dd></dl></div><div class="indexdiv"><h3>Z</h3><dl><dt>z-axis, rotation around, <a class="indexterm" href="ch01.html#I_indexterm1_id290041">Coordinate System</a>, <a class="indexterm" href="ch11.html#I_indexterm5_id329360">Rotation Matrices</a></dt><dd/><dt>zero range, <a class="indexterm" href="ch18.html#I_indexterm4_id346683">Bullet drop: Gravity and air resistance</a></dt><dd/><dt>zeroing the sights</dt><dd><dl><dt>about, <a class="indexterm" href="ch18.html#I_indexterm4_id346540">Zeroing the Sights</a></dt><dd/><dt>gravity and resistance, <a class="indexterm" href="ch18.html#ze18.2.1.1">Bullet drop: Gravity and air resistance</a>–<a class="indexterm" href="ch18.html#I_indexterm4_id347120">Bullet drop: Gravity and air resistance</a></dt><dd/><dt>wind and, <a class="indexterm" href="ch18.html#I_indexterm4_id347165">Wind</a></dt><dd/></dl></dd></dl></div></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Preface</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="upgrade_offer_front.html" title="Special Upgrade Offer"/><link rel="next" href="pt01.html" title="Part I. Fundamentals"/></head><body><section class="preface" title="Preface" epub:type="preface" id="preface"><div class="titlepage"><div><div><h2 class="title">Preface</h2></div></div></div><div class="sect1" title="Who Is This Book For?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286310">Who Is This Book For?</h2></div></div></div><p>Simply put, this book is targeted at computer game developers who do not have a strong
      mechanics or physics background, charged with the task of incorporating <span class="emphasis"><em>real
        physics</em></span> in their games. </p><p>As a game developer, and very likely as a gamer yourself, you’ve seen products being
      advertised as “ultra-realistic,” or as using “real-world physics.” At the same time you, or
      perhaps your company’s marketing department, are wondering how you can spice up your own games
      with such realism. Or perhaps you want to try something completely new that requires you to
      explore real physics. The only problem is that you threw your college physics text in the lake
      after final exams and haven’t touched the subject since. Maybe you licensed a really cool
      physics engine, but you have no idea how the underlying principles work and how they will
      affect what you’re trying to model. Or, perhaps you are charged with the task of tuning
      someone else’s physics code but you really don’t understand how it works. Well then, this book
      is for you. </p><p>Sure you could scour the Internet, trade journals, and magazines for information and
      how-to’s on adding physics-based realism to your games. You could even fish out that old
      physics text and start from scratch. However, you’re likely to find that either the material
      is too general to be applied directly, or too advanced requiring you to search for other
      sources to get up to speed on the basics. This book will pull together the information you
      need and will serve as the starting point for you, the game developer, in your effort to
      enrich your game’s content with physics-based realism. </p><p>This book is not a recipe book that simply gives sample code for a miscellaneous set of
      problems. The Internet is full of such example programs (some very good ones we might add).
      Rather than give you a collection of specific solutions to specific problems, our aim is to
      arm you with a thorough and fundamental understanding of the relevant topics such that you can
      formulate your own solutions to a variety of problems. We’ll do this by explaining, in detail,
      the principles of physics applicable to game development, and by providing complimentary hand
      calculation examples in addition to sample programs. </p></div><div class="sect1" title="What We Assume You Know"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286370">What We Assume You Know</h2></div></div></div><p> Although we don’t assume that you are a physics expert, we do assume that you have at
      least a basic college level understanding of classical physics typical of non-physics and
      non-engineering majors. It is not essential that your physics background is fresh in your mind
      as the first several chapters of this book review the subjects relevant to game physics. </p><p>We also assume that you are proficient in trigonometry, vector, and matrix math, although
      we do include reference material in the appendices. Further, we assume that you have at least
      a basic college level understanding of calculus, including integration and differentiation of
      explicit functions. Numerical integration and differentiation is a different story, and we
      cover these techniques in detail in the later chapters of this book. </p></div><div class="sect1" title="Mechanics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286399">Mechanics</h2></div></div></div><p> Most people that we’ve talked to when we was developing the concept for this book
      immediately thought of flight simulators when the phrases “real physics” and “real-time
      simulation” came up. Certainly cutting edge flight simulations are relevant in this context;
      however, many different types of games, and specific game elements, stand to benefit from
      physics-based realism. </p><p>Consider this example: You’re working on the next blockbuster hunting game complete with
      first-person 3D, beautiful textures, and an awesome sound track to set the mood, but something
      is missing. That something is realism. Specifically, you want the game to “feel” more real by
      challenging the gamer’s marksmanship, and you want to do this by adding considerations such as
      distance to target, wind speed and direction, and muzzle velocity, among others. Moreover, you
      don’t want to fake these elements, but rather, you’d like to realistically model them based on
      the principles of physics. Gary Powell, with MathEngine Plc, put it like this “The illusion
      and immersive experience of the virtual world, so carefully built up with high polygon models,
      detailed textures and advanced lighting, is so often shattered as soon as objects start to
      move and interact.”<sup>[<a id="id326051" href="#ftn.id326051" epub:type="noteref" class="footnote">1</a>]</sup> “It’s all about interactivity and immersiveness,” says Dr. Steven Collins, CEO of Havok.com.<sup>[<a id="id309949" href="#ftn.id309949" epub:type="noteref" class="footnote">2</a>]</sup> We think both these guys or right on target. Why invest so much time and effort
      making your game world look as realistic as possible, but not take the extra step to make it
      behave just as realistically? </p><p>Here are a few examples of specific game elements that stand to benefit, in terms of
      realism, from the use of real physics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The trajectory of rockets and missiles including the effects of fuel burn off</p></li><li class="listitem"><p>The collision of objects such as billiard balls </p></li><li class="listitem"><p>The effects of gravitation between large objects such as planets and battle stations
        </p></li><li class="listitem"><p>The stability of cars racing around tight curves </p></li><li class="listitem"><p>The dynamics of boats and other waterborne vehicles </p></li><li class="listitem"><p>The flight path of a baseball after being struck by a bat </p></li><li class="listitem"><p>The flight of a playing card being tossed into a hat </p></li></ul></div><p>This is by no means an exhaustive list, but just a few examples to get you in the right
      frame of mind, so to speak. Pretty much anything in your games that bounces around, flies,
      rolls, slides, or isn’t sitting dead still can be realistically modeled to create compelling,
      believable content for your games. </p><p>So how can this realism be achieved? By using physics, of course, which brings us back to
      the title of this section, the subject of <span class="emphasis"><em>mechanics</em></span>. Physics is a vast
      field of science that covers many different, but related subjects. The subject most applicable
      to realistic game content is the subject of mechanics, which is really what’s meant by “real
      physics.” </p><p>By definition, mechanics is the study of bodies at rest and in motion, and of the effect
      of forces on them. The subject of mechanics is subdivided into <span class="emphasis"><em>statics</em></span>,
      which specifically focuses on bodies at rest, and <span class="emphasis"><em>dynamics</em></span>, which focuses
      on bodies in motion. One of the oldest and most studied subjects of physics, the formal
      origins of mechanics can be traced back more than 2000 years to Aristotle. An even earlier
      treatment of the subject was formalized in <span class="emphasis"><em>Problems of Mechanics</em></span>, but the
      origins of this work are unknown. Although some of these early works attributed some physical
      phenomena to magical elements, the contributions of such great minds as Galileo, Kepler,
      Euler, Lagrange, d’Alembert, Newton, and Einstein, to name a few, have helped develop our
      understanding of this subject to such a degree that we have been able to achieve the
      remarkable state of technological advancement that we see today. </p><p>Because you want your game content to be alive and active, we’ll primarily look at bodies
      in motion and will thus delve into the details of the subject of dynamics. Within the subject
      of dynamics there are even more specific subjects to investigate, namely,
        <span class="emphasis"><em>kinematics</em></span>, which focuses on the motion of bodies without regard to the
      forces that act on the body, and <span class="emphasis"><em>kinetics</em></span>, which considers both the
      motion of bodies and the forces that act on or otherwise affect bodies in motion. We’ll take a
      very close look at these two subjects throughout this book. </p></div><div class="sect1" title="Digital Physics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286570">Digital Physics</h2></div></div></div><p>This book’s first edition focused exclusively on mechanics. More than a decade after its
      release we’ve broadened our definition of game physics to include <span class="emphasis"><em>digital
        physics</em></span> not in the cosmological sense but in the context of the physics
      associated with such devices as smart phones and their unique user interaction experience. As
      more platforms such as the Wii, PlayStation, X Box and smart phones come out and are expanded
      developers will have to keep up with and understand the new input and sensors technologies
      that accompany these platforms in order to keep producing fresh gaming experiences. But you
      shouldn’t look at this as a burden, and instead look at it as an opportunity to enhance the
      user’s interactive experience with your games. </p></div><div class="sect1" title="Arrangement of This Book"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286592">Arrangement of This Book</h2></div></div></div><p> Physics-based realism is not new to gaming, and in fact many games on the shelves these
      days advertise their physics engines. Also, many 3D modeling and animation tools have physics
      engines built in to help realistically animate specific types of motion. Naturally, there are
      magazine articles that appear every now and then that discuss various aspects of physics-based
      game content. In parallel, but at a different level, research in the area of real-time rigid body<sup>[<a id="id328167" href="#ftn.id328167" epub:type="noteref" class="footnote">3</a>]</sup> simulation has been active for many years, and the technical journals are full of
      papers that deal with various aspects of this subject. You’ll find papers on subjects ranging
      from the simulation of multiple, connected rigid bodies to the simulation of cloth. However,
      while these are fascinating subjects and valuable resources, as we hinted earlier, many of
      them are of limited immediate use to the game developer as they first require a solid
      understanding of the subject of mechanics requiring you to learn the basics from other
      sources. Further, many of them focus primarily on the mathematics involved in solving the
      equations of motion and don’t address the practical treatment of the forces acting on the body
      or system being simulated. </p><p>We asked John Nagle, with Animats, what is, in his opinion, the most difficult part of
      developing a physics-based simulation for games and his response was developing numerically
      stable, robust code.<sup>[<a id="id149326" href="#ftn.id149326" epub:type="noteref" class="footnote">4</a>]</sup> Gary Powell echoed this when he told me that minimizing the amount of parameter
      tuning to produce stable, realistic behavior was one of the most difficult challenges. We
      agree; speed and robustness in dealing with the mathematics of bodies in motion are crucial
      elements of a simulator. And on top of that, so are completeness and accuracy in representing
      the interacting forces that initiate and perpetuate the simulation in the first place. As
      you’ll see later in this book, forces govern the behavior of objects in your simulation and
      you need to model them accurately if your objects are to behave realistically. </p><p>This prerequisite understanding of mechanics and the real world nature of forces that may
      act on a particular body or system have governed the organization of this book. Generally,
      this book is organized in four parts with each building on the material covered in previous
      parts: </p><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a></span></dt><dd><p>A mechanics refresher, comprising Chapters <a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">1</a> through <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">6</a>.</p></dd><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. Basic Concepts">Chapter 1, <em>Basic Concepts</em></a></span></dt><dd><p>This warm up chapter covers the most basic of principles that are used and
              referred to throughout this book.  The specific topics addressed include mass and
              center of mass, Newton’s Laws, inertia, units and measures, and vectors. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2, <em>Kinematics</em></a></span></dt><dd><p>This chapter covers such topics as linear and angular velocity, acceleration,
              momentum, and the general motion of particles and rigid bodies in two and three
              dimensions.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch03.html" title="Chapter 3. Force">Chapter 3, <em>Force</em></a></span></dt><dd><p>The principles of force and torque are covered in this chapter, which serves as a
              bridge from the subject of kinematics to that of kinetics.  General categories of
              forces are discussed including drag forces, force fields, and pressure.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch04.html" title="Chapter 4. Kinetics">Chapter 4, <em>Kinetics</em></a></span></dt><dd><p>This chapter combines elements of Chapters <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">2</a> and <a class="xref" href="ch03.html" title="Chapter 3. Force">3</a> to address the subject of kinetics and explains
              the difference between kinematics and kinetics.  Further discussion treats the
              kinetics of particles and rigid bodies in two and three dimensions.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch05.html" title="Chapter 5. Collisions">Chapter 5, <em>Collisions</em></a></span></dt><dd><p>In this chapter we’ll cover particle and rigid body collision response, that is,
              what happens after two objects run in to each other.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch06.html" title="Chapter 6. Projectiles">Chapter 6, <em>Projectiles</em></a></span></dt><dd><p>This chapter will focus on the physics of simple projectiles laying the ground
              work for further specific modeling treatment in later chapters. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="pt02.html" title="Part II. Rigid-Body Dynamics">Part II</a></span></dt><dd><p>An introduction to real time simulations, comprising Chapters <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">7</a> through <a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">14</a>.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch07.html" title="Chapter 7. Real-Time Simulations">Chapter 7, <em>Real-Time Simulations</em></a></span></dt><dd><p>This chapter will introduce real-time simulations and detail the core of such
              simulations—the numerical integrator. Various methods will be presented and coverage
              will include stability and tuning. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch08.html" title="Chapter 8. Particles">Chapter 8, <em>Particles</em></a></span></dt><dd><p>Before diving into rigid body simulations, this chapter will show how to implement
              a particle simulation, which will be extended in the next chapter to include rigid
              bodies.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch09.html" title="Chapter 9. 2D Rigid-Body Simulator">Chapter 9, <em>2D Rigid-Body Simulator</em></a></span></dt><dd><p>This chapter will extend the particle simulator from the previous chapter showing
              how to implement rigid bodies, which primarily consists of adding rotation and dealing
              with the inertia tensor.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch10.html" title="Chapter 10. Implementing Collision Response">Chapter 10, <em>Implementing Collision Response</em></a></span></dt><dd><p>Collision detection and response will be combined to implement real‐time collision
              capabilities in the 2D simulator.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch11.html" title="Chapter 11. Rotation in 3D Rigid-Body Simulators">Chapter 11, <em>Rotation in 3D Rigid-Body Simulators</em></a></span></dt><dd><p>This chapter will address how to handle rigid body rotation in 3D including how to
              deal with the inertia tensor. Then we’ll show the reader how to extend the 2D
              simulator to 3D.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch12.html" title="Chapter 12. 3D Rigid-Body Simulator">Chapter 12, <em>3D Rigid-Body Simulator</em></a></span></dt><dd><p>Multiple unconnected bodies will be incorporated in the simulator in this chapter.
              Introduction of multiple bodies requires resolution of multiple rigid body collisions,
              which can be very tricky. Issues of stability and realism will be covered. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. Connecting Objects">Chapter 13, <em>Connecting Objects</em></a></span></dt><dd><p>Taking things a step further, this chapter will show how to join rigid bodies
              forming connected bodies, which may be used to simulate human bodies, complex vehicles
              that may blow apart, among many other game objects. Various connector types will be
              considered. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch14.html" title="Chapter 14. Physics Engines">Chapter 14, <em>Physics Engines</em></a></span></dt><dd><p>In this chapter, specific aspects of automobile performance are addressed,
              including aerodynamic drag, rolling resistance, skidding distance, and roadway
              banking.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="pt03.html" title="Part III. Physical Modeling">Part III</a></span></dt><dd><p> A look at some real world problems, comprising Chapters <a class="xref" href="ch15.html" title="Chapter 15. Aircraft">15</a> through <a class="xref" href="ch19.html" title="Chapter 19. Sports">19</a>.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch15.html" title="Chapter 15. Aircraft">Chapter 15, <em>Aircraft</em></a></span></dt><dd><p>This chapter focuses on the elements of flight including propulsor forces, drag,
              geometry, mass, and most importantly lift.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch16.html" title="Chapter 16. Ships and Boats">Chapter 16, <em>Ships and Boats</em></a></span></dt><dd><p>The fundamental elements of floating vehicles are discussed in this chapter,
              including floatation, stability, volume, drag, and speed. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch17.html" title="Chapter 17. Cars and Hovercraft">Chapter 17, <em>Cars and Hovercraft</em></a></span></dt><dd><p>In this chapter, specific aspects of automobile performance are addressed,
              including aerodynamic drag, rolling resistance, skidding distance, and roadway
              banking. Additionally hovercraft shares some of the same characteristics of both cars
              and boats. This chapter will consider those characteristics that distinguish the
              hovercraft as a unique vehicle.  Topics covered include hovering flight, aerostatic
              lift, and directional control </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. Guns and Explosions">Chapter 18, <em>Guns and Explosions</em></a></span></dt><dd><p>This chapter will focus on the physics of guns including power, recoil, and
              projectile flight. Since we generally want things to explode when hit with a large
              projectile, this chapter will also address the physics of and modeling
              explosions.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. Sports">Chapter 19, <em>Sports</em></a></span></dt><dd><p>This chapter will focus on the physics of ball sports such as baseball, golf, and
              tennis. Coverage will go beyond projectile physics and include such topics as
              including pitching, bat swing, bat‐ball impact, golf club swing and club ball impact,
              plus tennis racket swinging and racket/ball impacts.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="pt04.html" title="Part IV. Digital Physics">Part IV</a></span></dt><dd><p>Chapters in this part of the book will explain the physics behind accelerometers,
              touch screens, GPS and other gizmos showing the reader how to leverage these elements
              in their games, comprising Chapters <a class="xref" href="ch20.html" title="Chapter 20. Touch Screens">20</a> through <a class="xref" href="ch26.html" title="Chapter 26. Sound">26</a>.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch20.html" title="Chapter 20. Touch Screens">Chapter 20, <em>Touch Screens</em></a></span></dt><dd><p>Touch screens facilitate virtual tactile interfaces with mobile device games, such
              as those made for the iPhone. This chapter will explain the physics of touch screen
              and how the reader can leverage this interface in their games particularly with
              respect to virtual physical interaction with game elements through gesturing.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch21.html" title="Chapter 21. Accelerometers">Chapter 21, <em>Accelerometers</em></a></span></dt><dd><p>Accelerometers are now widely used in mobile devices and game controllers allowing
              virtual physical interaction between players and game objects. This chapter will
              explain how accelerometers work, what data they provide and how that data can be
              manipulated with respect to virtual physical interaction with game elements. Topics
              covered will include, but not be limited to integration of acceleration data to derive
              velocities and displacements and rotations.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"> <a class="xref" href="ch22.html" title="Chapter 22. Gaming from One Place to Another">Chapter 22, <em>Gaming from One Place to Another</em></a></span></dt><dd><p>Mobile devices commonly have GPS capabilities and this chapter will explain the
              physics of the GPS system including relativistic effects. Further, GPS data will be
              explained and this chapter showing the reader how to manipulate that data for virtual
              interaction with game elements. For example, we’ll show the reader how to
              differentiate GPS data to derive speed and acceleration among other manipulations.
            </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch23.html" title="Chapter 23. Pressure Sensors and Load Cells">Chapter 23, <em>Pressure Sensors and Load Cells</em></a></span></dt><dd><p>Pressure sensing devices are used in games as a means of allowing players to
              interact with game elements, for example, the Wii balance board uses pressure sensors
              allowing players to interact with the Wii Fit game. This chapter will explain the
              physics behind such pressure sensors, what data they generate, and how to manipulate
              that data for game interaction.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch24.html" title="Chapter 24. 3D Display">Chapter 24, <em>3D Display</em></a></span></dt><dd><p>The new PlayStation Move and Microsoft’s Kinect use optical tracking systems to
              detect the position of players’ game controllers or gestures. This chapter will
              explain the physics behind optical tracking and how to leverage this technology in
              games.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch25.html" title="Chapter 25. Optical Tracking">Chapter 25, <em>Optical Tracking</em></a></span></dt><dd><p>As televisions and handheld game consoles race to implement 3D displays, several
              different technologies are being developed. By understanding the physics of the
              glasses dependent stereoscopic displays, the new “glasses free” autostereoscopic
              displays, and looking forward to holography and volumetric displays, developers will
              be better positioned to leverage these effects in their games.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term">
            <a class="xref" href="ch26.html" title="Chapter 26. Sound">Chapter 26, <em>Sound</em></a></span></dt><dd><p>Sound is a particularly important part of a game’s immersive experience; however,
              to date no book on game physics addresses the physics of sound. This chapter will
              focus on sound physics including such topics of sound speed and the Doppler Effect.
              Discussions will also include why sound physics is often ignored in games, for
              example, when simulating explosions in outer space. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="apa.html" title="Appendix A. Vector Operations">Appendix A</a></span></dt><dd><p>This appendix shows you how to implement a C++ class that captures all of the
              vector operations that you’ll need to when writing 2D or 3D simulations. </p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="apb.html" title="Appendix B. Matrix Operations">Appendix B</a></span></dt><dd><p>This appendix implements a class that captures all of the operations you need to
              handle 3x3 matrices.</p></dd></dl></div><p>
      </p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="apc.html" title="Appendix C. Quaternion Operations">Appendix C</a></span></dt><dd><p>This appendix implements a class that captures all of the operations you need to
              handle quaternions when writing 3D rigid body simulations.</p></dd></dl></div><p>
    </p><p><a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a> focuses on fundamental topics in
      Newtonian mechanics such as kinematics and kinetics. Kinematics deals with the motion of
      objects. We’ll cover both linear and angular velocity and acceleration. Kinetics deals with
      forces and resulting motion. Part I serves as a primer for <a class="xref" href="pt02.html" title="Part II. Rigid-Body Dynamics">Part II</a> that covers rigid body dynamics. Readers already versed in
      classical mechanics can skip <a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a> without loss
      of continuity.</p><p><a class="xref" href="pt02.html" title="Part II. Rigid-Body Dynamics">Part II</a> focuses on rigid body dynamics and
      development of both single and multi-body simulations. This part covers numerical integration,
      real-time simulation of particles and rigid bodies, and connected rigid bodies. Generally,
      this part covers what most game programmers consider elements of a physics engine. </p><p><a class="xref" href="pt03.html" title="Part III. Physical Modeling">Part III</a> focuses on physical modeling. The aim
      of this part is to provide valuable physical insight for the reader so they can make better
      judgments on what to include in their models and what they can safely leave out without
      sacrificing physical realism. We cannot and do not attempt to cover all the possible things
      you might want to simulate. Instead we cover several typical things you may try to simulate in
      a game such as aircraft, boats, sports balls, among others with the purpose of giving you some
      insight into the physical nature of those things and some of the choices you must make when
      developing suitable models. </p><p><a class="xref" href="pt04.html" title="Part IV. Digital Physics">Part IV</a> covers digital physics in a broad
      sense. This is an exciting topic as it relates to the technologies associated with mobile
      platforms, such as smart phones like the iPhone, and ground breaking game systems such as the
      Nentendo Wii. Chapters in this part of the book will explain the physics behind
      accelerometers, touch screens, GPS and other gizmos showing the reader how to leverage these
      elements in their games. We recognize that these topics are not what most game programmers
      typically think about when they think of game physics; however, the technologies covered play
      an increasingly important role in modern mobile games and we feel it important to explain the
      underlying physics behind them with the hope that you’ll be better able to leverage these
      technologies in your games. </p><p>In addition to resources pertaining to real-time simulations, the <a class="link" href="apd.html" title="Appendix D. Bibliography">Bibliography</a> at the end of this book will provide sources of information on
      mechanics, mathematics, and other specific technical subjects, such as books on
      aerodynamics.</p></div><div class="sect1" title="Conventions Used in This Book"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id286597">Conventions Used in This Book</h2></div></div></div><p>The following typographical conventions are used in this book:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">Constant width</code></span></dt><dd><p>Used to indicate command-line computer output, code examples, Registry keys, and
            keyboard accelerators (see “Keyboard Accelerators” later in this book).</p></dd><dt><span class="term"><em class="replaceable"><code>Constant width italic</code></em></span></dt><dd><p>Used to indicate variables in code examples.</p></dd><dt><span class="term"><span class="emphasis"><em>Italic</em></span></span></dt><dd><p>Introduces new terms and to indicate URLs, variables, filenames and directories,
            commands, and file extensions.</p></dd><dt><span class="term"><span class="bold"><strong>Bold</strong></span></span></dt><dd><p>Indicates vector variables.</p></dd></dl></div><div class="tip" title="Tip"><h3 class="title">Tip</h3><p>This icon signifies a tip, suggestion, or general note.</p></div><div class="caution" title="Caution"><h3 class="title">Caution</h3><p>This icon indicates a warning or caution.</p></div><p>We use boldface type to indicate a vector quantity, such as force, <span class="bold"><strong>F</strong></span>. When referring to the magnitude only of a vector quantity, we use standard
      type. For example, the magnitude of the vector force, <span class="bold"><strong>F</strong></span>, is F
      with components along the coordinate axes, Fx, Fy, and Fz. In the code samples throughout the
      book, we use the * (asterisk) to indicate vector dot product, or scalar product, operations
      depending on the context, and we use the ^ (caret) to indicate vector cross product. </p></div><div class="sect1" title="Using Code Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id287764">Using Code Examples</h2></div></div></div><p>This book is here to help you get your job done. In general, if this book includes code
      examples, you may use the code in your programs and documentation. You do not need to contact
      us for permission unless you’re reproducing a significant portion of the code. For example,
      writing a program that uses several chunks of code from this book does not require permission.
      Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.
      Answering a question by citing this book and quoting example code does not require permission.
      Incorporating a significant amount of example code from this book into your product’s
      documentation does require permission.</p><p>We appreciate, but do not require, attribution. An attribution usually includes the title,
      author, publisher, and ISBN. For example: “<span class="emphasis"><em>Physics for Game Developers, 2nd
        Edition</em></span> by David M. Bourg and Bryan Bywalec (O’Reilly). Copyright 2013 David M.
      Bourg and Bryan Bywalec, 978-1-449-39251-2.”</p><p>If you feel your use of code examples falls outside fair use or the permission given
      above, feel free to contact us at <span class="email"><a class="email" href="mailto:permissions@oreilly.com">permissions@oreilly.com</a></span>.</p></div><div class="sect1" title="Safari® Books Online"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id287799">Safari® Books Online</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Safari Books Online (<a class="ulink" href="http://my.safaribooksonline.com/?portal=oreilly" target="_top">www.safaribooksonline.com</a>)
        is an on-demand digital library that delivers expert <a class="ulink" href="http://www.safaribooksonline.com/content" target="_top">content</a> in both book and video form
        from the world’s leading authors in technology and business.</p></div><p>Technology professionals, software developers, web designers, and business and creative
      professionals use Safari Books Online as their primary resource for research, problem solving,
      learning, and certification training.</p><p>Safari Books Online offers a range of <a class="ulink" href="http://www.safaribooksonline.com/subscriptions" target="_top">product mixes</a> and pricing
      programs for <a class="ulink" href="http://www.safaribooksonline.com/organizations-teams" target="_top">organizations</a>, <a class="ulink" href="http://www.safaribooksonline.com/government" target="_top">government
        agencies</a>, and <a class="ulink" href="http://www.safaribooksonline.com/individuals" target="_top">individuals</a>. Subscribers have
      access to thousands of books, training videos, and prepublication manuscripts in one fully
      searchable database from publishers like O’Reilly Media, Prentice Hall Professional,
      Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco
      Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT
      Press, Apress, Manning, New Riders, McGraw-Hill, Jones &amp; Bartlett, Course Technology, and
      dozens <a class="ulink" href="http://www.safaribooksonline.com/publishers" target="_top">more</a>. For more information about Safari Books Online, please visit us <a class="ulink" href="http://www.safaribooksonline.com/" target="_top">online</a>.</p></div><div class="sect1" title="How to Contact Us"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id287901">How to Contact Us</h2></div></div></div><p>Please address comments and questions concerning this book to the publisher:</p><table style="border: 0; " class="simplelist"><tr><td>O’Reilly Media, Inc.</td></tr><tr><td>1005 Gravenstein Highway North</td></tr><tr><td>Sebastopol, CA 95472</td></tr><tr><td>800-998-9938 (in the United States or Canada)</td></tr><tr><td>707-829-0515 (international or local)</td></tr><tr><td>707-829-0104 (fax)</td></tr></table><p>We have a web page for this book, where we list errata, examples, and any additional
      information. You can access this page at <a class="ulink" href="http://oreil.ly/Physics-GameDev2" target="_top">http://oreil.ly/Physics-GameDev2</a>.</p><p>To comment or ask technical questions about this book, send email to
        <span class="email"><a class="email" href="mailto:bookquestions@oreilly.com">bookquestions@oreilly.com</a></span>.</p><p>For more information about our books, courses, conferences, and news, see our website at
        <a class="ulink" href="http://www.oreilly.com" target="_top">http://www.oreilly.com</a>.</p><p>Find us on Facebook: <a class="ulink" href="http://facebook.com/oreilly" target="_top">http://facebook.com/oreilly</a></p><p>Follow us on Twitter: <a class="ulink" href="http://twitter.com/oreillymedia" target="_top">http://twitter.com/oreillymedia</a></p><p>Watch us on YouTube: <a class="ulink" href="http://www.youtube.com/oreillymedia" target="_top">http://www.youtube.com/oreillymedia</a></p></div><div class="sect1" title="Acknowledgments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="I_sect1_id287997">Acknowledgments</h2></div></div></div><p>We want to thank Andy Oram, the editor of this edition of the book, for his skillful
      review of our writing and his insightful comments and suggestions, not to mention his
      patience. We also want to express my appreciation to O’Reilly for agreeing to take on this
      project giving us the opportunity to expand on the original edition. Furthermore, special
      thanks go to all of the production and technical staff at O’Reilly. </p><p>We’d also like to thank the technical reviewers, Christian Stober and Paul Zirkle, whose
      valuable insight added much to this edition. </p><p>Individually, David would like to thank his loving wife and best friend, Helena, for her
      endless support and encouragement, and his wonderful daughter, Natalia, for making every day
      special. </p><p>Bryan would like to thank his co-author David for the opportunity to help with the second
      edition and would also like to thank his parents, Barry and Sharon, for raising him to be
      curious about the world. Lastly, he would like to thank his fiancée, Anne Hasuly, for her
      support without which many chapters would still be half-finished. </p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id326051"><p><sup>[<a href="#id326051" class="para">1</a>] </sup>At the time of this book’s first edition, Gary Powell worked for MathEngine Plc. Their
          products included Dynamics Toolkit 2 and Collision Toolkit 1, which handled single and
          multiple body dynamics. Currently the company operates under the name CM Labs.</p></div><div class="footnote" epub:type="footnote" id="ftn.id309949"><p><sup>[<a href="#id309949" class="para">2</a>] </sup>At the time of this book’s first edition, Dr. Collins was the CEO of Havok.com. Their
          technology handled rigid body, soft body, cloth, and fluid and particle dynamics. Intel
          purchased Havok in 2005. </p></div><div class="footnote" epub:type="footnote" id="ftn.id328167"><p><sup>[<a href="#id328167" class="para">3</a>] </sup>A rigid body is formally defined as a body, composed of a system of particles, whose
          particles remain at fixed distances from each other with no relative translation or
          rotation among particles. Although the subject of mechanics deals with flexible bodies and
          even fluids such as water, we’ll focus our attention on bodies that are rigid.</p></div><div class="footnote" epub:type="footnote" id="ftn.id149326"><p><sup>[<a href="#id149326" class="para">4</a>] </sup>At the time of this book’s first edition, John Nagle was the developer of Falling
          Bodies, a dynamics plug-in for Softimage|3D. </p></div></div></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Part I. Fundamentals</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="pr02.html" title="Preface"/><link rel="next" href="ch01.html" title="Chapter 1. Basic Concepts"/></head><body><div class="part" title="Part I. Fundamentals" epub:type="part" id="part1"><div class="titlepage"><div><div><h1 class="title">Part I. Fundamentals</h1></div></div></div><div class="partintro" title="Fundamentals" id="id454829"><div/><p><a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a> focuses on fundamental topics in Newtonian mechanics such as
        <span class="emphasis"><em>kinematics</em></span> and <span class="emphasis"><em>kinetics</em></span>. Kinematics deals with the
      motion of objects; we’ll cover both linear and angular velocity and acceleration. Kinetics
      deals with forces and resulting motion. <a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a> serves as a primer for <a class="xref" href="pt02.html" title="Part II. Rigid-Body Dynamics">Part II</a>, which covers rigid-body dynamics. Readers already versed in classical
      mechanics can skip <a class="xref" href="pt01.html" title="Part I. Fundamentals">Part I</a> without loss of continuity. </p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Part II. Rigid-Body Dynamics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="ch06.html" title="Chapter 6. Projectiles"/><link rel="next" href="ch07.html" title="Chapter 7. Real-Time Simulations"/></head><body><div class="part" title="Part II. Rigid-Body Dynamics" epub:type="part" id="part2"><div class="titlepage"><div><div><h1 class="title">Part II. Rigid-Body Dynamics</h1></div></div></div><div class="partintro" title="Rigid-Body Dynamics" id="id301128"><div/><p><a class="xref" href="pt02.html" title="Part II. Rigid-Body Dynamics">Part II</a> focuses on rigid-body dynamics and development of both single- and
      multibody simulations. This part covers numerical integration, real-time simulation of
      particles and rigid bodies, and connected rigid bodies. Generally, this part covers what most
      game programmers consider elements of a physics engine. </p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Part III. Physical Modeling</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="ch14.html" title="Chapter 14. Physics Engines"/><link rel="next" href="ch15.html" title="Chapter 15. Aircraft"/></head><body><div class="part" title="Part III. Physical Modeling" epub:type="part" id="part3"><div class="titlepage"><div><div><h1 class="title">Part III. Physical Modeling</h1></div></div></div><div class="partintro" title="Physical Modeling" id="id354284"><div/><p><a class="xref" href="pt03.html" title="Part III. Physical Modeling">Part III</a> focuses on physical modeling. The aim of this part is to provide
      you with valuable physical insight so you can make better judgments on what to include in your
      models and what you can safely leave out without sacrificing physical realism. We cannot and
      do not attempt to cover all the possible things you might want to simulate. Instead, we cover
      several <span class="emphasis"><em>typical</em></span> things you may try to simulate in a game—such as
      aircraft, boats, and sports balls, among others—in order to give you some insight into their
      physical nature and into some of the choices you must make when developing suitable models. </p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Part IV. Digital Physics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="ch19.html" title="Chapter 19. Sports"/><link rel="next" href="ch20.html" title="Chapter 20. Touch Screens"/></head><body><div class="part" title="Part IV. Digital Physics" epub:type="part" id="part4"><div class="titlepage"><div><div><h1 class="title">Part IV. Digital Physics</h1></div></div></div><div class="partintro" title="Digital Physics" id="id432159"><div/><p><a class="xref" href="pt04.html" title="Part IV. Digital Physics">Part IV</a> covers digital physics in a broad sense. This is an exciting
      topic, as it relates to the technologies associated with mobile platforms, such as smartphones
      like the iPhone, and groundbreaking game systems like the Wii. Chapters in this part of the
      book will explain the physics behind accelerometers, touch screens, GPS, and other gizmos,
      showing you how to leverage these elements in your games. We recognize that these topics are
      not what most game programmers typically think about when they think of game physics; however,
      these technologies play an increasingly important role in modern mobile games, and we feel
      it’s important to explain their underlying physics in the hope that you’ll be better able to
      leverage these technologies in your games. </p></div></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Special Upgrade Offer</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="co02.html" title="Colophon"/><link rel="next" href="copyright.html" title=""/></head><body><section class="preface" title="Special Upgrade Offer" epub:type="preface" id="back_of_book_promo"><div class="titlepage"><div><div><h2 class="title">Special Upgrade Offer</h2></div></div></div><p>If you purchased this ebook from a retailer other than O’Reilly, you can upgrade it for $4.99 at oreilly.com by <a class="ulink" href="http://opds.oreilly.com/buy/9781449302603.EBOOK?source=ibooks" target="_top">clicking here</a>.</p></section></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Special Upgrade Offer</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Physics for Game Developers"/><link rel="prev" href="index.html" title="Physics for Game Developers"/><link rel="next" href="pr02.html" title="Preface"/></head><body><section class="preface" title="Special Upgrade Offer" epub:type="preface" id="front_of_book_promo"><div class="titlepage"><div><div><h2 class="title">Special Upgrade Offer</h2></div></div></div><p>If you purchased this ebook directly from <a class="ulink" href="http://oreilly.com" target="_top">oreilly.com</a>, you have the following benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>DRM-free ebooks—use your ebooks across devices without restrictions or limitations</p></li><li class="listitem"><p>Multiple formats—use on your laptop, tablet, or phone</p></li><li class="listitem"><p>Lifetime access, with free updates</p></li><li class="listitem"><p>Dropbox syncing—your files, anywhere</p></li></ul></div><p>If you purchased this ebook from another retailer, you can upgrade your ebook to take advantage of all these benefits for just $4.99. <a class="link" href="upgrade_offer_back.html" title="Special Upgrade Offer">Click here</a> to access your ebook upgrade.</p><p><sub><span class="emphasis"><em>Please note that upgrade offers are not available from sample content.</em></span></sub></p></section></body></html>
