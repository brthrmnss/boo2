<!--?xml version="1.0" encoding="UTF-8" standalone="no"?--><html><head><title>Chapter&#xA0;10.&#xA0;Implementing Collision Response</title><link rel="stylesheet" type="text/css" href="core.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="up" href="pt02.html" title="Part&#xA0;II.&#xA0;Rigid-Body Dynamics"><link rel="prev" href="ch09.html" title="Chapter&#xA0;9.&#xA0;2D Rigid-Body Simulator"><link rel="next" href="ch11.html" title="Chapter&#xA0;11.&#xA0;Rotation in 3D Rigid-Body Simulators"></head><body>
         
        <script>
        function ok(){ 
            window.gggs()
            return;
            //$('#musicPlayer').parent().remove();
            //speakTransportPanelDialogV2.closeEmoteDialog()
            //speakTransportPanelDialog.closeEmoteDialog()
            //
            debugger
            let url = 'http://127.0.0.1:8080/uploads/extracted/' +
             'Crazy Rich Asians  Kevin Kwanepub/' +
              'jsonSets/OEBPS/Kwan_9780385536981_epub_prl_r1.htm.html.sentences.json'
            speakTransportPanelDialogV2.sideLoadSentences2(null, null, null, url)
            
        }
        setTimeout(ok, 1500)
        </script>
        <div style="background:white">````````</div><section class="chapter" title="Chapter&#xA0;10.&#xA0;Implementing Collision Response" epub:type="chapter" id="implementing_collision_response"><div class="titlepage"><div><div><h2 class="title"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">1</span><span sentence-index="6081" class="nonQuoteStr">Chapter&#xA0;10.&#xA0;Implementing  Collision  Response</span></span></h2></div></div></div><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">2</span><span sentence-index="6082" class="">In  this  chapter,  we&apos;ll  show  you  how  to  add  a  </span></span><a id="ho10.0" class="indexterm"></a><a id="co10.0" class="indexterm"></a><a id="si10.0" class="indexterm"></a><a id="tw10.0" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6086</span><span sentence-index="6086" class="">little  excitement  to  the  hovercraft  example  discussed  in  the  preceding  chapter. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6087</span><span sentence-index="6087" class="">        Specifically,  we&apos;ll  add  another  hovercraft  and  show  you  how  to  add  collision  response  so  that        the  hovercraft  can  crash  into  each  other  and  bounce  off  like  a  couple  of  bumper  cars. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6088</span><span sentence-index="6088" class="">  This  is  an        important  element  for  many  types  of  games,  so  it&apos;s  crucial  that  you  understand  the  code  that        we&apos;ll  present  here. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">9</span><span sentence-index="6089" class=""> Now  would  be  a  good  time  to  go  back  and  review  </span></span></a><a class="xref" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Collisions"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">10</span><span sentence-index="6090" class="">Chapter&#xA0;5</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6091</span><span sentence-index="6091" class="">        to  refresh  your  memory  on  the  fundamentals  of  rigid-body  collision  response  since  we&apos;ll  use  the        principles  and  formulas  discussed  there  to  develop  the  collision  response  algorithms  for  the        hovercraft  simulation. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">12</span><span sentence-index="6092" class=""> In  </span></span><a class="xref" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Particles"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">13</span><span sentence-index="6093" class="">Chapter&#xA0;8</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6094</span><span sentence-index="6094" class="">  you  saw  how  to  implement  linear  collision        response  for  particles,  and  now  we&apos;ll  show  you  how  to  handle  angular  effects.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">16</span><span sentence-index="6096" class="nonQuoteStr">To  start  simply,  we&apos;ll  first  show  you  how  to  implement  collision  response  as  if  the        hovercraft  were  a  couple  of  particles  just  like  those  in  </span></span><a class="xref" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Particles"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">17</span><span sentence-index="6097" class="">Chapter&#xA0;8</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6098</span><span sentence-index="6098" class=""> . </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6099</span><span sentence-index="6099" class="">  This        approach  uses  only  linear  impulse  and  does  not  include  angular  effects,  so  the  results  will  be        somewhat  unrealistic  for  these  hovercraft;  however,  this  approach  is  applicable  to  other  types        of  problems  that  you  may  be  interested  in  (for  example,  billiard  ball  collisions). </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6100</span><span sentence-index="6100" class="">  Plus,  taking        this  approach  allows  us  to  show  you  very  clearly  the  distinction  between  linear  and  angular        effects. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6101</span><span sentence-index="6101" class="">  Including  angular  effects  will  make  the  simulation  much  more  realistic;  when  the        hovercraft  crash  into  each  other,  not  only  will  they  bounce  off  each  other,  but  they  will  also        spin.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">23</span><span sentence-index="6103" class="nonQuoteStr">Before  diving  into  collisions,  let&apos;s  add  another  hovercraft  to  the  example  we  started  in            </span></span><a class="xref" href="ch09.html" title="Chapter&#xA0;9.&#xA0;2D Rigid-Body Simulator"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">24</span><span sentence-index="6104" class="">Chapter&#xA0;9</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6105</span><span sentence-index="6105" class=""> . </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6106</span><span sentence-index="6106" class="">  Recall  in  that  example,  we  had  a  single  craft  that        you  could  control  using  the  keyboard. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6107</span><span sentence-index="6107" class="">  Now,  we&apos;ll  add  another  hovercraft  that  simply  moves  under        constant  forward  thrust. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6108</span><span sentence-index="6108" class="">  Later,  when  we  add  collision  detection  and  response  you&apos;ll  be  able  to        run  into  this  new  hovercraft  to  alter  its  course.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">30</span><span sentence-index="6110" class="">Referring  back  to  the  example  from  </span></span><a class="xref" href="ch09.html" title="Chapter&#xA0;9.&#xA0;2D Rigid-Body Simulator"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">31</span><span sentence-index="6111" class="">Chapter&#xA0;9</span></span></a><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">31</span><span sentence-index="6111" class="">,  we  need  to  add        another  craft  as  follows:</span></span></p><a id="I_programlisting4_id326953"><pre class="programlisting">RigidBody2D    Craft2;</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">34</span><span sentence-index="6114" class="">We&apos;re  calling  the  new  hovercraft,  very  creatively,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">34</span><span sentence-index="6114" class="">Craft2</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6114</span><span sentence-index="6114" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">35</span><span sentence-index="6115" class=""> In  the  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">35</span><span sentence-index="6115" class="">Initialize</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">35</span><span sentence-index="6115" class=""> function,  we  must  now        add  the  following  code:</span></span></p></a><a id="I_programlisting4_id326976"><pre class="programlisting">bool    Initialize(void)
{
.
.
.
    Craft2.vPosition.x = _WINWIDTH/2;
    Craft2.vPosition.y = _WINHEIGHT/2;
    Craft2.fOrientation = 90;
.
.
.
}</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6117</span><span sentence-index="6117" class="">This  new  code  sample  positions  the  second  hovercraft  in  the  middle  of  the  screen  and        pointing  toward  the  bottom.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">39</span><span sentence-index="6119" class="">There  are  a  few  required  changes  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">39</span><span sentence-index="6119" class="">UpdateSimulation</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6119</span><span sentence-index="6119" class="">  as        well. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">40</span><span sentence-index="6120" class=""> First,  add  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">40</span><span sentence-index="6120" class="">Craft2.UpdateBodyEuler(dt);</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">40</span><span sentence-index="6120" class=""> right  after  the        line  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">40</span><span sentence-index="6120" class="">Craft.UpdateBodyEuler(dt);</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6120</span><span sentence-index="6120" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">41</span><span sentence-index="6121" class=""> Then,  add  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">41</span><span sentence-index="6121" class="">DrawCraft(Craft2,  RGB(200,  200,  0));</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">41</span><span sentence-index="6121" class=""> after  the  similar  line  that        draws  the  first  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">41</span><span sentence-index="6121" class="">Craft</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6121</span><span sentence-index="6121" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">42</span><span sentence-index="6122" class=""> </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">42</span><span sentence-index="6122" class="">Craft2</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">42</span><span sentence-index="6122" class=""> will  be  drawn  yellow  to  distinguish  it  from  the  first  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">42</span><span sentence-index="6122" class="">Craft</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6122</span><span sentence-index="6122" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">43</span><span sentence-index="6123" class=""> Finally,  add  the  following  lies  at  the  end  of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">43</span><span sentence-index="6123" class="">UpdateSimulation</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">43</span><span sentence-index="6123" class="">:</span></span></p></a><a id="I_programlisting4_id327041"><pre class="programlisting">    if(Craft2.vPosition.x &gt; _WINWIDTH) Craft2.vPosition.x = 0;
    if(Craft2.vPosition.x &lt; 0) Craft2.vPosition.x = _WINWIDTH;
    if(Craft2.vPosition.y &gt; _WINHEIGHT) Craft2.vPosition.y = 0;
    if(Craft2.vPosition.y &lt; 0) Craft2.vPosition.y = _WINHEIGHT;</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6125</span><span sentence-index="6125" class="">Now,  we  can  add  the  code  to  handle  collision  detection  and  response,  allowing  you  to  ram        your  hovercraft  into  the  new  one  we  just  added.</span></span></p></a><div class="sect1" title="Linear Collision Response"><a id="I_programlisting4_id327041"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="linear_collision_response"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">48</span><span sentence-index="6128" class="nonQuoteStr">Linear  Collision  Response</span></span></h2></div></div></div></a><p><a id="I_programlisting4_id327041"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">50</span><span sentence-index="6130" class="">In  this  section,  </span></span></a><a id="li10.1" class="indexterm"></a><a id="co10.1" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6132</span><span sentence-index="6132" class="">we&apos;ll  show  you  how  to  implement  simple  collision  response,  assuming  that  the  two            hovercraft  are  particles. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6133</span><span sentence-index="6133" class="">  We&apos;re  going  to  implement  only  bare-minimum  collision  detection  in            this  simulation;  however,  regardless  of  the  level  of  sophistication  of  your  collision            detection  routines,  there  are  very  specific  pieces  of  information  that  you  must  collect  from            your  collision  detection  routine(s)  in  order  for  your  physics-based  collision  response            routines  to  work.</span></span></a></p><p><a id="co10.1" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">To  revise  the  hovercraft  example  of  the  previous  chapter  to  include  simple  collision            response,  you&apos;ll  have  to  modify  the  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">UpdateSimulation</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">           function  and  add  a  couple  more  functions:  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">           and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">56</span><span sentence-index="6136" class="">ApplyImpulse</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6136</span><span sentence-index="6136" class=""> .</span></span></a></p><p><a id="co10.1" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">59</span><span sentence-index="6139" class="">Before  showing  you  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">59</span><span sentence-index="6139" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">59</span><span sentence-index="6139" class="">,  we  want  to            explain  what  your  </span></span></a><a id="I_indexterm4_id327140" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6140</span><span sentence-index="6140" class="">collision  detection  function  must  do. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6141</span><span sentence-index="6141" class="">  First,  it  must  let  you  know  whether  or  not            there  is  a  collision  occurring  between  the  hovercraft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6142</span><span sentence-index="6142" class="">  Secondly,  it  must  let  you  know  if  the            hovercraft  are  penetrating  each  other. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">63</span><span sentence-index="6143" class=""> Thirdly,  if  the  hovercraft  are  colliding,  it  must  tell            you  what  the  collision  normal  vector  is  and  what  the  relative  velocity</span></span></a><a id="I_indexterm4_id327154" class="indexterm"></a><a id="I_indexterm4_id327164" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6145</span><span sentence-index="6145" class="">  is  between  the  colliding  hovercraft.</span></span></a></p><p><a id="I_indexterm4_id327164" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">68</span><span sentence-index="6148" class="nonQuoteStr">To  determine  whether  or  not  there  is  a  collision,  you  need  to  consider  two  factors:</span></span></a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a id="I_indexterm4_id327164" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">70</span><span sentence-index="6150" class="nonQuoteStr">Whether  or  not  the  objects  are  close  enough,  within  numerical  tolerances,  to  be                    considered  in  colliding  contact</span></span></a></p></li><li class="listitem"><p><a id="I_indexterm4_id327164" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">72</span><span sentence-index="6152" class="">What  the  relative  normal  velocity  is  between  the  objects</span></span></a></p></li></ul></div><p><a id="I_indexterm4_id327164" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6154</span><span sentence-index="6154" class="">If  the  objects  aren&apos;t  close  to  each  other,  they  obviously  have  not  collided. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">75</span><span sentence-index="6155" class=""> If  they  are            within  your  tolerance  for  contact,  then  they  may  be  colliding;  and  if  they  are  touching  and            overlapping  such  that  they  are  moving  inside  each  other,  they  are  penetrating,  as  illustrated            in  </span></span></a><a class="xref" href="ch10.html#collision_nomenclature" title="Figure&#xA0;10-1.&#xA0;Collision nomenclature"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">76</span><span sentence-index="6156" class="">Figure&#xA0;10-1</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6157</span><span sentence-index="6157" class=""> . </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6158</span><span sentence-index="6158" class="">  If  your  collision  detection  routine  finds  that            the  two  objects  are  indeed  close  enough  to  be  in  colliding  contact,  then  you  have  to  do            another  check  on  the  relative  normal  velocity  to  see  if  they  are  moving  away  from  each  other            or  toward  each  other. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6159</span><span sentence-index="6159" class="">  A  collision  occurs  when  the  objects  are  in  contact  and  the  contact            points  are  moving  toward  each  other.</span></span></p><div class="figure"><a id="collision_nomenclature"></a><div class="figure-contents"><a id="collision_nomenclature"></a><div class="mediaobject"><a id="collision_nomenclature"></a><a id="I_mediaobject4_id327225"><img src="httpatomoreillycomsourceoreillyimages1598943.png" alt="Collision nomenclature"></a></div></div><div class="figure-title"><a id="I_mediaobject4_id327225"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">85</span><span sentence-index="6165" class="">Figure&#xA0;10-1.&#xA0;Collision  nomenclature</span></span></a></div></div><p><a id="I_mediaobject4_id327225"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">87</span><span sentence-index="6167" class="">Penetration  is  </span></span></a><a id="I_indexterm4_id327246" class="indexterm"></a><a id="I_indexterm4_id327252" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6169</span><span sentence-index="6169" class="">important  because  if  your  objects  overlap  during  the  simulation,  the  results  won&apos;t            look  realistic&#x2014;you&apos;ll  have  one  hovercraft  moving  inside  the  other. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6170</span><span sentence-index="6170" class="">  What  you  have  to  do  is            detect  this  penetration  condition  and  then  back  up  your  simulation,  reduce  the  time  step,  and            try  again. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6171</span><span sentence-index="6171" class="">  You  keep  doing  this  until  they  are  no  longer  penetrating  or  they  are  within            tolerance  to  be  considered  colliding.</span></span></a></p><p><a id="I_indexterm4_id327252" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">94</span><span sentence-index="6174" class="">You  need  to  determine  the  normal  velocity  vector  of  the  collision  in  order  to  calculate            the  </span></span></a><a id="I_indexterm4_id327273" class="indexterm"></a><a id="I_indexterm4_id327285" class="indexterm"></a><a id="I_indexterm4_id327295" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6177</span><span sentence-index="6177" class="">collision  impulse  that  will  be  used  to  simulate  their  response  to  the  collision. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6178</span><span sentence-index="6178" class="">            For  simple  cases,  determining  this  normal  vector  is  fairly  straightforward. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">99</span><span sentence-index="6179" class=""> In  the  case  of            particles  or  spheres,  the  collision  normal  is  simply  along  the  line  that  connects  the  centers            of  gravity  of  each  colliding  object;  this  </span></span></a><a id="I_indexterm4_id327309" class="indexterm"></a><a id="I_indexterm4_id327315" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">101</span><span sentence-index="6181" class="">is  </span></span><span class="emphasis"><em><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">101</span><span sentence-index="6181" class="">central  impact</span></span></em></span><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">101</span><span sentence-index="6181" class="">,  as  discussed  in  </span></span></a><a class="xref" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Collisions"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">102</span><span sentence-index="6182" class="">Chapter&#xA0;5</span></span></a><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">102</span><span sentence-index="6182" class="">,  and  is  the  same  as  that  used  for  the  particle  example  in  </span></span><a class="xref" href="ch08.html" title="Chapter&#xA0;8.&#xA0;Particles"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">104</span><span sentence-index="6184" class="">Chapter&#xA0;8</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6184</span><span sentence-index="6184" class=""> .</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">106</span><span sentence-index="6186" class="nonQuoteStr">Now  take  a  look  at  the  function  we&apos;ve  prepared  for  this  simulation  to  check  for            collisions:</span></span></p><a id="I_programlisting4_id327344"><pre class="programlisting">int     CheckForCollision (pRigidBody2D body1, pRigidBody2D body2)
{
     Vector    d;
     float     r;
     int       retval = 0;
     float     s;
     Vector    v1, v2;
     float     Vrn;

     r = body1-&gt;ColRadius + body2-&gt;ColRadius;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     d.Normalize();
     vCollisionNormal = d;

     v1 = body1-&gt;vVelocity;
     v2 = body2-&gt;vVelocity;
     vRelativeVelocity = v1 - v2;

     Vrn = vRelativeVelocity * vCollisionNormal;
     if((fabs(s) &lt;= ctol) &amp;&amp; (Vrn &lt; 0.0))
     {
          retval = 1; // collision;
          CollisionBody1 = body1;
          CollisionBody2 = body2;
     } else      if(s &lt; -ctol)
     {
          retval = &#x2212;1; // interpenetrating
     } else
          retval = 0; // no collision

     return retval;
}</pre></a><p><a id="I_programlisting4_id327344"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">109</span><span sentence-index="6189" class="">This  function  uses  a  simple  bounding  circle  check  </span></span></a><a id="I_indexterm4_id327359" class="indexterm"></a><a id="I_indexterm4_id327366" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6191</span><span sentence-index="6191" class="">to  determine  whether  or  not  the  hovercraft  are  colliding. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">112</span><span sentence-index="6192" class=""> The  first  thing  it  does            is  calculate  the  distance,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">112</span><span sentence-index="6192" class="">r</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6192</span><span sentence-index="6192" class=""> ,  that  represents  the  absolute            minimum  separation  between  these  hovercraft  when  they  are  in  contact. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">113</span><span sentence-index="6193" class=""> </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">113</span><span sentence-index="6193" class="">ColRadius</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6193</span><span sentence-index="6193" class="">  is  the  radius  of  the  bounding  circle  of  the  hovercraft. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">114</span><span sentence-index="6194" class=""> We  must  compute            it  for  each  hovercraft  upon  initialization  as  follows:</span></span></a></p><a id="I_programlisting4_id327392"><pre class="programlisting">-&gt;ColRadius = SQRT(fLength*fLength + fWidth*fWidth);</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">116</span><span sentence-index="6196" class="">Next,  the  distance  separating  the  hovercraft  at  the  time  this  function  is  called  is            determined  and  stored  in  the  variable  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">116</span><span sentence-index="6196" class="">d</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6196</span><span sentence-index="6196" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">117</span><span sentence-index="6197" class=""> Since  we&apos;re            assuming  that  these  hovercraft  are  particles,  determining  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">117</span><span sentence-index="6197" class="">d</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6197</span><span sentence-index="6197" class="">            is  simply  a  matter  of  calculating  the  distance  between  the  coordinates  of  each  craft&apos;s  center            of  gravity. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6198</span><span sentence-index="6198" class="">  In  terms  of  vectors,  this  is  simply  the  position  vector  of  one  craft  minus  the            position  vector  of  the  other.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class="">Once  the  function  has  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class="">d</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class=""> and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class="">r</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class="">,  it  needs  to  determine  the  actual  amount  of  space,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">120</span><span sentence-index="6200" class="">s</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6200</span><span sentence-index="6200" class=""> ,  separating  the  hovercraft&apos;s  bounding  circles. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">121</span><span sentence-index="6201" class=""> After  this  separation  is            determined,  the  function  normalizes  the  vector  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">121</span><span sentence-index="6201" class="">d</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6201</span><span sentence-index="6201" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">122</span><span sentence-index="6202" class=""> Since  the            vector  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">122</span><span sentence-index="6202" class="">d</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6202</span><span sentence-index="6202" class="">  is  along  the  line  that  separates  the  hovercraft&apos;s            centers  of  gravity,  normalizing  it  yields  the  collision  normal  vector  that  we  need  for  our            collision  response  calculations. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">123</span><span sentence-index="6203" class=""> The  collision  normal  vector  is  saved  in  the  global  variable                </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">123</span><span sentence-index="6203" class="">vCollisionNormal</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6203</span><span sentence-index="6203" class=""> .</span></span></p></a><p><a id="I_programlisting4_id327392"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">126</span><span sentence-index="6206" class="">After  calculating  the  collision  normal,  this  function  goes  on  to  determine  the  </span></span></a><a id="I_indexterm4_id327462" class="indexterm"></a><a id="I_indexterm4_id327474" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6208</span><span sentence-index="6208" class="">relative  velocity  between  the  hovercraft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6209</span><span sentence-index="6209" class="">  In  vector  form,  this  is  simply  the            difference  between  the  velocity  vectors  of  each  craft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6210</span><span sentence-index="6210" class="">  Note  that  the  velocity  vectors  used            here  must  be  in  global  coordinates,  not  body-fixed  (local)  coordinates. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">131</span><span sentence-index="6211" class=""> Since  what&apos;s  really            needed  to  determine  if  a  collision  is  made  is  the</span></span></a><a id="I_indexterm4_id327488" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">132</span><span sentence-index="6212" class=""> relative  </span></span><span class="emphasis"><em><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">132</span><span sentence-index="6212" class="">normal</span></span></em></span><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">132</span><span sentence-index="6212" class=""> velocity,  the  function  proceeds  to  take  the            vector  dot  product  of  the  relative  velocity  and  the  collision  normal  vectors,  saving  the            result  in  the  variable  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">132</span><span sentence-index="6212" class="">Vrn</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6213</span><span sentence-index="6213" class=""> .</span></span></a></p><p><a id="I_indexterm4_id327488" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6216</span><span sentence-index="6216" class="">At  this  point,  all  of  the  calculations  are  complete,  and  the  only  thing  left  to  do  is  make            the  appropriate  checks  to  determine  if  there  is  a  collision,  penetration,  or  no  collision  at            all.</span></span></a></p><p><a id="I_indexterm4_id327488" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6219</span><span sentence-index="6219" class="">The  first  check  is  to  see  if  the  hovercraft  are  colliding. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">140</span><span sentence-index="6220" class=""> We  determine  this  by  comparing            the  absolute  value  of  the  separation  between  the  hovercraft,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">140</span><span sentence-index="6220" class="">s</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">140</span><span sentence-index="6220" class="">,  with  a  </span></span></a><a id="I_indexterm4_id327524" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">141</span><span sentence-index="6221" class="">distance  tolerance,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">141</span><span sentence-index="6221" class="">ctol</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6222</span><span sentence-index="6222" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">143</span><span sentence-index="6223" class=""> If  the  absolute  value            of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">143</span><span sentence-index="6223" class="">s</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">143</span><span sentence-index="6223" class=""> is  less  than  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">143</span><span sentence-index="6223" class="">ctol</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6223</span><span sentence-index="6223" class=""> ,            a  collision  might  be  occurring. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6224</span><span sentence-index="6224" class="">  The  second  requirement  is  that  the  relative  normal  velocity  be            negative,  which  implies  that  the  points  of  impact  on  the  hovercraft  are  moving  toward  each            other. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">145</span><span sentence-index="6225" class=""> If  there  is  a  collision,  the  function  returns  a  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">145</span><span sentence-index="6225" class="">1</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6225</span><span sentence-index="6225" class="">  to            indicate  that  collision  response  is  necessary.</span></span></a></p><p><a id="I_indexterm4_id327524" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6228</span><span sentence-index="6228" class="">If  the  hovercraft  are  found  not  to  be  colliding,  then  we  perform  a  second  check  to  see  if            they&apos;ve  moved  so  close  together  that  they  are  penetrating  each  other. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class=""> In  this  case,  if                </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class="">s</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class=""> is  less  than  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class="">&#x2013;ctol</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class="">,            the  hovercraft  are  penetrating  and  the  function  returns  a  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">149</span><span sentence-index="6229" class="">&#x2212;1</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6229</span><span sentence-index="6229" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">150</span><span sentence-index="6230" class=""> If  the  hovercraft  are  not  colliding  and  not  penetrating,  then  the  function            simply  returns  a  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">150</span><span sentence-index="6230" class="">0</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6230</span><span sentence-index="6230" class=""> ,  indicating  that  no  further  action  is            required.</span></span></a></p><p><a id="I_indexterm4_id327524" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">153</span><span sentence-index="6233" class="">Before  moving  on,  let&apos;s  say  a  word  or  two  about  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">153</span><span sentence-index="6233" class="">ctol</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6233</span><span sentence-index="6233" class=""> &#x2014;the  collision  tolerance  distance. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6234</span><span sentence-index="6234" class="">  This  value  is  subject  to  tuning. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6235</span><span sentence-index="6235" class="">  There&apos;s  no            single  value  that  works  well  in  all  cases. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6236</span><span sentence-index="6236" class="">  You  must  consider  the  overall  sizes  of  the  objects            potentially  colliding,  the  step  size  you&apos;re  using,  and  how  far  the  colliding  objects  are  from            the  viewer  while  being  rendered  (i.e.,  their  scale). </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6237</span><span sentence-index="6237" class="">  Basically,  you  should  choose  a  value  that            makes  collisions  look  correct,  so  that  on  the  one  hand  objects  do  not  appear  to  be  penetrating            each  other,  and  on  the  other  hand  you  do  not  report  a  collision  when  objects  do  not  appear  to            be  touching  at  all.</span></span></a></p><p><a id="I_indexterm4_id327524" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">160</span><span sentence-index="6240" class="">Take  a  look  now  at  the  other  new  function,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">160</span><span sentence-index="6240" class="">ApplyImpulse</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">160</span><span sentence-index="6240" class="">:</span></span></a></p><a id="I_programlisting4_id327616"><pre class="programlisting">void     ApplyImpulse(pRigidBody2D body1, pRigidBody2D body2)
{
     float j;


     j =  (-(1+fCr) * (vRelativeVelocity*vCollisionNormal)) /
          ( (vCollisionNormal*vCollisionNormal) *
            (1/body1-&gt;fMass + 1/body2-&gt;fMass) );

     body1-&gt;vVelocity += (j * vCollisionNormal) / body1-&gt;fMass;
     body2-&gt;vVelocity -= (j * vCollisionNormal) / body2-&gt;fMass;
}</pre></a><p><a id="I_programlisting4_id327616"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6243</span><span sentence-index="6243" class="">This  is  a  simple  but  crucial  function  for  collision  response. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">164</span><span sentence-index="6244" class=""> What  it  does  is  calculate            the  linear  collision  impulse  as  a  function  of  the  colliding  hovercraft&apos;s  relative  normal            velocity,  masses,  and  coefficient  of  restitution,  using  the  formula  that  we  showed  you  in                </span></span></a><a class="xref" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Collisions"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">165</span><span sentence-index="6245" class="">Chapter&#xA0;5</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6246</span><span sentence-index="6246" class=""> . </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6247</span><span sentence-index="6247" class="">  Further,  it  applies  this  impulse  to  each  hovercraft,            effectively  changing  their  velocities  in  response  to  the  collision. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6248</span><span sentence-index="6248" class="">  Note  that  the  impulse  is            applied  to  one  hovercraft  and  then  the  negative  impulse  applied  to  the  other.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">170</span><span sentence-index="6250" class="">With  those  two  new  functions  complete,  it&apos;s  now  time  to  revise  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">170</span><span sentence-index="6250" class="">UpdateSimulation</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6250</span><span sentence-index="6250" class="">  to  handle  collision  detection  and  response  as  the  simulation            steps  through  time. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">171</span><span sentence-index="6251" class=""> Here&apos;s  what  the  new  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">171</span><span sentence-index="6251" class="">UpdateSimulation</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">171</span><span sentence-index="6251" class="">           function  looks  like:</span></span></p><a id="I_programlisting4_id327654"><pre class="programlisting">void     UpdateSimulation(float dt)
{
     float     dtime = dt;
     bool      tryAgain = true;
     int       check=0;
     RigidBody2D     craft1Copy, craft2Copy;
     bool      didPen = false;
     int       count = 0;


    Craft.SetThrusters(false, false);

    if (IsKeyDown(VK_UP))
        Craft.ModulateThrust(true);

    if (IsKeyDown(VK_DOWN))
        Craft.ModulateThrust(false);

    if (IsKeyDown(VK_RIGHT))
        Craft.SetThrusters(true, false);

    if (IsKeyDown(VK_LEFT))
        Craft.SetThrusters(false, true);


     while(tryAgain &amp;&amp; dtime &gt; tol)
     {
          tryAgain = false;
          memcpy(&amp;craft1Copy, &amp;Craft, sizeof(RigidBody2D));
          memcpy(&amp;craft2Copy, &amp;Craft2, sizeof(RigidBody2D));

          Craft.UpdateBodyEuler(dtime);
          Craft2.UpdateBodyEuler(dtime);

          CollisionBody1 = 0;
          CollisionBody2 = 0;
          check = CheckForCollision(&amp;craft1Copy, &amp;craft2Copy);

          if(check == PENETRATING)
          {
               dtime = dtime/2;
               tryAgain = true;
               didPen = true;
          } else if(check == COLLISION)
          {
               if(CollisionBody1 != 0 &amp;&amp; CollisionBody2 != 0)
                    ApplyImpulse(CollisionBody1,  CollisionBody2);
          }
     }

     if(!didPen)
     {
          memcpy(&amp;Craft, &amp;craft1Copy, sizeof(RigidBody2D));
          memcpy(&amp;Craft2, &amp;craft2Copy, sizeof(RigidBody2D));
     }
}</pre></a><p><a id="I_programlisting4_id327654"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6254</span><span sentence-index="6254" class="">Obviously,  this  version  is  more  complicated  than  the  original  version. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">175</span><span sentence-index="6255" class=""> There&apos;s  one  main            reason  for  this:</span></span></a><a id="I_indexterm4_id327675" class="indexterm"></a><a id="I_indexterm4_id327681" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6257</span><span sentence-index="6257" class="">  penetration  could  occur  because  the  hovercraft  can  move  far  enough  within  a            single  time  step  to  become  overlapped. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6258</span><span sentence-index="6258" class="">  Visually,  this  situation  is  unappealing  and            unrealistic,  so  you  should  to  try  to  prevent  it.</span></span></a></p><p><a id="I_indexterm4_id327681" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">181</span><span sentence-index="6261" class="">The  first  thing  this  function  does  is  enter  a  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">181</span><span sentence-index="6261" class="">while</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">181</span><span sentence-index="6261" class="">           loop:</span></span></a></p><a id="I_programlisting4_id327705"><pre class="programlisting">     while(tryAgain &amp;&amp; dtime &gt; tol)
     {
         .
         .
         .
     }</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6263</span><span sentence-index="6263" class="">This  loop  is  used  to  back  up  the  simulation  if  penetration  has  occurred  on  the  initial            time  step. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6264</span><span sentence-index="6264" class="">  What  happens  is  this:  the  function  first  tries  to  update  the  hovercraft  and  then            checks  to  see  if  there  is  a  collision. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6265</span><span sentence-index="6265" class="">  If  there  is  a  collision,  then  it  gets  handled  by            applying  the  impulse. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6266</span><span sentence-index="6266" class="">  If  there  is  penetration,  however,  then  you  know  the  time  step  was  too            big  and  you  have  to  try  again. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">187</span><span sentence-index="6267" class=""> When  this  occurs,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">187</span><span sentence-index="6267" class="">tryAgain</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">187</span><span sentence-index="6267" class="">           is  set  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">187</span><span sentence-index="6267" class="">true</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6267</span><span sentence-index="6267" class=""> ,  the  time  step  is  cut  in  half,  and  another            attempt  is  made. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6268</span><span sentence-index="6268" class="">  The  function  stays  in  this  loop  as  long  as  there  is  penetration  or  until  the            time  step  has  been  reduced  to  a  size  small  enough  to  force  an  exit  to  the  loop. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">189</span><span sentence-index="6269" class=""> The  purpose  of            this  looping  is  to  find  the  largest  step  size,  less  than  or  equal  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">189</span><span sentence-index="6269" class="">dt</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6269</span><span sentence-index="6269" class=""> ,  that  can  be  taken  and  still  avoid  penetration. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6270</span><span sentence-index="6270" class="">  You  either  want  a  collision  or            no  collision.</span></span></p><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6272</span><span sentence-index="6272" class="">You  might  ask  yourself  when  does  small  become  too  small  in  terms  of  time  step? </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6273</span><span sentence-index="6273" class="">  Too  small            is  obviously  when  the  time  step  approaches  0  and  your  entire  simulation  grinds  to  a  halt. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6274</span><span sentence-index="6274" class="">            Therefore,  you  may  want  to  put  in  some  criteria  to  exit  this  loop  before  things  slow  down  too            much. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">195</span><span sentence-index="6275" class=""> This  is  all  subject  to  tuning,  by  the  way,  and  it  also  depends  on  the  value  you  set  for                </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">195</span><span sentence-index="6275" class="">ctol</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6275</span><span sentence-index="6275" class=""> . </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6276</span><span sentence-index="6276" class="">  We  can&apos;t  stress  enough  the  importance  of  tuning            these  parameters. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6277</span><span sentence-index="6277" class="">  Basically,  you  must  strive  for  visual  realism  while  keeping  your  frame  rates            up  to  required  levels.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">199</span><span sentence-index="6279" class="">Looking  inside  this  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">199</span><span sentence-index="6279" class="">while</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6279</span><span sentence-index="6279" class="">  loop  reveals  what&apos;s  going  on. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class="">           First,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class="">tryAgain</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class=""> is  set  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class="">false</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class="">,  optimistically  assuming  that  there  will  be  no  penetration,  and  we  make            copies  of  the  hovercraft&apos;s  states,  reflecting  the  last  successful  call  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">200</span><span sentence-index="6280" class="">UpdateSimulation</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6280</span><span sentence-index="6280" class=""> .</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">202</span><span sentence-index="6282" class="">Next,  we  make  the  usual  call  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">202</span><span sentence-index="6282" class="">UpdateBody</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6282</span><span sentence-index="6282" class="">  for  each            copy  of  the  hovercraft. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class=""> Then  a  call  to  the  collision  detection  function,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class="">,  is  made  to  see  if  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class="">Craft</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class=""> is  colliding  with  or  penetrating  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">203</span><span sentence-index="6283" class="">Craft2</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6283</span><span sentence-index="6283" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">           If  there  is  penetration,  then  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">tryAgain</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span> is  set  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span>true</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">dtime</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class=""> is  cut  in  half,                </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">didPen</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class=""> is  set  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">true</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">,            and  the  function  takes  another  lap  through  the  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">204</span><span sentence-index="6284" class="">while</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6284</span><span sentence-index="6284" class="">  loop. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">205</span><span sentence-index="6285" class="">               </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">205</span><span sentence-index="6285" class="">didPen</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6285</span><span sentence-index="6285" class="">  is  a  flag  that  lets  us  know  that  a  penetration            condition  did  occur.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">207</span><span sentence-index="6287" class="nonQuoteStr">If  there  was  a  collision,  the  function  handles  it  by  applying  the  appropriate            impulse:</span></span></p></a><a id="I_programlisting4_id327858"><pre class="programlisting">     if(CollisionBody1 != 0 &amp;&amp; CollisionBody2 != 0)
          ApplyImpulse(CollisionBody1,  CollisionBody2);</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">209</span><span sentence-index="6289" class="">After  getting  through  the  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">209</span><span sentence-index="6289" class="">while</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">209</span><span sentence-index="6289" class=""> loop,  the  updated            hovercraft  states  are  saved  and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">209</span><span sentence-index="6289" class="">UpdateSimulation</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6289</span><span sentence-index="6289" class="">  is            complete.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">211</span><span sentence-index="6291" class="">The  last  bit  of  code  you  need  to  add  includes  a  few  new  global  variables  and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">211</span><span sentence-index="6291" class="">define</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">211</span><span sentence-index="6291" class="">s:</span></span></p></a><a id="I_programlisting4_id327892"><pre class="programlisting">#define     LINEARDRAGCOEFFICIENT        0.25f
#define     COEFFICIENTOFRESTITUTION     0.5f
#define     COLLISIONTOLERANCE           2.0f

Vector      vCollisionNormal;
Vector      vRelativeVelocity;
float       fCr = COEFFICIENTOFRESTITUTION;
float const ctol = COLLISIONTOLERANCE;</pre></a><p><a id="I_programlisting4_id327892"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">214</span><span sentence-index="6294" class="">The  only  one  we  haven&apos;t  mentioned  so  far,  although  you&apos;ve  seen  it  in  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">214</span><span sentence-index="6294" class="">ApplyImpulse</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">214</span><span sentence-index="6294" class="">,  is  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">214</span><span sentence-index="6294" class="">fCr</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6294</span><span sentence-index="6294" class=""> ,  the            coefficient  of  restitution. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">215</span><span sentence-index="6295" class=""> Here  we  have  it  set  to  0.5,  which  means  that  the  collisions  are            halfway  between  perfectly  elastic  and  perfectly  inelastic  (refer  back  to  our  earlier            discussions  on  coefficients  of  restitution  in  </span></span></a><a class="xref" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Collisions"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">216</span><span sentence-index="6296" class="">Chapter&#xA0;5</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6297</span><span sentence-index="6297" class="">  if  you&apos;ve  forgotten            these  terms). </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6298</span><span sentence-index="6298" class="">  This  is  one  of  those  parameters  that  you&apos;ll  have  to  tune  to  get  the  desired            behavior.</span></span></p><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6300</span><span sentence-index="6300" class="">While  we&apos;re  on  the  subject  of  tuning,  we  should  mention  that  you&apos;ll  also  have  to  play  with            the  linear  drag  coefficient  used  to  calculate  the  drag  force  on  the  hovercraft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6301</span><span sentence-index="6301" class="">  While  this            coefficient  is  used  to  simulate  fluid  dynamic  drag,  it  also  plays  an  important  role  in  terms            of  numerical  stability. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6302</span><span sentence-index="6302" class="">  You  need  some  damping  in  your  simulation  so  that  your  integrator  does            not  blow  up&#x2014;that  is,  damping  helps  keep  your  simulation  stable.</span></span></p><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6304</span><span sentence-index="6304" class="">That&apos;s  pretty  much  it  as  far  as  implementing  basic  collision  response. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6305</span><span sentence-index="6305" class="">  If  you  run  this            example,  you&apos;ll  be  able  to  drive  the  hovercraft  into  each  other  and  bounce  off  accordingly. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6306</span><span sentence-index="6306" class="">            You  can  play  around  with  the  mass  of  each  hovercraft  and  the  coefficient  of  restitution  to  see            how  the  craft  behave  when  one  is  more  massive  than  the  other,  or  when  the  collision  is            somewhere  between  perfectly  elastic  and  perfectly  inelastic.</span></span></p><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6308</span><span sentence-index="6308" class="">You  may  notice  that  the  collision  response  in  this  example  sometimes  looks  a  little            strange. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6309</span><span sentence-index="6309" class="">  Keep  in  mind  that&apos;s  because  this  collision  response  algorithm,  so  far,  assumes  that            the  hovercraft  are  round  when  in  fact  they  are  rectangular. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6310</span><span sentence-index="6310" class="">  This  approach  will  work  just  fine            for  round  objects  like  billiard  balls,  but  to  get  the  level  of  realism  required  for  non-round            rigid  bodies  you  need  to  include  angular  effects. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">231</span><span sentence-index="6311" class=""> We&apos;ll  show  you  how  to  do  that  in  the                </span></span><a id="I_indexterm4_id327946" class="indexterm"></a><a id="I_indexterm4_id327955" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6313</span><span sentence-index="6313" class="">next  section.</span></span></a></p></div><div class="sect1" title="Angular Effects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="angular_effects"><a id="I_indexterm4_id327955" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">236</span><span sentence-index="6316" class="">Angular  Effects</span></span></a></h2></div></div></div><p><a id="I_indexterm4_id327955" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">238</span><span sentence-index="6318" class="">Including  angular  </span></span></a><a id="an10.2" class="indexterm"></a><a id="co10.2" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6320</span><span sentence-index="6320" class="">effects  will  yield  more  realistic  collision  responses  for  these  rigid  bodies,  the            hovercraft. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">241</span><span sentence-index="6321" class=""> To  get  this  to  work,  you&apos;ll  have  to  make  several  changes  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">241</span><span sentence-index="6321" class="">ApplyImpulse</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">241</span><span sentence-index="6321" class=""> and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">241</span><span sentence-index="6321" class="">CheckForCollision;</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6321</span><span sentence-index="6321" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">242</span><span sentence-index="6322" class=""> </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">242</span><span sentence-index="6322" class="">UpdateSimulation</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6322</span><span sentence-index="6322" class="">  will            remain  unchanged. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">243</span><span sentence-index="6323" class=""> The  more  extensive  changes  are  in  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">243</span><span sentence-index="6323" class="">CheckForCollision</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6323</span><span sentence-index="6323" class=""> ,  so  we&apos;ll  discuss  it  first.</span></span></a></p><p><a id="co10.2" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">246</span><span sentence-index="6326" class="">The  new  version  of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">246</span><span sentence-index="6326" class="">CheckForCollision</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6326</span><span sentence-index="6326" class="">  will  do  more  than            a  simple  bounding  circle  check. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">247</span><span sentence-index="6327" class=""> Here,  each  hovercraft  will  be  represented  by  a  polygon  with            four  edges  and  four  vertices,  and  the  types  of  contact  that  will  be  checked  for  are            vertex-vertex  and  vertex-edge  contact  (see  </span></span></a><a class="xref" href="ch10.html#types_of_collision" title="Figure&#xA0;10-2.&#xA0;Types of collision"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">248</span><span sentence-index="6328" class="">Figure&#xA0;10-2</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6329</span><span sentence-index="6329" class=""> ).</span></span><sup><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">250</span><span sentence-index="6330" class="">[</span></span><a id="CHP-10-FN-1" href="#ftn.CHP-10-FN-1" epub:type="noteref" class="footnote"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">251</span><span sentence-index="6331" class="">19</span></span></a><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">251</span><span sentence-index="6331" class="">]</span></span></sup></p><div class="figure"><a id="types_of_collision"></a><div class="figure-contents"><a id="types_of_collision"></a><div class="mediaobject"><a id="types_of_collision"></a><a id="I_mediaobject4_id328069"><img src="httpatomoreillycomsourceoreillyimages1598944.png" alt="Types of collision"></a></div></div><div class="figure-title"><a id="I_mediaobject4_id328069"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">257</span><span sentence-index="6337" class="nonQuoteStr">Figure&#xA0;10-2.&#xA0;Types  of  collision</span></span></a></div></div><p><a id="I_mediaobject4_id328069"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">259</span><span sentence-index="6339" class="">In  addition  to  the  tasks  discussed  in  the  last  section,  this  new  version  of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">259</span><span sentence-index="6339" class="">CheckForCollision</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6339</span><span sentence-index="6339" class="">  must  also  determine  the  exact  point  of  contact            between  the  hovercraft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6340</span><span sentence-index="6340" class="">  This  is  a  very  important  distinction  between  this  new  version  and  the            last. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6341</span><span sentence-index="6341" class="">  You  need  to  know  the  point  of  contact  because  in  order  to  affect  the  angular  velocity,            you  must  apply  the  impulse  at  the  point  of  contact. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6342</span><span sentence-index="6342" class="">  In  the  last  section,  the  normal  to  the            contact  point  always  passed  through  the  center  of  gravity  of  the  hovercraft  because  we  assumed            they  were  spheres;  that&apos;s  not  the  case  here.</span></span></a></p><p><a id="I_mediaobject4_id328069"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6345</span><span sentence-index="6345" class="">This  now  brings  up  the  challenge  of  finding  the  collision  normal. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6346</span><span sentence-index="6346" class="">  There  are  two  cases  to            consider  here. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6347</span><span sentence-index="6347" class="">  In  edge-vertex  collisions,  the  normal  is  always  perpendicular  to  the  edge            that&apos;s  involved  in  the  collision. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6348</span><span sentence-index="6348" class="">  In  vertex-vertex  collisions,  however,  the  normal  is            ambiguous,  so  we&apos;ve  resorted  to  taking  the  normal  parallel  to  the  line  connecting  the            hovercraft&apos;s  centers  of  gravity.</span></span></a></p><p><a id="I_mediaobject4_id328069"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">271</span><span sentence-index="6351" class="">All  of  these  considerations  make  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">271</span><span sentence-index="6351" class="">CheckForCollisions</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6351</span><span sentence-index="6351" class="">  a            little  more  involved  than  in  the  previous  section. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">272</span><span sentence-index="6352" class=""> The  following  code  listing  shows  what  we            mean:</span></span></a></p><a id="I_programlisting4_id328122"><pre class="programlisting">int     CheckForCollision(pRigidBody2D body1, pRigidBody2D body2)
{
     Vector    d;
     float     r;
     int       retval = 0;
     float     s;
     Vector    vList1[4], vList2[4];
     float     wd, lg;
     int       i,j;
     bool      haveNodeNode = false;
     bool      interpenetrating = false;
     bool      haveNodeEdge = false;
     Vector    v1, v2, u;
     Vector    edge, p, proj;
     float     dist, dot;
     float     Vrn;

     // First check to see if the bounding circles are colliding
     r = body1-&gt;fLength/2 + body2-&gt;fLength/2;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     if(s &lt;= ctol)
     {   // We have a possible collision, check further
          // build vertex lists for each hovercraft
          wd = body1-&gt;fWidth;
          lg = body1-&gt;fLength;
          vList1[0].y = wd/2;          vList1[0].x = lg/2;
          vList1[1].y = -wd/2;         vList1[1].x = lg/2;
          vList1[2].y = -wd/2;         vList1[2].x = -lg/2;
          vList1[3].y = wd/2;          vList1[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body1-&gt;fOrientation, vList1[i]);
               vList1[i] = vList1[i] + body1-&gt;vPosition;
          }

          wd = body2-&gt;fWidth;
          lg = body2-&gt;fLength;
          vList2[0].y = wd/2;          vList2[0].x = lg/2;
          vList2[1].y = -wd/2;         vList2[1].x = lg/2;
          vList2[2].y = -wd/2;         vList2[2].x = -lg/2;
          vList2[3].y = wd/2;          vList2[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body2-&gt;fOrientation, vList2[i]);
               vList2[i] = vList2[i] + body2-&gt;vPosition;
          }

          // Check for vertex-vertex collision
          for(i=0; i&lt;4 &amp;&amp; !haveNodeNode; i++)
          {
               for(j=0; j&lt;4 &amp;&amp; !haveNodeNode; j++)
               {

                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body2-&gt;vPosition;

                    vCollisionNormal = body1-&gt;vPosition &#x2212;
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();

                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;

                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                        (Vrn &lt; 0.0) )
                         haveNodeNode = true;

               }
          }

          // Check for vertex-edge collision
          if(!haveNodeNode)
          {
               for(i=0; i&lt;4 &amp;&amp; !haveNodeEdge; i++)
               {
                    for(j=0; j&lt;3 &amp;&amp; !haveNodeEdge; j++)
                    {
                         if(j==2)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();

                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();

                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body2-&gt;vPosition;

                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();

                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;

                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;
                    }
               }
          }

          // Check for penetration
          if(!haveNodeNode &amp;&amp; !haveNodeEdge)
          {
               for(i=0; i&lt;4 &amp;&amp; !interpenetrating; i++)
               {
                    for(j=0; j&lt;4 &amp;&amp; !interpenetrating; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];

                         p = vList1[i] - vList2[j];
                         dot = p * edge;
                         if(dot &lt; 0)
                         {
                              interpenetrating = true;
                         }
                    }
               }
       }

       if(interpenetrating)
       {
               retval = &#x2212;1;
       } else if(haveNodeNode || haveNodeEdge)
       {
               retval = 1;
       } else
               retval = 0;

     } else
     {
          retval = 0;
     }

     return retval;
}</pre></a><p><a id="I_programlisting4_id328122"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">275</span><span sentence-index="6355" class="">The  first  thing  that  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">275</span><span sentence-index="6355" class="">CheckForCollision</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6355</span><span sentence-index="6355" class="">  does  is  perform            a  quick  bounding-circle  check  to  see  if  there  is  a  possible  collision. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">276</span><span sentence-index="6356" class=""> If  no  collision  is            detected,  the  function  simply  exits,  returning  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">276</span><span sentence-index="6356" class="">0</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6356</span><span sentence-index="6356" class=""> . </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">277</span><span sentence-index="6357" class=""> This  is            the  same  bounding-circle  check</span></span></a><a id="I_indexterm4_id328196" class="indexterm"></a><a id="I_indexterm4_id328202" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">279</span><span sentence-index="6359" class=""> performed  in  the  earlier  version:</span></span></a></p><a id="I_programlisting4_id328214"><pre class="programlisting">     r = body1-&gt;fLength/2 + body2-&gt;fLength/2;
     d = body1-&gt;vPosition - body2-&gt;vPosition;
     s = d.Magnitude() - r;

     if(s &lt;= ctol)
     {
          .
          .
          .
     } else
          retval = 0;
     }</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">281</span><span sentence-index="6361" class="nonQuoteStr">If  the  bounding-circle  check  indicates  the  possibility  of  a  collision,  then  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">281</span><span sentence-index="6361" class="nonQuoteStr">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">281</span><span sentence-index="6361" class="nonQuoteStr"> proceeds  by  setting  up  a  couple  of  polygons,            represented  by  vertex  lists,  for  each  hovercraft:</span></span></p></a><a id="I_programlisting4_id328232"><pre class="programlisting">          wd = body1-&gt;fWidth;
          lg = body1-&gt;fLength;
          vList1[0].y = wd/2;          vList1[0].x = lg/2;
          vList1[1].y = -wd/2;         vList1[1].x = lg/2;
          vList1[2].y = -wd/2;         vList1[2].x = -lg/2;
          vList1[3].y = wd/2;          vList1[3].x = -lg/2;

          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body1-&gt;fOrientation, vList1[i]);
               vList1[i] = vList1[i] + body1-&gt;vPosition;
          }

          wd = body2-&gt;fWidth;
          lg = body2-&gt;fLength;
          vList2[0].y = wd/2;          vList2[0].x = lg/2;
          vList2[1].y = -wd/2;         vList2[1].x = lg/2;
          vList2[2].y = -wd/2;         vList2[2].x = -lg/2;
          vList2[3].y = wd/2;          vList2[3].x = -lg/2;
          for(i=0; i&lt;4; i++)
          {
               VRotate2D(body2-&gt;fOrientation, vList2[i]);
               vList2[i] = vList2[i] + body2-&gt;vPosition;
          }</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6363</span><span sentence-index="6363" class="">The  vertex  lists  are  initialized  in  unrotated  body-fixed  (local)  coordinates  based  on  the            length  and  width  of  the  hovercraft. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6364</span><span sentence-index="6364" class="">  The  vertices  are  then  rotated  to  reflect  the  orientation            of  each  hovercraft. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">285</span><span sentence-index="6365" class=""> After  that,  the  position  of  each  hovercraft  is  added  to  each  vertex  to            convert  from  local  coordinates  to  global  coordinates</span></span></p></a><p><a id="I_programlisting4_id328232"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">287</span><span sentence-index="6367" class="">Checking  first  for  vertex-vertex  collisions,  the  </span></span></a><a id="vv10.2" class="indexterm"></a><a id="covv10.2" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6369</span><span sentence-index="6369" class="">function  iterates  through  each  vertex  in  one  list,  comparing  it  with  each  vertex            in  the  other  list  to  see  if  the  points  are  coincident.</span></span></a></p><a id="I_programlisting4_id328285"><pre class="programlisting">          // Check for vertex-vertex collision
          for(i=0; i&lt;4 &amp;&amp; !haveNodeNode; i++)
          {
               for(j=0; j&lt;4 &amp;&amp; !haveNodeNode; j++)
               {

                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body2-&gt;vPosition;

                    vCollisionNormal = body1-&gt;vPosition &#x2212;
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();

                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;

                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                                       (Vrn &lt; 0.0) )
                         haveNodeNode = true;

               }
          }</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">292</span><span sentence-index="6372" class="">This  comparison  makes  a  call  to  another  new  function,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">292</span><span sentence-index="6372" class="">ArePointsEqual</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">292</span><span sentence-index="6372" class="">:</span></span></p></a><a id="I_programlisting4_id328311"><pre class="programlisting">                    if( ArePointsEqual(vList1[i],
                                       vList2[j]) &amp;&amp;
                                       (Vrn &lt; 0.0) )
                         haveNodeNode = true;</pre><p><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">294</span><span sentence-index="6374" class="">ArePointsEqual</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">294</span><span sentence-index="6374" class=""> simply  checks  to  see  if  the  points  are            within  a  specified  distance  from  each  other,  as  shown  here:</span></span></p></a><a id="I_programlisting4_id328329"><pre class="programlisting">bool     ArePointsEqual(Vector p1, Vector p2)
{
     // Points are equal if each component is within ctol of each other
     if(  (fabs(p1.x - p2.x) &lt;= ctol) &amp;&amp;
          (fabs(p1.y - p2.y) &lt;= ctol) &amp;&amp;
          (fabs(p1.z - p2.z) &lt;= ctol) )
          return true;
     else
          return false;
}</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">296</span><span sentence-index="6376" class="">Within  the  nested  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">296</span><span sentence-index="6376" class="">for</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6376</span><span sentence-index="6376" class="">  loops  of  the  vertex-vertex  check,            we  perform  a  number  of  important  calculations  to  determine  the  collision  normal  vector  and            relative  velocity  that  are  required  for  collision  response.</span></span></p><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6378</span><span sentence-index="6378" class="">First,  we  calculate  the  collision  point,  which  is  simply  the  coordinates  of  a  vertex  that            is  involved  in  the  collision. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6379</span><span sentence-index="6379" class="">  Note  that  this  point  will  be  in  global  coordinates,  so  it  will            have  to  be  converted  to  local  coordinates  for  each  hovercraft  in  order  to  be  useful  for            collision  response. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">300</span><span sentence-index="6380" class=""> Here&apos;s  how  that&apos;s  done:</span></span></p></a><a id="I_programlisting4_id328355"><pre class="programlisting">                    vCollisionPoint = vList1[i];
                    body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body1-&gt;vPosition;

                    body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                             body2-&gt;vPosition;</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6382</span><span sentence-index="6382" class="">The  second  calculation  is  aimed  at  determining  the  collision  normal  vector,  which  for            vertex-vertex  collisions  we&apos;ve  assumed  is  along  the  line  connecting  the  centers  of  gravity  of            each  hovercraft. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">303</span><span sentence-index="6383" class=""> The  calculation  is  the  same  as  that  shown  in  the  earlier  version  of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">303</span><span sentence-index="6383" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">303</span><span sentence-index="6383" class="">:</span></span></p></a><a id="I_programlisting4_id328375"><pre class="programlisting">                    vCollisionNormal = body1-&gt;vPosition &#x2212;
                                       body2-&gt;vPosition;

                    vCollisionNormal.Normalize();</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6385</span><span sentence-index="6385" class="">The  third  and  final  calculation  is  aimed  at  determining  the  relative  velocity  between  the            points  of  impact. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">306</span><span sentence-index="6386" class=""> This  is  an  important  distinction  from  the  earlier  version,  since  the            velocities  of  the  points  of  impact  on  each  body  are  functions  of  the  linear  and  angular            velocities  of  the  hovercraft:</span></span></p></a><a id="I_programlisting4_id328389"><pre class="programlisting">                    v1 = body1-&gt;vVelocityBody +
                        (body1-&gt;vAngularVelocity^body1-&gt;vCollisionPoint);

                    v2 = body2-&gt;vVelocityBody +
                        (body2-&gt;vAngularVelocity^body2-&gt;vCollisionPoint);

                    v1 = VRotate2D(body1-&gt;fOrientation, v1);
                    v2 = VRotate2D(body2-&gt;fOrientation, v2);

                    vRelativeVelocity = v1 - v2;
                    Vrn = vRelativeVelocity * vCollisionNormal;</pre></a><p><a id="I_programlisting4_id328389"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">309</span><span sentence-index="6389" class="">Here,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">309</span><span sentence-index="6389" class="">v1</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">309</span><span sentence-index="6389" class=""> and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">309</span><span sentence-index="6389" class="">v2</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6389</span><span sentence-index="6389" class="">            represent  the  velocities  of  the  points  of  collision  relative  to  each  hovercraft  in  local            coordinates,  which  are  then  converted  to  global  coordinates. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">310</span><span sentence-index="6390" class=""> Once  we&apos;ve  obtained  the  relative            velocity,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">310</span><span sentence-index="6390" class="">vRelativeVelocity</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">310</span><span sentence-index="6390" class="">,  we  obtain  the  relative  normal            velocity,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">310</span><span sentence-index="6390" class="">Vrn</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">310</span><span sentence-index="6390" class="">,  by  taking  the  dot  product  of  the  relative            velocity  with  the  collision  normal  </span></span></a><a id="I_indexterm4_id328429" class="indexterm"></a><a id="I_indexterm4_id328438" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6392</span><span sentence-index="6392" class="">vector.</span></span></a></p><p><a id="I_indexterm4_id328438" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">315</span><span sentence-index="6395" class="">If  there  is  no  vertex-vertex  collision,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">315</span><span sentence-index="6395" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">315</span><span sentence-index="6395" class=""> proceeds  to  check  for  </span></span></a><a id="ve10.2" class="indexterm"></a><a id="cove10.2" class="indexterm"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">317</span><span sentence-index="6397" class="">vertex-edge  collisions:</span></span></a></p><a id="I_programlisting4_id328486"><pre class="programlisting">          // Check for vertex-edge collision
          if(!haveNodeNode)
          {
               for(i=0; i&lt;4 &amp;&amp; !haveNodeEdge; i++)
               {
                    for(j=0; j&lt;3 &amp;&amp; !haveNodeEdge; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();

                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();

                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body2-&gt;vPosition;

                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();

                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;

                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;
                    }
               }
          }</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">319</span><span sentence-index="6399" class="">Here,  the  nested  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">319</span><span sentence-index="6399" class="">for</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6399</span><span sentence-index="6399" class="">  loops  check  each  vertex  in  one            list  to  see  if  it  is  in  contact  with  each  edge  built  from  the  vertices  in  the  other  list. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">320</span><span sentence-index="6400" class="">           After  building  the  edge  under  consideration,  we  save  and  normalize  a  copy  of  it  to  represent  a            unit  vector  pointing  along  the  edge:</span></span></p></a><a id="I_programlisting4_id328519"><pre class="programlisting">                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];
                         u = edge;
                         u.Normalize();</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">322</span><span sentence-index="6402" class="">Variable  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">322</span><span sentence-index="6402" class="">u</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6402</span><span sentence-index="6402" class="">  represents  that  unit  vector,  and  it  will  be            used  in  subsequent  calculations. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">323</span><span sentence-index="6403" class=""> The  next  set  of  calculations  determines  the  location  of  the            projection  of  the  vertex  under  consideration  onto  the  edge  under  consideration,  as  well  as  the            minimum  distance  from  the  vertex  to  edge:</span></span></p></a><a id="I_programlisting4_id328539"><pre class="programlisting">                         p = vList1[i] - vList2[j];
                         proj = (p * u) * u;

                         d = p^u;
                         dist = d.Magnitude();</pre></a><p><a id="I_programlisting4_id328539"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">326</span><span sentence-index="6406" class="">Variable  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">326</span><span sentence-index="6406" class="">p</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">326</span><span sentence-index="6406" class=""> is  a  vector  from  the  first  vertex  on  the            edge  to  the  vertex  under  consideration,  and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">326</span><span sentence-index="6406" class="">proj</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6406</span><span sentence-index="6406" class="">  is  the            distance  from  the  first  edge  vertex,  along  the  edge,  to  the  point  upon  which  the  vertex            projects. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">327</span><span sentence-index="6407" class=""> </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">327</span><span sentence-index="6407" class="">dist</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6407</span><span sentence-index="6407" class="">  is  the  minimum  distance  from  the  vertex  to            the  edge. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">328</span><span sentence-index="6408" class=""> </span></span></a><a class="xref" href="ch10.html#vertex-edge_check" title="Figure&#xA0;10-3.&#xA0;Vertex-edge check"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">329</span><span sentence-index="6409" class="">Figure&#xA0;10-3</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6410</span><span sentence-index="6410" class="">  illustrates  this  geometry.</span></span></p><div class="figure"><a id="vertex-edge_check"></a><div class="figure-contents"><a id="vertex-edge_check"></a><div class="mediaobject"><a id="vertex-edge_check"></a><a id="I_mediaobject4_id328585"><img src="httpatomoreillycomsourceoreillyimages1598945.png" alt="Vertex-edge check"></a></div></div><div class="figure-title"><a id="I_mediaobject4_id328585"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">336</span><span sentence-index="6416" class="">Figure&#xA0;10-3.&#xA0;Vertex-edge  check</span></span></a></div></div><p><a id="I_mediaobject4_id328585"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">338</span><span sentence-index="6418" class="">If  there  is  a  collision,  the  global  location  of  the  point  of  impact  is  equal  to  the  vertex            under  consideration,  which  we  must  convert  to  local  coordinates  for  each  hovercraft,  as  shown            here:</span></span></a></p><a id="I_programlisting4_id328610"><pre class="programlisting">                         vCollisionPoint = vList1[i];
                         body1-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body1-&gt;vPosition;

                         body2-&gt;vCollisionPoint = vCollisionPoint &#x2212;
                                                  body2-&gt;vPosition;</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr">Since,  in  this  type  of  collision,  the  collision  normal  vector  is  perpendicular  to  the            edge,  you  can  determine  it  by  taking  the  result  of  the  cross  product  of  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span>u</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr"> and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr">p</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr"> and  crossing  it  with                </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr">u</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">340</span><span sentence-index="6420" class="nonQuoteStr"> as  follows:</span></span></p></a><a id="I_programlisting4_id328641"><pre class="programlisting">                         vCollisionNormal = ((u^p)^u);
                         vCollisionNormal.Normalize();</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">342</span><span sentence-index="6422" class="">These  calculations  give  you  a  unit  length  vector  in  the  plane  of  vectors  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">342</span><span sentence-index="6422" class="">u</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">342</span><span sentence-index="6422" class=""> and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">342</span><span sentence-index="6422" class="">p</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6422</span><span sentence-index="6422" class="">  and  perpendicular  to            the  edge.</span></span></p><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">344</span><span sentence-index="6424" class="nonQuoteStr">Next,  the  relative  velocity  between  the  points  of  impact  on  each  hovercraft  is  determined,            just  as  in  the  vertex-vertex  collision  check:</span></span></p></a><a id="I_programlisting4_id328668"><pre class="programlisting">                         v1 = body1-&gt;vVelocityBody +
                             (body1-&gt;vAngularVelocity ^
                              body1-&gt;vCollisionPoint);

                         v2 = body2-&gt;vVelocityBody +
                             (body2-&gt;vAngularVelocity ^
                              body2-&gt;vCollisionPoint);

                         v1 = VRotate2D(body1-&gt;fOrientation, v1);
                         v2 = VRotate2D(body2-&gt;fOrientation, v2);

                         vRelativeVelocity = (v1 - v2);
                         Vrn = vRelativeVelocity * vCollisionNormal;</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6426</span><span sentence-index="6426" class="">In  determining  whether  or  not  the  vertex  under  consideration  is  in  fact  colliding  with  an            edge,  you  have  to  check  to  see  if  the  distance  from  the  vertex  is  within  your  collision            tolerance,  and  you  also  have  to  make  sure  the  vertex  actually  projects  onto  the  edge  (that  is,            it  does  not  project  beyond  the  endpoints  of  the  edge). </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6427</span><span sentence-index="6427" class="">  Additionally,  you  need  to  make  sure  the            relative  normal  velocity  indicates  that  the  points  of  contact  are  moving  toward  each  other. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">348</span><span sentence-index="6428" class="">           Here&apos;s  how  this  check  looks:</span></span></p></a><a id="I_programlisting4_id328687"><pre class="programlisting">                         if( (proj.Magnitude() &gt; 0.0f) &amp;&amp;
                             (proj.Magnitude() &lt;= edge.Magnitude()) &amp;&amp;
                             (dist &lt;= ctol) &amp;&amp;
                             (Vrn &lt; 0.0) )
                              haveNodeEdge = true;</pre><p><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">350</span><span sentence-index="6430" class="nonQuoteStr">After  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">350</span><span sentence-index="6430" class="nonQuoteStr">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">350</span><span sentence-index="6430" class="nonQuoteStr"> checks  for  vertex-vertex  and            vertex-edge  collisions,  it  goes  on  to  check  for  penetration:</span></span></p></a><a id="I_programlisting4_id328706"><pre class="programlisting">          if(!haveNodeNode &amp;&amp; !haveNodeEdge)
          {
               for(i=0; i&lt;4 &amp;&amp; !interpenetrating; i++)
               {
                    for(j=0; j&lt;4 &amp;&amp; !interpenetrating; j++)
                    {
                         if(j==3)
                              edge = vList2[0] - vList2[j];
                         else
                              edge = vList2[j+1] - vList2[j];

                         p = vList1[i] - vList2[j];
                         dot = p * edge;
                         if(dot &lt; 0)
                         {
                              interpenetrating = true;
                         }
                    }
               }
       }</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6432</span><span sentence-index="6432" class="">This  check  is  a  standard  point-in-polygon  check  using  the  vector  dot  product  to  determine            if  any  vertex  of  one  polygon  lies  within  the  bounds  of  the  other  polygon. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6433</span><span sentence-index="6433" class="">  After  this  check,            the  function  simply  returns  the  appropriate  result. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class=""> Here  again,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class="">0</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class=""> indicates  no  collision  or  penetration,  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class="">1</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class="">           indicates  a  collision,  and  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">354</span><span sentence-index="6434" class="">&#x2212;1</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6434</span><span sentence-index="6434" class="">  indicates  penetration.</span></span></p></a><p><a id="I_programlisting4_id328706"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">357</span><span sentence-index="6437" class="">With  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">357</span><span sentence-index="6437" class="">CheckForCollision</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">357</span><span sentence-index="6437" class=""> out  of  the  way,  turn  your            attention  to  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">357</span><span sentence-index="6437" class="">ApplyImpulse</span></span></code><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6437</span><span sentence-index="6437" class=""> ,  which  also  has  to  be  revised  to            include  angular  effects. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">358</span><span sentence-index="6438" class=""> Specifically,  you  need  to  use  the  impulse  formula  that  includes            angular  as  well  as  linear  effects  (see  </span></span></a><a class="xref" href="ch05.html" title="Chapter&#xA0;5.&#xA0;Collisions"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">359</span><span sentence-index="6439" class="">Chapter&#xA0;5</span></span></a><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6440</span><span sentence-index="6440" class=""> ),  and  you  also  have  to            apply  the  impulse  to  the  hovercraft&apos;s  angular  velocities  in  addition  to  their  linear            velocities. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">361</span><span sentence-index="6441" class=""> Here&apos;s  how  the  new  </span></span><code class="literal"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">361</span><span sentence-index="6441" class="">ApplyImpulse</span></span></code><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">361</span><span sentence-index="6441" class=""> function            looks:</span></span></p><a id="I_programlisting4_id328770"><pre class="programlisting">void     ApplyImpulse(pRigidBody2D body1, pRigidBody2D body2)
{
     float j;

     j = (-(1+fCr) * (vRelativeVelocity*vCollisionNormal)) /
          ( (1/body1-&gt;fMass + 1/body2-&gt;fMass) +
          (vCollisionNormal * (((body1-&gt;vCollisionPoint ^
           vCollisionNormal)/body1-&gt;fInertia)^body1-&gt;vCollisionPoint)) +
          (vCollisionNormal * (((body2-&gt;vCollisionPoint ^
           vCollisionNormal)/body2-&gt;fInertia)^body2-&gt;vCollisionPoint))
          );

     body1-&gt;vVelocity += (j * vCollisionNormal) / body1-&gt;fMass;
     body1-&gt;vAngularVelocity += (body1-&gt;vCollisionPoint ^
                                 (j * vCollisionNormal)) /
                                 body1-&gt;fInertia;

     body2-&gt;vVelocity -= (j * vCollisionNormal) / body2-&gt;fMass;
     body2-&gt;vAngularVelocity -= (body2-&gt;vCollisionPoint ^
                                 (j * vCollisionNormal)) /
                                 body2-&gt;fInertia;
}</pre><p><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6443</span><span sentence-index="6443" class="">Remember,  the  impulse  is  applied  to  one  hovercraft  while  its  negative  is  applied  to  the            other.</span></span></p></a><p><a id="I_programlisting4_id328770"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6446</span><span sentence-index="6446" class="">That  does  it  for  this  new  version  of  the  hovercraft  simulation. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6447</span><span sentence-index="6447" class="">  If  you  run  the  program            now,  you&apos;ll  see  that  you  can  crash  the  hovercraft  into  each  other  and  they  bounce  and  rotate            accordingly. </span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6448</span><span sentence-index="6448" class="">  This  makes  for  a  much  more  realistic  simulation  than  the  simple,  linear  collision            response  approach  of  the  last  section. </span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">369</span><span sentence-index="6449" class=""> Here  again,  you  can  play  with  the  mass  of  each            hovercraft  and  the  coefficient  of  restitution  to  see  how  these  parameters  affect  the  collision            response  between  the  </span></span></a><a id="I_indexterm4_id328796" class="indexterm"></a><a id="I_indexterm4_id328805" class="indexterm"></a><a id="I_indexterm4_id328814" class="indexterm"></a><a id="I_indexterm4_id328824" class="indexterm"></a><a id="I_indexterm4_id328833" class="indexterm"></a><a id="I_indexterm4_id328842" class="indexterm"></a><a id="I_indexterm4_id328852" class="indexterm"></a><a id="I_indexterm4_id328861" class="indexterm"><span class="nonQuoteStr"><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6457</span><span sentence-index="6457" class="">hovercraft.</span></span></a></p></div><div class="footnotes" epub:type="footnotes"><a id="I_indexterm4_id328861" class="indexterm"><br><hr style="width: 100; align: left;"></a><div class="footnote" epub:type="footnote" id="ftn.CHP-10-FN-1"><a id="I_indexterm4_id328861" class="indexterm"></a><p><a id="I_indexterm4_id328861" class="indexterm"><sup><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">383</span><span sentence-index="6463" class="">[</span></span></sup></a><a href="#CHP-10-FN-1" class="para"><span><span style="background-color: lightgray; padding: 4px;" class="spanSentenceIndexNumber">384</span><span sentence-index="6464" class="">19</span></span></a><span><span style="margin-right: 5px; margin-left: 5px;" class="spanSentenceIndexNumber">6465</span><span sentence-index="6465" class=""> ]  Note  that  this  function  does  not  handle  multiple  contact  points.</span></span></p></div></div></section>
</body></html>