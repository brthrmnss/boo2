<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 22. Gaming from One Place to Another</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt04.html" title="Part IV. Digital Physics"/><link rel="prev" href="ch21.html" title="Chapter 21. Accelerometers"/><link rel="next" href="ch23.html" title="Chapter 23. Pressure Sensors and Load Cells"/></head><body><section class="chapter" title="Chapter 22. Gaming from One Place to Another" epub:type="chapter" id="gaming_from_one_place_to_another"><div class="titlepage"><div><div><h2 class="title">Chapter 22. Gaming from One Place to Another</h2></div></div></div><p>Once a tool meant to help the <a id="I_indexterm3_id355966" class="indexterm"/><a id="I_indexterm3_id355976" class="indexterm"/>United States guide intercontinental ballistic missiles, the
  <span class="emphasis"><em>Global Positioning System</em></span> (GPS) has evolved to be a
  part of our everyday lives. The current generation will never have known a
  world where getting lost was something that couldn’t be fixed by
  trilaterating their position between satellites orbiting the planet.
  Although GPS has become commonplace in the navigational world, the
  proliferation of smartphones is just now opening the doors to GPS gaming.
  While this genre is just emerging, we’d like to give you an introduction to
  the physics behind GPS and the current applications in the gaming
  world.</p><p>Let’s recall that <a id="I_indexterm3_id356000" class="indexterm"/><a id="I_indexterm3_id356013" class="indexterm"/><a id="I_indexterm3_id356019" class="indexterm"/>positions near the earth’s surface are generally given in the
  <span class="emphasis"><em>geographic coordinate system</em></span>, more often described as
  latitude, longitude, and altitude. <span class="emphasis"><em>Latitude</em></span> is a
  <a id="I_indexterm3_id356038" class="indexterm"/>measure in degrees of how far north or south you are from the
  equator. <span class="emphasis"><em>Longitude</em></span> <a id="I_indexterm3_id356053" class="indexterm"/>is the measure in degrees of how far east or west you are from
  the prime meridian. A meridian is a line of constant latitude that runs from
  the North Pole to the South Pole. The prime meridian is arbitrarily defined
  as the meridian that passes through the <a id="I_indexterm3_id356066" class="indexterm"/>Greenwich Observatory in the <a id="I_indexterm3_id356074" class="indexterm"/>UK. <span class="emphasis"><em>Altitude</em></span> is usually given as the
  measure of how far above or below sea level you are at the point described
  by latitude and longitude.</p><div class="sect1" title="Location-Based Gaming"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="location-based_gaming">Location-Based Gaming</h2></div></div></div><p>Before getting <a id="I_indexterm3_id356101" class="indexterm"/><a id="I_indexterm3_id356111" class="indexterm"/><a id="I_indexterm3_id356121" class="indexterm"/>to the physics behind GPS, we’d like to take a moment to
    discuss how GPS is being implemented into games. Right now, this is an
    emerging market that is just starting to gain traction. There are several
    broad categories into which games fall. Another step beyond what the
    accelerometer did, GPS enables users to move computer games not only off
    the couch but also out into the world.</p><div class="sect2" title="Geocaching and Reverse Geocaching"><div class="titlepage"><div><div><h3 class="title" id="geocaching_and_reverse_geocaching">Geocaching and Reverse Geocaching</h3></div></div></div><p>Geocaching is the <a id="I_indexterm3_id356148" class="indexterm"/>oldest form of gaming involving GPS. It originated after
      selective availability was removed from GPS, making it more accurate, in
      the year 2000. In its most basic form, it is the process of hunting down
      a “cache” using provided GPS coordinates. The cache usually has a
      logbook and may contain other items such as coins with serial numbers
      that the finder can move to another cache and track online.</p><p>Because of the large amount of setup involved in implementing a
      geocaching game on a commercial scale, most implementations are
      community based. However, <a id="I_indexterm3_id356165" class="indexterm"/>reverse geocaching has more promise for the gaming
      industry. In this variation there is nothing at the supplied
      coordinates, but traveling to them is required to execute some action.
      Think of it as carrying around a cache that cannot be unlocked until it
      is within range of some specific coordinate. This could be used to force
      users to travel in order to unlock a game item. For instance, perhaps to
      gain the ability to use a sword in a game, the user must travel to the
      nearest sporting goods store. The commercial possibility of corporate
      tie-ins is an obvious plus.</p></div><div class="sect2" title="Mixed Reality"><div class="titlepage"><div><div><h3 class="title" id="mixed_reality">Mixed Reality</h3></div></div></div><p>Mixed-reality games <a id="I_indexterm3_id356191" class="indexterm"/>are similar to geocaching. They go beyond just using the coordinates of the user
        to trigger events, to using reality-based locals. A current example is Gbanga’s
          <span class="emphasis"><em>Famiglia</em></span>. In this game your movement in the real world allows you to
        discover virtual establishments in the game world. This divorces it from the actual physical
        locations that your GPS is reporting but requires moving between locations in the real world
        to move your character in the virtual world. Popular right now is the <a id="I_indexterm3_id356206" class="indexterm"/>FourSquare app on mobile devices. This is the simplest possible implementation
        of mixed-reality gaming. FourSquare allows a user to become the mayor of a place if she
        “checks in” at the locale more than anyone else.</p></div><div class="sect2" title="Street Games"><div class="titlepage"><div><div><h3 class="title" id="street_games">Street Games</h3></div></div></div><p>Street games <a id="I_indexterm3_id356228" class="indexterm"/>are another step beyond mixed reality. These turn the
      environment around the user into a virtual game board. One example is
      the recent <span class="emphasis"><em>Pac-Manhattan</em></span> multiplayer game using GPS
      in smartphones to play a live version of <span class="emphasis"><em>Pac-Man</em></span> in
      Washington Square Park. In general, the idea is to create a court for
      game play using the environment surrounding the user. The relationship
      between users is tracked in the virtual space of the game and provides
      the interactive elements.</p></div></div><div class="sect1" title="What Time Is It?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="what_time_is_it_question">What Time Is It?</h2></div></div></div><p>The story of GPS<a id="I_indexterm3_id356263" class="indexterm"/><a id="I_indexterm3_id356274" class="indexterm"/> really begins with a prize offered by the British
    government in 1717 for a simple way to determine your <a id="I_indexterm3_id356286" class="indexterm"/><a id="ti22.2" class="indexterm"/>longitude. Awarded in 1773, the accepted solution was to
    compare local noon to the official noon sighted at the <a id="I_indexterm3_id356312" class="indexterm"/>Greenwich Observatory. The difference between these two
    times would allow you to tell how far around the world you were from the
    observatory. Fast-forward three centuries, and we have satellites orbiting
    the earth, broadcasting time-stamped messages. By calculating the
    difference between the time the message was received and the time it was
    transmitted, we can calculate our distance from the satellite. In both
    cases you need an accurate way to keep or measure time. For sailors in the
    1800s, the device was the newly invented chronometer. For us, it is the
    atomic clock.</p><p>Because the signals from a GPS satellite are moving at the speed of
    light, you need a very accurate clock to keep track of how long it took to
    travel to you. For instance, if the clock you are using to time when the
    signal arrives is 1 microsecond off, you will estimate a distance over 900
    miles in error. On the supply side of the signal, each satellite has an
    atomic clock, and internal GPS time is accurate to about 14 nanoseconds.
    The problem is that you also need a very accurate clock in the receiver,
    and it would be pretty hard to fit an atomic clock into a phone
    economically. To get around this, the receiver must figure out the correct
    current time based on the signals from the satellites.</p><div class="sect2" title="Two-Dimensional Mathematical Treatment"><div class="titlepage"><div><div><h3 class="title" id="two-dimensional_mathematical_treatment">Two-Dimensional Mathematical Treatment</h3></div></div></div><p>This section will <a id="gp22.2" class="indexterm"/><a id="gl22.2" class="indexterm"/>give you a good idea of how GPS systems determine their
      location. This background will help you in many applications of geometry
      in games in general, but most GPS devices do the heavy lifting and
      report through an API your current latitude and longitude. Some APIs may
      include more information—for example, the current iOS API, called Core
      Location, gives the current <a id="la22.2.1" class="indexterm"/><a id="lo22.2.1" class="indexterm"/>latitude and longitude, the direction of travel, the
      distance traveled, and the distance in meters to a given coordinate. It
      also gives an estimate for the error associated with its position fix in
      meters.</p><p>One way to get your position via the kind of information that GPS
      provides is a technique <a id="tr22.2.1" class="indexterm"/>called <span class="emphasis"><em>trilateration</em></span>. We are going to
      give this problem a mathematical treatment in two dimensions. You could
      extend this to three dimensions by using spheres instead of
      circles.</p><p>To begin, we can list our unknowns: our <span class="emphasis"><em>x</em></span>
      coordinate and <span class="emphasis"><em>y</em></span> coordinate in space, and the error
      in our receiver’s clock (or <span class="emphasis"><em>bias</em></span>),
      <span class="emphasis"><em>b</em></span>. In a two-dimensional plane, trilateration among
      three circles gives you an exact position; in three-dimensional space,
      four spheres are required to determine all three special coordinates.
      Note that if we included an assumption about being on the surface of
      some geometric shape, such as the earth, we could reduce the number of
      unknowns. No such simplification is used here to provide you with the
      most general case.</p><p>In our example, we are somewhere on the surface of the
      two-dimensional earth, shown in <a class="xref" href="ch22.html#trilateration_in_2d" title="Figure 22-1. Trilateration in 2D">Figure 22-1</a>
      as a light gray solid disk. This disk is being orbited by several GPS
      satellites. The satellites’ orbits are regular, and their positions at
      any time are tabulated in an almanac that is stored in the receiver. The
      time of transmission is encoded in the signal so that the givens are
      <span class="emphasis"><em>x</em></span><sub>i</sub>,
      <span class="emphasis"><em>y</em></span><sub>i</sub>, and
      <span class="emphasis"><em>t</em></span><sub>i</sub>, with
      <span class="emphasis"><em>i</em></span> =1,2,3.</p><div class="figure"><a id="trilateration_in_2d"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id356508"/><img src="httpatomoreillycomsourceoreillyimages1599001.png" alt="Trilateration in 2D"/></div></div><div class="figure-title">Figure 22-1. Trilateration in 2D</div></div><p>To make things easier for us, we are going to abandon the
      coordinate system of the earth and use the coordinate system defined by
      our three satellites. The origin will be at satellite 1, the x-axis
      going directly from satellite 1 straight to satellite 2 and the y-axis
      being perpendicular to that. This is shown in <a class="xref" href="ch22.html#satellite_coordinate_system" title="Figure 22-2. Satellite coordinate system">Figure 22-2</a>.</p><div class="figure"><a id="satellite_coordinate_system"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_id356549"/><img src="httpatomoreillycomsourceoreillyimages1599002.png" alt="Satellite coordinate system"/></div></div><div class="figure-title">Figure 22-2. Satellite coordinate system</div></div><p>The equations of the three circles are therefore:</p><table style="border: 0; " class="simplelist"><tr><td>r<sup>2</sup><sub>1</sub> =
        x<sup>2</sup>+y<sup>2</sup></td></tr><tr><td>r<sup>2</sup><sub>2</sub> =
        (x–d)<sup>2</sup>+y<sup>2</sup></td></tr><tr><td>r<sup>2</sup><sub>3</sub> =
        (x–i)<sup>2</sup>+(y–j)<sup>2</sup></td></tr></table><p>Each radius is found by subtracting the transmission time,
          <span class="emphasis"><em>t</em></span><sub>i</sub>, from the current time and multiplying by
        the speed of light. As the speed of light is very large, and our current time is only a
        rough estimate, these radii are commonly referred  <a id="I_indexterm3_id356637" class="indexterm"/>to as <span class="emphasis"><em>pseudoranges</em></span> to remind us they are still approximate.
        The <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values that satisfy these equations
        are our current location in two-dimensional space. We now subtract the second equation from
        the first:</p><table style="border: 0; " class="simplelist"><tr><td>r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> =
        x<sup>2</sup> + y<sup>2</sup> –
        (x-d)<sup>2</sup> –
        y<sup>2</sup></td></tr><tr><td>r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> =
        x<sup>2</sup> –
        (x-d)<sup>2</sup></td></tr></table><p>Solving for <span class="emphasis"><em>x</em></span> gives:</p><table style="border: 0; " class="simplelist"><tr><td><span class="emphasis"><em>x</em></span> =
        (r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup>+d<sup>2</sup>)
        / 2d</td></tr></table><p>where <span class="emphasis"><em>d</em></span> is the distance between the known
      locations of satellite 1 and satellite 2. We now substitute our
      <span class="emphasis"><em>x</em></span> coordinate back into the first circle’s
      equation:</p><table style="border: 0; " class="simplelist"><tr><td>y<sup>2</sup> =
        r<sub>1</sub><sup>2</sup> –
        [((r<sub>1</sub><sup>2</sup> –
        r<sub>2</sub><sup>2</sup> +
        d<sup>2</sup>)<sup>2</sup>) /
        (4d<sup>2</sup>)]</td></tr></table><p>and finally after we take the square root:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2201.png" alt="Satellite coordinate system"/></div></div><p>notice that the <span class="emphasis"><em>y</em></span> value is now expressed as a
      positive or negative square root. This means there can be zero, one, or
      two real-number solutions. If the circles do not intersect, then the
      quantity under the square root will be negative and the
      <span class="emphasis"><em>y</em></span> value will have zero real solutions. This is
      unlikely for the first two satellites because you have already received
      pseudoranges to them in the form of
      <span class="emphasis"><em>r</em></span><sub>1</sub> and
      <span class="emphasis"><em>r</em></span><sub>2</sub>, which the algorithm
      assumes to have zero error. If the two circles happen to intersect at
      only a single tangent point, the <span class="emphasis"><em>y</em></span> will have one
      solution and will be equal to 0. This is also unlikely. The most likely
      result will be that <span class="emphasis"><em>y</em></span> will be the set of two
      values, plus or minus the square root of a positive value, and that
      those two points will be widely separated.</p><p>Now if we included the assumption that we were on the earth’s
      surface, we could already break the tie between the two points by
      picking whichever was closest to the earth’s surface. However, we still
      would have to deal with the likelihood that there is a large error in
      our position given the imprecise clock in the receiver.</p><p>We can fix our position (<span class="emphasis"><em>x,y</em></span>) with no assumptions and account for
        clock bias by introducing the third point and its pseudorange. Now, it was very likely that
        the circles obtained from the first two satellites would intersect because of the way that
        GPS satellites are arranged around the earth. However, because our calculations use
        pseudoranges, it is relatively unlikely that the third circle will pass directly through one
        of the two points defined by the intersection of the first two circles. To remove such
        clock-related distance errors, we first calculate which point (<span class="emphasis"><em>x,y</em></span>) or
          (<span class="emphasis"><em>x,–y</em></span>) is closer to (<span class="emphasis"><em>i,j</em></span>) and choose that to be
        our assumed location. The difference between the smaller of these two distances and the
        pseudorange <span class="emphasis"><em>r</em></span><sub>3</sub> is then our distance correction,
          <span class="emphasis"><em>d</em></span><sub>a</sub>. As the signal is traveling at the <a id="I_indexterm3_id356904" class="indexterm"/><a id="I_indexterm3_id356916" class="indexterm"/>speed of light, the following quotient provides an estimate of the error between
        the correct time and the receiver’s time:</p><table style="border: 0; " class="simplelist"><tr><td>b = d<sub>a</sub>/c</td></tr></table><p>As all the GPS satellites have synchronized atomic clocks, the
      same bias exists for each. This means that the bias we calculated would
      actually affect the first pseudoranges we used to find our initial bias.
      Therefore an iterative approach is required to adjust all the variables
      in real time until they converge. A more direct, but less obvious,
      algebraic solution that requires no iteration was developed by
      <a id="I_indexterm3_id356948" class="indexterm"/>Stephen Bancroft. It is detailed in his paper “An
      Algebraic Solution of the GPS Equations” in the <span class="emphasis"><em>IEEE
      Transactions on Aerospace and Electronics Systems</em></span>
      journal.</p><p>Besides clock errors, other errors are introduced by the
      atmosphere, signals bouncing off the ground and back to the receiver,
      relativistic effects (discussed in <a class="xref" href="ch02.html" title="Chapter 2. Kinematics">Chapter 2</a>), and
      <a id="I_indexterm3_id356970" class="indexterm"/><a id="I_indexterm3_id356977" class="indexterm"/><a id="I_indexterm3_id356983" class="indexterm"/>atomic clock drift. These are all accounted for in
      mathematical models applied to the raw position data. For instance, the
      GPS clocks lose about 7,214 nanoseconds every day due to their velocity
      according to special relativity. However, because they are higher up in
      the earth’s gravity well, they gain 45,850 nanoseconds every day
      according to general relativity. The net effect is found by adding these
      values together: they run 38,640 nanoseconds faster each day, which
      would cause about 10 kilometers inaccuracy to build each day they are in
      orbit. To account for this, the clocks in the GPS receivers are
      pre-adjusted from 10.23 MHz to 10.22999999543 MHz. The fact that we are
      giving you a number to 11 decimal places demonstrates the amount of
      accuracy the modern age enjoys in its time keeping.</p><p>Once the bias is taken care of and all the other possible errors
      adjusted for, the converged solution can be translated back into
      whatever coordinate system is convenient to give to the end user.
      Usually this is latitude, longitude, and <a id="I_indexterm3_id357009" class="indexterm"/>altitude. Next, we will learn how to calculate different
      quantities based in the <a id="I_indexterm3_id357020" class="indexterm"/><a id="I_indexterm3_id357025" class="indexterm"/>geographic coordinate <a id="I_indexterm3_id357036" class="indexterm"/><a id="I_indexterm3_id357046" class="indexterm"/><a id="I_indexterm3_id357055" class="indexterm"/><a id="I_indexterm3_id357065" class="indexterm"/><a id="I_indexterm3_id357074" class="indexterm"/><a id="I_indexterm3_id357083" class="indexterm"/>system.</p></div></div><div class="sect1" title="Location, Location, Location"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="location_comma_location_comma_location">Location, Location, Location</h2></div></div></div><p>Let’s take a minute to discuss distance between two <a id="gl22.3" class="indexterm"/><a id="gp22.3" class="indexterm"/><a id="la22.3" class="indexterm"/><a id="lo22.3" class="indexterm"/><a id="di22.3" class="indexterm"/>latitude and longitude coordinates. You might be tempted to
    calculate it as the distance between two points. For very small distances,
    this approximation is probably accurate enough. However, because the earth
    is actually a sphere, over great distances the calculated route will be
    much shorter than the actual distance along the surface.</p><p>The shortest distance between two points on a sphere, especially in
    problems of navigation, is <a id="I_indexterm3_id357185" class="indexterm"/>called a <span class="emphasis"><em>great circle</em></span>. A great circle
    is the intersection of a sphere and a plane defined by the center point of
    the sphere, the origin, and the destination. The resulting course actually
    has a heading that constantly changes. On ships, this is avoided in favor
    of <a id="I_indexterm3_id357198" class="indexterm"/>using a <span class="emphasis"><em>rhumb line</em></span>, which is the
    shortest path of constant heading. This makes navigation easier at the
    expense of time. Airplanes, however, do follow great-circle routes to
    minimize fuel burn.</p><div class="sect2" title="Distance"><div class="titlepage"><div><div><h3 class="title" id="distance">Distance</h3></div></div></div><p>There are several ways of <a id="I_indexterm3_id357227" class="indexterm"/>calculating the distance along a great circle. The one we will discuss here <a id="I_indexterm3_id357238" class="indexterm"/>is the <span class="emphasis"><em>haversine formula</em></span>. There are other methods like <a id="I_indexterm3_id357249" class="indexterm"/>the <span class="emphasis"><em>spherical law of cosines</em></span> and <a id="I_indexterm3_id357259" class="indexterm"/>the <span class="emphasis"><em>Vincenty formula</em></span>, but the haversine is more accurate
        for small distances than the spherical law of cosines while remaining much simpler than the
        Vincenty formula.</p><p>The haversine formula for distance is:</p><table style="border: 0; " class="simplelist"><tr><td>d = (R)(c)</td></tr></table><p>where <span class="emphasis"><em>R</em></span> = earth’s radius and
      <span class="emphasis"><em>c</em></span> is the angular distance in radians given
      by:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2202.png" alt="Distance"/></div></div><p>Here, <span class="emphasis"><em>a</em></span> is the square of half the chord
      length between the two points, calculated as:</p><table style="border: 0; " class="simplelist"><tr><td>a =
        sin<sup>2</sup>(Δ<sub>lat</sub>/2) +
        cos(lat<sub>1</sub>)cos(lat<sub>2</sub>)sin<sup>2</sup>(Δ<sub>long</sub>
        /2)</td></tr></table><p>Finally:</p><table style="border: 0; " class="simplelist"><tr><td>Δ<sub>long</sub> = long<sub>2</sub> –
        long<sub>1</sub></td></tr><tr><td>Δ<sub>lat</sub> = lat<sub>2</sub> –
        lat<sub>1</sub></td></tr></table><p>Remember to first convert the angles to radians before using them in the trig function.
        Next we will begin showing you an implementation of several different formulas in <a id="I_indexterm3_id357389" class="indexterm"/>Objective-C; however, these should translate to C with little modification.
        These all use the following data structure to hold latitude and longitude
        information:</p><a id="I_programlisting3_id357403"/><pre class="programlisting">typedef enum {
float lat;
float lon;
} Coordinate2D;</pre><p>Given this, the haversine implementation would look like:</p><a id="I_programlisting3_id357412"/><pre class="programlisting">float distanceGreatCircle(Coordinate2D startPoint, Coordinate2D endPoint){

    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * endPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //Calculate half chord legnth
float a = sin(dLat/2) * sin(dLat/2) + cos(lat1) * cos(lat2) * sin(dLon/2) 
                                                           * sin(dLon/2);

//Calculate angular distance
    float C = 2 * atan(sqrt(a)/sqrt(1-a));

//Find arclength
    float distance = 6371 * C; //6371 is radius of earth in km
    return distance;
}</pre><p>One limitation of the preceding method is that if the two locations are <a id="I_indexterm3_id357428" class="indexterm"/>nearly <span class="emphasis"><em>antipodal</em></span>—that is, on opposite sides of the
        earth—then the haversine formula may have round-off issues that could results in errors on
        the order of 2 km. These, however, will be over a distance of 20,000 km. If extreme accuracy
        is required for nearly antipodal coordinates, you can fall back to the spherical law of
        cosines, which is best suited for large distances such as the antipodal case.</p></div><div class="sect2" title="Great-Circle Heading"><div class="titlepage"><div><div><h3 class="title" id="great-circle_heading">Great-Circle Heading</h3></div></div></div><p>As discussed before, to follow the shortest path between two
      points on a <a id="I_indexterm3_id357455" class="indexterm"/><a id="I_indexterm3_id357466" class="indexterm"/>sphere you must travel along a great circle. However, this
      requires that your heading be constantly changing with time. The formula
      to calculate your initial heading, <a id="I_indexterm3_id357474" class="indexterm"/>or <span class="emphasis"><em>forward azimuth</em></span>, is:</p><table style="border: 0; " class="simplelist"><tr><td>Θ<sub>i</sub> =
        atan2[sin(Δ<sub>long</sub>)cos(lat<sub>2</sub>),
        cos(lat<sub>1</sub>)sin(lat<sub>2</sub>) –
        sin(lat<sub>1</sub>)cos(lat<sub>2</sub>)cos(Δ<sub>long</sub>)]</td></tr></table><p>Recall that <a id="I_indexterm3_id357529" class="indexterm"/><code class="literal">atan2</code> is the two-argument variation of the
          <code class="literal">arctangent</code> function. It returns a normalized angle in radians between
        −π and π (−180° and 180°). The code that calculates the value and returns the compass
        bearing is as follows:</p><a id="I_programlisting3_id357546"/><pre class="programlisting">float initialBearing (Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * startPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    // Calculate bearing in radians
float theta = atan2f( sin(dlon) * cos(lat2), cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)
                                                                        *cos(dlon));

//Convert to compass bearing
Float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range
return bearing;
}</pre><p>A negative angle involves starting at 0° and rotating in the decreasing-heading
        direction, but compasses aren’t labeled with negative values! To fix this, the line that has
        the comment “fix range” is using a ternary operator to say that if the bearing is less than
        0, return the value the compass would read. For example, if the bearing were −10°, then the
        compass bearing is −10° + 360° = 350°. If the value is positive, then it just returns the
        same value.</p><p>To find the final bearing, we simply take the initial bearing
      going from the end point to the start point and then reverse it. The
      code is produced as follows:</p><a id="I_programlisting3_id357571"/><pre class="programlisting">float finalBearing (Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
    float lat1 = (M_PI/180.) * endPoint.lat;
    float lon1 = (M_PI/180.) * endPoint.longi;
float lat2 = (M_PI/180.) * startPoint.lat;
    float lon2 = (M_PI/180.) * startPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //Calculate bearing in radians
float theta = atan2f( sin(dlon) * cos(lat2), cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)
                                                                        *cos(dlon));

//Convert to compass bearing
float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range
bearing = ((bearing + 180) % 360) //reverse heading
return bearing;
}</pre><p>The difference here is that we have flipped <code class="literal">lat1</code>, <code class="literal">long1</code>
      and <code class="literal">lat2</code>, <code class="literal">long2</code> while converting the locations to
      radians. Also, before we return the bearing value, we reverse it by
      adding 180° degrees to it. The modulo operator (<code class="literal">%</code>) ensures that values over 360° are rolled
      over into compass coordinates. For example, if we calculate a bearing of
      350° and add 180° to it, we get 530° degrees. If you start at 0° and go
      around 530°, you’ll end up at 170°. The modulo operator<a id="I_indexterm3_id357622" class="indexterm"/> will result in the bearing being calculated with this
      correct compass value.</p></div><div class="sect2" title="Rhumb Line"><div class="titlepage"><div><div><h3 class="title" id="rhumb_line">Rhumb Line</h3></div></div></div><p>As discussed before, it is <a id="I_indexterm3_id357643" class="indexterm"/>sometimes preferable to take a longer path of constant
      heading, called a rhumb line, as compared to constantly changing your
      heading to follow a great circle path. The rhumb line will be longer
      than the great circle, and the distance you are from the great circle
      route at any moment is called <a id="I_indexterm3_id357654" class="indexterm"/>the <span class="emphasis"><em>cross track error</em></span>. To cross the
      Atlantic is about 5% longer if you follow a rhumb line. The extreme
      example of going from the East Coast of the United States to China is
      about 30% longer. However, such large penalties are rarely encountered
      because ships have to alter course to avoid land! This makes “as the
      crow flies” examples unrealistic.</p><p>If your game is providing navigation information to anyone but pilots, it will probably
        be using rhumb lines. The following are the formulas used to calculate distance and bearing
        between two coordinates on a rhumb line. The easiest way to begin is to flatten the globe.
        In a <a id="I_indexterm3_id357674" class="indexterm"/>Mercator projection, rhumb lines are straight. In fact, this makes graphically
        solving the problem very simple. You use a ruler. Mathematically, things get a bit more
        complicated. The following equation gives Δφ, which is the difference in latitude after
        taking into account that we have stretched them in order to flatten the sphere:</p><table style="border: 0; " class="simplelist"><tr><td>Δφ = ln[tan(lat2/2 + π/4) / tan(lat1/2 + π/4)]</td></tr></table><p>The distance between two points on a rhumb line is given
      by:</p><div class="informalequation"><div class="mediaobject"><img src="eq_2203.png" alt="Rhumb Line"/></div></div><p>The variable <span class="emphasis"><em>q</em></span> is a value whose formula
      depends on Δφ. If Δφ is equal to 0, that means that the calculated
      course is going to be either directly east or west. If that is the case,
      then the intermediate value of <span class="emphasis"><em>q</em></span> is:</p><table style="border: 0; " class="simplelist"><tr><td>q = cos(lat1)</td></tr></table><p>if Δφ is not equal to 0, then:</p><table style="border: 0; " class="simplelist"><tr><td>q = Δ<sub>lat</sub>/Δφ</td></tr></table><p>You can see that if not properly implemented, a direct east or
      west course would result in division by 0. Finally, the constant bearing
      is:</p><table style="border: 0; " class="simplelist"><tr><td>Θ<sub>rhumb</sub> =
        atan2(Δ<sub>long</sub>, Δφ)</td></tr></table><p>There are, in fact, an infinite number of rhumb lines that will get us to our end point.
        However, the longer ones will either take us the wrong way around the globe, or spiral
        around the globe before hitting our end point. At any rate, the shortest route will be the
        one in which Δ<sub>long</sub> is less that 180°. The preceding is implemented in <a id="I_indexterm3_id357781" class="indexterm"/>Objective-C as follows:</p><a id="I_programlisting3_id357793"/><pre class="programlisting">float rhumbBearing ( Coordinate2D startPoint, Coordinate2D endPoint){
    //Convert location from degrees to radians
float lat1 = (M_PI/180.) * startPoint.lat;
    float lon1 = (M_PI/180.) * startPoint.longi;
    float lat2 = (M_PI/180.) * endPoint.lat;
    float lon2 = (M_PI/180.) * endPoint.longi;

    //Calculate deltas
float dLat = lat2 - lat1;
    float dLon = lon2 - lon1;

    //find delta phi
    float deltaPhi = log(tan(lat2/2+(M_PI)/4)/tan(lat1+M_PI/4))
    float q=(deltaPhi==0 ? dlat/deltaPhi : cos(lat1); //avoids division by 0

if (abs(dLon) &gt; M_PI){
        dLon = (dLon&gt;0 ? −(2*(M_PI-dLon):(2*M_PI+dLon));
}

float D = sqrt(dLat*dLat + q*q*dLon*dLo)* 6371;
float theta = atan2f(dLon, deltaPhi);

//now convert to compass heading
float bearing = theta * (180 / M_PI); //radians to degrees
bearing = ( bearing &gt; 0 ? bearing : (360.0 + bearing)); //fix range

return bearing;
}</pre><p>There are a few things worth pointing out. First is that we are
      using a ternary function in the line commented by “avoids division by 0”
      to take care of the case when <code class="literal">deltaPhi</code> is equal to 0. If it is 0,
      <span class="emphasis"><em>q</em></span> is set to <code class="literal">cos(lat1)</code>; if not, then it is set to <code class="literal">dlat/deltaPhi</code>. The <code class="literal">if</code> statement immediately following ensures
      that if <code class="literal">dLon</code> is greater than π
      (180°), hence putting us on a longer-than-required rhumb line, then we
      should correct the value to correspond to the shortest route. This is
      achieved via the ternary, which ensures that <code class="literal">dLon</code> is less than π and nonnegative. Lastly,
      we convert from a normalized radian answer to a compass
      direction.</p><p>Now that you have a good idea about how to calculate position and
      distance in the geographic coordinate system, you can use the earlier
      chapters to determine other quantities like speed and <a id="I_indexterm3_id357858" class="indexterm"/><a id="I_indexterm3_id357868" class="indexterm"/><a id="I_indexterm3_id357878" class="indexterm"/><a id="I_indexterm3_id357887" class="indexterm"/><a id="I_indexterm3_id357896" class="indexterm"/>acceleration.</p></div></div></section></body></html>
